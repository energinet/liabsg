diff -r -C3 -P linux-2.6.29.4/arch/arm/Kconfig liab-linux-2.6.29.4/arch/arm/Kconfig
*** linux-2.6.29.4/arch/arm/Kconfig	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/arch/arm/Kconfig	2012-01-20 14:48:35.505306210 +0100
***************
*** 241,246 ****
--- 241,247 ----
  config ARCH_AT91
  	bool "Atmel AT91"
  	select GENERIC_GPIO
+ 	select ARCH_REQUIRE_GPIOLIB
  	select HAVE_CLK
  	help
  	  This enables support for systems based on the Atmel AT91RM9200,
***************
*** 1313,1318 ****
--- 1314,1321 ----
  
  source "drivers/leds/Kconfig"
  
+ source "drivers/liab/Kconfig"
+ 
  source "drivers/rtc/Kconfig"
  
  source "drivers/dma/Kconfig"
diff -r -C3 -P linux-2.6.29.4/arch/arm/mach-at91/at91rm9200_devices.c liab-linux-2.6.29.4/arch/arm/mach-at91/at91rm9200_devices.c
*** linux-2.6.29.4/arch/arm/mach-at91/at91rm9200_devices.c	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/arch/arm/mach-at91/at91rm9200_devices.c	2012-01-20 14:48:32.565306174 +0100
***************
*** 22,27 ****
--- 22,29 ----
  #include <mach/at91rm9200.h>
  #include <mach/at91rm9200_mc.h>
  
+ #include <linux/i2c-gpio.h>
+ 
  #include "generic.h"
  
  
***************
*** 160,166 ****
  		return;
  
  	if (data->phy_irq_pin) {
! 		at91_set_gpio_input(data->phy_irq_pin, 0);
  		at91_set_deglitch(data->phy_irq_pin, 1);
  	}
  
--- 162,168 ----
  		return;
  
  	if (data->phy_irq_pin) {
! 		at91_set_gpio_input(data->phy_irq_pin, 1);
  		at91_set_deglitch(data->phy_irq_pin, 1);
  	}
  
***************
*** 432,437 ****
--- 434,466 ----
  void __init at91_add_device_nand(struct atmel_nand_data *data) {}
  #endif
  
+ /* msawh */
+ 
+ /* --------------------------------------------------------------------
+  *  TLC320 SoC Audio
+  * -------------------------------------------------------------------- */
+ 
+ #if defined(CONFIG_ARCH_AT91) && defined(CONFIG_SND_SOC)
+ static struct tlv320_setup_data audio_data;
+ 
+ static struct platform_device tlv320_audio_device = {
+   .name           = "tlv320",
+   .id             = -1,
+ 	.dev		= {
+     .platform_data	= &audio_data,
+ 	},
+ };
+ 
+ void __init at91_add_device_audio(struct tlv320_setup_data *data)
+ {
+   int ret;
+   audio_data = *data;
+ 	ret = platform_device_register(&tlv320_audio_device);
+ }
+ #else
+ void __init at91_add_device_audio(struct tlv320_setup_data *data) {}
+ #endif
+ /* end msawh */
  
  /* --------------------------------------------------------------------
   *  TWI (i2c)
***************
*** 494,499 ****
--- 523,529 ----
  
  void __init at91_add_device_i2c(struct i2c_board_info *devices, int nr_devices)
  {
+   int ret;
  	/* pins used for TWI interface */
  	at91_set_A_periph(AT91_PIN_PA25, 0);		/* TWD */
  	at91_set_multi_drive(AT91_PIN_PA25, 1);
***************
*** 510,515 ****
--- 540,610 ----
  
  
  /* --------------------------------------------------------------------
+  *  TWI (i2c) GPIO interface
+  * -------------------------------------------------------------------- */
+ 
+ #if defined(CONFIG_I2C_AT91_GPIO)
+ 
+ // Control interface for TLV320 audio codec
+ // DS1337 RTC
+ static struct i2c_gpio_platform_data at91_i2c_gpio_pins = {
+ 	.sda_pin	= AT91_PIN_PA21,
+ 	.scl_pin	= AT91_PIN_PA24,
+ 	.udelay   = 500, // (500/udelay) kHz
+ 	.timeout  = 10,  // jiffies
+ 	.sda_is_open_drain = 0,
+ 	.sda_is_open_drain = 0,
+ 	.sda_is_open_drain = 0
+ };
+ 
+ static struct platform_device at91_gpio_i2c_controller = {
+ 	.name		= "i2c-gpio",
+ 	.id		= 0,
+ 	.dev		= {
+ 		.platform_data = &at91_i2c_gpio_pins,
+ 	},
+ 	.num_resources	= 0
+ };
+ 
+ 
+ #ifdef undef
+ static struct i2c_gpio_platform_data at91_i2c_gpio_pins2 = {
+ 	.sda_pin	= AT91_PIN_PB2,
+ 	.scl_pin	= AT91_PIN_PB1,
+ 	.udelay   = 500, // (500/udelay) kHz
+ 	.timeout  = 10,  // jiffies
+ 	.sda_is_open_drain = 0,
+ 	.sda_is_open_drain = 0,
+ 	.sda_is_open_drain = 0
+ };
+ 
+ static struct platform_device at91_gpio_i2c_controller2 = {
+ 	.name		= "i2c-gpio",
+ 	.id		= 1,
+ 	.dev		= {
+ 		.platform_data = &at91_i2c_gpio_pins2,
+ 	},
+ 	.num_resources	= 0
+ };
+ #endif
+ 
+ void __init at91_add_device_gpio_i2c(void)
+ {
+ 	at91_set_gpio_output(at91_i2c_gpio_pins.sda_pin, 1);		/* TWD */
+ 	at91_set_gpio_output(at91_i2c_gpio_pins.scl_pin, 1);		/* TWCK */
+ 
+ 	platform_device_register(&at91_gpio_i2c_controller);
+ 
+ 	//	at91_set_gpio_output(at91_i2c_gpio_pins2.sda_pin, 1);		/* TWD */
+ 	//	at91_set_gpio_output(at91_i2c_gpio_pins2.scl_pin, 1);		/* TWCK */
+ 
+ 	//	platform_device_register(&at91_gpio_i2c_controller2);
+ }
+ #else
+ void __init at91_add_device_gpio_i2c(void){}
+ #endif
+ 
+ /* --------------------------------------------------------------------
   *  SPI
   * -------------------------------------------------------------------- */
  
***************
*** 1100,1106 ****
--- 1195,1206 ----
  	if (pins & ATMEL_UART_CTS)
  		at91_set_B_periph(AT91_PIN_PB1, 0);	/* CTS3 */
  	if (pins & ATMEL_UART_RTS)
+ #ifdef CONFIG_LIAB_ENABLE_UART3
+ 		at91_set_A_periph(AT91_PIN_PD24, 0);	/* RTS3 */
+ #else
+ prut
  		at91_set_B_periph(AT91_PIN_PB0, 0);	/* RTS3 */
+ #endif
  }
  
  static struct platform_device *__initdata at91_uarts[ATMEL_MAX_UART];	/* the UARTs to use */
diff -r -C3 -P linux-2.6.29.4/arch/arm/mach-at91/at91sam9260_devices.c liab-linux-2.6.29.4/arch/arm/mach-at91/at91sam9260_devices.c
*** linux-2.6.29.4/arch/arm/mach-at91/at91sam9260_devices.c	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/arch/arm/mach-at91/at91sam9260_devices.c	2012-01-20 14:48:32.561306174 +0100
***************
*** 777,783 ****
  
  static inline void configure_dbgu_pins(void)
  {
! 	at91_set_A_periph(AT91_PIN_PB14, 0);		/* DRXD */
  	at91_set_A_periph(AT91_PIN_PB15, 1);		/* DTXD */
  }
  
--- 777,783 ----
  
  static inline void configure_dbgu_pins(void)
  {
! 	at91_set_A_periph(AT91_PIN_PB14, 1);		/* DRXD */
  	at91_set_A_periph(AT91_PIN_PB15, 1);		/* DTXD */
  }
  
***************
*** 1043,1049 ****
  void __init at91_register_uart(unsigned id, unsigned portnr, unsigned pins)
  {
  	struct platform_device *pdev;
! 
  	switch (id) {
  		case 0:		/* DBGU */
  			pdev = &at91sam9260_dbgu_device;
--- 1043,1049 ----
  void __init at91_register_uart(unsigned id, unsigned portnr, unsigned pins)
  {
  	struct platform_device *pdev;
!     struct atmel_uart_data *uart_data; 
  	switch (id) {
  		case 0:		/* DBGU */
  			pdev = &at91sam9260_dbgu_device;
***************
*** 1085,1090 ****
--- 1085,1098 ----
  	}
  	pdev->id = portnr;		/* update to mapped ID */
  
+     uart_data = (struct atmel_uart_data *)pdev->dev.platform_data;
+ 
+     if(pins & ATMEL_UART_RS485){     
+         uart_data->rs485_mode = 1;
+     } else {
+         uart_data->rs485_mode = 0;        
+     }
+ 
  	if (portnr < ATMEL_MAX_UART)
  		at91_uarts[portnr] = pdev;
  }
diff -r -C3 -P linux-2.6.29.4/arch/arm/mach-at91/at91sam9rl_devices.c liab-linux-2.6.29.4/arch/arm/mach-at91/at91sam9rl_devices.c
*** linux-2.6.29.4/arch/arm/mach-at91/at91sam9rl_devices.c	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/arch/arm/mach-at91/at91sam9rl_devices.c	2012-01-20 14:48:32.565306174 +0100
***************
*** 1064,1072 ****
  		default:
  			return;
  	}
! 	pdev->id = portnr;		/* update to mapped ID */
  
! 	if (portnr < ATMEL_MAX_UART)
  		at91_uarts[portnr] = pdev;
  }
  
--- 1064,1073 ----
  		default:
  			return;
  	}
!     
! 	pdev->id = portnr;		/* update to mapped ID */      
  
!     if (portnr < ATMEL_MAX_UART)
  		at91_uarts[portnr] = pdev;
  }
  
diff -r -C3 -P linux-2.6.29.4/arch/arm/mach-at91/board-dk.c liab-linux-2.6.29.4/arch/arm/mach-at91/board-dk.c
*** linux-2.6.29.4/arch/arm/mach-at91/board-dk.c	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/arch/arm/mach-at91/board-dk.c	2012-01-20 14:48:32.569306174 +0100
***************
*** 71,78 ****
  }
  
  static struct at91_eth_data __initdata dk_eth_data = {
! 	.phy_irq_pin	= AT91_PIN_PC4,
! 	.is_rmii	= 1,
  };
  
  static struct at91_usbh_data __initdata dk_usbh_data = {
--- 71,78 ----
  }
  
  static struct at91_eth_data __initdata dk_eth_data = {
! 	.phy_irq_pin	= AT91_PIN_PC0,
! 	.is_rmii	= 0,
  };
  
  static struct at91_usbh_data __initdata dk_usbh_data = {
diff -r -C3 -P linux-2.6.29.4/arch/arm/mach-at91/board-liabdin.c liab-linux-2.6.29.4/arch/arm/mach-at91/board-liabdin.c
*** linux-2.6.29.4/arch/arm/mach-at91/board-liabdin.c	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/arch/arm/mach-at91/board-liabdin.c	2012-01-20 14:48:32.565306174 +0100
***************
*** 0 ****
--- 1,566 ----
+ /*
+  * linux/arch/arm/mach-at91/board-nanoliab.c
+  *
+  *  Shamelessly ripped off from the original AT91RM9200-DK
+  *  by Mikkel S. Andersen <msa@liab.dk> 2007.
+  * 
+  *  Copyright (C) 2005 SAN People
+  *
+  *  Epson S1D framebuffer glue code is:
+  *     Copyright (C) 2005 Thibaut VARENE <varenet@parisc-linux.org>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2 of the License, or
+  * (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+  */
+ 
+ #include <linux/types.h>
+ #include <linux/init.h>
+ #include <linux/mm.h>
+ #include <linux/module.h>
+ #include <linux/platform_device.h>
+ #include <linux/spi/spi.h>
+ #include <linux/mtd/physmap.h>
+ #include <linux/i2c.h>
+ #include <linux/input.h>
+ #include <linux/gpio_keys.h>
+ 
+ #include <asm/setup.h>
+ #include <asm/mach-types.h>
+ #include <asm/irq.h>
+ 
+ #include <asm/mach/arch.h>
+ #include <asm/mach/map.h>
+ #include <asm/mach/irq.h>
+ 
+ #include <mach/hardware.h>
+ #include <mach/board.h>
+ #include <mach/gpio.h>
+ #include <mach/at91rm9200_mc.h>
+ 
+ #ifdef CONFIG_LIAB_TDC_LIABDIN_ADDON
+ #  include <linux/dm9000.h>
+ #endif 
+ 
+ #include <linux/sound.h>
+ 
+ #include "generic.h"
+ 
+ 
+ static void __init liabdin_map_io(void)
+ {
+ 	/* Initialize processor: 14.7456 MHz crystal */
+ 	at91rm9200_initialize(14745600, AT91RM9200_BGA);
+ 
+   /* Debug on ttyS0 */
+   at91_register_uart(0, 0, 0);
+   at91_set_serial_console(0);
+ 
+ #ifdef CONFIG_LIAB_ENABLE_UART0
+   at91_register_uart(AT91RM9200_ID_US0, 1, 
+                      ATMEL_UART_CTS | 
+                      ATMEL_UART_RTS);
+ #endif
+ #ifdef CONFIG_LIAB_ENABLE_UART1
+   at91_register_uart(AT91RM9200_ID_US1, 2, 
+                      ATMEL_UART_CTS | 
+                      ATMEL_UART_RTS | 
+                      ATMEL_UART_DSR | 
+                      ATMEL_UART_DTR);
+ #endif
+ #ifdef CONFIG_LIAB_ENABLE_UART2
+   at91_register_uart(AT91RM9200_ID_US2, 3, 0);
+ #endif
+ #ifdef CONFIG_LIAB_ENABLE_UART3
+ 	/* USART3 on ttyS3. (Rx, Tx, RTS - RS485 interface) */
+ 	at91_register_uart(AT91RM9200_ID_US3, 4, ATMEL_UART_RTS);
+ #endif
+ 
+ 	/* Setup the LEDs */
+ 	at91_init_leds(AT91_PIN_PC13, AT91_PIN_PC13);
+ }
+ 
+ static void __init liabdin_init_irq(void)
+ {
+ 	at91rm9200_init_interrupts(NULL);
+ }
+ 
+ static struct at91_eth_data __initdata liabdin_eth_data = {
+   /* msawh - removed to that at timer
+      check will be done instead */
+   //.phy_irq_pin = AT91_PIN_PC0, 
+ 	.is_rmii	= 0,
+ };
+ 
+ static struct at91_usbh_data __initdata liabdin_usbh_data = {
+ 	.ports		= 2,
+ };
+ 
+ #ifdef CONFIG_LIAB_TDC_LIABDIN_ADDON
+ static struct at91_udc_data __initdata liabdin_udc_data = {
+ 	.vbus_pin	= AT91_PIN_PA29,
+ 	.pullup_pin	= AT91_PIN_PA28,
+ };
+ #endif
+ 
+ static struct at91_mmc_data __initdata liabdin_mmc_data = {
+ 	.slot_b		= 0,
+ 	.wire4		= 1,
+ };
+ 
+ 
+ static struct i2c_board_info __initdata liabdin_i2c_devices[] = 
+ {	{ I2C_BOARD_INFO("rtc-ds1307", 0x68),
+ 	  .type = "ds1307",
+ 	},
+ 	{ I2C_BOARD_INFO("eeprom", 0x50),
+ 	  .type = "eeprom",
+ 	},
+ };
+ 
+ 
+ static struct resource timer_resources[] = {
+   [0] = {
+     .start	= AT91RM9200_BASE_TC0,
+     .end	= AT91RM9200_BASE_TC0 + 64 - 1,
+     .flags	= IORESOURCE_MEM,
+   },
+   [1] = {
+     .start	= AT91RM9200_BASE_TC1,
+     .end	= AT91RM9200_BASE_TC1 + 64 - 1,
+     .flags	= IORESOURCE_MEM,
+   },
+   [2] = {
+     .start	= AT91RM9200_BASE_TC2,
+     .end	= AT91RM9200_BASE_TC2 + 64 - 1,
+     .flags	= IORESOURCE_MEM,
+   },
+ };
+ 
+ static u32 no = 1;
+ static struct platform_device at91_timer_device = {
+   .name		= "at91_pwm",
+   .id		= -1,
+   .dev		= {
+     .platform_data		= &no,
+   },
+   .resource	= timer_resources,
+ 	.num_resources	= ARRAY_SIZE(timer_resources),
+ };
+ 
+ void __init at91_add_device_pwm(u32 mask)
+ {
+ 
+   at91_set_B_periph(AT91_PIN_PA19, 0);
+   platform_device_register(&at91_timer_device);
+ }
+ 
+ /**** Modem device ****/
+ static struct platform_device liabdin_modem_device = {
+   .name		= "liabdin_modem",
+   .id		= -1,
+   .dev		= {
+     .platform_data		= NULL,
+   },
+ 	.num_resources	= 0,
+ };
+ 
+ void __init at91_add_device_modem(void)
+ {
+   platform_device_register(&liabdin_modem_device);
+ }
+ 
+ 
+ #ifdef CONFIG_LIAB_TDC_LIABDIN_ADDON
+ /* DM9000 ethernet devices */
+ 
+ static struct resource liabdin_dm9k_resource[] = {
+ 	[0] = {
+ 		.start = AT91_CHIPSELECT_2,
+ 		.end   = AT91_CHIPSELECT_2 + 3,
+ 		.flags = IORESOURCE_MEM
+ 	},
+ 	[1] = {
+ 		.start = AT91_CHIPSELECT_2 + 4,
+ 		.end   = AT91_CHIPSELECT_2 + 0x7f,
+ 		.flags = IORESOURCE_MEM
+ 	},
+ 	[2] = {
+ 		.start = AT91RM9200_ID_IRQ0,
+ 		.end   = AT91RM9200_ID_IRQ0,
+ 		.flags = IORESOURCE_IRQ /*| IORESOURCE_IRQ_HIGHLEVEL*/,
+ 	},
+ };
+ 
+ 
+ /* for the moment we limit ourselves to 16bit IO until some
+  * better IO routines can be written and tested
+ */
+ 
+ static struct dm9000_plat_data liabdin_dm9k_platdata = {
+ 	.flags		= DM9000_PLATF_16BITONLY,
+ };
+ 
+ static struct platform_device liabdin_dm9k = {
+ 	.name		= "dm9000",
+ 	.id		= 0,
+ 	.num_resources	= ARRAY_SIZE(liabdin_dm9k_resource),
+ 	.resource	= liabdin_dm9k_resource,
+ 	.dev		= {
+ 		.platform_data = &liabdin_dm9k_platdata,
+ 	}
+ };
+ 
+ void __init at91_add_device_dm9000(void)
+ {
+   unsigned int csa;
+ 
+   /* enable the address range of CS2 */
+ 	csa = at91_sys_read(AT91_EBI_CSA);
+ 	at91_sys_write(AT91_EBI_CSA, csa | AT91_EBI_CS3A_SMC); // msawh <--- wtf... should map to cs2?!
+ 	/*
+ 	 * Static memory controller timing adjustments.
+ 	 * REVISIT:  these timings are in terms of MCK cycles, so
+ 	 * when MCK changes (cpufreq etc) so must these values...
+ 	 */
+ 	at91_sys_write(AT91_SMC_CSR(2),
+ 				  AT91_SMC_ACSS_STD
+ 				| AT91_SMC_DBW_16
+ 				| AT91_SMC_BAT
+ 				| AT91_SMC_WSEN
+ 				| AT91_SMC_NWS_(32)	/* wait states */
+ 				| AT91_SMC_RWSETUP_(6)	/* setup time */
+ 				| AT91_SMC_RWHOLD_(4)	/* hold time */
+ 	);
+ 
+   platform_device_register(&liabdin_dm9k);
+ }
+ #else
+ void __init at91_add_device_dm9000(void) {return; }
+ #endif
+ 
+ 
+ #if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
+ static struct gpio_keys_button liabdin_buttons[] = {
+ 	{
+ 		.gpio		= AT91_PIN_PC2,
+ 		.code		= BTN_0,
+ 		.desc		= "bot-sw2",
+ 		.active_low	= 1,
+ 	},
+ 	{
+ 		.gpio		= AT91_PIN_PC10,
+ 		.code		= BTN_1,
+ 		.desc		= "addon-sw1",
+ 		.active_low	= 1,
+ 	},
+ 	{
+ 		.gpio		= AT91_PIN_PC11,
+ 		.code		= BTN_2,
+ 		.desc		= "addon-sw2",
+ 		.active_low	= 1,
+ 	},
+ 	{ /* Opto X5 */
+ 		.gpio		= AT91_PIN_PD4,
+ 		.code		= BTN_3,
+ 		.desc		= "opto-X5",
+ 		.active_low	= 1,
+ 	},
+ 	{ /* Opto X6 */
+ 		.gpio		= AT91_PIN_PD5,
+ 		.code		= BTN_4,
+ 		.desc		= "opto-X6",
+ 		.active_low	= 1,
+ 	},
+ 	{ /* Opto X7 */
+ 		.gpio		= AT91_PIN_PD6,
+ 		.code		= BTN_5,
+ 		.desc		= "opto-X7",
+ 		.active_low	= 1,
+ 	},
+ 	{ /* Opto X8 */
+ 		.gpio		= AT91_PIN_PD7,
+ 		.code		= BTN_6,
+ 		.desc		= "opto-X8",
+ 		.active_low	= 1,
+ 	},
+ };
+ 
+ static struct gpio_keys_platform_data liabdin_button_data = {
+ 	.buttons	= liabdin_buttons,
+ 	.nbuttons	= ARRAY_SIZE(liabdin_buttons),
+ };
+ 
+ static struct platform_device liabdin_button_device = {
+ 	.name		= "gpio-keys",
+ 	.id		= -1,
+ 	.num_resources	= 0,
+ 	.dev		= {
+ 		.platform_data	= &liabdin_button_data,
+ 	}
+ };
+ 
+ static void __init din_add_device_buttons(void)
+ {
+   int i;
+   for(i=0; i<ARRAY_SIZE(liabdin_buttons); i++) {
+     at91_set_gpio_input(liabdin_buttons[i].gpio, 0);
+     at91_set_deglitch(liabdin_buttons[i].gpio, 1);
+   }
+ 
+   platform_device_register(&liabdin_button_device);
+ }
+ #else
+ static void __init din_add_device_buttons(void) {}
+ #endif
+ 
+ 
+ 
+ static struct gpio_led liabdin_leds[] = {
+ #ifndef CONFIG_LEDS
+   {	/* "D0" */
+     .name		= "led-d2",
+     .gpio		= AT91_PIN_PC13,
+     .active_low		= 1,
+     .default_trigger	= "led-d2",
+   },
+ #endif
+   {	/* "D1" */
+     .name	       	= "led-d3",
+     .gpio		= AT91_PIN_PC14,
+     .active_low		= 1,
+     .default_trigger	= "led-d3",
+   },
+   {	/* "D2" */
+     .name	       	= "led-d4",
+     .gpio		= AT91_PIN_PC15,
+     .active_low		= 1,
+     .default_trigger	= "led-d4",
+   },
+   {	/* "relay X1" */
+     .name	       	= "relay-X1",
+     .gpio		= AT91_PIN_PD0,
+     .active_low		= 0,
+   },
+   {	/* "relay X2" */
+     .gpio		= AT91_PIN_PD1,
+     .name	       	= "relay-X2",
+     .active_low		= 0,
+   },
+   {	/* "relay X3" */
+     .name	       	= "relay-X3",
+     .gpio		= AT91_PIN_PD2,
+     .active_low		= 0,
+   },
+   {	/* "relay X4" */
+     .name	       	= "relay-X4",
+     .gpio		= AT91_PIN_PD3,
+     .active_low		= 0,
+   },
+   {	/* "USB Power - top" */
+     .name	       	= "usbpwr-top",
+     .gpio		= AT91_PIN_PC3,
+     .active_low		= 0,
+     .default_trigger	= "default-on",
+   },
+   {	/* "USB Power - bottom" */
+     .name	       	= "usbpwr-bot",
+     .gpio		= AT91_PIN_PC4,
+     .active_low		= 0,
+     .default_trigger	= "default-on",
+   },
+ };
+ 
+ #ifdef CONFIG_LIAB_TDC_LIABDIN_ADDON
+ static struct gpio_led addon_leds[] = {
+   {	
+     .name		= "addon-led-0",
+     .default_trigger	= "heartbeat",
+   },
+   {	
+     .name		= "addon-led-1",
+     .default_trigger	= "timer",
+   },
+   {	
+     .name		= "addon-led-2",
+   },
+   {	
+     .name		= "addon-led-3",
+   },
+   {	
+     .name		= "addon-led-4",
+   },
+   {	
+     .name		= "addon-led-5",
+   },
+   {	
+     .name		= "addon-led-6",
+   },
+   {	
+     .name		= "addon-led-7",
+   },
+   {	
+     .name		= "addon-led-8",
+   },
+   {	
+     .name		= "addon-led-9",
+   },
+ };
+ #else
+ static struct gpio_led addon_leds[] = {
+   {	
+     .name		= "addon-led-0",
+     .default_trigger	= "heartbeat",
+   },
+   {	
+     .name		= "addon-led-1",
+     .default_trigger	= "timer",
+   },
+   {	
+     .name		= "addon-led-2",
+   },
+   {	
+     .name		= "addon-led-3",
+   },
+   {	
+     .name		= "addon-led-4",
+   },
+   {	
+     .name		= "addon-led-5",
+   },
+   {	
+     .name		= "addon-led-6",
+   },
+   {	
+     .name		= "addon-led-7",
+   },
+   {	
+     .name		= "addon-led-8",
+   },
+   {	
+     .name		= "addon-led-9",
+   },
+   {	
+     .name		= "addon-led-10",
+   },
+   {	
+     .name		= "addon-led-11",
+   },
+   {	
+     .name		= "addon-led-12",
+   },
+   {	
+     .name		= "addon-led-13",
+   },
+   {	
+     .name		= "addon-led-14",
+   },
+ };
+ #endif
+ 
+ static struct gpio_led_platform_data led_data;
+ 
+ static struct platform_device liabdin_addon_device = {
+ 	.name		= "leds-liabdin-addon",
+ 	.id		= -1,
+ 	.num_resources	= 0,
+ 	.dev		= {
+ 		.platform_data	= &led_data,
+ 	}
+ };
+ 
+ void __init liabdin_addon_leds(struct gpio_led *leds, int nr)
+ {
+ 	if (!nr)
+ 		return;
+ 
+ 	led_data.leds = leds;
+ 	led_data.num_leds = nr;
+ 	platform_device_register(&liabdin_addon_device);
+ }
+ 
+ 
+ /*
+  * SPI devices.
+  */
+ static struct spi_board_info ipatu_spi_devices[] = {
+ 	{	/* MAX1098 5-port A/D */
+ 		.modalias	= "max1098",
+ 		.chip_select	= 0,
+     .bus_num	= 0,
+ 		.max_speed_hz	= 2 * 1000 * 1000,
+ 	},
+ 	{	/* MAX5513 2-port D/A */
+ 		.modalias	= "spidev",
+ 		.chip_select	= 1,
+     .bus_num	= 0,
+ 		.max_speed_hz	= 6 * 1000 * 1000,
+ 	},
+ };
+ 
+ 
+ static void __init liabdin_board_init(void)
+ {
+ 	/* Serial */
+ 	at91_add_device_serial();
+ 	/* Ethernet */
+ 	at91_add_device_eth(&liabdin_eth_data);
+ 	/* USB Host */
+ 	at91_add_device_usbh(&liabdin_usbh_data);
+   /*
+   at91_set_gpio_output(AT91_PIN_PC3, 1);
+   at91_set_gpio_output(AT91_PIN_PC4, 1);
+   */
+ 	/* USB Device */
+ #ifdef CONFIG_LIAB_TDC_LIABDIN_ADDON
+ 	at91_add_device_udc(&liabdin_udc_data);
+ 	at91_set_multi_drive(liabdin_udc_data.pullup_pin, 1);	/* pullup_pin is connected to reset */
+ #endif
+ 	/* I2C */
+ 	at91_add_device_i2c(liabdin_i2c_devices, ARRAY_SIZE(liabdin_i2c_devices));
+ 	/* SPI */
+ 	at91_add_device_spi(ipatu_spi_devices, ARRAY_SIZE(ipatu_spi_devices));
+   /* Buttons */
+   din_add_device_buttons();
+ 
+ #ifdef CONFIG_LIAB_LIABDIN_ADDON
+   /* Addon board LEDs */
+   liabdin_addon_leds(addon_leds, ARRAY_SIZE(addon_leds));
+ #endif
+ 
+ #ifdef CONFIG_LIAB_TDC_LIABDIN_ADDON
+   at91_add_device_dm9000();
+ #endif
+ 
+   at91_add_device_pwm(0);
+   at91_add_device_modem();
+ 
+ #ifdef CONFIG_LEDS_GPIO
+ 	/* LEDs */
+ 	at91_gpio_leds(liabdin_leds, ARRAY_SIZE(liabdin_leds));
+ #endif
+ 
+ 	at91_add_device_watchdog();
+ 
+ }
+ 
+ MACHINE_START(AT91RM9200DK, "Atmel AT91RM9200-DK")
+ 	/* Maintainer: SAN People/Atmel */
+ 	.phys_io	= AT91_BASE_SYS,
+ 	.io_pg_offst	= (AT91_VA_BASE_SYS >> 18) & 0xfffc,
+ 	.boot_params	= AT91_SDRAM_BASE + 0x100,
+ 	.timer		= &at91rm9200_timer,
+ 	.map_io		= liabdin_map_io,
+ 	.init_irq	= liabdin_init_irq,
+ 	.init_machine	= liabdin_board_init,
+ MACHINE_END
diff -r -C3 -P linux-2.6.29.4/arch/arm/mach-at91/board-liabrcserv.c liab-linux-2.6.29.4/arch/arm/mach-at91/board-liabrcserv.c
*** linux-2.6.29.4/arch/arm/mach-at91/board-liabrcserv.c	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/arch/arm/mach-at91/board-liabrcserv.c	2012-01-20 14:48:32.565306174 +0100
***************
*** 0 ****
--- 1,314 ----
+ /*
+  * linux/arch/arm/mach-at91/board-rcserv.c
+  *
+  * Shamelessly ripped of from
+  * linux/arch/arm/mach-at91/board-sam9260ek.c
+  *
+  * By LIAB ApS 2008
+  *
+  *  Copyright (C) 2005 SAN People
+  *  Copyright (C) 2006 Atmel
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2 of the License, or
+  * (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+  */
+ 
+ #include <linux/types.h>
+ #include <linux/init.h>
+ #include <linux/mm.h>
+ #include <linux/module.h>
+ #include <linux/platform_device.h>
+ #include <linux/spi/spi.h>
+ #include <linux/spi/flash.h>
+ #include <linux/input.h>
+ #include <linux/gpio_keys.h>
+ 
+ #include <asm/hardware.h>
+ #include <asm/setup.h>
+ #include <asm/mach-types.h>
+ #include <asm/irq.h>
+ 
+ #include <asm/mach/arch.h>
+ #include <asm/mach/map.h>
+ #include <asm/mach/irq.h>
+ 
+ #include <asm/arch/board.h>
+ #include <asm/arch/gpio.h>
+ #include <asm/arch/at91sam926x_mc.h>
+ 
+ #include "generic.h"
+ 
+ 
+ /*
+  * Serial port configuration.
+  *    0 .. 5 = USART0 .. USART5
+  *    6      = DBGU
+  */
+ static struct at91_uart_config __initdata rcserv_uart_config = {
+ 	.console_tty	= 0,				/* ttyS0 */
+ 	.nr_tty		= 3,
+ 	.tty_map	= { 6, 0, 1, -1, -1, -1, -1 }	/* ttyS0, ..., ttyS6 */
+ };
+ 
+ static void __init rcserv_map_io(void)
+ {
+   /* Initialize processor: 14.7456 MHz crystal */
+   at91sam9260_initialize(14745600);
+   
+   /* Setup the LEDs */
+   //  at91_init_leds(AT91_PIN_PC6, AT91_PIN_PC6);
+   
+   /* Setup the serial ports and console */
+   at91_init_serial(&rcserv_uart_config);
+ }
+ 
+ static void __init rcserv_init_irq(void)
+ {
+ 	at91sam9260_init_interrupts(NULL);
+ }
+ 
+ 
+ /*
+  * USB Host port
+  */
+ static struct at91_usbh_data __initdata rcserv_usbh_data = {
+ 	.ports		 = 2,
+   .vbus_pin        = {AT91_PIN_PC7, AT91_PIN_PC7},
+   .vbus_active_low = 0,
+ };
+ 
+ 
+ /*
+  * USB Device port
+  */
+ static struct at91_udc_data __initdata rcserv_udc_data = {
+ 	.vbus_pin	= AT91_PIN_PC8,
+ 	.pullup_pin	= AT91_PIN_PC13, 
+ };
+ 
+ 
+ /*
+  * SPI devices.
+  */
+ static struct spi_board_info rcserv_spi_devices[] = {
+ 	{	/* DataFlash chip */
+ 		.modalias	= "mtd_dataflash",
+ 		.chip_select	= 1,
+ 		.max_speed_hz	= 1 * 1000 * 1000, /* 1 MHz */
+ 		.bus_num	= 0,
+ 	},
+ };
+ 
+ 
+ /*
+  * MACB Ethernet device
+  */
+ static struct at91_eth_data __initdata rcserv_macb_data = {
+ 	.phy_irq_pin	= AT91_PIN_PC5,
+ 	.is_rmii	= 0,
+ };
+ 
+ 
+ /*
+  * NAND flash
+  */
+ static struct mtd_partition __initdata rcserv_nand_partition[] = {
+ 	{
+ 		.name	= "Kernel+Root partition",
+ 		.offset	= 0,
+ 		.size	= 16*1024*1024,
+ 	},
+ 	{
+ 		.name	= "JFFS2 User storage",
+ 		.offset	= (16*1024*1024),
+ 		.size	= MTDPART_SIZ_FULL,
+ 	},
+ };
+ 
+ static struct mtd_partition * __init nand_partitions(int size, int *num_partitions)
+ {
+ 	*num_partitions = ARRAY_SIZE(rcserv_nand_partition);
+ 	return rcserv_nand_partition;
+ };
+ 
+ static struct at91_nand_data __initdata rcserv_nand_data = {
+ 	.ale		= 21,
+ 	.cle		= 22,
+ //	.det_pin	= ... not connected
+ 	.rdy_pin	= AT91_PIN_PC4,
+   .enable_pin	= AT91_PIN_PC14,
+ 	.partition_info	= nand_partitions,
+ 	.bus_width_16	= 0,
+ };
+ 
+ static struct i2c_board_info __initdata rcserv_i2c_devices[] = {
+ 	{
+ 		I2C_BOARD_INFO("rtc-ds1307", 0x68),
+ 		.type	= "ds1307",
+ 	},
+ 	{
+ 		I2C_BOARD_INFO("adm9240", (0x2c<<1)),
+ 		.type	= "adm9240",
+ 	},
+ };
+ 
+ #if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
+ static struct gpio_keys_button rcserv_buttons[] = {
+ 	{
+ 		.gpio		= AT91_PIN_PA8,
+ 		.code		= BTN_0,
+ 		.desc		= "sw1",
+ 		.active_low	= 1,
+ 	},
+ 	{
+ 		.gpio		= AT91_PIN_PA9,
+ 		.code		= BTN_1,
+ 		.desc		= "sw2",
+ 		.active_low	= 1,
+ 	},
+ 	{
+ 		.gpio		= AT91_PIN_PC12,
+ 		.code		= BTN_2,
+ 		.desc		= "opto1",
+ 		.active_low	= 1,
+ 	},
+ 	{
+ 		.gpio		= AT91_PIN_PC13,
+ 		.code		= BTN_3,
+ 		.desc		= "opto2",
+ 		.active_low	= 1,
+ 	},
+ };
+ 
+ static struct gpio_keys_platform_data rcserv_button_data = {
+ 	.buttons	= rcserv_buttons,
+ 	.nbuttons	= ARRAY_SIZE(rcserv_buttons),
+ };
+ 
+ static struct platform_device rcserv_button_device = {
+ 	.name		= "gpio-keys",
+ 	.id		= -1,
+ 	.num_resources	= 0,
+ 	.dev		= {
+ 		.platform_data	= &rcserv_button_data,
+ 	}
+ };
+ 
+ static void __init rcserv_add_device_buttons(void)
+ {
+   int i;
+   for(i=0; i<ARRAY_SIZE(rcserv_buttons); i++) {
+     at91_set_gpio_input(rcserv_buttons[i].gpio, 0);
+     at91_set_deglitch(rcserv_buttons[i].gpio, 1);
+   }
+ 
+   platform_device_register(&rcserv_button_device);
+ }
+ #else
+ static void __init rcserv_add_device_buttons(void) {}
+ #endif
+ 
+ 
+ static struct gpio_led rcserv_leds[] = {
+   {
+     .name		= "system-ok-green",
+     .gpio		= AT91_PIN_PA6,
+     .active_low		= 0,
+     .default_trigger	= "key-red",
+   },
+   /* Ahem... tiny nomenclature hack. */
+   {	/* Relay 1 */
+     .name		= "relay1",
+     .gpio		= AT91_PIN_PB30,
+     .active_low		= 0,
+   },
+   {	/* Relay 2 */
+     .name		= "relay2",
+     .gpio		= AT91_PIN_PB31,
+     .active_low		= 0,
+   },
+ };
+ 
+ 
+ static struct resource timer_resources[] = {
+   [0] = {
+     .start	= AT91SAM9260_BASE_TC0,
+     .end	= AT91SAM9260_BASE_TC0 + 64 - 1,
+     .flags	= IORESOURCE_MEM,
+   },
+   [1] = {
+     .start	= AT91SAM9260_BASE_TC1,
+     .end	= AT91SAM9260_BASE_TC1 + 64 - 1,
+     .flags	= IORESOURCE_MEM,
+   },
+   [2] = {
+     .start	= AT91SAM9260_BASE_TC2,
+     .end	= AT91SAM9260_BASE_TC2 + 64 - 1,
+     .flags	= IORESOURCE_MEM,
+   },
+ };
+ 
+ static u32 no = 1;
+ static struct platform_device at91_timer_device = {
+   .name		= "at91_pwm",
+   .id		= -1,
+   .dev		= {
+     .platform_data		= &no,
+   },
+   .resource	= timer_resources,
+ 	.num_resources	= ARRAY_SIZE(timer_resources),
+ };
+ 
+ void __init at91_add_device_pwm(void)
+ {
+ 
+   at91_set_B_periph(AT91_PIN_PC9, 0);
+   platform_device_register(&at91_timer_device);
+   
+ }
+ 
+ static void __init rcserv_board_init(void)
+ {
+ 	/* Serial */
+ 	at91_add_device_serial();
+ 	/* USB Host */
+ 	at91_add_device_usbh(&rcserv_usbh_data);
+ 	/* USB Device */
+ 	at91_add_device_udc(&rcserv_udc_data);
+ 	/* SPI */
+ 	at91_add_device_spi(rcserv_spi_devices, ARRAY_SIZE(rcserv_spi_devices));
+ 	/* NAND */
+ 	at91_add_device_nand(&rcserv_nand_data);
+ 	/* Ethernet */
+ 	at91_add_device_eth(&rcserv_macb_data);
+ 	/* I2C */
+ 	at91_add_device_i2c(rcserv_i2c_devices, ARRAY_SIZE(rcserv_i2c_devices));
+   /* Buttons */
+   rcserv_add_device_buttons();
+ #ifdef CONFIG_LEDS_GPIO
+ 	/* LEDs */
+ 	at91_gpio_leds(rcserv_leds, ARRAY_SIZE(rcserv_leds));
+ #endif
+ }
+ 
+ MACHINE_START(LIABARM, "Atmel AT91SAM9260 LIAB-board")
+ 	/* Maintainer: Atmel */
+ 	.phys_io	= AT91_BASE_SYS,
+ 	.io_pg_offst	= (AT91_VA_BASE_SYS >> 18) & 0xfffc,
+ 	.boot_params	= AT91_SDRAM_BASE + 0x100,
+ 	.timer		= &at91sam926x_timer,
+ 	.map_io		= rcserv_map_io,
+ 	.init_irq	= rcserv_init_irq,
+ 	.init_machine	= rcserv_board_init,
+ MACHINE_END
diff -r -C3 -P linux-2.6.29.4/arch/arm/mach-at91/board-liabsg.c liab-linux-2.6.29.4/arch/arm/mach-at91/board-liabsg.c
*** linux-2.6.29.4/arch/arm/mach-at91/board-liabsg.c	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/arch/arm/mach-at91/board-liabsg.c	2012-01-20 14:48:32.565306174 +0100
***************
*** 0 ****
--- 1,611 ----
+ /*
+  * linux/arch/arm/mach-at91/board-sam9260ek.c
+  *
+  *  Copyright (C) 2005 SAN People
+  *  Copyright (C) 2006 Atmel
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2 of the License, or
+  * (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+  */
+ 
+ #include <linux/types.h>
+ #include <linux/init.h>
+ #include <linux/mm.h>
+ #include <linux/module.h>
+ #include <linux/platform_device.h>
+ #include <linux/spi/spi.h>
+ #include <linux/spi/at73c213.h>
+ #include <linux/clk.h>
+ #include <linux/i2c/at24.h>
+ #include <linux/i2c.h>
+ #include <linux/i2c/pca953x.h>
+ #include <linux/gpio_keys.h>
+ #include <linux/input.h>
+ 
+ #include <asm/setup.h>
+ #include <asm/mach-types.h>
+ #include <asm/irq.h>
+ 
+ #include <asm/mach/arch.h>
+ #include <asm/mach/map.h>
+ #include <asm/mach/irq.h>
+ 
+ #include <mach/hardware.h>
+ #include <mach/board.h>
+ #include <mach/gpio.h>
+ #include <mach/at91sam9_smc.h>
+ #include <mach/at91_shdwc.h>
+ 
+ #include "sam9_smc.h"
+ #include "generic.h"
+ 
+ #define U800_OFFSET (192)
+ #define U801_OFFSET (208)
+ 
+ static void __init sg_map_io(void)
+ {
+ 	/* Initialize processor: 18.432 MHz crystal */
+  	at91sam9260_initialize(25000000);
+ 
+ 	/* DGBU on ttyS0. (Rx & Tx only) */
+ 	at91_register_uart(0, 0, 0);
+ 
+     /* AUX serial */
+ 	/* USART0 on ttyS0. (Rx, Tx, CTS, RTS, DTR, DSR, DCD, RI) */
+ 	at91_register_uart(AT91SAM9260_ID_US0, 1, ATMEL_UART_CTS | ATMEL_UART_RTS
+ 			   | ATMEL_UART_DTR | ATMEL_UART_DSR | ATMEL_UART_DCD
+ 			   | ATMEL_UART_RI);
+ 
+     /* Modem 0 */
+ 	/* USART1 on ttyS1. (Rx, Tx, RTS, CTS) modem */
+ 	at91_register_uart(AT91SAM9260_ID_US1, 2, ATMEL_UART_CTS | ATMEL_UART_RTS);
+ 
+     /* RS485 interface */
+ 	/* USART2 on ttyS2. (Rx, Tx, RTS - RS485 interface) */
+ 	at91_register_uart(AT91SAM9260_ID_US2, 4, ATMEL_UART_RTS|ATMEL_UART_RS485);
+ 
+     /* modem 1 */ 
+     at91_register_uart(AT91SAM9260_ID_US3, 3, 0);
+ 
+ 	/* set serial console to ttyS0 (ie, DBGU) */
+ 	at91_set_serial_console(0);
+ }
+ 
+ static void __init sg_init_irq(void)
+ {
+ 	at91sam9260_init_interrupts(NULL);
+ }
+ 
+ 
+ /*
+  * USB Host port
+  */
+ static struct at91_usbh_data __initdata sg_usbh_data = {
+ 	.ports		= 2,
+ };
+ 
+ /*
+  * USB Device port
+  */
+ static struct at91_udc_data __initdata sg_udc_data = {
+ 	.vbus_pin	= AT91_PIN_PC9,
+ 	.pullup_pin	= 0,		/* pull-up driven by UDC */
+ };
+ 
+ /*
+  * SPI devices.
+  */
+ static struct spi_board_info sg_spi_devices[] = {
+ 	{	/* DataFlash chip */
+ 		.modalias	= "mtd_dataflash",
+ 		.chip_select	= 0,
+ 		.max_speed_hz	= 15 * 1000 * 1000,
+ 		.bus_num	= 0,
+ 	},
+ 	{	/* ADC */
+ 		.modalias	= "adc78h98",
+ 		.chip_select	= 0,
+ 		.max_speed_hz	= 15 * 1000 * 1000,
+ 		.bus_num	= 1,
+ 	},
+ 	{	/* ADC */
+ 		.modalias	= "adc78h98",
+ 		.chip_select	= 1,
+ 		.max_speed_hz	= 15 * 1000 * 1000,
+ 		.bus_num	= 1,
+ 	},
+ };
+ 
+ 
+ /*
+  * MACB Ethernet device
+  */
+ static struct at91_eth_data __initdata sg_macb_data = {
+ 	.phy_irq_pin	= AT91_PIN_PB31,
+ 	.is_rmii	= 0,
+ };
+ 
+ 
+ /*
+  * NAND flash
+  */
+ static struct mtd_partition __initdata sg_nand_partition[] = {
+ 	{
+ 		.name	= "Bootstrap",
+ 		.offset	= 0,
+ 		.size	= (32*SZ_1M),
+ 	},
+ 	{
+ 		.name	= "FLASH storage",
+ 		.offset	= MTDPART_OFS_NXTBLK,
+ 		.size	= (200 * SZ_1M),
+ 	},
+     {
+       .name	= "UPDATE scratch area",
+       .offset	= MTDPART_OFS_NXTBLK,
+       .size	= MTDPART_SIZ_FULL,
+     },
+ };
+ 
+ static struct mtd_partition * __init nand_partitions(int size, int *num_partitions)
+ {
+ 	*num_partitions = ARRAY_SIZE(sg_nand_partition);
+ 	return sg_nand_partition;
+ }
+ 
+ static struct atmel_nand_data __initdata sg_nand_data = {
+ 	.ale		= 21,
+ 	.cle		= 22,
+ //	.det_pin	= ... not connected
+ 	.rdy_pin	= AT91_PIN_PC10,
+ 	.enable_pin	= AT91_PIN_PC14,
+ 	.partition_info	= nand_partitions,
+ 	.bus_width_16	= 0,
+ };
+ 
+ static struct sam9_smc_config __initdata sg_nand_smc_config = {
+ 	.ncs_read_setup		= 0,
+ 	.nrd_setup		= 1,
+ 	.ncs_write_setup	= 0,
+ 	.nwe_setup		= 1,
+ 
+ 	.ncs_read_pulse		= 3,
+ 	.nrd_pulse		= 3,
+ 	.ncs_write_pulse	= 3,
+ 	.nwe_pulse		= 3,
+ 
+ 	.read_cycle		= 5,
+ 	.write_cycle		= 5,
+ 
+ 	.mode			= AT91_SMC_READMODE | AT91_SMC_WRITEMODE | AT91_SMC_EXNWMODE_DISABLE,
+ 	.tdf_cycles		= 2,
+ };
+ 
+ static void __init sg_add_device_nand(void)
+ {
+ 	/* setup bus-width (8 or 16) */
+   sg_nand_smc_config.mode |= AT91_SMC_DBW_8;
+ 
+ 	/* configure chip-select 3 (NAND) */
+ 	sam9_smc_configure(3, &sg_nand_smc_config);
+ 
+ 	at91_add_device_nand(&sg_nand_data);
+ }
+ 
+ 
+ 
+ /*
+  * LEDs
+  */
+ static struct gpio_led sg_leds[] = {
+ 	{	/* "bottom" led, green, userled1 to be defined */
+ 		.name			= "led_00g",
+ 		.gpio			= U800_OFFSET+6,
+ 		.active_low		= 1,
+ 		.default_trigger	= "heartbeat",
+ 	},
+ 	{	/* "bottom" led, green, userled1 to be defined */
+ 		.name			= "led_00r",
+ 		.gpio			= U800_OFFSET+7,
+ 		.active_low		= 1,
+ 		.default_trigger	= "none",
+ 	},
+ 	{	/* "bottom" led, green, userled1 to be defined */
+ 		.name			= "led_01g",
+ 		.gpio			= U800_OFFSET+4,
+ 		.active_low		= 1,
+ 		.default_trigger	= "cpu-busy",
+ 	},
+ 	{	/* "bottom" led, green, userled1 to be defined */
+ 		.name			= "led_01r",
+ 		.gpio			= U800_OFFSET+5,
+ 		.active_low		= 1,
+ 		.default_trigger	= "none",
+ 	},
+ 	{	/* "bottom" led, green, userled1 to be defined */
+ 		.name			= "led_02g",
+ 		.gpio			= U800_OFFSET+2,
+ 		.active_low		= 1,
+ 		.default_trigger	= "none",
+ 	},
+ 	{	/* "bottom" led, green, userled1 to be defined */
+ 		.name			= "led_02r",
+ 		.gpio			= U800_OFFSET+3,
+ 		.active_low		= 1,
+ 		.default_trigger	= "nand-disk",
+ 	},
+ 	{	/* "bottom" led, green, userled1 to be defined */
+ 		.name			= "led_03g",
+ 		.gpio			= U800_OFFSET+0,
+ 		.active_low		= 1,
+ 		.default_trigger	= "timer",
+ 	},
+ 	{	/* "bottom" led, green, userled1 to be defined */
+ 		.name			= "led_03r",
+ 		.gpio			= U800_OFFSET+1,
+ 		.active_low		= 1,
+ 		.default_trigger	= "none",
+ 	},
+ 	{	/* "bottom" led, green, userled1 to be defined */
+ 		.name			= "led_04g",
+ 		.gpio			= U800_OFFSET+14,
+ 		.active_low		= 1,
+ 		.default_trigger	= "none",
+ 	},
+ 	{	/* "bottom" led, green, userled1 to be defined */
+ 		.name			= "led_04r",
+ 		.gpio			= U800_OFFSET+15,
+ 		.active_low		= 1,
+ 		.default_trigger	= "none",
+ 	},
+ 	{	/* "bottom" led, green, userled1 to be defined */
+ 		.name			= "led_05g",
+ 		.gpio			= U800_OFFSET+12,
+ 		.active_low		= 1,
+ 		.default_trigger	= "none",
+ 	},
+ 	{	/* "bottom" led, green, userled1 to be defined */
+ 		.name			= "led_05r",
+ 		.gpio			= U800_OFFSET+13,
+ 		.active_low		= 1,
+ 		.default_trigger	= "none",
+ 	},
+ 	{	/* "bottom" led, green, userled1 to be defined */
+ 		.name			= "led_06g",
+ 		.gpio			= U800_OFFSET+10,
+ 		.active_low		= 1,
+ 		.default_trigger	= "none",
+ 	},
+ 	{	/* "bottom" led, green, userled1 to be defined */
+ 		.name			= "led_06r",
+ 		.gpio			= U800_OFFSET+11,
+ 		.active_low		= 1,
+ 		.default_trigger	= "none",
+ 	},
+ 	{	/* "bottom" led, green, userled1 to be defined */
+ 		.name			= "led_07g",
+ 		.gpio			= U800_OFFSET+8,
+ 		.active_low		= 1,
+ 		.default_trigger	= "none",
+ 	},
+ 	{	/* "bottom" led, green, userled1 to be defined */
+ 		.name			= "led_07r",
+ 		.gpio			= U800_OFFSET+9,
+ 		.active_low		= 1,
+ 		.default_trigger	= "none",
+ 	},
+ 	
+ 
+ /*
+ 	{	
+ 		.name			= "led_08g",
+ 		.gpio			= U801_OFFSET+0,
+ 		.active_low		= 1,
+ 		.default_trigger	= "nand-disk",
+ 	},
+ 	{	
+ 		.name			= "led_08r",
+ 		.gpio			= U801_OFFSET+1,
+ 		.active_low		= 1,
+ 		.default_trigger	= "none",
+ 	},
+ 	{	
+ 		.name			= "led_09g",
+ 		.gpio			= U801_OFFSET+2,
+ 		.active_low		= 1,
+ 		.default_trigger	= "none",
+ 	},
+ 	{	
+ 		.name			= "led_09r",
+ 		.gpio			= U801_OFFSET+3,
+ 		.active_low		= 1,
+ 		.default_trigger	= "none",
+ 	},
+ 	{	
+ 		.name			= "led_10g",
+ 		.gpio			= U801_OFFSET+4,
+ 		.active_low		= 1,
+ 		.default_trigger	= "none",
+ 	},
+ 	{	
+ 		.name			= "led_10r",
+ 		.gpio			= U801_OFFSET+5,
+ 		.active_low		= 1,
+ 		.default_trigger	= "cpu-busy",
+ 	},
+ 	{	
+ 		.name			= "led_11g",
+ 		.gpio			= U801_OFFSET+6,
+ 		.active_low		= 1,
+ 		.default_trigger	= "timer", //nand-disk
+ 	},
+ 
+ 
+ 	{	
+ 		.name			= "led_11r",
+ 		.gpio			= U801_OFFSET+7,
+ 		.active_low		= 1,
+ 		.default_trigger	= "heartbeat",
+ 	},
+ */
+ 	{	/* "power" led, yellow */
+ 		.name			= "relay_1",
+ 		.gpio			= AT91_PIN_PC6,
+ 		.default_trigger	= "none",
+ 	},
+ 	{	/* "power" led, yellow */
+ 		.name			= "relay_2",
+ 		.gpio			= AT91_PIN_PC7,
+ 		.default_trigger	= "none",
+ 	},
+ 	{	/* "power" led, yellow */
+ 		.name			= "relay_3",
+ 		.gpio			= AT91_PIN_PC12,
+ 		.default_trigger	= "none",
+ 	}
+ 
+ };
+ 
+ static struct pca953x_platform_data pca9535_gpio_ext_pdata_u800 = {
+ 	.gpio_base = U800_OFFSET,
+ };
+ 
+ /*
+ static struct pca953x_platform_data pca9535_gpio_ext_pdata_u801 = {
+ 	.gpio_base = U801_OFFSET,
+ };
+ */
+ 
+ /*
+  * I2C devices
+  */
+ 
+ static struct at24_platform_data at24lc256 = {
+ 	.byte_len	= SZ_256K / 8,
+ 	.page_size	= 64,
+ 	.flags		= AT24_FLAG_ADDR16,
+ };
+ 
+ 
+ static struct i2c_board_info __initdata sg_i2c_devices[] = {
+     {
+ 	I2C_BOARD_INFO("rtc-ds1307", 0x68),
+ 	.type	= "ds1307",
+     },
+     { 
+ 	I2C_BOARD_INFO("pca953x", 0x20),
+ 	.type = "pca9535",
+ 	.platform_data = &pca9535_gpio_ext_pdata_u800,
+     }, 
+     { 
+ 	I2C_BOARD_INFO("adm9240", 0x2c),
+ 	.type = "adm9240",
+     },
+     {
+ 	I2C_BOARD_INFO("24c256", 0x50),
+ 	.platform_data = &at24lc256,
+     },
+ 
+ 	/* more devices can be added using expansion connectors */
+ };
+ 
+ 
+ /*
+  * GPIO Buttons
+  */
+ #if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
+ static struct gpio_keys_button sg_buttons[] = {
+ 	{
+ 		.gpio		= AT91_PIN_PC15,
+ 		.code		= BTN_4,
+ 		.desc		= "opto_1",
+ 		.active_low	= 1,
+ 		.wakeup		= 1,
+ 	},
+ 	{
+ 		.gpio		= AT91_PIN_PC11,
+ 		.code		= BTN_5,
+ 		.desc		= "opto_2",
+ 		.active_low	= 1,
+ 		.wakeup		= 1,
+ 	},
+ 	{
+ 		.gpio		= AT91_PIN_PA30,
+ 		.code		= BTN_6,
+ 		.desc		= "button_1",
+ 		.active_low	= 1,
+ 		.wakeup		= 1,
+ 	}
+ 
+ };
+ 
+ static struct gpio_keys_platform_data sg_button_data = {
+ 	.buttons	= sg_buttons,
+ 	.nbuttons	= ARRAY_SIZE(sg_buttons),
+ };
+ 
+ static struct platform_device sg_button_device = {
+ 	.name		= "gpio-keys",
+ 	.id		= -1,
+ 	.num_resources	= 0,
+ 	.dev		= {
+ 		.platform_data	= &sg_button_data,
+ 	}
+ };
+ 
+ static void __init sg_add_device_buttons(void)
+ {
+  	at91_set_gpio_input(AT91_PIN_PC15, 1);	/* opto 1 */
+  	at91_set_deglitch(AT91_PIN_PC15, 1); 
+  	at91_set_gpio_input(AT91_PIN_PC11, 1);	/* opto 2 */
+  	at91_set_deglitch(AT91_PIN_PC11, 1); 
+  	at91_set_gpio_input(AT91_PIN_PA30, 1);	/* button 2 */
+  	at91_set_deglitch(AT91_PIN_PA30, 1); 
+ 
+     printk(KERN_ERR "add buttons\n");
+ 
+ 	platform_device_register(&sg_button_device);
+ }
+ #else
+ static void __init sg_add_device_buttons(void) { printk(KERN_ERR "no buttons\n");}
+ #endif
+ 
+ 
+ static void __init sg_board_init(void)
+ {
+ 	/* Serial */
+ 	at91_add_device_serial();
+ 	/* USB Host */
+ 	at91_add_device_usbh(&sg_usbh_data);
+ 
+ 	/* set gpio outputs */
+ 	at91_set_gpio_output(AT91_PIN_PB16, 1); // usb_vcc_on
+ 	at91_set_gpio_output(AT91_PIN_PB18, 1); // adv vcc
+ 	
+ 	/* USB Device */
+ 	at91_add_device_udc(&sg_udc_data);
+ 	/* SPI */
+ 	at91_add_device_spi(sg_spi_devices, ARRAY_SIZE(sg_spi_devices));
+ 	/* NAND */
+ 	sg_add_device_nand();
+ 	/* Ethernet */
+ 	at91_add_device_eth(&sg_macb_data);
+ 	/* I2C */
+ 	at91_add_device_i2c(sg_i2c_devices, ARRAY_SIZE(sg_i2c_devices));
+ 
+ 	/* LEDs */
+     at91_gpio_leds(sg_leds, ARRAY_SIZE(sg_leds));
+ 
+ 	/* Push Buttons */
+ 	sg_add_device_buttons();
+ 
+   
+ 	printk(KERN_INFO "Board file liab sg");
+ 
+ }
+ 
+ struct gpio_sysfs {
+     const char *name;
+     unsigned long pin;
+     int init_val;
+     bool output;
+     bool user_direction;
+ };
+ 
+ static struct gpio_sysfs  sg_sysgpio[] = {
+     {
+         .name = "gsm_on-off",
+         .pin = AT91_PIN_PB12,
+         .output = true,
+         .user_direction = false,
+         .init_val = 0,
+     },
+     {
+         .name = "gsm_reset",
+         .pin = AT91_PIN_PB13,
+         .output = true,
+         .user_direction = false,
+         .init_val = 0,
+     },
+     {
+         .name = "gsm_pwrmon",
+         .pin = AT91_PIN_PA9,
+         .output = false,
+         .user_direction = false,
+         .init_val = 0,
+     }
+ };
+ 
+ void __init sg_gpio_sysfs_init(struct gpio_sysfs *gpios, int nr){
+ 
+     int i;
+ 
+ 	if (!nr){
+         printk(KERN_ERR "gpio_sysfs_init nr == 0\n");
+ 		return;
+     }
+ 
+     for (i = 0; i < nr; i++){
+         if (gpio_request(gpios[i].pin, gpios[i].name)){
+             printk(KERN_ERR "could not obtain gpio for "
+                    "%s\n", gpios[i].name);
+             continue;
+         }
+ 
+         if(gpios[i].output){
+             if(gpio_direction_output(gpios[i].pin, gpios[i].init_val)){
+                 printk(KERN_ERR "could not change direction for %s\n",
+                        gpios[i].name);
+                 continue;
+             }
+             printk(KERN_INFO "Exported gpio %ld (%s) as direction outout\n", 
+                    gpios[i].pin , gpios[i].name);
+         } else {
+             if(gpio_direction_input(gpios[i].pin)){
+                 printk(KERN_ERR "could not change direction for %s\n",
+                        gpios[i].name);
+                 continue;
+             }
+             printk(KERN_INFO "Exported gpio %ld (%s) as direction input\n",
+                    gpios[i].pin , gpios[i].name);            
+         }
+         
+         gpio_export(gpios[i].pin, gpios[i].user_direction);
+         printk(KERN_ERR "%s added to sysfs \n", gpios[i].name);
+     }
+ 
+ }
+ 
+ static int __init gpio_in_sysfs_init(void)
+ {
+ 
+     sg_gpio_sysfs_init(sg_sysgpio,  ARRAY_SIZE(sg_sysgpio));
+ 
+     return 0;
+     
+ }
+ 
+ late_initcall(gpio_in_sysfs_init);
+ 
+ 
+ MACHINE_START(LIABSG, "LIAB SG")
+ 	/* Maintainer: Atmel */
+ 	.phys_io	= AT91_BASE_SYS,
+ 	.io_pg_offst	= (AT91_VA_BASE_SYS >> 18) & 0xfffc,
+ 	.boot_params	= AT91_SDRAM_BASE + 0x100,
+ 	.timer		= &at91sam926x_timer,
+ 	.map_io		= sg_map_io,
+ 	.init_irq	= sg_init_irq,
+ 	.init_machine	= sg_board_init,
+ MACHINE_END
diff -r -C3 -P linux-2.6.29.4/arch/arm/mach-at91/board-sam9260ek.c liab-linux-2.6.29.4/arch/arm/mach-at91/board-sam9260ek.c
*** linux-2.6.29.4/arch/arm/mach-at91/board-sam9260ek.c	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/arch/arm/mach-at91/board-sam9260ek.c	2012-01-20 14:48:32.561306174 +0100
***************
*** 18,24 ****
   * along with this program; if not, write to the Free Software
   * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
   */
! 
  #include <linux/types.h>
  #include <linux/init.h>
  #include <linux/mm.h>
--- 18,24 ----
   * along with this program; if not, write to the Free Software
   * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
   */
! nej nej nej!!!!!!
  #include <linux/types.h>
  #include <linux/init.h>
  #include <linux/mm.h>
***************
*** 28,33 ****
--- 28,35 ----
  #include <linux/spi/at73c213.h>
  #include <linux/clk.h>
  #include <linux/i2c/at24.h>
+ #include <linux/i2c.h>
+ #include <linux/i2c/pca953x.h>
  #include <linux/gpio_keys.h>
  #include <linux/input.h>
  
***************
*** 48,70 ****
  #include "sam9_smc.h"
  #include "generic.h"
  
  
  static void __init ek_map_io(void)
  {
  	/* Initialize processor: 18.432 MHz crystal */
! 	at91sam9260_initialize(18432000);
  
  	/* DGBU on ttyS0. (Rx & Tx only) */
  	at91_register_uart(0, 0, 0);
  
! 	/* USART0 on ttyS1. (Rx, Tx, CTS, RTS, DTR, DSR, DCD, RI) */
  	at91_register_uart(AT91SAM9260_ID_US0, 1, ATMEL_UART_CTS | ATMEL_UART_RTS
  			   | ATMEL_UART_DTR | ATMEL_UART_DSR | ATMEL_UART_DCD
  			   | ATMEL_UART_RI);
  
! 	/* USART1 on ttyS2. (Rx, Tx, RTS, CTS) */
  	at91_register_uart(AT91SAM9260_ID_US1, 2, ATMEL_UART_CTS | ATMEL_UART_RTS);
  
  	/* set serial console to ttyS0 (ie, DBGU) */
  	at91_set_serial_console(0);
  }
--- 50,83 ----
  #include "sam9_smc.h"
  #include "generic.h"
  
+ #define U800_OFFSET (192)
+ #define U801_OFFSET (208)
  
  static void __init ek_map_io(void)
  {
  	/* Initialize processor: 18.432 MHz crystal */
!  	at91sam9260_initialize(25000000);
  
  	/* DGBU on ttyS0. (Rx & Tx only) */
  	at91_register_uart(0, 0, 0);
  
!     /* AUX serial */
! 	/* USART0 on ttyS0. (Rx, Tx, CTS, RTS, DTR, DSR, DCD, RI) */
  	at91_register_uart(AT91SAM9260_ID_US0, 1, ATMEL_UART_CTS | ATMEL_UART_RTS
  			   | ATMEL_UART_DTR | ATMEL_UART_DSR | ATMEL_UART_DCD
  			   | ATMEL_UART_RI);
  
!     /* Modem 0 */
! 	/* USART1 on ttyS1. (Rx, Tx, RTS, CTS) modem */
  	at91_register_uart(AT91SAM9260_ID_US1, 2, ATMEL_UART_CTS | ATMEL_UART_RTS);
  
+     /* RS485 interface */
+ 	/* USART2 on ttyS2. (Rx, Tx, RTS - RS485 interface) */
+ 	at91_register_uart(AT91SAM9260_ID_US2, 4, ATMEL_UART_RTS|ATMEL_UART_RS485);
+ 
+     /* modem 1 */ 
+     at91_register_uart(AT91SAM9260_ID_US3, 3, 0);
+ 
  	/* set serial console to ttyS0 (ie, DBGU) */
  	at91_set_serial_console(0);
  }
***************
*** 86,155 ****
   * USB Device port
   */
  static struct at91_udc_data __initdata ek_udc_data = {
! 	.vbus_pin	= AT91_PIN_PC5,
  	.pullup_pin	= 0,		/* pull-up driven by UDC */
  };
  
- 
- /*
-  * Audio
-  */
- static struct at73c213_board_info at73c213_data = {
- 	.ssc_id		= 0,
- 	.shortname	= "AT91SAM9260-EK external DAC",
- };
- 
- #if defined(CONFIG_SND_AT73C213) || defined(CONFIG_SND_AT73C213_MODULE)
- static void __init at73c213_set_clk(struct at73c213_board_info *info)
- {
- 	struct clk *pck0;
- 	struct clk *plla;
- 
- 	pck0 = clk_get(NULL, "pck0");
- 	plla = clk_get(NULL, "plla");
- 
- 	/* AT73C213 MCK Clock */
- 	at91_set_B_periph(AT91_PIN_PC1, 0);	/* PCK0 */
- 
- 	clk_set_parent(pck0, plla);
- 	clk_put(plla);
- 
- 	info->dac_clk = pck0;
- }
- #else
- static void __init at73c213_set_clk(struct at73c213_board_info *info) {}
- #endif
- 
  /*
   * SPI devices.
   */
  static struct spi_board_info ek_spi_devices[] = {
- #if !defined(CONFIG_MMC_AT91)
  	{	/* DataFlash chip */
  		.modalias	= "mtd_dataflash",
! 		.chip_select	= 1,
  		.max_speed_hz	= 15 * 1000 * 1000,
  		.bus_num	= 0,
  	},
! #if defined(CONFIG_MTD_AT91_DATAFLASH_CARD)
! 	{	/* DataFlash card */
! 		.modalias	= "mtd_dataflash",
  		.chip_select	= 0,
  		.max_speed_hz	= 15 * 1000 * 1000,
! 		.bus_num	= 0,
  	},
! #endif
! #endif
! #if defined(CONFIG_SND_AT73C213) || defined(CONFIG_SND_AT73C213_MODULE)
! 	{	/* AT73C213 DAC */
! 		.modalias	= "at73c213",
! 		.chip_select	= 0,
! 		.max_speed_hz	= 10 * 1000 * 1000,
  		.bus_num	= 1,
- 		.mode		= SPI_MODE_1,
- 		.platform_data	= &at73c213_data,
  	},
- #endif
  };
  
  
--- 99,130 ----
   * USB Device port
   */
  static struct at91_udc_data __initdata ek_udc_data = {
! 	.vbus_pin	= AT91_PIN_PC9,
  	.pullup_pin	= 0,		/* pull-up driven by UDC */
  };
  
  /*
   * SPI devices.
   */
  static struct spi_board_info ek_spi_devices[] = {
  	{	/* DataFlash chip */
  		.modalias	= "mtd_dataflash",
! 		.chip_select	= 0,
  		.max_speed_hz	= 15 * 1000 * 1000,
  		.bus_num	= 0,
  	},
! 	{	/* ADC */
! 		.modalias	= "adc78h98",
  		.chip_select	= 0,
  		.max_speed_hz	= 15 * 1000 * 1000,
! 		.bus_num	= 1,
  	},
! 	{	/* ADC */
! 		.modalias	= "adc78h98",
! 		.chip_select	= 1,
! 		.max_speed_hz	= 15 * 1000 * 1000,
  		.bus_num	= 1,
  	},
  };
  
  
***************
*** 157,164 ****
   * MACB Ethernet device
   */
  static struct at91_eth_data __initdata ek_macb_data = {
! 	.phy_irq_pin	= AT91_PIN_PA7,
! 	.is_rmii	= 1,
  };
  
  
--- 132,139 ----
   * MACB Ethernet device
   */
  static struct at91_eth_data __initdata ek_macb_data = {
! 	.phy_irq_pin	= AT91_PIN_PB31,
! 	.is_rmii	= 0,
  };
  
  
***************
*** 167,181 ****
   */
  static struct mtd_partition __initdata ek_nand_partition[] = {
  	{
! 		.name	= "Partition 1",
  		.offset	= 0,
! 		.size	= SZ_256K,
  	},
  	{
! 		.name	= "Partition 2",
  		.offset	= MTDPART_OFS_NXTBLK,
! 		.size	= MTDPART_SIZ_FULL,
  	},
  };
  
  static struct mtd_partition * __init nand_partitions(int size, int *num_partitions)
--- 142,161 ----
   */
  static struct mtd_partition __initdata ek_nand_partition[] = {
  	{
! 		.name	= "Bootstrap",
  		.offset	= 0,
! 		.size	= (32*SZ_1M),
  	},
  	{
! 		.name	= "FLASH storage",
  		.offset	= MTDPART_OFS_NXTBLK,
! 		.size	= (200 * SZ_1M),
  	},
+     {
+       .name	= "UPDATE scratch area",
+       .offset	= MTDPART_OFS_NXTBLK,
+       .size	= MTDPART_SIZ_FULL,
+     },
  };
  
  static struct mtd_partition * __init nand_partitions(int size, int *num_partitions)
***************
*** 188,201 ****
  	.ale		= 21,
  	.cle		= 22,
  //	.det_pin	= ... not connected
! 	.rdy_pin	= AT91_PIN_PC13,
  	.enable_pin	= AT91_PIN_PC14,
  	.partition_info	= nand_partitions,
- #if defined(CONFIG_MTD_NAND_ATMEL_BUSWIDTH_16)
- 	.bus_width_16	= 1,
- #else
  	.bus_width_16	= 0,
- #endif
  };
  
  static struct sam9_smc_config __initdata ek_nand_smc_config = {
--- 168,177 ----
  	.ale		= 21,
  	.cle		= 22,
  //	.det_pin	= ... not connected
! 	.rdy_pin	= AT91_PIN_PC10,
  	.enable_pin	= AT91_PIN_PC14,
  	.partition_info	= nand_partitions,
  	.bus_width_16	= 0,
  };
  
  static struct sam9_smc_config __initdata ek_nand_smc_config = {
***************
*** 219,228 ****
  static void __init ek_add_device_nand(void)
  {
  	/* setup bus-width (8 or 16) */
! 	if (ek_nand_data.bus_width_16)
! 		ek_nand_smc_config.mode |= AT91_SMC_DBW_16;
! 	else
! 		ek_nand_smc_config.mode |= AT91_SMC_DBW_8;
  
  	/* configure chip-select 3 (NAND) */
  	sam9_smc_configure(3, &ek_nand_smc_config);
--- 195,201 ----
  static void __init ek_add_device_nand(void)
  {
  	/* setup bus-width (8 or 16) */
!   ek_nand_smc_config.mode |= AT91_SMC_DBW_8;
  
  	/* configure chip-select 3 (NAND) */
  	sam9_smc_configure(3, &ek_nand_smc_config);
***************
*** 231,279 ****
  }
  
  
- /*
-  * MCI (SD/MMC)
-  */
- static struct at91_mmc_data __initdata ek_mmc_data = {
- 	.slot_b		= 1,
- 	.wire4		= 1,
- //	.det_pin	= ... not connected
- //	.wp_pin		= ... not connected
- //	.vcc_pin	= ... not connected
- };
- 
  
  /*
   * LEDs
   */
  static struct gpio_led ek_leds[] = {
  	{	/* "bottom" led, green, userled1 to be defined */
! 		.name			= "ds5",
! 		.gpio			= AT91_PIN_PA6,
  		.active_low		= 1,
  		.default_trigger	= "none",
  	},
! 	{	/* "power" led, yellow */
! 		.name			= "ds1",
! 		.gpio			= AT91_PIN_PA9,
  		.default_trigger	= "heartbeat",
  	}
  };
  
  /*
   * I2C devices
   */
! static struct at24_platform_data at24c512 = {
! 	.byte_len	= SZ_512K / 8,
! 	.page_size	= 128,
  	.flags		= AT24_FLAG_ADDR16,
  };
  
  static struct i2c_board_info __initdata ek_i2c_devices[] = {
! 	{
! 		I2C_BOARD_INFO("24c512", 0x50),
! 		.platform_data = &at24c512,
! 	},
  	/* more devices can be added using expansion connectors */
  };
  
--- 204,422 ----
  }
  
  
  
  /*
   * LEDs
   */
  static struct gpio_led ek_leds[] = {
  	{	/* "bottom" led, green, userled1 to be defined */
! 		.name			= "led_00g",
! 		.gpio			= U800_OFFSET+6,
! 		.active_low		= 1,
! 		.default_trigger	= "heartbeat",
! 	},
! 	{	/* "bottom" led, green, userled1 to be defined */
! 		.name			= "led_00r",
! 		.gpio			= U800_OFFSET+7,
  		.active_low		= 1,
  		.default_trigger	= "none",
  	},
! 	{	/* "bottom" led, green, userled1 to be defined */
! 		.name			= "led_01g",
! 		.gpio			= U800_OFFSET+4,
! 		.active_low		= 1,
! 		.default_trigger	= "cpu-busy",
! 	},
! 	{	/* "bottom" led, green, userled1 to be defined */
! 		.name			= "led_01r",
! 		.gpio			= U800_OFFSET+5,
! 		.active_low		= 1,
! 		.default_trigger	= "none",
! 	},
! 	{	/* "bottom" led, green, userled1 to be defined */
! 		.name			= "led_02g",
! 		.gpio			= U800_OFFSET+2,
! 		.active_low		= 1,
! 		.default_trigger	= "none",
! 	},
! 	{	/* "bottom" led, green, userled1 to be defined */
! 		.name			= "led_02r",
! 		.gpio			= U800_OFFSET+3,
! 		.active_low		= 1,
! 		.default_trigger	= "nand-disk",
! 	},
! 	{	/* "bottom" led, green, userled1 to be defined */
! 		.name			= "led_03g",
! 		.gpio			= U800_OFFSET+0,
! 		.active_low		= 1,
! 		.default_trigger	= "timer",
! 	},
! 	{	/* "bottom" led, green, userled1 to be defined */
! 		.name			= "led_03r",
! 		.gpio			= U800_OFFSET+1,
! 		.active_low		= 1,
! 		.default_trigger	= "none",
! 	},
! 	{	/* "bottom" led, green, userled1 to be defined */
! 		.name			= "led_04g",
! 		.gpio			= U800_OFFSET+14,
! 		.active_low		= 1,
! 		.default_trigger	= "none",
! 	},
! 	{	/* "bottom" led, green, userled1 to be defined */
! 		.name			= "led_04r",
! 		.gpio			= U800_OFFSET+15,
! 		.active_low		= 1,
! 		.default_trigger	= "none",
! 	},
! 	{	/* "bottom" led, green, userled1 to be defined */
! 		.name			= "led_05g",
! 		.gpio			= U800_OFFSET+12,
! 		.active_low		= 1,
! 		.default_trigger	= "none",
! 	},
! 	{	/* "bottom" led, green, userled1 to be defined */
! 		.name			= "led_05r",
! 		.gpio			= U800_OFFSET+13,
! 		.active_low		= 1,
! 		.default_trigger	= "none",
! 	},
! 	{	/* "bottom" led, green, userled1 to be defined */
! 		.name			= "led_06g",
! 		.gpio			= U800_OFFSET+10,
! 		.active_low		= 1,
! 		.default_trigger	= "none",
! 	},
! 	{	/* "bottom" led, green, userled1 to be defined */
! 		.name			= "led_06r",
! 		.gpio			= U800_OFFSET+11,
! 		.active_low		= 1,
! 		.default_trigger	= "none",
! 	},
! 	{	/* "bottom" led, green, userled1 to be defined */
! 		.name			= "led_07g",
! 		.gpio			= U800_OFFSET+8,
! 		.active_low		= 1,
! 		.default_trigger	= "none",
! 	},
! 	{	/* "bottom" led, green, userled1 to be defined */
! 		.name			= "led_07r",
! 		.gpio			= U800_OFFSET+9,
! 		.active_low		= 1,
! 		.default_trigger	= "none",
! 	},
! 	
! 
! /*
! 	{	
! 		.name			= "led_08g",
! 		.gpio			= U801_OFFSET+0,
! 		.active_low		= 1,
! 		.default_trigger	= "nand-disk",
! 	},
! 	{	
! 		.name			= "led_08r",
! 		.gpio			= U801_OFFSET+1,
! 		.active_low		= 1,
! 		.default_trigger	= "none",
! 	},
! 	{	
! 		.name			= "led_09g",
! 		.gpio			= U801_OFFSET+2,
! 		.active_low		= 1,
! 		.default_trigger	= "none",
! 	},
! 	{	
! 		.name			= "led_09r",
! 		.gpio			= U801_OFFSET+3,
! 		.active_low		= 1,
! 		.default_trigger	= "none",
! 	},
! 	{	
! 		.name			= "led_10g",
! 		.gpio			= U801_OFFSET+4,
! 		.active_low		= 1,
! 		.default_trigger	= "none",
! 	},
! 	{	
! 		.name			= "led_10r",
! 		.gpio			= U801_OFFSET+5,
! 		.active_low		= 1,
! 		.default_trigger	= "cpu-busy",
! 	},
! 	{	
! 		.name			= "led_11g",
! 		.gpio			= U801_OFFSET+6,
! 		.active_low		= 1,
! 		.default_trigger	= "timer", //nand-disk
! 	},
! 
! 
! 	{	
! 		.name			= "led_11r",
! 		.gpio			= U801_OFFSET+7,
! 		.active_low		= 1,
  		.default_trigger	= "heartbeat",
+ 	},
+ */
+ 	{	/* "power" led, yellow */
+ 		.name			= "relay_1",
+ 		.gpio			= AT91_PIN_PC6,
+ 		.default_trigger	= "none",
+ 	},
+ 	{	/* "power" led, yellow */
+ 		.name			= "relay_2",
+ 		.gpio			= AT91_PIN_PC7,
+ 		.default_trigger	= "none",
+ 	},
+ 	{	/* "power" led, yellow */
+ 		.name			= "relay_3",
+ 		.gpio			= AT91_PIN_PC12,
+ 		.default_trigger	= "none",
  	}
+ 
+ };
+ 
+ static struct pca953x_platform_data pca9535_gpio_ext_pdata_u800 = {
+ 	.gpio_base = U800_OFFSET,
+ };
+ 
+ /*
+ static struct pca953x_platform_data pca9535_gpio_ext_pdata_u801 = {
+ 	.gpio_base = U801_OFFSET,
  };
+ */
  
  /*
   * I2C devices
   */
! 
! static struct at24_platform_data at24lc256 = {
! 	.byte_len	= SZ_256K / 8,
! 	.page_size	= 64,
  	.flags		= AT24_FLAG_ADDR16,
  };
  
+ 
  static struct i2c_board_info __initdata ek_i2c_devices[] = {
!     {
! 	I2C_BOARD_INFO("rtc-ds1307", 0x68),
! 	.type	= "ds1307",
!     },
!     { 
! 	I2C_BOARD_INFO("pca953x", 0x20),
! 	.type = "pca9535",
! 	.platform_data = &pca9535_gpio_ext_pdata_u800,
!     }, 
!     { 
! 	I2C_BOARD_INFO("adm9240", 0x2c),
! 	.type = "adm9240",
!     },
!     {
! 	I2C_BOARD_INFO("24c256", 0x50),
! 	.platform_data = &at24lc256,
!     },
! 
  	/* more devices can be added using expansion connectors */
  };
  
***************
*** 284,302 ****
  #if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
  static struct gpio_keys_button ek_buttons[] = {
  	{
! 		.gpio		= AT91_PIN_PA30,
! 		.code		= BTN_3,
! 		.desc		= "Button 3",
  		.active_low	= 1,
  		.wakeup		= 1,
  	},
  	{
! 		.gpio		= AT91_PIN_PA31,
! 		.code		= BTN_4,
! 		.desc		= "Button 4",
  		.active_low	= 1,
  		.wakeup		= 1,
  	}
  };
  
  static struct gpio_keys_platform_data ek_button_data = {
--- 427,453 ----
  #if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
  static struct gpio_keys_button ek_buttons[] = {
  	{
! 		.gpio		= AT91_PIN_PC15,
! 		.code		= BTN_4,
! 		.desc		= "opto_1",
  		.active_low	= 1,
  		.wakeup		= 1,
  	},
  	{
! 		.gpio		= AT91_PIN_PC11,
! 		.code		= BTN_5,
! 		.desc		= "opto_2",
! 		.active_low	= 1,
! 		.wakeup		= 1,
! 	},
! 	{
! 		.gpio		= AT91_PIN_PA30,
! 		.code		= BTN_6,
! 		.desc		= "button_1",
  		.active_low	= 1,
  		.wakeup		= 1,
  	}
+ 
  };
  
  static struct gpio_keys_platform_data ek_button_data = {
***************
*** 315,329 ****
  
  static void __init ek_add_device_buttons(void)
  {
! 	at91_set_gpio_input(AT91_PIN_PA30, 1);	/* btn3 */
! 	at91_set_deglitch(AT91_PIN_PA30, 1);
! 	at91_set_gpio_input(AT91_PIN_PA31, 1);	/* btn4 */
! 	at91_set_deglitch(AT91_PIN_PA31, 1);
  
  	platform_device_register(&ek_button_device);
  }
  #else
! static void __init ek_add_device_buttons(void) {}
  #endif
  
  
--- 466,484 ----
  
  static void __init ek_add_device_buttons(void)
  {
!  	at91_set_gpio_input(AT91_PIN_PC15, 1);	/* opto 1 */
!  	at91_set_deglitch(AT91_PIN_PC15, 1); 
!  	at91_set_gpio_input(AT91_PIN_PC11, 1);	/* opto 2 */
!  	at91_set_deglitch(AT91_PIN_PC11, 1); 
!  	at91_set_gpio_input(AT91_PIN_PA30, 1);	/* button 2 */
!  	at91_set_deglitch(AT91_PIN_PA30, 1); 
! 
!     printk(KERN_ERR "add buttons\n");
  
  	platform_device_register(&ek_button_device);
  }
  #else
! static void __init ek_add_device_buttons(void) { printk(KERN_ERR "no buttons\n");}
  #endif
  
  
***************
*** 333,338 ****
--- 488,498 ----
  	at91_add_device_serial();
  	/* USB Host */
  	at91_add_device_usbh(&ek_usbh_data);
+ 
+ 	/* set gpio outputs */
+ 	at91_set_gpio_output(AT91_PIN_PB16, 1); // usb_vcc_on
+ 	at91_set_gpio_output(AT91_PIN_PB18, 1); // adv vcc
+ 	
  	/* USB Device */
  	at91_add_device_udc(&ek_udc_data);
  	/* SPI */
***************
*** 341,359 ****
  	ek_add_device_nand();
  	/* Ethernet */
  	at91_add_device_eth(&ek_macb_data);
- 	/* MMC */
- 	at91_add_device_mmc(0, &ek_mmc_data);
  	/* I2C */
  	at91_add_device_i2c(ek_i2c_devices, ARRAY_SIZE(ek_i2c_devices));
! 	/* SSC (to AT73C213) */
! 	at73c213_set_clk(&at73c213_data);
! 	at91_add_device_ssc(AT91SAM9260_ID_SSC, ATMEL_SSC_TX);
  	/* LEDs */
! 	at91_gpio_leds(ek_leds, ARRAY_SIZE(ek_leds));
  	/* Push Buttons */
  	ek_add_device_buttons();
  }
  
  MACHINE_START(AT91SAM9260EK, "Atmel AT91SAM9260-EK")
  	/* Maintainer: Atmel */
  	.phys_io	= AT91_BASE_SYS,
--- 501,603 ----
  	ek_add_device_nand();
  	/* Ethernet */
  	at91_add_device_eth(&ek_macb_data);
  	/* I2C */
  	at91_add_device_i2c(ek_i2c_devices, ARRAY_SIZE(ek_i2c_devices));
! 
  	/* LEDs */
!     at91_gpio_leds(ek_leds, ARRAY_SIZE(ek_leds));
! 
  	/* Push Buttons */
  	ek_add_device_buttons();
+ 
+   
  }
  
+ struct gpio_sysfs {
+     const char *name;
+     unsigned long pin;
+     int init_val;
+     bool output;
+     bool user_direction;
+ };
+ 
+ static struct gpio_sysfs  ek_sysgpio[] = {
+     {
+         .name = "gsm_on-off",
+         .pin = AT91_PIN_PB12,
+         .output = true,
+         .user_direction = false,
+         .init_val = 0,
+     },
+     {
+         .name = "gsm_reset",
+         .pin = AT91_PIN_PB13,
+         .output = true,
+         .user_direction = false,
+         .init_val = 0,
+     },
+     {
+         .name = "gsm_pwrmon",
+         .pin = AT91_PIN_PA9,
+         .output = false,
+         .user_direction = false,
+         .init_val = 0,
+     }
+ };
+ 
+ void __init ek_gpio_sysfs_init(struct gpio_sysfs *gpios, int nr){
+ 
+     int i;
+ 
+ 	if (!nr){
+         printk(KERN_ERR "gpio_sysfs_init nr == 0\n");
+ 		return;
+     }
+ 
+     for (i = 0; i < nr; i++){
+         if (gpio_request(gpios[i].pin, gpios[i].name)){
+             printk(KERN_ERR "could not obtain gpio for "
+                    "%s\n", gpios[i].name);
+             continue;
+         }
+ 
+         if(gpios[i].output){
+             if(gpio_direction_output(gpios[i].pin, gpios[i].init_val)){
+                 printk(KERN_ERR "could not change direction for %s\n",
+                        gpios[i].name);
+                 continue;
+             }
+             printk(KERN_INFO "Exported gpio %ld (%s) as direction outout\n", 
+                    gpios[i].pin , gpios[i].name);
+         } else {
+             if(gpio_direction_input(gpios[i].pin)){
+                 printk(KERN_ERR "could not change direction for %s\n",
+                        gpios[i].name);
+                 continue;
+             }
+             printk(KERN_INFO "Exported gpio %ld (%s) as direction input\n",
+                    gpios[i].pin , gpios[i].name);            
+         }
+         
+         gpio_export(gpios[i].pin, gpios[i].user_direction);
+         printk(KERN_ERR "%s added to sysfs \n", gpios[i].name);
+     }
+ 
+ }
+ 
+ static int __init gpio_in_sysfs_init(void)
+ {
+ 
+     
+     ek_gpio_sysfs_init(ek_sysgpio,  ARRAY_SIZE(ek_sysgpio));
+ 
+     return 0;
+     
+ }
+ 
+ late_initcall(gpio_in_sysfs_init);
+ 
+ 
  MACHINE_START(AT91SAM9260EK, "Atmel AT91SAM9260-EK")
  	/* Maintainer: Atmel */
  	.phys_io	= AT91_BASE_SYS,
diff -r -C3 -P linux-2.6.29.4/arch/arm/mach-at91/generic.h liab-linux-2.6.29.4/arch/arm/mach-at91/generic.h
*** linux-2.6.29.4/arch/arm/mach-at91/generic.h	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/arch/arm/mach-at91/generic.h	2012-01-20 14:48:32.565306174 +0100
***************
*** 47,55 ****
  #define AT91RM9200_BGA		4	/* AT91RM9200 BGA package has 4 banks */
  
  struct at91_gpio_bank {
- 	unsigned chipbase;		/* bank's first GPIO number */
- 	void __iomem *regbase;		/* base of register bank */
- 	struct at91_gpio_bank *next;	/* bank sharing same IRQ/clock/... */
  	unsigned short id;		/* peripheral ID */
  	unsigned long offset;		/* offset from system peripheral base */
  	struct clk *clock;		/* associated clock */
--- 47,52 ----
diff -r -C3 -P linux-2.6.29.4/arch/arm/mach-at91/gpio.c liab-linux-2.6.29.4/arch/arm/mach-at91/gpio.c
*** linux-2.6.29.4/arch/arm/mach-at91/gpio.c	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/arch/arm/mach-at91/gpio.c	2012-01-20 14:48:32.561306174 +0100
***************
*** 24,42 ****
  #include <mach/at91_pio.h>
  #include <mach/gpio.h>
  
  #include "generic.h"
  
  
! static struct at91_gpio_bank *gpio;
! static int gpio_banks;
  
  
  static inline void __iomem *pin_to_controller(unsigned pin)
  {
  	pin -= PIN_BASE;
  	pin /= 32;
  	if (likely(pin < gpio_banks))
! 		return gpio[pin].regbase;
  
  	return NULL;
  }
--- 24,82 ----
  #include <mach/at91_pio.h>
  #include <mach/gpio.h>
  
+ #include <asm/gpio.h>
+ 
  #include "generic.h"
  
+ struct at91_gpio_chip {
+ 	struct gpio_chip	chip;
+ 	struct at91_gpio_chip	*next;		/* Bank sharing same clock */
+ 	struct at91_gpio_bank	*bank;		/* Bank definition */
+ 	void __iomem		*regbase;	/* Base of register bank */
+ };
  
! #define to_at91_gpio_chip(c) container_of(c, struct at91_gpio_chip, chip)
  
+ static void at91_gpiolib_dbg_show(struct seq_file *s, struct gpio_chip *chip);
+ static void at91_gpiolib_set(struct gpio_chip *chip, unsigned offset, int val);
+ static int at91_gpiolib_get(struct gpio_chip *chip, unsigned offset);
+ static int at91_gpiolib_direction_output(struct gpio_chip *chip,
+ 					 unsigned offset, int val);
+ static int at91_gpiolib_direction_input(struct gpio_chip *chip,
+ 					unsigned offset);
+ static int at91_gpiolib_request(struct gpio_chip *chip, unsigned offset);
+ 
+ #define AT91_GPIO_CHIP(name, base_gpio, nr_gpio)			\
+ 	{								\
+ 		.chip = {						\
+ 			.label		  = name,			\
+ 			.request	  = at91_gpiolib_request,	\
+ 			.direction_input  = at91_gpiolib_direction_input, \
+ 			.direction_output = at91_gpiolib_direction_output, \
+ 			.get		  = at91_gpiolib_get,		\
+ 			.set		  = at91_gpiolib_set,		\
+ 			.dbg_show	  = at91_gpiolib_dbg_show,	\
+ 			.base		  = base_gpio,			\
+ 			.ngpio		  = nr_gpio,			\
+ 		},							\
+ 	}
+ 
+ static struct at91_gpio_chip gpio_chip[] = {
+ 	AT91_GPIO_CHIP("A", 0x00 + PIN_BASE, 32),
+ 	AT91_GPIO_CHIP("B", 0x20 + PIN_BASE, 32),
+ 	AT91_GPIO_CHIP("C", 0x40 + PIN_BASE, 32),
+ 	AT91_GPIO_CHIP("D", 0x60 + PIN_BASE, 32),
+ 	AT91_GPIO_CHIP("E", 0x80 + PIN_BASE, 32),
+ };
+ 
+ static int gpio_banks;
  
  static inline void __iomem *pin_to_controller(unsigned pin)
  {
  	pin -= PIN_BASE;
  	pin /= 32;
  	if (likely(pin < gpio_banks))
! 		return gpio_chip[pin].regbase;
  
  	return NULL;
  }
***************
*** 197,235 ****
  }
  EXPORT_SYMBOL(at91_set_multi_drive);
  
- /*--------------------------------------------------------------------------*/
- 
- /* new-style GPIO calls; these expect at91_set_GPIO_periph to have been
-  * called, and maybe at91_set_multi_drive() for putout pins.
-  */
- 
- int gpio_direction_input(unsigned pin)
- {
- 	void __iomem	*pio = pin_to_controller(pin);
- 	unsigned	mask = pin_to_mask(pin);
- 
- 	if (!pio || !(__raw_readl(pio + PIO_PSR) & mask))
- 		return -EINVAL;
- 	__raw_writel(mask, pio + PIO_ODR);
- 	return 0;
- }
- EXPORT_SYMBOL(gpio_direction_input);
- 
- int gpio_direction_output(unsigned pin, int value)
- {
- 	void __iomem	*pio = pin_to_controller(pin);
- 	unsigned	mask = pin_to_mask(pin);
- 
- 	if (!pio || !(__raw_readl(pio + PIO_PSR) & mask))
- 		return -EINVAL;
- 	__raw_writel(mask, pio + (value ? PIO_SODR : PIO_CODR));
- 	__raw_writel(mask, pio + PIO_OER);
- 	return 0;
- }
- EXPORT_SYMBOL(gpio_direction_output);
- 
- /*--------------------------------------------------------------------------*/
- 
  /*
   * assuming the pin is muxed as a gpio output, set its value.
   */
--- 237,242 ----
***************
*** 282,288 ****
  	else
  		wakeups[bank] &= ~mask;
  
! 	set_irq_wake(gpio[bank].id, state);
  
  	return 0;
  }
--- 289,295 ----
  	else
  		wakeups[bank] &= ~mask;
  
! 	set_irq_wake(gpio_chip[bank].bank->id, state);
  
  	return 0;
  }
***************
*** 292,305 ****
  	int i;
  
  	for (i = 0; i < gpio_banks; i++) {
! 		void __iomem	*pio = gpio[i].regbase;
  
  		backups[i] = __raw_readl(pio + PIO_IMR);
  		__raw_writel(backups[i], pio + PIO_IDR);
  		__raw_writel(wakeups[i], pio + PIO_IER);
  
  		if (!wakeups[i])
! 			clk_disable(gpio[i].clock);
  		else {
  #ifdef CONFIG_PM_DEBUG
  			printk(KERN_DEBUG "GPIO-%c may wake for %08x\n", 'A'+i, wakeups[i]);
--- 299,312 ----
  	int i;
  
  	for (i = 0; i < gpio_banks; i++) {
! 		void __iomem	*pio = gpio_chip[i].regbase;
  
  		backups[i] = __raw_readl(pio + PIO_IMR);
  		__raw_writel(backups[i], pio + PIO_IDR);
  		__raw_writel(wakeups[i], pio + PIO_IER);
  
  		if (!wakeups[i])
! 			clk_disable(gpio_chip[i].bank->clock);
  		else {
  #ifdef CONFIG_PM_DEBUG
  			printk(KERN_DEBUG "GPIO-%c may wake for %08x\n", 'A'+i, wakeups[i]);
***************
*** 313,322 ****
  	int i;
  
  	for (i = 0; i < gpio_banks; i++) {
! 		void __iomem	*pio = gpio[i].regbase;
  
  		if (!wakeups[i])
! 			clk_enable(gpio[i].clock);
  
  		__raw_writel(wakeups[i], pio + PIO_IDR);
  		__raw_writel(backups[i], pio + PIO_IER);
--- 320,329 ----
  	int i;
  
  	for (i = 0; i < gpio_banks; i++) {
! 		void __iomem	*pio = gpio_chip[i].regbase;
  
  		if (!wakeups[i])
! 			clk_enable(gpio_chip[i].bank->clock);
  
  		__raw_writel(wakeups[i], pio + PIO_IDR);
  		__raw_writel(backups[i], pio + PIO_IER);
***************
*** 380,391 ****
  {
  	unsigned	pin;
  	struct irq_desc	*gpio;
! 	struct at91_gpio_bank *bank;
  	void __iomem	*pio;
  	u32		isr;
  
! 	bank = get_irq_chip_data(irq);
! 	pio = bank->regbase;
  
  	/* temporarily mask (level sensitive) parent IRQ */
  	desc->chip->ack(irq);
--- 387,398 ----
  {
  	unsigned	pin;
  	struct irq_desc	*gpio;
! 	struct at91_gpio_chip *at91_gpio;
  	void __iomem	*pio;
  	u32		isr;
  
! 	at91_gpio = get_irq_chip_data(irq);
! 	pio = at91_gpio->regbase;
  
  	/* temporarily mask (level sensitive) parent IRQ */
  	desc->chip->ack(irq);
***************
*** 396,409 ****
  		 */
  		isr = __raw_readl(pio + PIO_ISR) & __raw_readl(pio + PIO_IMR);
  		if (!isr) {
! 			if (!bank->next)
  				break;
! 			bank = bank->next;
! 			pio = bank->regbase;
  			continue;
  		}
  
! 		pin = bank->chipbase;
  		gpio = &irq_desc[pin];
  
  		while (isr) {
--- 403,416 ----
  		 */
  		isr = __raw_readl(pio + PIO_ISR) & __raw_readl(pio + PIO_IMR);
  		if (!isr) {
! 			if (!at91_gpio->next)
  				break;
! 			at91_gpio = at91_gpio->next;
! 			pio = at91_gpio->regbase;
  			continue;
  		}
  
! 		pin = at91_gpio->chip.base;
  		gpio = &irq_desc[pin];
  
  		while (isr) {
***************
*** 430,495 ****
  
  /*--------------------------------------------------------------------------*/
  
- #ifdef CONFIG_DEBUG_FS
- 
- static int at91_gpio_show(struct seq_file *s, void *unused)
- {
- 	int bank, j;
- 
- 	/* print heading */
- 	seq_printf(s, "Pin\t");
- 	for (bank = 0; bank < gpio_banks; bank++) {
- 		seq_printf(s, "PIO%c\t", 'A' + bank);
- 	};
- 	seq_printf(s, "\n\n");
- 
- 	/* print pin status */
- 	for (j = 0; j < 32; j++) {
- 		seq_printf(s, "%i:\t", j);
- 
- 		for (bank = 0; bank < gpio_banks; bank++) {
- 			unsigned	pin  = PIN_BASE + (32 * bank) + j;
- 			void __iomem	*pio = pin_to_controller(pin);
- 			unsigned	mask = pin_to_mask(pin);
- 
- 			if (__raw_readl(pio + PIO_PSR) & mask)
- 				seq_printf(s, "GPIO:%s", __raw_readl(pio + PIO_PDSR) & mask ? "1" : "0");
- 			else
- 				seq_printf(s, "%s", __raw_readl(pio + PIO_ABSR) & mask ? "B" : "A");
- 
- 			seq_printf(s, "\t");
- 		}
- 
- 		seq_printf(s, "\n");
- 	}
- 
- 	return 0;
- }
- 
- static int at91_gpio_open(struct inode *inode, struct file *file)
- {
- 	return single_open(file, at91_gpio_show, NULL);
- }
- 
- static const struct file_operations at91_gpio_operations = {
- 	.open		= at91_gpio_open,
- 	.read		= seq_read,
- 	.llseek		= seq_lseek,
- 	.release	= single_release,
- };
- 
- static int __init at91_gpio_debugfs_init(void)
- {
- 	/* /sys/kernel/debug/at91_gpio */
- 	(void) debugfs_create_file("at91_gpio", S_IFREG | S_IRUGO, NULL, NULL, &at91_gpio_operations);
- 	return 0;
- }
- postcore_initcall(at91_gpio_debugfs_init);
- 
- #endif
- 
- /*--------------------------------------------------------------------------*/
- 
  /*
   * This lock class tells lockdep that GPIO irqs are in a different
   * category than their parents, so it won't report false recursion.
--- 437,442 ----
***************
*** 502,518 ****
  void __init at91_gpio_irq_setup(void)
  {
  	unsigned		pioc, pin;
! 	struct at91_gpio_bank	*this, *prev;
  
! 	for (pioc = 0, pin = PIN_BASE, this = gpio, prev = NULL;
! 			pioc++ < gpio_banks;
! 			prev = this, this++) {
! 		unsigned	id = this->id;
  		unsigned	i;
  
  		__raw_writel(~0, this->regbase + PIO_IDR);
  
! 		for (i = 0, pin = this->chipbase; i < 32; i++, pin++) {
  			lockdep_set_class(&irq_desc[pin].lock, &gpio_lock_class);
  
  			/*
--- 449,470 ----
  void __init at91_gpio_irq_setup(void)
  {
  	unsigned		pioc, pin;
! 	struct at91_gpio_chip	*this, *prev;
  
! 
!   for (pioc = 0, pin = PIN_BASE, this = gpio_chip, prev = NULL;
!        pioc++ < gpio_banks;
!        prev = this, this++) {
! 
!     unsigned	id = this->bank->id;
  		unsigned	i;
  
+     /* enable PIO controller's clock */
+     clk_enable(this->bank->clock);
+ 
  		__raw_writel(~0, this->regbase + PIO_IDR);
  
!     for (i = 0, pin = this->chip.base; i < 32; i++, pin++) {
  			lockdep_set_class(&irq_desc[pin].lock, &gpio_lock_class);
  
  			/*
***************
*** 537,568 ****
  	pr_info("AT91: %d gpio irqs in %d banks\n", pin - PIN_BASE, gpio_banks);
  }
  
  /*
   * Called from the processor-specific init to enable GPIO pin support.
   */
  void __init at91_gpio_init(struct at91_gpio_bank *data, int nr_banks)
  {
  	unsigned		i;
! 	struct at91_gpio_bank	*last;
  
  	BUG_ON(nr_banks > MAX_GPIO_BANKS);
  
- 	gpio = data;
  	gpio_banks = nr_banks;
  
! 	for (i = 0, last = NULL; i < nr_banks; i++, last = data, data++) {
! 		data->chipbase = PIN_BASE + i * 32;
! 		data->regbase = data->offset + (void __iomem *)AT91_VA_BASE_SYS;
! 
! 		/* enable PIO controller's clock */
! 		clk_enable(data->clock);
! 
! 		/*
! 		 * Some processors share peripheral ID between multiple GPIO banks.
! 		 *  SAM9263 (PIOC, PIOD, PIOE)
! 		 *  CAP9 (PIOA, PIOB, PIOC, PIOD)
! 		 */
! 		if (last && last->id == data->id)
! 			last->next = data;
  	}
  }
--- 489,606 ----
  	pr_info("AT91: %d gpio irqs in %d banks\n", pin - PIN_BASE, gpio_banks);
  }
  
+ /* gpiolib support */
+ static int at91_gpiolib_direction_input(struct gpio_chip *chip,
+ 					unsigned offset)
+ {
+ 	struct at91_gpio_chip *at91_gpio = to_at91_gpio_chip(chip);
+ 	void __iomem *pio = at91_gpio->regbase;
+ 	unsigned mask = 1 << offset;
+ 	
+ 	__raw_writel(mask, pio + PIO_ODR);
+ 	return 0;
+ }
+ 
+ static int at91_gpiolib_direction_output(struct gpio_chip *chip,
+ 					 unsigned offset, int val)
+ {
+ 	struct at91_gpio_chip *at91_gpio = to_at91_gpio_chip(chip);
+ 	void __iomem *pio = at91_gpio->regbase;
+ 	unsigned mask = 1 << offset;
+ 
+ 	__raw_writel(mask, pio + (val ? PIO_SODR : PIO_CODR));
+ 	__raw_writel(mask, pio + PIO_OER);
+ 	return 0;
+ }
+ 
+ static int at91_gpiolib_get(struct gpio_chip *chip, unsigned offset)
+ {
+ 	struct at91_gpio_chip *at91_gpio = to_at91_gpio_chip(chip);
+ 	void __iomem *pio = at91_gpio->regbase;
+ 	unsigned mask = 1 << offset;
+ 	u32 pdsr;
+ 
+ 	pdsr = __raw_readl(pio + PIO_PDSR);
+ 	return (pdsr & mask) != 0;
+ }
+ 
+ static void at91_gpiolib_set(struct gpio_chip *chip, unsigned offset, int val)
+ {	
+ 	struct at91_gpio_chip *at91_gpio = to_at91_gpio_chip(chip);
+ 	void __iomem *pio = at91_gpio->regbase;
+ 	unsigned mask = 1 << offset;
+ 	
+ 	__raw_writel(mask, pio + (val ? PIO_SODR : PIO_CODR));
+ }
+ 
+ static int at91_gpiolib_request(struct gpio_chip *chip, unsigned offset)
+ {
+ 	unsigned pin = chip->base + offset;
+ 	void __iomem *pio = pin_to_controller(pin);
+ 	unsigned mask = pin_to_mask(pin);
+ 	
+ 	/* Cannot request GPIOs that are in alternate function mode */
+ 	if (!(__raw_readl(pio + PIO_PSR) & mask))
+ 		return -EPERM;
+ 	
+ 	return 0;
+ }
+ 
+ static void at91_gpiolib_dbg_show(struct seq_file *s, struct gpio_chip *chip)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < chip->ngpio; i++) {
+ 		unsigned pin = chip->base + i;
+ 		void __iomem *pio = pin_to_controller(pin);
+ 		unsigned mask = pin_to_mask(pin);
+ 		const char *gpio_label;
+ 
+ 		gpio_label = gpiochip_is_requested(chip, i);
+ 		if (gpio_label) {
+ 			seq_printf(s, "[%s] GPIO%s%d: ",
+ 				   gpio_label, chip->label, i);
+ 			if (__raw_readl(pio + PIO_PSR) & mask)
+ 				seq_printf(s, "[gpio] %s\n",
+ 					   at91_get_gpio_value(pin) ?
+ 					   "set" : "clear");
+ 			else
+ 				seq_printf(s, "[periph %s]\n",
+ 					   __raw_readl(pio + PIO_ABSR) &
+ 					   mask ? "B" : "A");
+ 		}
+ 	}
+ }
+ 
+ 
  /*
   * Called from the processor-specific init to enable GPIO pin support.
   */
  void __init at91_gpio_init(struct at91_gpio_bank *data, int nr_banks)
  {
  	unsigned		i;
!   struct at91_gpio_chip *at91_gpio, *last = NULL;
!  
  
  	BUG_ON(nr_banks > MAX_GPIO_BANKS);
  
  	gpio_banks = nr_banks;
  
! 
! 	for (i = 0; i < nr_banks; i++) {
! 		at91_gpio = &gpio_chip[i];
! 
! 		at91_gpio->bank = &data[i];
! 		at91_gpio->chip.base = PIN_BASE + i * 32;
! 		at91_gpio->regbase = at91_gpio->bank->offset + 
! 			(void __iomem *)AT91_VA_BASE_SYS;
! 
! 		/* AT91SAM9263_ID_PIOCDE groups PIOC, PIOD, PIOE */
! 		if (last && last->bank->id == at91_gpio->bank->id)
! 			last->next = at91_gpio;
! 		last = at91_gpio;
! 
! 		gpiochip_add(&at91_gpio->chip);
! 
  	}
  }
diff -r -C3 -P linux-2.6.29.4/arch/arm/mach-at91/include/mach/board.h liab-linux-2.6.29.4/arch/arm/mach-at91/include/mach/board.h
*** linux-2.6.29.4/arch/arm/mach-at91/include/mach/board.h	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/arch/arm/mach-at91/include/mach/board.h	2012-01-20 14:48:32.537306174 +0100
***************
*** 106,111 ****
--- 106,112 ----
  
   /* I2C*/
  extern void __init at91_add_device_i2c(struct i2c_board_info *devices, int nr_devices);
+ extern void __init at91_add_device_gpio_i2c(void);
  
   /* SPI */
  extern void __init at91_add_device_spi(struct spi_board_info *devices, int nr_devices);
***************
*** 117,122 ****
--- 118,124 ----
  #define ATMEL_UART_DTR	0x08
  #define ATMEL_UART_DCD	0x10
  #define ATMEL_UART_RI	0x20
+ #define ATMEL_UART_RS485	0x40
  
  extern void __init at91_register_uart(unsigned id, unsigned portnr, unsigned pins);
  extern void __init at91_set_serial_console(unsigned portnr);
***************
*** 132,137 ****
--- 134,140 ----
  struct atmel_uart_data {
  	short		use_dma_tx;	/* use transmit DMA? */
  	short		use_dma_rx;	/* use receive DMA? */
+     short       rs485_mode;
  	void __iomem	*regs;		/* virtual base address, if any */
  };
  extern void __init at91_add_device_serial(void);
diff -r -C3 -P linux-2.6.29.4/arch/arm/mach-at91/include/mach/gpio.h liab-linux-2.6.29.4/arch/arm/mach-at91/include/mach/gpio.h
*** linux-2.6.29.4/arch/arm/mach-at91/include/mach/gpio.h	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/arch/arm/mach-at91/include/mach/gpio.h	2012-01-20 14:48:32.533306173 +0100
***************
*** 213,244 ****
   */
  
  #include <asm/errno.h>
- 
- static inline int gpio_request(unsigned gpio, const char *label)
- {
- 	return 0;
- }
- 
- static inline void gpio_free(unsigned gpio)
- {
- 	might_sleep();
- }
- 
- extern int gpio_direction_input(unsigned gpio);
- extern int gpio_direction_output(unsigned gpio, int value);
- 
- static inline int gpio_get_value(unsigned gpio)
- {
- 	return at91_get_gpio_value(gpio);
- }
- 
- static inline void gpio_set_value(unsigned gpio, int value)
- {
- 	at91_set_gpio_value(gpio, value);
- }
- 
  #include <asm-generic/gpio.h>		/* cansleep wrappers */
  
  static inline int gpio_to_irq(unsigned gpio)
  {
  	return gpio;
--- 213,224 ----
   */
  
  #include <asm/errno.h>
  #include <asm-generic/gpio.h>		/* cansleep wrappers */
  
+ #define gpio_get_value	__gpio_get_value
+ #define gpio_set_value	__gpio_set_value
+ #define gpio_cansleep	__gpio_cansleep
+ 
  static inline int gpio_to_irq(unsigned gpio)
  {
  	return gpio;
diff -r -C3 -P linux-2.6.29.4/arch/arm/mach-at91/Kconfig liab-linux-2.6.29.4/arch/arm/mach-at91/Kconfig
*** linux-2.6.29.4/arch/arm/mach-at91/Kconfig	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/arch/arm/mach-at91/Kconfig	2012-01-20 14:48:32.561306174 +0100
***************
*** 56,61 ****
--- 56,68 ----
  	bool
  	default !ARCH_AT91X40
  
+ 
+ config MACH_LIABARM
+ 	bool "LIAB (Linux-In-A-Box) board"
+ 	depends on ARCH_AT91RM9200 || ARCH_AT91SAM9260
+ 	help
+ 	  Select this if you are using an ARM-based LIAB board.
+ 
  # ----------------------------------------------------------
  
  if ARCH_AT91RM9200
***************
*** 76,81 ****
--- 83,145 ----
  	  Select this if you are using Atmel's AT91RM9200-DK Development board.
  	  (Discontinued)
  
+ choice
+   depends on MACH_LIABARM  
+   prompt "LIAB board type"
+   default MACH_LIABARM9200
+ 
+   config MACH_LIABARM9200
+     bool "LIABARM9200 board"
+ 
+   config MACH_NANOLIAB
+     bool "nanoLIAB board"
+ 
+   config MACH_LIABDIN
+     bool "LIABDIN board"
+ endchoice
+ 
+ config LIAB_TDC_LIABDIN_ADDON
+   bool "Enable TDC LIABDIN addon board features"
+ 	depends on MACH_LIABDIN
+ 	help
+ 	  Select this if you have the TDC addon board with SD-card, DM9000A network adapter, USB slave, etc.
+ 
+ config LIAB_LIABDIN_ADDON
+   bool "Enable Standard LIABDIN addon board features"
+ 	depends on MACH_LIABDIN
+ 	help
+ 	  Select this if you have the standard LIAB addon board with LEDs, antenna bezel, and SIM card holder
+ 
+ config LIAB_ENABLE_UART0
+ 	bool "Enable UART0"
+ 	depends on MACH_LIABARM
+ 	help
+ 	  Select this if you want to enable UART0 on ttyS1.
+ 
+ config LIAB_ENABLE_UART1
+ 	bool "Enable UART1"
+ 	depends on MACH_LIABARM
+ 	help
+ 	  Select this if you want to enable UART1 on ttyS2.
+ 
+ config LIAB_ENABLE_UART2
+ 	bool "Enable UART2"
+ 	depends on MACH_LIABARM
+ 	help
+ 	  Select this if you want to enable UART2 on ttyS3.
+ 
+ config LIAB_ENABLE_UART3
+ 	bool "Enable UART3"
+ 	depends on MACH_LIABARM
+ 	help
+ 	  Select this if you want to enable UART3 on ttyS4.
+ 
+ config LIAB_RELAY_ADDON
+   depends on MACH_LIABARM && MACH_NANOLIAB
+   bool "nanoLIAB relay board V1"
+   help
+ 	  Select this if you are using a version 1 nanoLIAB relay board.
+ 
  config MACH_AT91RM9200EK
  	bool "Atmel AT91RM9200-EK Evaluation Kit"
  	depends on ARCH_AT91RM9200
***************
*** 144,149 ****
--- 208,215 ----
  	help
  	  Select this if you are using the ucDragon YL-9200 board.
  
+ 
+ 
  endif
  
  # ----------------------------------------------------------
***************
*** 164,173 ****
--- 230,246 ----
  config MACH_AT91SAM9260EK
  	bool "Atmel AT91SAM9260-EK / AT91SAM9XE Evaluation Kit"
  	depends on ARCH_AT91SAM9260
+   select ARCH_WANT_OPTIONAL_GPIOLIB
  	help
  	  Select this if you are using Atmel's AT91SAM9260-EK or AT91SAM9XE Evaluation Kit
  	  <http://www.atmel.com/dyn/products/tools_card.asp?tool_id=3933>
  
+ config MACH_LIABSG
+   bool "LIAB SG board"
+   depends on (ARCH_AT91SAM9260 && MACH_LIABARM)   
+   help
+     Select this if you have a LIAB SmartGrid board.
+ 
  config MACH_CAM60
  	bool "KwikByte KB9260 (CAM60) board"
  	depends on ARCH_AT91SAM9260
***************
*** 326,331 ****
--- 399,422 ----
  	  On AT91SAM926x boards both types of NAND flash can be present
  	  (8 and 16 bit data bus width).
  
+ config ARCH_LIABAT91RM9200_HASMII
+ 	bool "Use MII (default is RMII) ethernet"
+ 	depends on ARCH_AT91RM9200 && MACH_LIABARM
+ 	help
+ 	  Select this if you are using MII on LIAB boards, e.g. nanoLIAB.
+ 
+ config ARCH_LIABAT91RM9200_SELECTDBGUANDUART0
+ 	bool "AT91RM9200-DK and LIABARM boards has support for DBGU and UART0"
+ 	depends on ARCH_AT91RM9200 && MACH_LIABARM
+ 	help
+ 	  Select this if you want compiled-in support for two UARTS: DBGU and UART0
+ 
+ config I2C_AT91_GPIO
+ 	bool "LIABARM support for GPIO I2C"
+ 	depends on ARCH_AT91RM9200 && MACH_LIABARM
+ 	help
+ 
+ 
  # ----------------------------------------------------------
  
  comment "AT91 Feature Selections"
diff -r -C3 -P linux-2.6.29.4/arch/arm/mach-at91/Makefile liab-linux-2.6.29.4/arch/arm/mach-at91/Makefile
*** linux-2.6.29.4/arch/arm/mach-at91/Makefile	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/arch/arm/mach-at91/Makefile	2012-01-20 14:48:32.565306174 +0100
***************
*** 32,39 ****
--- 32,42 ----
  obj-$(CONFIG_MACH_PICOTUX2XX)	+= board-picotux200.o
  obj-$(CONFIG_MACH_ECBAT91)	+= board-ecbat91.o
  obj-$(CONFIG_MACH_YL9200)	+= board-yl-9200.o
+ obj-$(CONFIG_MACH_NANOLIAB)	+= board-nanoliab.o
+ obj-$(CONFIG_MACH_LIABDIN)	+= board-liabdin.o
  
  # AT91SAM9260 board-specific support
+ obj-$(CONFIG_MACH_LIABSG) += board-liabsg.o
  obj-$(CONFIG_MACH_AT91SAM9260EK) += board-sam9260ek.o
  obj-$(CONFIG_MACH_CAM60)	+= board-cam60.o
  obj-$(CONFIG_MACH_SAM9_L9260)	+= board-sam9-l9260.o
***************
*** 41,46 ****
--- 44,52 ----
  obj-$(CONFIG_MACH_QIL_A9260)	+= board-qil-a9260.o
  obj-$(CONFIG_MACH_AFEB9260)	+= board-afeb-9260v1.o
  
+ # AT91SAM9260-based LIAB SG board
+ obj-$(CONFIG_MACH_LIABSG) += board-liabsg.o
+ 
  # AT91SAM9261 board-specific support
  obj-$(CONFIG_MACH_AT91SAM9261EK) += board-sam9261ek.o
  
diff -r -C3 -P linux-2.6.29.4/arch/arm/tools/mach-types liab-linux-2.6.29.4/arch/arm/tools/mach-types
*** linux-2.6.29.4/arch/arm/tools/mach-types	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/arch/arm/tools/mach-types	2012-01-20 14:48:31.481306158 +0100
***************
*** 277,282 ****
--- 277,283 ----
  ixcdp1100		ARCH_IXCDP1100		IXCDP1100		260
  prpmc1100		ARCH_PRPMC1100		PRPMC1100		261
  at91rm9200dk		ARCH_AT91RM9200DK	AT91RM9200DK		262
+ liabarm		MACH_LIABARM	LIABARM		262
  armstick		ARCH_ARMSTICK		ARMSTICK		263
  armonie			ARCH_ARMONIE		ARMONIE			264
  mport1			ARCH_MPORT1		MPORT1			265
***************
*** 2124,2126 ****
--- 2125,2128 ----
  fmzwebmodul		MACH_FMZWEBMODUL	FMZWEBMODUL		2134
  rd78x00_masa		MACH_RD78X00_MASA	RD78X00_MASA		2135
  smallogger		MACH_SMALLOGGER		SMALLOGGER		2136
+ liabsg			MACH_LIABSG		LIABSG			1099
\ No newline at end of file
diff -r -C3 -P linux-2.6.29.4/.config liab-linux-2.6.29.4/.config
*** linux-2.6.29.4/.config	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/.config	2012-04-03 14:04:14.724515233 +0200
***************
*** 0 ****
--- 1,1614 ----
+ #
+ # Automatically generated make config: don't edit
+ # Linux kernel version: 2.6.29.4
+ # Tue Apr  3 14:04:14 2012
+ #
+ CONFIG_ARM=y
+ CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+ CONFIG_GENERIC_GPIO=y
+ CONFIG_GENERIC_TIME=y
+ CONFIG_GENERIC_CLOCKEVENTS=y
+ CONFIG_MMU=y
+ # CONFIG_NO_IOPORT is not set
+ CONFIG_GENERIC_HARDIRQS=y
+ CONFIG_STACKTRACE_SUPPORT=y
+ CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+ CONFIG_LOCKDEP_SUPPORT=y
+ CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+ CONFIG_HARDIRQS_SW_RESEND=y
+ CONFIG_GENERIC_IRQ_PROBE=y
+ CONFIG_RWSEM_GENERIC_SPINLOCK=y
+ # CONFIG_ARCH_HAS_ILOG2_U32 is not set
+ # CONFIG_ARCH_HAS_ILOG2_U64 is not set
+ CONFIG_GENERIC_HWEIGHT=y
+ CONFIG_GENERIC_CALIBRATE_DELAY=y
+ CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+ CONFIG_VECTORS_BASE=0xffff0000
+ CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+ 
+ #
+ # General setup
+ #
+ CONFIG_EXPERIMENTAL=y
+ CONFIG_BROKEN_ON_SMP=y
+ CONFIG_LOCK_KERNEL=y
+ CONFIG_INIT_ENV_ARG_LIMIT=32
+ CONFIG_LOCALVERSION=""
+ # CONFIG_LOCALVERSION_AUTO is not set
+ CONFIG_SWAP=y
+ CONFIG_SYSVIPC=y
+ CONFIG_SYSVIPC_SYSCTL=y
+ CONFIG_POSIX_MQUEUE=y
+ # CONFIG_BSD_PROCESS_ACCT is not set
+ # CONFIG_TASKSTATS is not set
+ # CONFIG_AUDIT is not set
+ 
+ #
+ # RCU Subsystem
+ #
+ # CONFIG_CLASSIC_RCU is not set
+ # CONFIG_TREE_RCU is not set
+ CONFIG_PREEMPT_RCU=y
+ # CONFIG_RCU_TRACE is not set
+ # CONFIG_TREE_RCU_TRACE is not set
+ # CONFIG_PREEMPT_RCU_TRACE is not set
+ CONFIG_IKCONFIG=y
+ CONFIG_IKCONFIG_PROC=y
+ CONFIG_LOG_BUF_SHIFT=14
+ CONFIG_GROUP_SCHED=y
+ CONFIG_FAIR_GROUP_SCHED=y
+ # CONFIG_RT_GROUP_SCHED is not set
+ CONFIG_USER_SCHED=y
+ # CONFIG_CGROUP_SCHED is not set
+ # CONFIG_CGROUPS is not set
+ CONFIG_SYSFS_DEPRECATED=y
+ CONFIG_SYSFS_DEPRECATED_V2=y
+ # CONFIG_RELAY is not set
+ # CONFIG_NAMESPACES is not set
+ CONFIG_BLK_DEV_INITRD=y
+ CONFIG_INITRAMFS_SOURCE=""
+ CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+ CONFIG_SYSCTL=y
+ CONFIG_ANON_INODES=y
+ CONFIG_EMBEDDED=y
+ CONFIG_UID16=y
+ CONFIG_SYSCTL_SYSCALL=y
+ # CONFIG_KALLSYMS is not set
+ CONFIG_HOTPLUG=y
+ CONFIG_PRINTK=y
+ CONFIG_BUG=y
+ # CONFIG_ELF_CORE is not set
+ CONFIG_BASE_FULL=y
+ CONFIG_FUTEX=y
+ CONFIG_EPOLL=y
+ CONFIG_SIGNALFD=y
+ CONFIG_TIMERFD=y
+ CONFIG_EVENTFD=y
+ CONFIG_SHMEM=y
+ CONFIG_AIO=y
+ CONFIG_VM_EVENT_COUNTERS=y
+ CONFIG_COMPAT_BRK=y
+ CONFIG_SLAB=y
+ # CONFIG_SLUB is not set
+ # CONFIG_SLOB is not set
+ # CONFIG_PROFILING is not set
+ CONFIG_HAVE_OPROFILE=y
+ CONFIG_HAVE_KPROBES=y
+ CONFIG_HAVE_KRETPROBES=y
+ CONFIG_HAVE_CLK=y
+ CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+ CONFIG_SLABINFO=y
+ CONFIG_RT_MUTEXES=y
+ CONFIG_BASE_SMALL=0
+ CONFIG_MODULES=y
+ # CONFIG_MODULE_FORCE_LOAD is not set
+ CONFIG_MODULE_UNLOAD=y
+ CONFIG_MODULE_FORCE_UNLOAD=y
+ # CONFIG_MODVERSIONS is not set
+ # CONFIG_MODULE_SRCVERSION_ALL is not set
+ CONFIG_BLOCK=y
+ # CONFIG_LBD is not set
+ # CONFIG_BLK_DEV_IO_TRACE is not set
+ # CONFIG_BLK_DEV_BSG is not set
+ # CONFIG_BLK_DEV_INTEGRITY is not set
+ 
+ #
+ # IO Schedulers
+ #
+ CONFIG_IOSCHED_NOOP=y
+ # CONFIG_IOSCHED_AS is not set
+ # CONFIG_IOSCHED_DEADLINE is not set
+ CONFIG_IOSCHED_CFQ=y
+ # CONFIG_DEFAULT_AS is not set
+ # CONFIG_DEFAULT_DEADLINE is not set
+ CONFIG_DEFAULT_CFQ=y
+ # CONFIG_DEFAULT_NOOP is not set
+ CONFIG_DEFAULT_IOSCHED="cfq"
+ # CONFIG_FREEZER is not set
+ 
+ #
+ # System Type
+ #
+ # CONFIG_ARCH_AAEC2000 is not set
+ # CONFIG_ARCH_INTEGRATOR is not set
+ # CONFIG_ARCH_REALVIEW is not set
+ # CONFIG_ARCH_VERSATILE is not set
+ CONFIG_ARCH_AT91=y
+ # CONFIG_ARCH_CLPS711X is not set
+ # CONFIG_ARCH_EBSA110 is not set
+ # CONFIG_ARCH_EP93XX is not set
+ # CONFIG_ARCH_FOOTBRIDGE is not set
+ # CONFIG_ARCH_NETX is not set
+ # CONFIG_ARCH_H720X is not set
+ # CONFIG_ARCH_IMX is not set
+ # CONFIG_ARCH_IOP13XX is not set
+ # CONFIG_ARCH_IOP32X is not set
+ # CONFIG_ARCH_IOP33X is not set
+ # CONFIG_ARCH_IXP23XX is not set
+ # CONFIG_ARCH_IXP2000 is not set
+ # CONFIG_ARCH_IXP4XX is not set
+ # CONFIG_ARCH_L7200 is not set
+ # CONFIG_ARCH_KIRKWOOD is not set
+ # CONFIG_ARCH_KS8695 is not set
+ # CONFIG_ARCH_NS9XXX is not set
+ # CONFIG_ARCH_LOKI is not set
+ # CONFIG_ARCH_MV78XX0 is not set
+ # CONFIG_ARCH_MXC is not set
+ # CONFIG_ARCH_ORION5X is not set
+ # CONFIG_ARCH_PNX4008 is not set
+ # CONFIG_ARCH_PXA is not set
+ # CONFIG_ARCH_RPC is not set
+ # CONFIG_ARCH_SA1100 is not set
+ # CONFIG_ARCH_S3C2410 is not set
+ # CONFIG_ARCH_S3C64XX is not set
+ # CONFIG_ARCH_SHARK is not set
+ # CONFIG_ARCH_LH7A40X is not set
+ # CONFIG_ARCH_DAVINCI is not set
+ # CONFIG_ARCH_OMAP is not set
+ # CONFIG_ARCH_MSM is not set
+ # CONFIG_ARCH_W90X900 is not set
+ 
+ #
+ # Atmel AT91 System-on-Chip
+ #
+ # CONFIG_ARCH_AT91RM9200 is not set
+ CONFIG_ARCH_AT91SAM9260=y
+ # CONFIG_ARCH_AT91SAM9261 is not set
+ # CONFIG_ARCH_AT91SAM9263 is not set
+ # CONFIG_ARCH_AT91SAM9RL is not set
+ # CONFIG_ARCH_AT91SAM9G20 is not set
+ # CONFIG_ARCH_AT91CAP9 is not set
+ # CONFIG_ARCH_AT91X40 is not set
+ CONFIG_AT91_PMC_UNIT=y
+ CONFIG_MACH_LIABARM=y
+ 
+ #
+ # AT91SAM9260 Variants
+ #
+ # CONFIG_ARCH_AT91SAM9260_SAM9XE is not set
+ 
+ #
+ # AT91SAM9260 / AT91SAM9XE Board Type
+ #
+ # CONFIG_MACH_AT91SAM9260EK is not set
+ CONFIG_MACH_LIABSG=y
+ # CONFIG_MACH_CAM60 is not set
+ # CONFIG_MACH_SAM9_L9260 is not set
+ # CONFIG_MACH_AFEB9260 is not set
+ # CONFIG_MACH_USB_A9260 is not set
+ # CONFIG_MACH_QIL_A9260 is not set
+ 
+ #
+ # AT91 Board Options
+ #
+ 
+ #
+ # AT91 Feature Selections
+ #
+ # CONFIG_AT91_PROGRAMMABLE_CLOCKS is not set
+ CONFIG_AT91_TIMER_HZ=128
+ CONFIG_AT91_EARLY_DBGU=y
+ # CONFIG_AT91_EARLY_USART0 is not set
+ # CONFIG_AT91_EARLY_USART1 is not set
+ # CONFIG_AT91_EARLY_USART2 is not set
+ # CONFIG_AT91_EARLY_USART3 is not set
+ # CONFIG_AT91_EARLY_USART4 is not set
+ # CONFIG_AT91_EARLY_USART5 is not set
+ 
+ #
+ # Processor Type
+ #
+ CONFIG_CPU_32=y
+ CONFIG_CPU_ARM926T=y
+ CONFIG_CPU_32v5=y
+ CONFIG_CPU_ABRT_EV5TJ=y
+ CONFIG_CPU_PABRT_NOIFAR=y
+ CONFIG_CPU_CACHE_VIVT=y
+ CONFIG_CPU_COPY_V4WB=y
+ CONFIG_CPU_TLB_V4WBI=y
+ CONFIG_CPU_CP15=y
+ CONFIG_CPU_CP15_MMU=y
+ 
+ #
+ # Processor Features
+ #
+ CONFIG_ARM_THUMB=y
+ # CONFIG_CPU_ICACHE_DISABLE is not set
+ # CONFIG_CPU_DCACHE_DISABLE is not set
+ # CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+ # CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+ # CONFIG_OUTER_CACHE is not set
+ 
+ #
+ # Bus support
+ #
+ # CONFIG_PCI_SYSCALL is not set
+ # CONFIG_ARCH_SUPPORTS_MSI is not set
+ # CONFIG_PCCARD is not set
+ 
+ #
+ # Kernel Features
+ #
+ # CONFIG_NO_HZ is not set
+ # CONFIG_HIGH_RES_TIMERS is not set
+ CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+ CONFIG_VMSPLIT_3G=y
+ # CONFIG_VMSPLIT_2G is not set
+ # CONFIG_VMSPLIT_1G is not set
+ CONFIG_PAGE_OFFSET=0xC0000000
+ CONFIG_PREEMPT=y
+ CONFIG_HZ=128
+ # CONFIG_AEABI is not set
+ CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+ # CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+ # CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+ CONFIG_SELECT_MEMORY_MODEL=y
+ CONFIG_FLATMEM_MANUAL=y
+ # CONFIG_DISCONTIGMEM_MANUAL is not set
+ # CONFIG_SPARSEMEM_MANUAL is not set
+ CONFIG_FLATMEM=y
+ CONFIG_FLAT_NODE_MEM_MAP=y
+ CONFIG_PAGEFLAGS_EXTENDED=y
+ CONFIG_SPLIT_PTLOCK_CPUS=4096
+ # CONFIG_PHYS_ADDR_T_64BIT is not set
+ CONFIG_ZONE_DMA_FLAG=0
+ CONFIG_VIRT_TO_BUS=y
+ CONFIG_UNEVICTABLE_LRU=y
+ CONFIG_LEDS=y
+ CONFIG_LEDS_CPU=y
+ CONFIG_ALIGNMENT_TRAP=y
+ 
+ #
+ # Boot options
+ #
+ CONFIG_ZBOOT_ROM_TEXT=0x0
+ CONFIG_ZBOOT_ROM_BSS=0x0
+ CONFIG_CMDLINE=""
+ # CONFIG_XIP_KERNEL is not set
+ # CONFIG_KEXEC is not set
+ 
+ #
+ # CPU Power Management
+ #
+ # CONFIG_CPU_IDLE is not set
+ 
+ #
+ # Floating point emulation
+ #
+ 
+ #
+ # At least one emulation must be selected
+ #
+ CONFIG_FPE_NWFPE=y
+ # CONFIG_FPE_NWFPE_XP is not set
+ # CONFIG_FPE_FASTFPE is not set
+ # CONFIG_VFP is not set
+ 
+ #
+ # Userspace binary formats
+ #
+ CONFIG_BINFMT_ELF=y
+ CONFIG_HAVE_AOUT=y
+ # CONFIG_BINFMT_AOUT is not set
+ # CONFIG_BINFMT_MISC is not set
+ # CONFIG_ARTHUR is not set
+ 
+ #
+ # Power management options
+ #
+ # CONFIG_PM is not set
+ CONFIG_ARCH_SUSPEND_POSSIBLE=y
+ CONFIG_NET=y
+ 
+ #
+ # Networking options
+ #
+ CONFIG_COMPAT_NET_DEV_OPS=y
+ CONFIG_PACKET=y
+ CONFIG_PACKET_MMAP=y
+ CONFIG_UNIX=y
+ # CONFIG_NET_KEY is not set
+ CONFIG_INET=y
+ CONFIG_IP_MULTICAST=y
+ CONFIG_IP_ADVANCED_ROUTER=y
+ CONFIG_ASK_IP_FIB_HASH=y
+ # CONFIG_IP_FIB_TRIE is not set
+ CONFIG_IP_FIB_HASH=y
+ CONFIG_IP_MULTIPLE_TABLES=y
+ CONFIG_IP_ROUTE_MULTIPATH=y
+ CONFIG_IP_ROUTE_VERBOSE=y
+ CONFIG_IP_PNP=y
+ CONFIG_IP_PNP_DHCP=y
+ CONFIG_IP_PNP_BOOTP=y
+ CONFIG_IP_PNP_RARP=y
+ # CONFIG_NET_IPIP is not set
+ # CONFIG_NET_IPGRE is not set
+ CONFIG_IP_MROUTE=y
+ CONFIG_IP_PIMSM_V1=y
+ # CONFIG_IP_PIMSM_V2 is not set
+ # CONFIG_ARPD is not set
+ CONFIG_SYN_COOKIES=y
+ # CONFIG_INET_AH is not set
+ # CONFIG_INET_ESP is not set
+ # CONFIG_INET_IPCOMP is not set
+ # CONFIG_INET_XFRM_TUNNEL is not set
+ # CONFIG_INET_TUNNEL is not set
+ # CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+ # CONFIG_INET_XFRM_MODE_TUNNEL is not set
+ # CONFIG_INET_XFRM_MODE_BEET is not set
+ # CONFIG_INET_LRO is not set
+ # CONFIG_INET_DIAG is not set
+ # CONFIG_TCP_CONG_ADVANCED is not set
+ CONFIG_TCP_CONG_CUBIC=y
+ CONFIG_DEFAULT_TCP_CONG="cubic"
+ # CONFIG_TCP_MD5SIG is not set
+ # CONFIG_IPV6 is not set
+ # CONFIG_NETWORK_SECMARK is not set
+ # CONFIG_NETFILTER is not set
+ # CONFIG_IP_DCCP is not set
+ # CONFIG_IP_SCTP is not set
+ # CONFIG_TIPC is not set
+ # CONFIG_ATM is not set
+ # CONFIG_BRIDGE is not set
+ # CONFIG_NET_DSA is not set
+ # CONFIG_VLAN_8021Q is not set
+ # CONFIG_DECNET is not set
+ # CONFIG_LLC2 is not set
+ # CONFIG_IPX is not set
+ # CONFIG_ATALK is not set
+ # CONFIG_X25 is not set
+ # CONFIG_LAPB is not set
+ # CONFIG_ECONET is not set
+ # CONFIG_WAN_ROUTER is not set
+ # CONFIG_NET_SCHED is not set
+ # CONFIG_DCB is not set
+ 
+ #
+ # Network testing
+ #
+ # CONFIG_NET_PKTGEN is not set
+ # CONFIG_HAMRADIO is not set
+ # CONFIG_CAN is not set
+ # CONFIG_IRDA is not set
+ # CONFIG_BT is not set
+ # CONFIG_AF_RXRPC is not set
+ # CONFIG_PHONET is not set
+ CONFIG_FIB_RULES=y
+ # CONFIG_WIRELESS is not set
+ # CONFIG_WIMAX is not set
+ # CONFIG_RFKILL is not set
+ # CONFIG_NET_9P is not set
+ 
+ #
+ # Device Drivers
+ #
+ 
+ #
+ # Generic Driver Options
+ #
+ CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+ CONFIG_STANDALONE=y
+ CONFIG_PREVENT_FIRMWARE_BUILD=y
+ CONFIG_FW_LOADER=y
+ # CONFIG_FIRMWARE_IN_KERNEL is not set
+ CONFIG_EXTRA_FIRMWARE=""
+ # CONFIG_DEBUG_DRIVER is not set
+ # CONFIG_DEBUG_DEVRES is not set
+ # CONFIG_SYS_HYPERVISOR is not set
+ # CONFIG_CONNECTOR is not set
+ CONFIG_MTD=y
+ # CONFIG_MTD_DEBUG is not set
+ # CONFIG_MTD_CONCAT is not set
+ CONFIG_MTD_PARTITIONS=y
+ # CONFIG_MTD_TESTS is not set
+ # CONFIG_MTD_REDBOOT_PARTS is not set
+ # CONFIG_MTD_CMDLINE_PARTS is not set
+ # CONFIG_MTD_AFS_PARTS is not set
+ # CONFIG_MTD_AR7_PARTS is not set
+ 
+ #
+ # User Modules And Translation Layers
+ #
+ CONFIG_MTD_CHAR=y
+ CONFIG_MTD_BLKDEVS=y
+ CONFIG_MTD_BLOCK=y
+ # CONFIG_FTL is not set
+ CONFIG_NFTL=y
+ CONFIG_NFTL_RW=y
+ # CONFIG_INFTL is not set
+ # CONFIG_RFD_FTL is not set
+ # CONFIG_SSFDC is not set
+ # CONFIG_MTD_OOPS is not set
+ 
+ #
+ # RAM/ROM/Flash chip drivers
+ #
+ CONFIG_MTD_CFI=y
+ # CONFIG_MTD_JEDECPROBE is not set
+ CONFIG_MTD_GEN_PROBE=y
+ # CONFIG_MTD_CFI_ADV_OPTIONS is not set
+ CONFIG_MTD_MAP_BANK_WIDTH_1=y
+ CONFIG_MTD_MAP_BANK_WIDTH_2=y
+ CONFIG_MTD_MAP_BANK_WIDTH_4=y
+ # CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+ # CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+ # CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+ CONFIG_MTD_CFI_I1=y
+ CONFIG_MTD_CFI_I2=y
+ # CONFIG_MTD_CFI_I4 is not set
+ # CONFIG_MTD_CFI_I8 is not set
+ CONFIG_MTD_CFI_INTELEXT=y
+ CONFIG_MTD_CFI_AMDSTD=y
+ # CONFIG_MTD_CFI_STAA is not set
+ CONFIG_MTD_CFI_UTIL=y
+ # CONFIG_MTD_RAM is not set
+ # CONFIG_MTD_ROM is not set
+ # CONFIG_MTD_ABSENT is not set
+ 
+ #
+ # Mapping drivers for chip access
+ #
+ # CONFIG_MTD_COMPLEX_MAPPINGS is not set
+ # CONFIG_MTD_PHYSMAP is not set
+ # CONFIG_MTD_ARM_INTEGRATOR is not set
+ CONFIG_MTD_LIABARM=y
+ CONFIG_MTD_LIAB_FLASH_SIZE=16384
+ CONFIG_MTD_LIAB_NOFLASH=1
+ CONFIG_MTD_LIABARM_BOOTSIZE=128
+ CONFIG_MTD_LIABARM_KERNELSIZE=1536
+ CONFIG_MTD_LIABARM_ROOTSIZE=6144
+ CONFIG_MTD_LIABARM_PARAMSIZE=128
+ CONFIG_MTD_LIABARM_JFFS2SIZE=8448
+ # CONFIG_MTD_PLATRAM is not set
+ 
+ #
+ # Self-contained MTD device drivers
+ #
+ # CONFIG_MTD_DATAFLASH is not set
+ # CONFIG_MTD_M25P80 is not set
+ # CONFIG_MTD_SLRAM is not set
+ # CONFIG_MTD_PHRAM is not set
+ # CONFIG_MTD_MTDRAM is not set
+ # CONFIG_MTD_BLOCK2MTD is not set
+ 
+ #
+ # Disk-On-Chip Device Drivers
+ #
+ # CONFIG_MTD_DOC2000 is not set
+ # CONFIG_MTD_DOC2001 is not set
+ # CONFIG_MTD_DOC2001PLUS is not set
+ CONFIG_MTD_NAND=y
+ # CONFIG_MTD_NAND_VERIFY_WRITE is not set
+ # CONFIG_MTD_NAND_ECC_SMC is not set
+ # CONFIG_MTD_NAND_MUSEUM_IDS is not set
+ # CONFIG_MTD_NAND_GPIO is not set
+ CONFIG_MTD_NAND_IDS=y
+ # CONFIG_MTD_NAND_DISKONCHIP is not set
+ CONFIG_MTD_NAND_ATMEL=y
+ # CONFIG_MTD_NAND_ATMEL_ECC_HW is not set
+ CONFIG_MTD_NAND_ATMEL_ECC_SOFT=y
+ # CONFIG_MTD_NAND_ATMEL_ECC_NONE is not set
+ # CONFIG_MTD_NAND_NANDSIM is not set
+ # CONFIG_MTD_NAND_PLATFORM is not set
+ # CONFIG_MTD_ALAUDA is not set
+ # CONFIG_MTD_ONENAND is not set
+ 
+ #
+ # LPDDR flash memory drivers
+ #
+ # CONFIG_MTD_LPDDR is not set
+ 
+ #
+ # UBI - Unsorted block images
+ #
+ # CONFIG_MTD_UBI is not set
+ # CONFIG_PARPORT is not set
+ CONFIG_BLK_DEV=y
+ # CONFIG_BLK_DEV_COW_COMMON is not set
+ # CONFIG_BLK_DEV_LOOP is not set
+ # CONFIG_BLK_DEV_NBD is not set
+ # CONFIG_BLK_DEV_UB is not set
+ CONFIG_BLK_DEV_RAM=y
+ CONFIG_BLK_DEV_RAM_COUNT=16
+ CONFIG_BLK_DEV_RAM_SIZE=32768
+ # CONFIG_BLK_DEV_XIP is not set
+ # CONFIG_CDROM_PKTCDVD is not set
+ # CONFIG_ATA_OVER_ETH is not set
+ CONFIG_MISC_DEVICES=y
+ # CONFIG_ATMEL_TCLIB is not set
+ CONFIG_AT91_PWM=y
+ # CONFIG_ICS932S401 is not set
+ # CONFIG_ATMEL_SSC is not set
+ # CONFIG_ENCLOSURE_SERVICES is not set
+ # CONFIG_C2PORT is not set
+ 
+ #
+ # EEPROM support
+ #
+ CONFIG_EEPROM_AT24=y
+ # CONFIG_EEPROM_AT25 is not set
+ # CONFIG_EEPROM_LEGACY is not set
+ # CONFIG_EEPROM_93CX6 is not set
+ CONFIG_HAVE_IDE=y
+ # CONFIG_IDE is not set
+ 
+ #
+ # SCSI device support
+ #
+ # CONFIG_RAID_ATTRS is not set
+ CONFIG_SCSI=m
+ CONFIG_SCSI_DMA=y
+ # CONFIG_SCSI_TGT is not set
+ # CONFIG_SCSI_NETLINK is not set
+ CONFIG_SCSI_PROC_FS=y
+ 
+ #
+ # SCSI support type (disk, tape, CD-ROM)
+ #
+ CONFIG_BLK_DEV_SD=m
+ # CONFIG_CHR_DEV_ST is not set
+ # CONFIG_CHR_DEV_OSST is not set
+ # CONFIG_BLK_DEV_SR is not set
+ # CONFIG_CHR_DEV_SG is not set
+ # CONFIG_CHR_DEV_SCH is not set
+ 
+ #
+ # Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+ #
+ CONFIG_SCSI_MULTI_LUN=y
+ # CONFIG_SCSI_CONSTANTS is not set
+ CONFIG_SCSI_LOGGING=y
+ # CONFIG_SCSI_SCAN_ASYNC is not set
+ CONFIG_SCSI_WAIT_SCAN=m
+ 
+ #
+ # SCSI Transports
+ #
+ # CONFIG_SCSI_SPI_ATTRS is not set
+ # CONFIG_SCSI_FC_ATTRS is not set
+ # CONFIG_SCSI_ISCSI_ATTRS is not set
+ # CONFIG_SCSI_SAS_LIBSAS is not set
+ # CONFIG_SCSI_SRP_ATTRS is not set
+ CONFIG_SCSI_LOWLEVEL=y
+ # CONFIG_ISCSI_TCP is not set
+ # CONFIG_LIBFC is not set
+ # CONFIG_SCSI_DEBUG is not set
+ # CONFIG_SCSI_DH is not set
+ # CONFIG_ATA is not set
+ # CONFIG_MD is not set
+ CONFIG_NETDEVICES=y
+ # CONFIG_DUMMY is not set
+ # CONFIG_BONDING is not set
+ # CONFIG_MACVLAN is not set
+ # CONFIG_EQUALIZER is not set
+ CONFIG_TUN=y
+ # CONFIG_VETH is not set
+ CONFIG_PHYLIB=y
+ 
+ #
+ # MII PHY device drivers
+ #
+ # CONFIG_MARVELL_PHY is not set
+ CONFIG_DAVICOM_PHY=y
+ # CONFIG_QSEMI_PHY is not set
+ # CONFIG_LXT_PHY is not set
+ # CONFIG_CICADA_PHY is not set
+ # CONFIG_VITESSE_PHY is not set
+ # CONFIG_SMSC_PHY is not set
+ # CONFIG_BROADCOM_PHY is not set
+ # CONFIG_ICPLUS_PHY is not set
+ # CONFIG_REALTEK_PHY is not set
+ # CONFIG_NATIONAL_PHY is not set
+ # CONFIG_STE10XP is not set
+ # CONFIG_LSI_ET1011C_PHY is not set
+ # CONFIG_FIXED_PHY is not set
+ # CONFIG_MDIO_BITBANG is not set
+ CONFIG_NET_ETHERNET=y
+ CONFIG_MII=y
+ CONFIG_MACB=y
+ # CONFIG_AX88796 is not set
+ # CONFIG_SMC91X is not set
+ # CONFIG_DM9000 is not set
+ # CONFIG_ENC28J60 is not set
+ # CONFIG_SMC911X is not set
+ # CONFIG_SMSC911X is not set
+ # CONFIG_DNET is not set
+ # CONFIG_IBM_NEW_EMAC_ZMII is not set
+ # CONFIG_IBM_NEW_EMAC_RGMII is not set
+ # CONFIG_IBM_NEW_EMAC_TAH is not set
+ # CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+ # CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+ # CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+ # CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+ # CONFIG_B44 is not set
+ # CONFIG_NETDEV_1000 is not set
+ # CONFIG_NETDEV_10000 is not set
+ 
+ #
+ # Wireless LAN
+ #
+ # CONFIG_WLAN_PRE80211 is not set
+ # CONFIG_WLAN_80211 is not set
+ # CONFIG_IWLWIFI_LEDS is not set
+ 
+ #
+ # Enable WiMAX (Networking options) to see the WiMAX drivers
+ #
+ 
+ #
+ # USB Network Adapters
+ #
+ # CONFIG_USB_CATC is not set
+ # CONFIG_USB_KAWETH is not set
+ # CONFIG_USB_PEGASUS is not set
+ # CONFIG_USB_RTL8150 is not set
+ # CONFIG_USB_USBNET is not set
+ # CONFIG_WAN is not set
+ CONFIG_PPP=y
+ # CONFIG_PPP_MULTILINK is not set
+ CONFIG_PPP_FILTER=y
+ CONFIG_PPP_ASYNC=y
+ # CONFIG_PPP_SYNC_TTY is not set
+ CONFIG_PPP_DEFLATE=y
+ CONFIG_PPP_BSDCOMP=y
+ CONFIG_PPP_MPPE=y
+ CONFIG_PPPOE=y
+ # CONFIG_PPPOL2TP is not set
+ # CONFIG_SLIP is not set
+ CONFIG_SLHC=y
+ # CONFIG_NETCONSOLE is not set
+ # CONFIG_NETPOLL is not set
+ # CONFIG_NET_POLL_CONTROLLER is not set
+ # CONFIG_ISDN is not set
+ 
+ #
+ # Input device support
+ #
+ CONFIG_INPUT=y
+ # CONFIG_INPUT_FF_MEMLESS is not set
+ # CONFIG_INPUT_POLLDEV is not set
+ 
+ #
+ # Userland interfaces
+ #
+ # CONFIG_INPUT_MOUSEDEV is not set
+ # CONFIG_INPUT_JOYDEV is not set
+ CONFIG_INPUT_EVDEV=y
+ # CONFIG_INPUT_EVBUG is not set
+ 
+ #
+ # Input Device Drivers
+ #
+ CONFIG_INPUT_KEYBOARD=y
+ # CONFIG_KEYBOARD_ATKBD is not set
+ # CONFIG_KEYBOARD_SUNKBD is not set
+ # CONFIG_KEYBOARD_LKKBD is not set
+ # CONFIG_KEYBOARD_XTKBD is not set
+ # CONFIG_KEYBOARD_NEWTON is not set
+ # CONFIG_KEYBOARD_STOWAWAY is not set
+ CONFIG_KEYBOARD_GPIO=y
+ # CONFIG_INPUT_MOUSE is not set
+ # CONFIG_INPUT_JOYSTICK is not set
+ # CONFIG_INPUT_TABLET is not set
+ # CONFIG_INPUT_TOUCHSCREEN is not set
+ # CONFIG_INPUT_MISC is not set
+ 
+ #
+ # Hardware I/O ports
+ #
+ # CONFIG_SERIO is not set
+ # CONFIG_GAMEPORT is not set
+ 
+ #
+ # Character devices
+ #
+ # CONFIG_VT is not set
+ CONFIG_DEVKMEM=y
+ # CONFIG_SERIAL_NONSTANDARD is not set
+ 
+ #
+ # Serial drivers
+ #
+ # CONFIG_SERIAL_8250 is not set
+ 
+ #
+ # Non-8250 serial port support
+ #
+ CONFIG_SERIAL_ATMEL=y
+ CONFIG_SERIAL_ATMEL_CONSOLE=y
+ CONFIG_SERIAL_ATMEL_PDC=y
+ # CONFIG_SERIAL_ATMEL_TTYAT is not set
+ CONFIG_SERIAL_CORE=y
+ CONFIG_SERIAL_CORE_CONSOLE=y
+ CONFIG_UNIX98_PTYS=y
+ # CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+ CONFIG_LEGACY_PTYS=y
+ CONFIG_LEGACY_PTY_COUNT=256
+ # CONFIG_IPMI_HANDLER is not set
+ CONFIG_HW_RANDOM=y
+ # CONFIG_R3964 is not set
+ # CONFIG_RAW_DRIVER is not set
+ # CONFIG_TCG_TPM is not set
+ CONFIG_I2C=y
+ CONFIG_I2C_BOARDINFO=y
+ CONFIG_I2C_CHARDEV=y
+ CONFIG_I2C_HELPER_AUTO=y
+ CONFIG_I2C_ALGOBIT=y
+ 
+ #
+ # I2C Hardware Bus support
+ #
+ 
+ #
+ # I2C system bus drivers (mostly embedded / system-on-chip)
+ #
+ CONFIG_I2C_GPIO=y
+ # CONFIG_I2C_OCORES is not set
+ # CONFIG_I2C_SIMTEC is not set
+ 
+ #
+ # External I2C/SMBus adapter drivers
+ #
+ # CONFIG_I2C_PARPORT_LIGHT is not set
+ # CONFIG_I2C_TAOS_EVM is not set
+ # CONFIG_I2C_TINY_USB is not set
+ 
+ #
+ # Other I2C/SMBus bus drivers
+ #
+ # CONFIG_I2C_PCA_PLATFORM is not set
+ # CONFIG_I2C_STUB is not set
+ 
+ #
+ # Miscellaneous I2C Chip support
+ #
+ # CONFIG_DS1682 is not set
+ # CONFIG_SENSORS_PCF8574 is not set
+ # CONFIG_PCF8575 is not set
+ # CONFIG_SENSORS_PCF8591 is not set
+ # CONFIG_SENSORS_MAX6875 is not set
+ # CONFIG_SENSORS_TSL2550 is not set
+ # CONFIG_I2C_DEBUG_CORE is not set
+ # CONFIG_I2C_DEBUG_ALGO is not set
+ # CONFIG_I2C_DEBUG_BUS is not set
+ # CONFIG_I2C_DEBUG_CHIP is not set
+ CONFIG_SPI=y
+ # CONFIG_SPI_DEBUG is not set
+ CONFIG_SPI_MASTER=y
+ 
+ #
+ # SPI Master Controller Drivers
+ #
+ CONFIG_SPI_ATMEL=y
+ # CONFIG_SPI_BITBANG is not set
+ # CONFIG_SPI_GPIO is not set
+ 
+ #
+ # SPI Protocol Masters
+ #
+ # CONFIG_SPI_SPIDEV is not set
+ # CONFIG_SPI_TLE62X0 is not set
+ CONFIG_ARCH_REQUIRE_GPIOLIB=y
+ CONFIG_GPIOLIB=y
+ CONFIG_DEBUG_GPIO=y
+ CONFIG_GPIO_SYSFS=y
+ 
+ #
+ # Memory mapped GPIO expanders:
+ #
+ 
+ #
+ # I2C GPIO expanders:
+ #
+ # CONFIG_GPIO_MAX732X is not set
+ CONFIG_GPIO_PCA953X=y
+ # CONFIG_GPIO_PCF857X is not set
+ 
+ #
+ # PCI GPIO expanders:
+ #
+ 
+ #
+ # SPI GPIO expanders:
+ #
+ # CONFIG_GPIO_MAX7301 is not set
+ # CONFIG_GPIO_MCP23S08 is not set
+ # CONFIG_W1 is not set
+ # CONFIG_POWER_SUPPLY is not set
+ CONFIG_HWMON=y
+ CONFIG_HWMON_VID=y
+ # CONFIG_SENSORS_AD7414 is not set
+ # CONFIG_SENSORS_AD7418 is not set
+ # CONFIG_SENSORS_ADCXX is not set
+ # CONFIG_SENSORS_ADM1021 is not set
+ # CONFIG_SENSORS_ADM1025 is not set
+ # CONFIG_SENSORS_ADM1026 is not set
+ # CONFIG_SENSORS_ADM1029 is not set
+ # CONFIG_SENSORS_ADM1031 is not set
+ CONFIG_SENSORS_ADM9240=y
+ # CONFIG_SENSORS_ADT7462 is not set
+ # CONFIG_SENSORS_ADT7470 is not set
+ # CONFIG_SENSORS_ADT7473 is not set
+ # CONFIG_SENSORS_ADT7475 is not set
+ # CONFIG_SENSORS_ATXP1 is not set
+ # CONFIG_SENSORS_DS1621 is not set
+ # CONFIG_SENSORS_F71805F is not set
+ # CONFIG_SENSORS_F71882FG is not set
+ # CONFIG_SENSORS_F75375S is not set
+ # CONFIG_SENSORS_GL518SM is not set
+ # CONFIG_SENSORS_GL520SM is not set
+ # CONFIG_SENSORS_IT87 is not set
+ # CONFIG_SENSORS_LM63 is not set
+ # CONFIG_SENSORS_LM70 is not set
+ # CONFIG_SENSORS_LM75 is not set
+ # CONFIG_SENSORS_LM77 is not set
+ # CONFIG_SENSORS_LM78 is not set
+ # CONFIG_SENSORS_LM80 is not set
+ # CONFIG_SENSORS_LM83 is not set
+ # CONFIG_SENSORS_LM85 is not set
+ # CONFIG_SENSORS_LM87 is not set
+ # CONFIG_SENSORS_LM90 is not set
+ # CONFIG_SENSORS_LM92 is not set
+ # CONFIG_SENSORS_LM93 is not set
+ # CONFIG_SENSORS_LTC4245 is not set
+ # CONFIG_SENSORS_MAX1111 is not set
+ # CONFIG_SENSORS_MAX1619 is not set
+ # CONFIG_SENSORS_MAX6650 is not set
+ # CONFIG_SENSORS_PC87360 is not set
+ # CONFIG_SENSORS_PC87427 is not set
+ # CONFIG_SENSORS_DME1737 is not set
+ # CONFIG_SENSORS_SMSC47M1 is not set
+ # CONFIG_SENSORS_SMSC47M192 is not set
+ # CONFIG_SENSORS_SMSC47B397 is not set
+ # CONFIG_SENSORS_ADS7828 is not set
+ # CONFIG_SENSORS_THMC50 is not set
+ # CONFIG_SENSORS_VT1211 is not set
+ # CONFIG_SENSORS_W83781D is not set
+ # CONFIG_SENSORS_W83791D is not set
+ # CONFIG_SENSORS_W83792D is not set
+ # CONFIG_SENSORS_W83793 is not set
+ # CONFIG_SENSORS_W83L785TS is not set
+ # CONFIG_SENSORS_W83L786NG is not set
+ # CONFIG_SENSORS_W83627HF is not set
+ # CONFIG_SENSORS_W83627EHF is not set
+ # CONFIG_HWMON_DEBUG_CHIP is not set
+ # CONFIG_THERMAL is not set
+ # CONFIG_THERMAL_HWMON is not set
+ CONFIG_WATCHDOG=y
+ # CONFIG_WATCHDOG_NOWAYOUT is not set
+ 
+ #
+ # Watchdog Device Drivers
+ #
+ # CONFIG_SOFT_WATCHDOG is not set
+ CONFIG_AT91SAM9X_WATCHDOG=y
+ 
+ #
+ # USB-based Watchdog Cards
+ #
+ # CONFIG_USBPCWATCHDOG is not set
+ CONFIG_SSB_POSSIBLE=y
+ 
+ #
+ # Sonics Silicon Backplane
+ #
+ # CONFIG_SSB is not set
+ 
+ #
+ # Multifunction device drivers
+ #
+ # CONFIG_MFD_CORE is not set
+ # CONFIG_MFD_SM501 is not set
+ # CONFIG_MFD_ASIC3 is not set
+ # CONFIG_HTC_EGPIO is not set
+ # CONFIG_HTC_PASIC3 is not set
+ # CONFIG_TPS65010 is not set
+ # CONFIG_TWL4030_CORE is not set
+ # CONFIG_MFD_TMIO is not set
+ # CONFIG_MFD_T7L66XB is not set
+ # CONFIG_MFD_TC6387XB is not set
+ # CONFIG_MFD_TC6393XB is not set
+ # CONFIG_PMIC_DA903X is not set
+ # CONFIG_MFD_WM8400 is not set
+ # CONFIG_MFD_WM8350_I2C is not set
+ # CONFIG_MFD_PCF50633 is not set
+ 
+ #
+ # Multimedia devices
+ #
+ 
+ #
+ # Multimedia core support
+ #
+ # CONFIG_VIDEO_DEV is not set
+ # CONFIG_DVB_CORE is not set
+ # CONFIG_VIDEO_MEDIA is not set
+ 
+ #
+ # Multimedia drivers
+ #
+ # CONFIG_DAB is not set
+ 
+ #
+ # Graphics support
+ #
+ # CONFIG_VGASTATE is not set
+ # CONFIG_VIDEO_OUTPUT_CONTROL is not set
+ # CONFIG_FB is not set
+ # CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+ 
+ #
+ # Display device support
+ #
+ # CONFIG_DISPLAY_SUPPORT is not set
+ # CONFIG_SOUND is not set
+ CONFIG_HID_SUPPORT=y
+ CONFIG_HID=y
+ # CONFIG_HID_DEBUG is not set
+ # CONFIG_HIDRAW is not set
+ 
+ #
+ # USB Input Devices
+ #
+ # CONFIG_USB_HID is not set
+ # CONFIG_HID_PID is not set
+ 
+ #
+ # USB HID Boot Protocol drivers
+ #
+ # CONFIG_USB_KBD is not set
+ # CONFIG_USB_MOUSE is not set
+ 
+ #
+ # Special HID drivers
+ #
+ CONFIG_HID_COMPAT=y
+ CONFIG_USB_SUPPORT=y
+ CONFIG_USB_ARCH_HAS_HCD=y
+ CONFIG_USB_ARCH_HAS_OHCI=y
+ # CONFIG_USB_ARCH_HAS_EHCI is not set
+ CONFIG_USB=y
+ # CONFIG_USB_DEBUG is not set
+ # CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+ 
+ #
+ # Miscellaneous USB options
+ #
+ CONFIG_USB_DEVICEFS=y
+ CONFIG_USB_DEVICE_CLASS=y
+ # CONFIG_USB_DYNAMIC_MINORS is not set
+ # CONFIG_USB_OTG is not set
+ # CONFIG_USB_OTG_WHITELIST is not set
+ # CONFIG_USB_OTG_BLACKLIST_HUB is not set
+ CONFIG_USB_MON=y
+ # CONFIG_USB_WUSB is not set
+ # CONFIG_USB_WUSB_CBAF is not set
+ 
+ #
+ # USB Host Controller Drivers
+ #
+ # CONFIG_USB_C67X00_HCD is not set
+ # CONFIG_USB_OXU210HP_HCD is not set
+ # CONFIG_USB_ISP116X_HCD is not set
+ CONFIG_USB_OHCI_HCD=y
+ # CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+ # CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+ CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+ # CONFIG_USB_SL811_HCD is not set
+ # CONFIG_USB_R8A66597_HCD is not set
+ # CONFIG_USB_HWA_HCD is not set
+ # CONFIG_USB_MUSB_HDRC is not set
+ # CONFIG_USB_GADGET_MUSB_HDRC is not set
+ 
+ #
+ # USB Device Class drivers
+ #
+ CONFIG_USB_ACM=m
+ # CONFIG_USB_PRINTER is not set
+ # CONFIG_USB_WDM is not set
+ # CONFIG_USB_TMC is not set
+ 
+ #
+ # NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
+ #
+ 
+ #
+ # see USB_STORAGE Help for more information
+ #
+ CONFIG_USB_STORAGE=m
+ # CONFIG_USB_STORAGE_DEBUG is not set
+ # CONFIG_USB_STORAGE_DATAFAB is not set
+ # CONFIG_USB_STORAGE_FREECOM is not set
+ # CONFIG_USB_STORAGE_ISD200 is not set
+ # CONFIG_USB_STORAGE_USBAT is not set
+ # CONFIG_USB_STORAGE_SDDR09 is not set
+ # CONFIG_USB_STORAGE_SDDR55 is not set
+ # CONFIG_USB_STORAGE_JUMPSHOT is not set
+ # CONFIG_USB_STORAGE_ALAUDA is not set
+ # CONFIG_USB_STORAGE_ONETOUCH is not set
+ # CONFIG_USB_STORAGE_KARMA is not set
+ # CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+ # CONFIG_USB_LIBUSUAL is not set
+ 
+ #
+ # USB Imaging devices
+ #
+ # CONFIG_USB_MDC800 is not set
+ # CONFIG_USB_MICROTEK is not set
+ 
+ #
+ # USB port drivers
+ #
+ CONFIG_USB_SERIAL=m
+ # CONFIG_USB_EZUSB is not set
+ CONFIG_USB_SERIAL_GENERIC=y
+ # CONFIG_USB_SERIAL_AIRCABLE is not set
+ # CONFIG_USB_SERIAL_ARK3116 is not set
+ # CONFIG_USB_SERIAL_BELKIN is not set
+ # CONFIG_USB_SERIAL_CH341 is not set
+ # CONFIG_USB_SERIAL_WHITEHEAT is not set
+ # CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+ # CONFIG_USB_SERIAL_CP2101 is not set
+ # CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+ # CONFIG_USB_SERIAL_EMPEG is not set
+ # CONFIG_USB_SERIAL_FTDI_SIO is not set
+ # CONFIG_USB_SERIAL_FUNSOFT is not set
+ # CONFIG_USB_SERIAL_VISOR is not set
+ # CONFIG_USB_SERIAL_IPAQ is not set
+ # CONFIG_USB_SERIAL_IR is not set
+ # CONFIG_USB_SERIAL_EDGEPORT is not set
+ # CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+ # CONFIG_USB_SERIAL_GARMIN is not set
+ # CONFIG_USB_SERIAL_IPW is not set
+ # CONFIG_USB_SERIAL_IUU is not set
+ # CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+ # CONFIG_USB_SERIAL_KEYSPAN is not set
+ # CONFIG_USB_SERIAL_KLSI is not set
+ # CONFIG_USB_SERIAL_KOBIL_SCT is not set
+ # CONFIG_USB_SERIAL_MCT_U232 is not set
+ # CONFIG_USB_SERIAL_MOS7720 is not set
+ # CONFIG_USB_SERIAL_MOS7840 is not set
+ # CONFIG_USB_SERIAL_MOTOROLA is not set
+ # CONFIG_USB_SERIAL_NAVMAN is not set
+ CONFIG_USB_SERIAL_PL2303=m
+ # CONFIG_USB_SERIAL_OTI6858 is not set
+ # CONFIG_USB_SERIAL_SPCP8X5 is not set
+ # CONFIG_USB_SERIAL_HP4X is not set
+ # CONFIG_USB_SERIAL_SAFE is not set
+ # CONFIG_USB_SERIAL_SIEMENS_MPI is not set
+ # CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+ # CONFIG_USB_SERIAL_TI is not set
+ # CONFIG_USB_SERIAL_CYBERJACK is not set
+ # CONFIG_USB_SERIAL_XIRCOM is not set
+ # CONFIG_USB_SERIAL_OPTION is not set
+ # CONFIG_USB_SERIAL_OMNINET is not set
+ # CONFIG_USB_SERIAL_OPTICON is not set
+ # CONFIG_USB_SERIAL_DEBUG is not set
+ 
+ #
+ # USB Miscellaneous drivers
+ #
+ # CONFIG_USB_EMI62 is not set
+ # CONFIG_USB_EMI26 is not set
+ # CONFIG_USB_ADUTUX is not set
+ # CONFIG_USB_SEVSEG is not set
+ # CONFIG_USB_RIO500 is not set
+ # CONFIG_USB_LEGOTOWER is not set
+ # CONFIG_USB_LCD is not set
+ # CONFIG_USB_BERRY_CHARGE is not set
+ # CONFIG_USB_LED is not set
+ # CONFIG_USB_CYPRESS_CY7C63 is not set
+ # CONFIG_USB_CYTHERM is not set
+ # CONFIG_USB_PHIDGET is not set
+ # CONFIG_USB_IDMOUSE is not set
+ # CONFIG_USB_FTDI_ELAN is not set
+ # CONFIG_USB_APPLEDISPLAY is not set
+ # CONFIG_USB_LD is not set
+ # CONFIG_USB_TRANCEVIBRATOR is not set
+ # CONFIG_USB_IOWARRIOR is not set
+ # CONFIG_USB_TEST is not set
+ # CONFIG_USB_ISIGHTFW is not set
+ # CONFIG_USB_VST is not set
+ CONFIG_USB_GADGET=m
+ CONFIG_USB_GADGET_DEBUG=y
+ CONFIG_USB_GADGET_DEBUG_FILES=y
+ CONFIG_USB_GADGET_VBUS_DRAW=2
+ CONFIG_USB_GADGET_SELECTED=y
+ CONFIG_USB_GADGET_AT91=y
+ CONFIG_USB_AT91=m
+ # CONFIG_USB_GADGET_ATMEL_USBA is not set
+ # CONFIG_USB_GADGET_FSL_USB2 is not set
+ # CONFIG_USB_GADGET_LH7A40X is not set
+ # CONFIG_USB_GADGET_OMAP is not set
+ # CONFIG_USB_GADGET_PXA25X is not set
+ # CONFIG_USB_GADGET_PXA27X is not set
+ # CONFIG_USB_GADGET_S3C2410 is not set
+ # CONFIG_USB_GADGET_IMX is not set
+ # CONFIG_USB_GADGET_M66592 is not set
+ # CONFIG_USB_GADGET_AMD5536UDC is not set
+ # CONFIG_USB_GADGET_FSL_QE is not set
+ # CONFIG_USB_GADGET_CI13XXX is not set
+ # CONFIG_USB_GADGET_NET2280 is not set
+ # CONFIG_USB_GADGET_GOKU is not set
+ # CONFIG_USB_GADGET_DUMMY_HCD is not set
+ # CONFIG_USB_GADGET_DUALSPEED is not set
+ # CONFIG_USB_ZERO is not set
+ CONFIG_USB_ETH=m
+ CONFIG_USB_ETH_RNDIS=y
+ # CONFIG_USB_GADGETFS is not set
+ # CONFIG_USB_FILE_STORAGE is not set
+ CONFIG_USB_G_SERIAL=m
+ # CONFIG_USB_MIDI_GADGET is not set
+ # CONFIG_USB_G_PRINTER is not set
+ CONFIG_USB_CDC_COMPOSITE=m
+ 
+ #
+ # OTG and related infrastructure
+ #
+ # CONFIG_USB_GPIO_VBUS is not set
+ # CONFIG_MMC is not set
+ # CONFIG_MEMSTICK is not set
+ # CONFIG_ACCESSIBILITY is not set
+ CONFIG_NEW_LEDS=y
+ CONFIG_LEDS_CLASS=y
+ 
+ #
+ # LED drivers
+ #
+ # CONFIG_LEDS_ATMEL_PWM is not set
+ CONFIG_LEDS_LIABDIN_ADDON=y
+ # CONFIG_LEDS_PCA9532 is not set
+ CONFIG_LEDS_GPIO=y
+ # CONFIG_LEDS_PCA955X is not set
+ 
+ #
+ # LED Triggers
+ #
+ CONFIG_LEDS_TRIGGERS=y
+ CONFIG_LEDS_TRIGGER_TIMER=y
+ CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+ # CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+ # CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+ CONFIG_LIAB=y
+ CONFIG_RTC_LIB=y
+ CONFIG_RTC_CLASS=y
+ CONFIG_RTC_HCTOSYS=y
+ CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+ # CONFIG_RTC_DEBUG is not set
+ 
+ #
+ # RTC interfaces
+ #
+ CONFIG_RTC_INTF_SYSFS=y
+ CONFIG_RTC_INTF_PROC=y
+ CONFIG_RTC_INTF_DEV=y
+ CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+ # CONFIG_RTC_DRV_TEST is not set
+ 
+ #
+ # I2C RTC drivers
+ #
+ CONFIG_RTC_DRV_DS1307=y
+ # CONFIG_RTC_DRV_DS1374 is not set
+ # CONFIG_RTC_DRV_DS1672 is not set
+ # CONFIG_RTC_DRV_MAX6900 is not set
+ # CONFIG_RTC_DRV_RS5C372 is not set
+ # CONFIG_RTC_DRV_ISL1208 is not set
+ # CONFIG_RTC_DRV_X1205 is not set
+ # CONFIG_RTC_DRV_PCF8563 is not set
+ # CONFIG_RTC_DRV_PCF8583 is not set
+ # CONFIG_RTC_DRV_M41T80 is not set
+ # CONFIG_RTC_DRV_S35390A is not set
+ # CONFIG_RTC_DRV_FM3130 is not set
+ # CONFIG_RTC_DRV_RX8581 is not set
+ 
+ #
+ # SPI RTC drivers
+ #
+ # CONFIG_RTC_DRV_M41T94 is not set
+ # CONFIG_RTC_DRV_DS1305 is not set
+ # CONFIG_RTC_DRV_DS1390 is not set
+ # CONFIG_RTC_DRV_MAX6902 is not set
+ # CONFIG_RTC_DRV_R9701 is not set
+ # CONFIG_RTC_DRV_RS5C348 is not set
+ # CONFIG_RTC_DRV_DS3234 is not set
+ 
+ #
+ # Platform RTC drivers
+ #
+ # CONFIG_RTC_DRV_CMOS is not set
+ # CONFIG_RTC_DRV_DS1286 is not set
+ # CONFIG_RTC_DRV_DS1511 is not set
+ # CONFIG_RTC_DRV_DS1553 is not set
+ # CONFIG_RTC_DRV_DS1742 is not set
+ # CONFIG_RTC_DRV_STK17TA8 is not set
+ # CONFIG_RTC_DRV_M48T86 is not set
+ # CONFIG_RTC_DRV_M48T35 is not set
+ # CONFIG_RTC_DRV_M48T59 is not set
+ # CONFIG_RTC_DRV_BQ4802 is not set
+ # CONFIG_RTC_DRV_V3020 is not set
+ 
+ #
+ # on-CPU RTC drivers
+ #
+ # CONFIG_RTC_DRV_AT91SAM9 is not set
+ # CONFIG_DMADEVICES is not set
+ # CONFIG_REGULATOR is not set
+ # CONFIG_UIO is not set
+ # CONFIG_STAGING is not set
+ 
+ #
+ # File systems
+ #
+ CONFIG_EXT2_FS=y
+ CONFIG_EXT2_FS_XATTR=y
+ CONFIG_EXT2_FS_POSIX_ACL=y
+ CONFIG_EXT2_FS_SECURITY=y
+ # CONFIG_EXT2_FS_XIP is not set
+ CONFIG_EXT3_FS=y
+ CONFIG_EXT3_FS_XATTR=y
+ CONFIG_EXT3_FS_POSIX_ACL=y
+ CONFIG_EXT3_FS_SECURITY=y
+ # CONFIG_EXT4_FS is not set
+ CONFIG_JBD=y
+ CONFIG_FS_MBCACHE=y
+ # CONFIG_REISERFS_FS is not set
+ # CONFIG_JFS_FS is not set
+ CONFIG_FS_POSIX_ACL=y
+ CONFIG_FILE_LOCKING=y
+ # CONFIG_XFS_FS is not set
+ # CONFIG_OCFS2_FS is not set
+ # CONFIG_BTRFS_FS is not set
+ # CONFIG_DNOTIFY is not set
+ # CONFIG_INOTIFY is not set
+ # CONFIG_QUOTA is not set
+ # CONFIG_AUTOFS_FS is not set
+ # CONFIG_AUTOFS4_FS is not set
+ # CONFIG_FUSE_FS is not set
+ 
+ #
+ # CD-ROM/DVD Filesystems
+ #
+ # CONFIG_ISO9660_FS is not set
+ # CONFIG_UDF_FS is not set
+ 
+ #
+ # DOS/FAT/NT Filesystems
+ #
+ CONFIG_FAT_FS=y
+ CONFIG_MSDOS_FS=y
+ CONFIG_VFAT_FS=y
+ CONFIG_FAT_DEFAULT_CODEPAGE=850
+ CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+ # CONFIG_NTFS_FS is not set
+ 
+ #
+ # Pseudo filesystems
+ #
+ CONFIG_PROC_FS=y
+ CONFIG_PROC_SYSCTL=y
+ CONFIG_PROC_PAGE_MONITOR=y
+ CONFIG_SYSFS=y
+ CONFIG_TMPFS=y
+ # CONFIG_TMPFS_POSIX_ACL is not set
+ # CONFIG_HUGETLB_PAGE is not set
+ # CONFIG_CONFIGFS_FS is not set
+ CONFIG_MISC_FILESYSTEMS=y
+ # CONFIG_ADFS_FS is not set
+ # CONFIG_AFFS_FS is not set
+ # CONFIG_HFS_FS is not set
+ # CONFIG_HFSPLUS_FS is not set
+ # CONFIG_BEFS_FS is not set
+ # CONFIG_BFS_FS is not set
+ # CONFIG_EFS_FS is not set
+ CONFIG_YAFFS_FS=y
+ CONFIG_YAFFS_YAFFS1=y
+ # CONFIG_YAFFS_9BYTE_TAGS is not set
+ # CONFIG_YAFFS_DOES_ECC is not set
+ CONFIG_YAFFS_YAFFS2=y
+ CONFIG_YAFFS_AUTO_YAFFS2=y
+ # CONFIG_YAFFS_DISABLE_TAGS_ECC is not set
+ # CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
+ # CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED is not set
+ CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
+ # CONFIG_YAFFS_EMPTY_LOST_AND_FOUND is not set
+ # CONFIG_YAFFS_DISABLE_BLOCK_REFRESHING is not set
+ # CONFIG_YAFFS_DISABLE_BACKGROUND is not set
+ CONFIG_JFFS2_FS=y
+ CONFIG_JFFS2_FS_DEBUG=0
+ CONFIG_JFFS2_FS_WRITEBUFFER=y
+ # CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+ # CONFIG_JFFS2_SUMMARY is not set
+ # CONFIG_JFFS2_FS_XATTR is not set
+ # CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+ CONFIG_JFFS2_ZLIB=y
+ # CONFIG_JFFS2_LZO is not set
+ CONFIG_JFFS2_RTIME=y
+ # CONFIG_JFFS2_RUBIN is not set
+ # CONFIG_CRAMFS is not set
+ # CONFIG_SQUASHFS is not set
+ # CONFIG_VXFS_FS is not set
+ # CONFIG_MINIX_FS is not set
+ # CONFIG_OMFS_FS is not set
+ # CONFIG_HPFS_FS is not set
+ # CONFIG_QNX4FS_FS is not set
+ # CONFIG_ROMFS_FS is not set
+ # CONFIG_SYSV_FS is not set
+ # CONFIG_UFS_FS is not set
+ CONFIG_NETWORK_FILESYSTEMS=y
+ CONFIG_NFS_FS=y
+ CONFIG_NFS_V3=y
+ # CONFIG_NFS_V3_ACL is not set
+ # CONFIG_NFS_V4 is not set
+ CONFIG_ROOT_NFS=y
+ # CONFIG_NFSD is not set
+ CONFIG_LOCKD=y
+ CONFIG_LOCKD_V4=y
+ CONFIG_NFS_COMMON=y
+ CONFIG_SUNRPC=y
+ # CONFIG_SUNRPC_REGISTER_V4 is not set
+ # CONFIG_RPCSEC_GSS_KRB5 is not set
+ # CONFIG_RPCSEC_GSS_SPKM3 is not set
+ # CONFIG_SMB_FS is not set
+ # CONFIG_CIFS is not set
+ # CONFIG_NCP_FS is not set
+ # CONFIG_CODA_FS is not set
+ # CONFIG_AFS_FS is not set
+ 
+ #
+ # Partition Types
+ #
+ # CONFIG_PARTITION_ADVANCED is not set
+ CONFIG_MSDOS_PARTITION=y
+ CONFIG_NLS=y
+ CONFIG_NLS_DEFAULT="iso8859-1"
+ # CONFIG_NLS_CODEPAGE_437 is not set
+ # CONFIG_NLS_CODEPAGE_737 is not set
+ # CONFIG_NLS_CODEPAGE_775 is not set
+ CONFIG_NLS_CODEPAGE_850=y
+ # CONFIG_NLS_CODEPAGE_852 is not set
+ # CONFIG_NLS_CODEPAGE_855 is not set
+ # CONFIG_NLS_CODEPAGE_857 is not set
+ # CONFIG_NLS_CODEPAGE_860 is not set
+ # CONFIG_NLS_CODEPAGE_861 is not set
+ # CONFIG_NLS_CODEPAGE_862 is not set
+ # CONFIG_NLS_CODEPAGE_863 is not set
+ # CONFIG_NLS_CODEPAGE_864 is not set
+ # CONFIG_NLS_CODEPAGE_865 is not set
+ # CONFIG_NLS_CODEPAGE_866 is not set
+ # CONFIG_NLS_CODEPAGE_869 is not set
+ # CONFIG_NLS_CODEPAGE_936 is not set
+ # CONFIG_NLS_CODEPAGE_950 is not set
+ # CONFIG_NLS_CODEPAGE_932 is not set
+ # CONFIG_NLS_CODEPAGE_949 is not set
+ # CONFIG_NLS_CODEPAGE_874 is not set
+ # CONFIG_NLS_ISO8859_8 is not set
+ # CONFIG_NLS_CODEPAGE_1250 is not set
+ # CONFIG_NLS_CODEPAGE_1251 is not set
+ # CONFIG_NLS_ASCII is not set
+ CONFIG_NLS_ISO8859_1=y
+ # CONFIG_NLS_ISO8859_2 is not set
+ # CONFIG_NLS_ISO8859_3 is not set
+ # CONFIG_NLS_ISO8859_4 is not set
+ # CONFIG_NLS_ISO8859_5 is not set
+ # CONFIG_NLS_ISO8859_6 is not set
+ # CONFIG_NLS_ISO8859_7 is not set
+ # CONFIG_NLS_ISO8859_9 is not set
+ # CONFIG_NLS_ISO8859_13 is not set
+ # CONFIG_NLS_ISO8859_14 is not set
+ # CONFIG_NLS_ISO8859_15 is not set
+ # CONFIG_NLS_KOI8_R is not set
+ # CONFIG_NLS_KOI8_U is not set
+ # CONFIG_NLS_UTF8 is not set
+ # CONFIG_DLM is not set
+ 
+ #
+ # Kernel hacking
+ #
+ # CONFIG_PRINTK_TIME is not set
+ CONFIG_ENABLE_WARN_DEPRECATED=y
+ CONFIG_ENABLE_MUST_CHECK=y
+ CONFIG_FRAME_WARN=1024
+ # CONFIG_MAGIC_SYSRQ is not set
+ # CONFIG_UNUSED_SYMBOLS is not set
+ # CONFIG_DEBUG_FS is not set
+ # CONFIG_HEADERS_CHECK is not set
+ CONFIG_DEBUG_KERNEL=y
+ # CONFIG_DEBUG_SHIRQ is not set
+ CONFIG_DETECT_SOFTLOCKUP=y
+ # CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+ CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+ CONFIG_SCHED_DEBUG=y
+ # CONFIG_SCHEDSTATS is not set
+ # CONFIG_TIMER_STATS is not set
+ # CONFIG_DEBUG_OBJECTS is not set
+ # CONFIG_DEBUG_SLAB is not set
+ CONFIG_DEBUG_PREEMPT=y
+ # CONFIG_DEBUG_RT_MUTEXES is not set
+ # CONFIG_RT_MUTEX_TESTER is not set
+ # CONFIG_DEBUG_SPINLOCK is not set
+ CONFIG_DEBUG_MUTEXES=y
+ # CONFIG_DEBUG_LOCK_ALLOC is not set
+ # CONFIG_PROVE_LOCKING is not set
+ # CONFIG_LOCK_STAT is not set
+ # CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+ # CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+ # CONFIG_DEBUG_KOBJECT is not set
+ # CONFIG_DEBUG_BUGVERBOSE is not set
+ # CONFIG_DEBUG_INFO is not set
+ # CONFIG_DEBUG_VM is not set
+ # CONFIG_DEBUG_WRITECOUNT is not set
+ # CONFIG_DEBUG_MEMORY_INIT is not set
+ # CONFIG_DEBUG_LIST is not set
+ # CONFIG_DEBUG_SG is not set
+ # CONFIG_DEBUG_NOTIFIERS is not set
+ CONFIG_FRAME_POINTER=y
+ # CONFIG_BOOT_PRINTK_DELAY is not set
+ # CONFIG_RCU_TORTURE_TEST is not set
+ # CONFIG_BACKTRACE_SELF_TEST is not set
+ # CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+ # CONFIG_FAULT_INJECTION is not set
+ # CONFIG_LATENCYTOP is not set
+ # CONFIG_SYSCTL_SYSCALL_CHECK is not set
+ CONFIG_HAVE_FUNCTION_TRACER=y
+ 
+ #
+ # Tracers
+ #
+ # CONFIG_FUNCTION_TRACER is not set
+ # CONFIG_IRQSOFF_TRACER is not set
+ # CONFIG_PREEMPT_TRACER is not set
+ # CONFIG_SCHED_TRACER is not set
+ # CONFIG_CONTEXT_SWITCH_TRACER is not set
+ # CONFIG_BOOT_TRACER is not set
+ # CONFIG_TRACE_BRANCH_PROFILING is not set
+ # CONFIG_STACK_TRACER is not set
+ # CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+ # CONFIG_SAMPLES is not set
+ CONFIG_HAVE_ARCH_KGDB=y
+ # CONFIG_KGDB is not set
+ # CONFIG_DEBUG_USER is not set
+ # CONFIG_DEBUG_ERRORS is not set
+ # CONFIG_DEBUG_STACK_USAGE is not set
+ CONFIG_DEBUG_LL=y
+ # CONFIG_DEBUG_ICEDCC is not set
+ 
+ #
+ # Security options
+ #
+ # CONFIG_KEYS is not set
+ # CONFIG_SECURITY is not set
+ # CONFIG_SECURITYFS is not set
+ # CONFIG_SECURITY_FILE_CAPABILITIES is not set
+ CONFIG_CRYPTO=y
+ 
+ #
+ # Crypto core or helper
+ #
+ # CONFIG_CRYPTO_FIPS is not set
+ CONFIG_CRYPTO_ALGAPI=y
+ CONFIG_CRYPTO_ALGAPI2=y
+ CONFIG_CRYPTO_AEAD2=y
+ CONFIG_CRYPTO_BLKCIPHER=y
+ CONFIG_CRYPTO_BLKCIPHER2=y
+ CONFIG_CRYPTO_HASH=y
+ CONFIG_CRYPTO_HASH2=y
+ CONFIG_CRYPTO_RNG2=y
+ CONFIG_CRYPTO_MANAGER=y
+ CONFIG_CRYPTO_MANAGER2=y
+ # CONFIG_CRYPTO_GF128MUL is not set
+ # CONFIG_CRYPTO_NULL is not set
+ # CONFIG_CRYPTO_CRYPTD is not set
+ # CONFIG_CRYPTO_AUTHENC is not set
+ # CONFIG_CRYPTO_TEST is not set
+ 
+ #
+ # Authenticated Encryption with Associated Data
+ #
+ # CONFIG_CRYPTO_CCM is not set
+ # CONFIG_CRYPTO_GCM is not set
+ # CONFIG_CRYPTO_SEQIV is not set
+ 
+ #
+ # Block modes
+ #
+ # CONFIG_CRYPTO_CBC is not set
+ # CONFIG_CRYPTO_CTR is not set
+ # CONFIG_CRYPTO_CTS is not set
+ CONFIG_CRYPTO_ECB=y
+ # CONFIG_CRYPTO_LRW is not set
+ # CONFIG_CRYPTO_PCBC is not set
+ # CONFIG_CRYPTO_XTS is not set
+ 
+ #
+ # Hash modes
+ #
+ # CONFIG_CRYPTO_HMAC is not set
+ # CONFIG_CRYPTO_XCBC is not set
+ 
+ #
+ # Digest
+ #
+ CONFIG_CRYPTO_CRC32C=y
+ # CONFIG_CRYPTO_MD4 is not set
+ # CONFIG_CRYPTO_MD5 is not set
+ # CONFIG_CRYPTO_MICHAEL_MIC is not set
+ # CONFIG_CRYPTO_RMD128 is not set
+ # CONFIG_CRYPTO_RMD160 is not set
+ # CONFIG_CRYPTO_RMD256 is not set
+ # CONFIG_CRYPTO_RMD320 is not set
+ CONFIG_CRYPTO_SHA1=y
+ # CONFIG_CRYPTO_SHA256 is not set
+ # CONFIG_CRYPTO_SHA512 is not set
+ # CONFIG_CRYPTO_TGR192 is not set
+ # CONFIG_CRYPTO_WP512 is not set
+ 
+ #
+ # Ciphers
+ #
+ CONFIG_CRYPTO_AES=y
+ # CONFIG_CRYPTO_ANUBIS is not set
+ CONFIG_CRYPTO_ARC4=y
+ # CONFIG_CRYPTO_BLOWFISH is not set
+ # CONFIG_CRYPTO_CAMELLIA is not set
+ # CONFIG_CRYPTO_CAST5 is not set
+ # CONFIG_CRYPTO_CAST6 is not set
+ # CONFIG_CRYPTO_DES is not set
+ # CONFIG_CRYPTO_FCRYPT is not set
+ # CONFIG_CRYPTO_KHAZAD is not set
+ # CONFIG_CRYPTO_SALSA20 is not set
+ # CONFIG_CRYPTO_SEED is not set
+ # CONFIG_CRYPTO_SERPENT is not set
+ # CONFIG_CRYPTO_TEA is not set
+ # CONFIG_CRYPTO_TWOFISH is not set
+ 
+ #
+ # Compression
+ #
+ # CONFIG_CRYPTO_DEFLATE is not set
+ # CONFIG_CRYPTO_LZO is not set
+ 
+ #
+ # Random Number Generation
+ #
+ # CONFIG_CRYPTO_ANSI_CPRNG is not set
+ CONFIG_CRYPTO_HW=y
+ 
+ #
+ # Library routines
+ #
+ CONFIG_BITREVERSE=y
+ CONFIG_GENERIC_FIND_LAST_BIT=y
+ CONFIG_CRC_CCITT=y
+ CONFIG_CRC16=y
+ # CONFIG_CRC_T10DIF is not set
+ CONFIG_CRC_ITU_T=y
+ CONFIG_CRC32=y
+ # CONFIG_CRC7 is not set
+ CONFIG_LIBCRC32C=y
+ CONFIG_ZLIB_INFLATE=y
+ CONFIG_ZLIB_DEFLATE=y
+ CONFIG_PLIST=y
+ CONFIG_HAS_IOMEM=y
+ CONFIG_HAS_IOPORT=y
+ CONFIG_HAS_DMA=y
diff -r -C3 -P linux-2.6.29.4/.config.old liab-linux-2.6.29.4/.config.old
*** linux-2.6.29.4/.config.old	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/.config.old	2012-04-03 14:04:09.948515362 +0200
***************
*** 0 ****
--- 1,1613 ----
+ #
+ # Automatically generated make config: don't edit
+ # Linux kernel version: 2.6.29.4
+ # Thu Oct 14 12:27:43 2010
+ #
+ CONFIG_ARM=y
+ CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+ CONFIG_GENERIC_GPIO=y
+ CONFIG_GENERIC_TIME=y
+ CONFIG_GENERIC_CLOCKEVENTS=y
+ CONFIG_MMU=y
+ # CONFIG_NO_IOPORT is not set
+ CONFIG_GENERIC_HARDIRQS=y
+ CONFIG_STACKTRACE_SUPPORT=y
+ CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+ CONFIG_LOCKDEP_SUPPORT=y
+ CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+ CONFIG_HARDIRQS_SW_RESEND=y
+ CONFIG_GENERIC_IRQ_PROBE=y
+ CONFIG_RWSEM_GENERIC_SPINLOCK=y
+ # CONFIG_ARCH_HAS_ILOG2_U32 is not set
+ # CONFIG_ARCH_HAS_ILOG2_U64 is not set
+ CONFIG_GENERIC_HWEIGHT=y
+ CONFIG_GENERIC_CALIBRATE_DELAY=y
+ CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+ CONFIG_VECTORS_BASE=0xffff0000
+ CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+ 
+ #
+ # General setup
+ #
+ CONFIG_EXPERIMENTAL=y
+ CONFIG_BROKEN_ON_SMP=y
+ CONFIG_LOCK_KERNEL=y
+ CONFIG_INIT_ENV_ARG_LIMIT=32
+ CONFIG_LOCALVERSION=""
+ # CONFIG_LOCALVERSION_AUTO is not set
+ CONFIG_SWAP=y
+ CONFIG_SYSVIPC=y
+ CONFIG_SYSVIPC_SYSCTL=y
+ CONFIG_POSIX_MQUEUE=y
+ # CONFIG_BSD_PROCESS_ACCT is not set
+ # CONFIG_TASKSTATS is not set
+ # CONFIG_AUDIT is not set
+ 
+ #
+ # RCU Subsystem
+ #
+ # CONFIG_CLASSIC_RCU is not set
+ # CONFIG_TREE_RCU is not set
+ CONFIG_PREEMPT_RCU=y
+ # CONFIG_RCU_TRACE is not set
+ # CONFIG_TREE_RCU_TRACE is not set
+ # CONFIG_PREEMPT_RCU_TRACE is not set
+ CONFIG_IKCONFIG=y
+ CONFIG_IKCONFIG_PROC=y
+ CONFIG_LOG_BUF_SHIFT=14
+ CONFIG_GROUP_SCHED=y
+ CONFIG_FAIR_GROUP_SCHED=y
+ # CONFIG_RT_GROUP_SCHED is not set
+ CONFIG_USER_SCHED=y
+ # CONFIG_CGROUP_SCHED is not set
+ # CONFIG_CGROUPS is not set
+ CONFIG_SYSFS_DEPRECATED=y
+ CONFIG_SYSFS_DEPRECATED_V2=y
+ # CONFIG_RELAY is not set
+ # CONFIG_NAMESPACES is not set
+ CONFIG_BLK_DEV_INITRD=y
+ CONFIG_INITRAMFS_SOURCE=""
+ CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+ CONFIG_SYSCTL=y
+ CONFIG_ANON_INODES=y
+ CONFIG_EMBEDDED=y
+ CONFIG_UID16=y
+ CONFIG_SYSCTL_SYSCALL=y
+ # CONFIG_KALLSYMS is not set
+ CONFIG_HOTPLUG=y
+ CONFIG_PRINTK=y
+ CONFIG_BUG=y
+ # CONFIG_ELF_CORE is not set
+ CONFIG_BASE_FULL=y
+ CONFIG_FUTEX=y
+ CONFIG_EPOLL=y
+ CONFIG_SIGNALFD=y
+ CONFIG_TIMERFD=y
+ CONFIG_EVENTFD=y
+ CONFIG_SHMEM=y
+ CONFIG_AIO=y
+ CONFIG_VM_EVENT_COUNTERS=y
+ CONFIG_COMPAT_BRK=y
+ CONFIG_SLAB=y
+ # CONFIG_SLUB is not set
+ # CONFIG_SLOB is not set
+ # CONFIG_PROFILING is not set
+ CONFIG_HAVE_OPROFILE=y
+ CONFIG_HAVE_KPROBES=y
+ CONFIG_HAVE_KRETPROBES=y
+ CONFIG_HAVE_CLK=y
+ CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+ CONFIG_SLABINFO=y
+ CONFIG_RT_MUTEXES=y
+ CONFIG_BASE_SMALL=0
+ CONFIG_MODULES=y
+ # CONFIG_MODULE_FORCE_LOAD is not set
+ CONFIG_MODULE_UNLOAD=y
+ CONFIG_MODULE_FORCE_UNLOAD=y
+ # CONFIG_MODVERSIONS is not set
+ # CONFIG_MODULE_SRCVERSION_ALL is not set
+ CONFIG_BLOCK=y
+ # CONFIG_LBD is not set
+ # CONFIG_BLK_DEV_IO_TRACE is not set
+ # CONFIG_BLK_DEV_BSG is not set
+ # CONFIG_BLK_DEV_INTEGRITY is not set
+ 
+ #
+ # IO Schedulers
+ #
+ CONFIG_IOSCHED_NOOP=y
+ # CONFIG_IOSCHED_AS is not set
+ # CONFIG_IOSCHED_DEADLINE is not set
+ CONFIG_IOSCHED_CFQ=y
+ # CONFIG_DEFAULT_AS is not set
+ # CONFIG_DEFAULT_DEADLINE is not set
+ CONFIG_DEFAULT_CFQ=y
+ # CONFIG_DEFAULT_NOOP is not set
+ CONFIG_DEFAULT_IOSCHED="cfq"
+ # CONFIG_FREEZER is not set
+ 
+ #
+ # System Type
+ #
+ # CONFIG_ARCH_AAEC2000 is not set
+ # CONFIG_ARCH_INTEGRATOR is not set
+ # CONFIG_ARCH_REALVIEW is not set
+ # CONFIG_ARCH_VERSATILE is not set
+ CONFIG_ARCH_AT91=y
+ # CONFIG_ARCH_CLPS711X is not set
+ # CONFIG_ARCH_EBSA110 is not set
+ # CONFIG_ARCH_EP93XX is not set
+ # CONFIG_ARCH_FOOTBRIDGE is not set
+ # CONFIG_ARCH_NETX is not set
+ # CONFIG_ARCH_H720X is not set
+ # CONFIG_ARCH_IMX is not set
+ # CONFIG_ARCH_IOP13XX is not set
+ # CONFIG_ARCH_IOP32X is not set
+ # CONFIG_ARCH_IOP33X is not set
+ # CONFIG_ARCH_IXP23XX is not set
+ # CONFIG_ARCH_IXP2000 is not set
+ # CONFIG_ARCH_IXP4XX is not set
+ # CONFIG_ARCH_L7200 is not set
+ # CONFIG_ARCH_KIRKWOOD is not set
+ # CONFIG_ARCH_KS8695 is not set
+ # CONFIG_ARCH_NS9XXX is not set
+ # CONFIG_ARCH_LOKI is not set
+ # CONFIG_ARCH_MV78XX0 is not set
+ # CONFIG_ARCH_MXC is not set
+ # CONFIG_ARCH_ORION5X is not set
+ # CONFIG_ARCH_PNX4008 is not set
+ # CONFIG_ARCH_PXA is not set
+ # CONFIG_ARCH_RPC is not set
+ # CONFIG_ARCH_SA1100 is not set
+ # CONFIG_ARCH_S3C2410 is not set
+ # CONFIG_ARCH_S3C64XX is not set
+ # CONFIG_ARCH_SHARK is not set
+ # CONFIG_ARCH_LH7A40X is not set
+ # CONFIG_ARCH_DAVINCI is not set
+ # CONFIG_ARCH_OMAP is not set
+ # CONFIG_ARCH_MSM is not set
+ # CONFIG_ARCH_W90X900 is not set
+ 
+ #
+ # Atmel AT91 System-on-Chip
+ #
+ # CONFIG_ARCH_AT91RM9200 is not set
+ CONFIG_ARCH_AT91SAM9260=y
+ # CONFIG_ARCH_AT91SAM9261 is not set
+ # CONFIG_ARCH_AT91SAM9263 is not set
+ # CONFIG_ARCH_AT91SAM9RL is not set
+ # CONFIG_ARCH_AT91SAM9G20 is not set
+ # CONFIG_ARCH_AT91CAP9 is not set
+ # CONFIG_ARCH_AT91X40 is not set
+ CONFIG_AT91_PMC_UNIT=y
+ CONFIG_MACH_LIABARM=y
+ 
+ #
+ # AT91SAM9260 Variants
+ #
+ # CONFIG_ARCH_AT91SAM9260_SAM9XE is not set
+ 
+ #
+ # AT91SAM9260 / AT91SAM9XE Board Type
+ #
+ # CONFIG_MACH_AT91SAM9260EK is not set
+ CONFIG_MACH_LIABSG=y
+ # CONFIG_MACH_CAM60 is not set
+ # CONFIG_MACH_SAM9_L9260 is not set
+ # CONFIG_MACH_AFEB9260 is not set
+ # CONFIG_MACH_USB_A9260 is not set
+ # CONFIG_MACH_QIL_A9260 is not set
+ 
+ #
+ # AT91 Board Options
+ #
+ 
+ #
+ # AT91 Feature Selections
+ #
+ # CONFIG_AT91_PROGRAMMABLE_CLOCKS is not set
+ CONFIG_AT91_TIMER_HZ=128
+ CONFIG_AT91_EARLY_DBGU=y
+ # CONFIG_AT91_EARLY_USART0 is not set
+ # CONFIG_AT91_EARLY_USART1 is not set
+ # CONFIG_AT91_EARLY_USART2 is not set
+ # CONFIG_AT91_EARLY_USART3 is not set
+ # CONFIG_AT91_EARLY_USART4 is not set
+ # CONFIG_AT91_EARLY_USART5 is not set
+ 
+ #
+ # Processor Type
+ #
+ CONFIG_CPU_32=y
+ CONFIG_CPU_ARM926T=y
+ CONFIG_CPU_32v5=y
+ CONFIG_CPU_ABRT_EV5TJ=y
+ CONFIG_CPU_PABRT_NOIFAR=y
+ CONFIG_CPU_CACHE_VIVT=y
+ CONFIG_CPU_COPY_V4WB=y
+ CONFIG_CPU_TLB_V4WBI=y
+ CONFIG_CPU_CP15=y
+ CONFIG_CPU_CP15_MMU=y
+ 
+ #
+ # Processor Features
+ #
+ CONFIG_ARM_THUMB=y
+ # CONFIG_CPU_ICACHE_DISABLE is not set
+ # CONFIG_CPU_DCACHE_DISABLE is not set
+ # CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+ # CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+ # CONFIG_OUTER_CACHE is not set
+ 
+ #
+ # Bus support
+ #
+ # CONFIG_PCI_SYSCALL is not set
+ # CONFIG_ARCH_SUPPORTS_MSI is not set
+ # CONFIG_PCCARD is not set
+ 
+ #
+ # Kernel Features
+ #
+ # CONFIG_NO_HZ is not set
+ # CONFIG_HIGH_RES_TIMERS is not set
+ CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+ CONFIG_VMSPLIT_3G=y
+ # CONFIG_VMSPLIT_2G is not set
+ # CONFIG_VMSPLIT_1G is not set
+ CONFIG_PAGE_OFFSET=0xC0000000
+ CONFIG_PREEMPT=y
+ CONFIG_HZ=128
+ # CONFIG_AEABI is not set
+ CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+ # CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+ # CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+ CONFIG_SELECT_MEMORY_MODEL=y
+ CONFIG_FLATMEM_MANUAL=y
+ # CONFIG_DISCONTIGMEM_MANUAL is not set
+ # CONFIG_SPARSEMEM_MANUAL is not set
+ CONFIG_FLATMEM=y
+ CONFIG_FLAT_NODE_MEM_MAP=y
+ CONFIG_PAGEFLAGS_EXTENDED=y
+ CONFIG_SPLIT_PTLOCK_CPUS=4096
+ # CONFIG_PHYS_ADDR_T_64BIT is not set
+ CONFIG_ZONE_DMA_FLAG=0
+ CONFIG_VIRT_TO_BUS=y
+ CONFIG_UNEVICTABLE_LRU=y
+ CONFIG_LEDS=y
+ CONFIG_LEDS_CPU=y
+ CONFIG_ALIGNMENT_TRAP=y
+ 
+ #
+ # Boot options
+ #
+ CONFIG_ZBOOT_ROM_TEXT=0x0
+ CONFIG_ZBOOT_ROM_BSS=0x0
+ CONFIG_CMDLINE=""
+ # CONFIG_XIP_KERNEL is not set
+ # CONFIG_KEXEC is not set
+ 
+ #
+ # CPU Power Management
+ #
+ # CONFIG_CPU_IDLE is not set
+ 
+ #
+ # Floating point emulation
+ #
+ 
+ #
+ # At least one emulation must be selected
+ #
+ CONFIG_FPE_NWFPE=y
+ # CONFIG_FPE_NWFPE_XP is not set
+ # CONFIG_FPE_FASTFPE is not set
+ # CONFIG_VFP is not set
+ 
+ #
+ # Userspace binary formats
+ #
+ CONFIG_BINFMT_ELF=y
+ CONFIG_HAVE_AOUT=y
+ # CONFIG_BINFMT_AOUT is not set
+ # CONFIG_BINFMT_MISC is not set
+ # CONFIG_ARTHUR is not set
+ 
+ #
+ # Power management options
+ #
+ # CONFIG_PM is not set
+ CONFIG_ARCH_SUSPEND_POSSIBLE=y
+ CONFIG_NET=y
+ 
+ #
+ # Networking options
+ #
+ CONFIG_COMPAT_NET_DEV_OPS=y
+ CONFIG_PACKET=y
+ CONFIG_PACKET_MMAP=y
+ CONFIG_UNIX=y
+ # CONFIG_NET_KEY is not set
+ CONFIG_INET=y
+ CONFIG_IP_MULTICAST=y
+ CONFIG_IP_ADVANCED_ROUTER=y
+ CONFIG_ASK_IP_FIB_HASH=y
+ # CONFIG_IP_FIB_TRIE is not set
+ CONFIG_IP_FIB_HASH=y
+ CONFIG_IP_MULTIPLE_TABLES=y
+ CONFIG_IP_ROUTE_MULTIPATH=y
+ CONFIG_IP_ROUTE_VERBOSE=y
+ CONFIG_IP_PNP=y
+ CONFIG_IP_PNP_DHCP=y
+ CONFIG_IP_PNP_BOOTP=y
+ CONFIG_IP_PNP_RARP=y
+ # CONFIG_NET_IPIP is not set
+ # CONFIG_NET_IPGRE is not set
+ CONFIG_IP_MROUTE=y
+ CONFIG_IP_PIMSM_V1=y
+ # CONFIG_IP_PIMSM_V2 is not set
+ # CONFIG_ARPD is not set
+ CONFIG_SYN_COOKIES=y
+ # CONFIG_INET_AH is not set
+ # CONFIG_INET_ESP is not set
+ # CONFIG_INET_IPCOMP is not set
+ # CONFIG_INET_XFRM_TUNNEL is not set
+ # CONFIG_INET_TUNNEL is not set
+ # CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+ # CONFIG_INET_XFRM_MODE_TUNNEL is not set
+ # CONFIG_INET_XFRM_MODE_BEET is not set
+ # CONFIG_INET_LRO is not set
+ # CONFIG_INET_DIAG is not set
+ # CONFIG_TCP_CONG_ADVANCED is not set
+ CONFIG_TCP_CONG_CUBIC=y
+ CONFIG_DEFAULT_TCP_CONG="cubic"
+ # CONFIG_TCP_MD5SIG is not set
+ # CONFIG_IPV6 is not set
+ # CONFIG_NETWORK_SECMARK is not set
+ # CONFIG_NETFILTER is not set
+ # CONFIG_IP_DCCP is not set
+ # CONFIG_IP_SCTP is not set
+ # CONFIG_TIPC is not set
+ # CONFIG_ATM is not set
+ # CONFIG_BRIDGE is not set
+ # CONFIG_NET_DSA is not set
+ # CONFIG_VLAN_8021Q is not set
+ # CONFIG_DECNET is not set
+ # CONFIG_LLC2 is not set
+ # CONFIG_IPX is not set
+ # CONFIG_ATALK is not set
+ # CONFIG_X25 is not set
+ # CONFIG_LAPB is not set
+ # CONFIG_ECONET is not set
+ # CONFIG_WAN_ROUTER is not set
+ # CONFIG_NET_SCHED is not set
+ # CONFIG_DCB is not set
+ 
+ #
+ # Network testing
+ #
+ # CONFIG_NET_PKTGEN is not set
+ # CONFIG_HAMRADIO is not set
+ # CONFIG_CAN is not set
+ # CONFIG_IRDA is not set
+ # CONFIG_BT is not set
+ # CONFIG_AF_RXRPC is not set
+ # CONFIG_PHONET is not set
+ CONFIG_FIB_RULES=y
+ # CONFIG_WIRELESS is not set
+ # CONFIG_WIMAX is not set
+ # CONFIG_RFKILL is not set
+ # CONFIG_NET_9P is not set
+ 
+ #
+ # Device Drivers
+ #
+ 
+ #
+ # Generic Driver Options
+ #
+ CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+ CONFIG_STANDALONE=y
+ CONFIG_PREVENT_FIRMWARE_BUILD=y
+ CONFIG_FW_LOADER=y
+ # CONFIG_FIRMWARE_IN_KERNEL is not set
+ CONFIG_EXTRA_FIRMWARE=""
+ # CONFIG_DEBUG_DRIVER is not set
+ # CONFIG_DEBUG_DEVRES is not set
+ # CONFIG_SYS_HYPERVISOR is not set
+ # CONFIG_CONNECTOR is not set
+ CONFIG_MTD=y
+ # CONFIG_MTD_DEBUG is not set
+ # CONFIG_MTD_CONCAT is not set
+ CONFIG_MTD_PARTITIONS=y
+ # CONFIG_MTD_TESTS is not set
+ # CONFIG_MTD_REDBOOT_PARTS is not set
+ # CONFIG_MTD_CMDLINE_PARTS is not set
+ # CONFIG_MTD_AFS_PARTS is not set
+ # CONFIG_MTD_AR7_PARTS is not set
+ 
+ #
+ # User Modules And Translation Layers
+ #
+ CONFIG_MTD_CHAR=y
+ CONFIG_MTD_BLKDEVS=y
+ CONFIG_MTD_BLOCK=y
+ # CONFIG_FTL is not set
+ CONFIG_NFTL=y
+ CONFIG_NFTL_RW=y
+ # CONFIG_INFTL is not set
+ # CONFIG_RFD_FTL is not set
+ # CONFIG_SSFDC is not set
+ # CONFIG_MTD_OOPS is not set
+ 
+ #
+ # RAM/ROM/Flash chip drivers
+ #
+ CONFIG_MTD_CFI=y
+ # CONFIG_MTD_JEDECPROBE is not set
+ CONFIG_MTD_GEN_PROBE=y
+ # CONFIG_MTD_CFI_ADV_OPTIONS is not set
+ CONFIG_MTD_MAP_BANK_WIDTH_1=y
+ CONFIG_MTD_MAP_BANK_WIDTH_2=y
+ CONFIG_MTD_MAP_BANK_WIDTH_4=y
+ # CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+ # CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+ # CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+ CONFIG_MTD_CFI_I1=y
+ CONFIG_MTD_CFI_I2=y
+ # CONFIG_MTD_CFI_I4 is not set
+ # CONFIG_MTD_CFI_I8 is not set
+ CONFIG_MTD_CFI_INTELEXT=y
+ CONFIG_MTD_CFI_AMDSTD=y
+ # CONFIG_MTD_CFI_STAA is not set
+ CONFIG_MTD_CFI_UTIL=y
+ # CONFIG_MTD_RAM is not set
+ # CONFIG_MTD_ROM is not set
+ # CONFIG_MTD_ABSENT is not set
+ 
+ #
+ # Mapping drivers for chip access
+ #
+ # CONFIG_MTD_COMPLEX_MAPPINGS is not set
+ # CONFIG_MTD_PHYSMAP is not set
+ # CONFIG_MTD_ARM_INTEGRATOR is not set
+ CONFIG_MTD_LIABARM=y
+ CONFIG_MTD_LIAB_FLASH_SIZE=16384
+ CONFIG_MTD_LIAB_NOFLASH=1
+ CONFIG_MTD_LIABARM_BOOTSIZE=128
+ CONFIG_MTD_LIABARM_KERNELSIZE=1536
+ CONFIG_MTD_LIABARM_ROOTSIZE=6144
+ CONFIG_MTD_LIABARM_PARAMSIZE=128
+ CONFIG_MTD_LIABARM_JFFS2SIZE=8448
+ # CONFIG_MTD_PLATRAM is not set
+ 
+ #
+ # Self-contained MTD device drivers
+ #
+ # CONFIG_MTD_DATAFLASH is not set
+ # CONFIG_MTD_M25P80 is not set
+ # CONFIG_MTD_SLRAM is not set
+ # CONFIG_MTD_PHRAM is not set
+ # CONFIG_MTD_MTDRAM is not set
+ # CONFIG_MTD_BLOCK2MTD is not set
+ 
+ #
+ # Disk-On-Chip Device Drivers
+ #
+ # CONFIG_MTD_DOC2000 is not set
+ # CONFIG_MTD_DOC2001 is not set
+ # CONFIG_MTD_DOC2001PLUS is not set
+ CONFIG_MTD_NAND=y
+ # CONFIG_MTD_NAND_VERIFY_WRITE is not set
+ # CONFIG_MTD_NAND_ECC_SMC is not set
+ # CONFIG_MTD_NAND_MUSEUM_IDS is not set
+ # CONFIG_MTD_NAND_GPIO is not set
+ CONFIG_MTD_NAND_IDS=y
+ # CONFIG_MTD_NAND_DISKONCHIP is not set
+ CONFIG_MTD_NAND_ATMEL=y
+ # CONFIG_MTD_NAND_ATMEL_ECC_HW is not set
+ CONFIG_MTD_NAND_ATMEL_ECC_SOFT=y
+ # CONFIG_MTD_NAND_ATMEL_ECC_NONE is not set
+ # CONFIG_MTD_NAND_NANDSIM is not set
+ # CONFIG_MTD_NAND_PLATFORM is not set
+ # CONFIG_MTD_ALAUDA is not set
+ # CONFIG_MTD_ONENAND is not set
+ 
+ #
+ # LPDDR flash memory drivers
+ #
+ # CONFIG_MTD_LPDDR is not set
+ 
+ #
+ # UBI - Unsorted block images
+ #
+ # CONFIG_MTD_UBI is not set
+ # CONFIG_PARPORT is not set
+ CONFIG_BLK_DEV=y
+ # CONFIG_BLK_DEV_COW_COMMON is not set
+ # CONFIG_BLK_DEV_LOOP is not set
+ # CONFIG_BLK_DEV_NBD is not set
+ # CONFIG_BLK_DEV_UB is not set
+ CONFIG_BLK_DEV_RAM=y
+ CONFIG_BLK_DEV_RAM_COUNT=16
+ CONFIG_BLK_DEV_RAM_SIZE=32768
+ # CONFIG_BLK_DEV_XIP is not set
+ # CONFIG_CDROM_PKTCDVD is not set
+ # CONFIG_ATA_OVER_ETH is not set
+ CONFIG_MISC_DEVICES=y
+ # CONFIG_ATMEL_TCLIB is not set
+ CONFIG_AT91_PWM=y
+ # CONFIG_ICS932S401 is not set
+ # CONFIG_ATMEL_SSC is not set
+ # CONFIG_ENCLOSURE_SERVICES is not set
+ # CONFIG_C2PORT is not set
+ 
+ #
+ # EEPROM support
+ #
+ CONFIG_EEPROM_AT24=y
+ # CONFIG_EEPROM_AT25 is not set
+ # CONFIG_EEPROM_LEGACY is not set
+ # CONFIG_EEPROM_93CX6 is not set
+ CONFIG_HAVE_IDE=y
+ # CONFIG_IDE is not set
+ 
+ #
+ # SCSI device support
+ #
+ # CONFIG_RAID_ATTRS is not set
+ CONFIG_SCSI=m
+ CONFIG_SCSI_DMA=y
+ # CONFIG_SCSI_TGT is not set
+ # CONFIG_SCSI_NETLINK is not set
+ CONFIG_SCSI_PROC_FS=y
+ 
+ #
+ # SCSI support type (disk, tape, CD-ROM)
+ #
+ CONFIG_BLK_DEV_SD=m
+ # CONFIG_CHR_DEV_ST is not set
+ # CONFIG_CHR_DEV_OSST is not set
+ # CONFIG_BLK_DEV_SR is not set
+ # CONFIG_CHR_DEV_SG is not set
+ # CONFIG_CHR_DEV_SCH is not set
+ 
+ #
+ # Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+ #
+ CONFIG_SCSI_MULTI_LUN=y
+ # CONFIG_SCSI_CONSTANTS is not set
+ CONFIG_SCSI_LOGGING=y
+ # CONFIG_SCSI_SCAN_ASYNC is not set
+ CONFIG_SCSI_WAIT_SCAN=m
+ 
+ #
+ # SCSI Transports
+ #
+ # CONFIG_SCSI_SPI_ATTRS is not set
+ # CONFIG_SCSI_FC_ATTRS is not set
+ # CONFIG_SCSI_ISCSI_ATTRS is not set
+ # CONFIG_SCSI_SAS_LIBSAS is not set
+ # CONFIG_SCSI_SRP_ATTRS is not set
+ CONFIG_SCSI_LOWLEVEL=y
+ # CONFIG_ISCSI_TCP is not set
+ # CONFIG_LIBFC is not set
+ # CONFIG_SCSI_DEBUG is not set
+ # CONFIG_SCSI_DH is not set
+ # CONFIG_ATA is not set
+ # CONFIG_MD is not set
+ CONFIG_NETDEVICES=y
+ # CONFIG_DUMMY is not set
+ # CONFIG_BONDING is not set
+ # CONFIG_MACVLAN is not set
+ # CONFIG_EQUALIZER is not set
+ CONFIG_TUN=y
+ # CONFIG_VETH is not set
+ CONFIG_PHYLIB=y
+ 
+ #
+ # MII PHY device drivers
+ #
+ # CONFIG_MARVELL_PHY is not set
+ CONFIG_DAVICOM_PHY=y
+ # CONFIG_QSEMI_PHY is not set
+ # CONFIG_LXT_PHY is not set
+ # CONFIG_CICADA_PHY is not set
+ # CONFIG_VITESSE_PHY is not set
+ # CONFIG_SMSC_PHY is not set
+ # CONFIG_BROADCOM_PHY is not set
+ # CONFIG_ICPLUS_PHY is not set
+ # CONFIG_REALTEK_PHY is not set
+ # CONFIG_NATIONAL_PHY is not set
+ # CONFIG_STE10XP is not set
+ # CONFIG_LSI_ET1011C_PHY is not set
+ # CONFIG_FIXED_PHY is not set
+ # CONFIG_MDIO_BITBANG is not set
+ CONFIG_NET_ETHERNET=y
+ CONFIG_MII=y
+ CONFIG_MACB=y
+ # CONFIG_AX88796 is not set
+ # CONFIG_SMC91X is not set
+ # CONFIG_DM9000 is not set
+ # CONFIG_ENC28J60 is not set
+ # CONFIG_SMC911X is not set
+ # CONFIG_SMSC911X is not set
+ # CONFIG_DNET is not set
+ # CONFIG_IBM_NEW_EMAC_ZMII is not set
+ # CONFIG_IBM_NEW_EMAC_RGMII is not set
+ # CONFIG_IBM_NEW_EMAC_TAH is not set
+ # CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+ # CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+ # CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+ # CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+ # CONFIG_B44 is not set
+ # CONFIG_NETDEV_1000 is not set
+ # CONFIG_NETDEV_10000 is not set
+ 
+ #
+ # Wireless LAN
+ #
+ # CONFIG_WLAN_PRE80211 is not set
+ # CONFIG_WLAN_80211 is not set
+ # CONFIG_IWLWIFI_LEDS is not set
+ 
+ #
+ # Enable WiMAX (Networking options) to see the WiMAX drivers
+ #
+ 
+ #
+ # USB Network Adapters
+ #
+ # CONFIG_USB_CATC is not set
+ # CONFIG_USB_KAWETH is not set
+ # CONFIG_USB_PEGASUS is not set
+ # CONFIG_USB_RTL8150 is not set
+ # CONFIG_USB_USBNET is not set
+ # CONFIG_WAN is not set
+ CONFIG_PPP=y
+ # CONFIG_PPP_MULTILINK is not set
+ CONFIG_PPP_FILTER=y
+ CONFIG_PPP_ASYNC=y
+ # CONFIG_PPP_SYNC_TTY is not set
+ CONFIG_PPP_DEFLATE=y
+ CONFIG_PPP_BSDCOMP=y
+ CONFIG_PPP_MPPE=y
+ CONFIG_PPPOE=y
+ # CONFIG_PPPOL2TP is not set
+ # CONFIG_SLIP is not set
+ CONFIG_SLHC=y
+ # CONFIG_NETCONSOLE is not set
+ # CONFIG_NETPOLL is not set
+ # CONFIG_NET_POLL_CONTROLLER is not set
+ # CONFIG_ISDN is not set
+ 
+ #
+ # Input device support
+ #
+ CONFIG_INPUT=y
+ # CONFIG_INPUT_FF_MEMLESS is not set
+ # CONFIG_INPUT_POLLDEV is not set
+ 
+ #
+ # Userland interfaces
+ #
+ # CONFIG_INPUT_MOUSEDEV is not set
+ # CONFIG_INPUT_JOYDEV is not set
+ CONFIG_INPUT_EVDEV=y
+ # CONFIG_INPUT_EVBUG is not set
+ 
+ #
+ # Input Device Drivers
+ #
+ CONFIG_INPUT_KEYBOARD=y
+ # CONFIG_KEYBOARD_ATKBD is not set
+ # CONFIG_KEYBOARD_SUNKBD is not set
+ # CONFIG_KEYBOARD_LKKBD is not set
+ # CONFIG_KEYBOARD_XTKBD is not set
+ # CONFIG_KEYBOARD_NEWTON is not set
+ # CONFIG_KEYBOARD_STOWAWAY is not set
+ CONFIG_KEYBOARD_GPIO=y
+ # CONFIG_INPUT_MOUSE is not set
+ # CONFIG_INPUT_JOYSTICK is not set
+ # CONFIG_INPUT_TABLET is not set
+ # CONFIG_INPUT_TOUCHSCREEN is not set
+ # CONFIG_INPUT_MISC is not set
+ 
+ #
+ # Hardware I/O ports
+ #
+ # CONFIG_SERIO is not set
+ # CONFIG_GAMEPORT is not set
+ 
+ #
+ # Character devices
+ #
+ # CONFIG_VT is not set
+ CONFIG_DEVKMEM=y
+ # CONFIG_SERIAL_NONSTANDARD is not set
+ 
+ #
+ # Serial drivers
+ #
+ # CONFIG_SERIAL_8250 is not set
+ 
+ #
+ # Non-8250 serial port support
+ #
+ CONFIG_SERIAL_ATMEL=y
+ CONFIG_SERIAL_ATMEL_CONSOLE=y
+ CONFIG_SERIAL_ATMEL_PDC=y
+ # CONFIG_SERIAL_ATMEL_TTYAT is not set
+ CONFIG_SERIAL_CORE=y
+ CONFIG_SERIAL_CORE_CONSOLE=y
+ CONFIG_UNIX98_PTYS=y
+ # CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+ CONFIG_LEGACY_PTYS=y
+ CONFIG_LEGACY_PTY_COUNT=256
+ # CONFIG_IPMI_HANDLER is not set
+ CONFIG_HW_RANDOM=y
+ # CONFIG_R3964 is not set
+ # CONFIG_RAW_DRIVER is not set
+ # CONFIG_TCG_TPM is not set
+ CONFIG_I2C=y
+ CONFIG_I2C_BOARDINFO=y
+ CONFIG_I2C_CHARDEV=y
+ CONFIG_I2C_HELPER_AUTO=y
+ CONFIG_I2C_ALGOBIT=y
+ 
+ #
+ # I2C Hardware Bus support
+ #
+ 
+ #
+ # I2C system bus drivers (mostly embedded / system-on-chip)
+ #
+ CONFIG_I2C_GPIO=y
+ # CONFIG_I2C_OCORES is not set
+ # CONFIG_I2C_SIMTEC is not set
+ 
+ #
+ # External I2C/SMBus adapter drivers
+ #
+ # CONFIG_I2C_PARPORT_LIGHT is not set
+ # CONFIG_I2C_TAOS_EVM is not set
+ # CONFIG_I2C_TINY_USB is not set
+ 
+ #
+ # Other I2C/SMBus bus drivers
+ #
+ # CONFIG_I2C_PCA_PLATFORM is not set
+ # CONFIG_I2C_STUB is not set
+ 
+ #
+ # Miscellaneous I2C Chip support
+ #
+ # CONFIG_DS1682 is not set
+ # CONFIG_SENSORS_PCF8574 is not set
+ # CONFIG_PCF8575 is not set
+ # CONFIG_SENSORS_PCF8591 is not set
+ # CONFIG_SENSORS_MAX6875 is not set
+ # CONFIG_SENSORS_TSL2550 is not set
+ # CONFIG_I2C_DEBUG_CORE is not set
+ # CONFIG_I2C_DEBUG_ALGO is not set
+ # CONFIG_I2C_DEBUG_BUS is not set
+ # CONFIG_I2C_DEBUG_CHIP is not set
+ CONFIG_SPI=y
+ # CONFIG_SPI_DEBUG is not set
+ CONFIG_SPI_MASTER=y
+ 
+ #
+ # SPI Master Controller Drivers
+ #
+ CONFIG_SPI_ATMEL=y
+ # CONFIG_SPI_BITBANG is not set
+ # CONFIG_SPI_GPIO is not set
+ 
+ #
+ # SPI Protocol Masters
+ #
+ # CONFIG_SPI_SPIDEV is not set
+ # CONFIG_SPI_TLE62X0 is not set
+ CONFIG_ARCH_REQUIRE_GPIOLIB=y
+ CONFIG_GPIOLIB=y
+ CONFIG_DEBUG_GPIO=y
+ CONFIG_GPIO_SYSFS=y
+ 
+ #
+ # Memory mapped GPIO expanders:
+ #
+ 
+ #
+ # I2C GPIO expanders:
+ #
+ # CONFIG_GPIO_MAX732X is not set
+ CONFIG_GPIO_PCA953X=y
+ # CONFIG_GPIO_PCF857X is not set
+ 
+ #
+ # PCI GPIO expanders:
+ #
+ 
+ #
+ # SPI GPIO expanders:
+ #
+ # CONFIG_GPIO_MAX7301 is not set
+ # CONFIG_GPIO_MCP23S08 is not set
+ # CONFIG_W1 is not set
+ # CONFIG_POWER_SUPPLY is not set
+ CONFIG_HWMON=y
+ CONFIG_HWMON_VID=y
+ # CONFIG_SENSORS_AD7414 is not set
+ # CONFIG_SENSORS_AD7418 is not set
+ # CONFIG_SENSORS_ADCXX is not set
+ # CONFIG_SENSORS_ADM1021 is not set
+ # CONFIG_SENSORS_ADM1025 is not set
+ # CONFIG_SENSORS_ADM1026 is not set
+ # CONFIG_SENSORS_ADM1029 is not set
+ # CONFIG_SENSORS_ADM1031 is not set
+ CONFIG_SENSORS_ADM9240=y
+ # CONFIG_SENSORS_ADT7462 is not set
+ # CONFIG_SENSORS_ADT7470 is not set
+ # CONFIG_SENSORS_ADT7473 is not set
+ # CONFIG_SENSORS_ADT7475 is not set
+ # CONFIG_SENSORS_ATXP1 is not set
+ # CONFIG_SENSORS_DS1621 is not set
+ # CONFIG_SENSORS_F71805F is not set
+ # CONFIG_SENSORS_F71882FG is not set
+ # CONFIG_SENSORS_F75375S is not set
+ # CONFIG_SENSORS_GL518SM is not set
+ # CONFIG_SENSORS_GL520SM is not set
+ # CONFIG_SENSORS_IT87 is not set
+ # CONFIG_SENSORS_LM63 is not set
+ # CONFIG_SENSORS_LM70 is not set
+ # CONFIG_SENSORS_LM75 is not set
+ # CONFIG_SENSORS_LM77 is not set
+ # CONFIG_SENSORS_LM78 is not set
+ # CONFIG_SENSORS_LM80 is not set
+ # CONFIG_SENSORS_LM83 is not set
+ # CONFIG_SENSORS_LM85 is not set
+ # CONFIG_SENSORS_LM87 is not set
+ # CONFIG_SENSORS_LM90 is not set
+ # CONFIG_SENSORS_LM92 is not set
+ # CONFIG_SENSORS_LM93 is not set
+ # CONFIG_SENSORS_LTC4245 is not set
+ # CONFIG_SENSORS_MAX1111 is not set
+ # CONFIG_SENSORS_MAX1619 is not set
+ # CONFIG_SENSORS_MAX6650 is not set
+ # CONFIG_SENSORS_PC87360 is not set
+ # CONFIG_SENSORS_PC87427 is not set
+ # CONFIG_SENSORS_DME1737 is not set
+ # CONFIG_SENSORS_SMSC47M1 is not set
+ # CONFIG_SENSORS_SMSC47M192 is not set
+ # CONFIG_SENSORS_SMSC47B397 is not set
+ # CONFIG_SENSORS_ADS7828 is not set
+ # CONFIG_SENSORS_THMC50 is not set
+ # CONFIG_SENSORS_VT1211 is not set
+ # CONFIG_SENSORS_W83781D is not set
+ # CONFIG_SENSORS_W83791D is not set
+ # CONFIG_SENSORS_W83792D is not set
+ # CONFIG_SENSORS_W83793 is not set
+ # CONFIG_SENSORS_W83L785TS is not set
+ # CONFIG_SENSORS_W83L786NG is not set
+ # CONFIG_SENSORS_W83627HF is not set
+ # CONFIG_SENSORS_W83627EHF is not set
+ # CONFIG_HWMON_DEBUG_CHIP is not set
+ # CONFIG_THERMAL is not set
+ # CONFIG_THERMAL_HWMON is not set
+ CONFIG_WATCHDOG=y
+ # CONFIG_WATCHDOG_NOWAYOUT is not set
+ 
+ #
+ # Watchdog Device Drivers
+ #
+ # CONFIG_SOFT_WATCHDOG is not set
+ CONFIG_AT91SAM9X_WATCHDOG=y
+ 
+ #
+ # USB-based Watchdog Cards
+ #
+ # CONFIG_USBPCWATCHDOG is not set
+ CONFIG_SSB_POSSIBLE=y
+ 
+ #
+ # Sonics Silicon Backplane
+ #
+ # CONFIG_SSB is not set
+ 
+ #
+ # Multifunction device drivers
+ #
+ # CONFIG_MFD_CORE is not set
+ # CONFIG_MFD_SM501 is not set
+ # CONFIG_MFD_ASIC3 is not set
+ # CONFIG_HTC_EGPIO is not set
+ # CONFIG_HTC_PASIC3 is not set
+ # CONFIG_TPS65010 is not set
+ # CONFIG_TWL4030_CORE is not set
+ # CONFIG_MFD_TMIO is not set
+ # CONFIG_MFD_T7L66XB is not set
+ # CONFIG_MFD_TC6387XB is not set
+ # CONFIG_MFD_TC6393XB is not set
+ # CONFIG_PMIC_DA903X is not set
+ # CONFIG_MFD_WM8400 is not set
+ # CONFIG_MFD_WM8350_I2C is not set
+ # CONFIG_MFD_PCF50633 is not set
+ 
+ #
+ # Multimedia devices
+ #
+ 
+ #
+ # Multimedia core support
+ #
+ # CONFIG_VIDEO_DEV is not set
+ # CONFIG_DVB_CORE is not set
+ # CONFIG_VIDEO_MEDIA is not set
+ 
+ #
+ # Multimedia drivers
+ #
+ # CONFIG_DAB is not set
+ 
+ #
+ # Graphics support
+ #
+ # CONFIG_VGASTATE is not set
+ # CONFIG_VIDEO_OUTPUT_CONTROL is not set
+ # CONFIG_FB is not set
+ # CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+ 
+ #
+ # Display device support
+ #
+ # CONFIG_DISPLAY_SUPPORT is not set
+ # CONFIG_SOUND is not set
+ CONFIG_HID_SUPPORT=y
+ CONFIG_HID=y
+ # CONFIG_HID_DEBUG is not set
+ # CONFIG_HIDRAW is not set
+ 
+ #
+ # USB Input Devices
+ #
+ # CONFIG_USB_HID is not set
+ # CONFIG_HID_PID is not set
+ 
+ #
+ # USB HID Boot Protocol drivers
+ #
+ # CONFIG_USB_KBD is not set
+ # CONFIG_USB_MOUSE is not set
+ 
+ #
+ # Special HID drivers
+ #
+ CONFIG_HID_COMPAT=y
+ CONFIG_USB_SUPPORT=y
+ CONFIG_USB_ARCH_HAS_HCD=y
+ CONFIG_USB_ARCH_HAS_OHCI=y
+ # CONFIG_USB_ARCH_HAS_EHCI is not set
+ CONFIG_USB=y
+ # CONFIG_USB_DEBUG is not set
+ # CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+ 
+ #
+ # Miscellaneous USB options
+ #
+ CONFIG_USB_DEVICEFS=y
+ CONFIG_USB_DEVICE_CLASS=y
+ # CONFIG_USB_DYNAMIC_MINORS is not set
+ # CONFIG_USB_OTG is not set
+ # CONFIG_USB_OTG_WHITELIST is not set
+ # CONFIG_USB_OTG_BLACKLIST_HUB is not set
+ CONFIG_USB_MON=y
+ # CONFIG_USB_WUSB is not set
+ # CONFIG_USB_WUSB_CBAF is not set
+ 
+ #
+ # USB Host Controller Drivers
+ #
+ # CONFIG_USB_C67X00_HCD is not set
+ # CONFIG_USB_OXU210HP_HCD is not set
+ # CONFIG_USB_ISP116X_HCD is not set
+ CONFIG_USB_OHCI_HCD=y
+ # CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+ # CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+ CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+ # CONFIG_USB_SL811_HCD is not set
+ # CONFIG_USB_R8A66597_HCD is not set
+ # CONFIG_USB_HWA_HCD is not set
+ # CONFIG_USB_MUSB_HDRC is not set
+ # CONFIG_USB_GADGET_MUSB_HDRC is not set
+ 
+ #
+ # USB Device Class drivers
+ #
+ CONFIG_USB_ACM=m
+ # CONFIG_USB_PRINTER is not set
+ # CONFIG_USB_WDM is not set
+ # CONFIG_USB_TMC is not set
+ 
+ #
+ # NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
+ #
+ 
+ #
+ # see USB_STORAGE Help for more information
+ #
+ CONFIG_USB_STORAGE=m
+ # CONFIG_USB_STORAGE_DEBUG is not set
+ # CONFIG_USB_STORAGE_DATAFAB is not set
+ # CONFIG_USB_STORAGE_FREECOM is not set
+ # CONFIG_USB_STORAGE_ISD200 is not set
+ # CONFIG_USB_STORAGE_USBAT is not set
+ # CONFIG_USB_STORAGE_SDDR09 is not set
+ # CONFIG_USB_STORAGE_SDDR55 is not set
+ # CONFIG_USB_STORAGE_JUMPSHOT is not set
+ # CONFIG_USB_STORAGE_ALAUDA is not set
+ # CONFIG_USB_STORAGE_ONETOUCH is not set
+ # CONFIG_USB_STORAGE_KARMA is not set
+ # CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+ # CONFIG_USB_LIBUSUAL is not set
+ 
+ #
+ # USB Imaging devices
+ #
+ # CONFIG_USB_MDC800 is not set
+ # CONFIG_USB_MICROTEK is not set
+ 
+ #
+ # USB port drivers
+ #
+ CONFIG_USB_SERIAL=m
+ # CONFIG_USB_EZUSB is not set
+ CONFIG_USB_SERIAL_GENERIC=y
+ # CONFIG_USB_SERIAL_AIRCABLE is not set
+ # CONFIG_USB_SERIAL_ARK3116 is not set
+ # CONFIG_USB_SERIAL_BELKIN is not set
+ # CONFIG_USB_SERIAL_CH341 is not set
+ # CONFIG_USB_SERIAL_WHITEHEAT is not set
+ # CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+ # CONFIG_USB_SERIAL_CP2101 is not set
+ # CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+ # CONFIG_USB_SERIAL_EMPEG is not set
+ # CONFIG_USB_SERIAL_FTDI_SIO is not set
+ # CONFIG_USB_SERIAL_FUNSOFT is not set
+ # CONFIG_USB_SERIAL_VISOR is not set
+ # CONFIG_USB_SERIAL_IPAQ is not set
+ # CONFIG_USB_SERIAL_IR is not set
+ # CONFIG_USB_SERIAL_EDGEPORT is not set
+ # CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+ # CONFIG_USB_SERIAL_GARMIN is not set
+ # CONFIG_USB_SERIAL_IPW is not set
+ # CONFIG_USB_SERIAL_IUU is not set
+ # CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+ # CONFIG_USB_SERIAL_KEYSPAN is not set
+ # CONFIG_USB_SERIAL_KLSI is not set
+ # CONFIG_USB_SERIAL_KOBIL_SCT is not set
+ # CONFIG_USB_SERIAL_MCT_U232 is not set
+ # CONFIG_USB_SERIAL_MOS7720 is not set
+ # CONFIG_USB_SERIAL_MOS7840 is not set
+ # CONFIG_USB_SERIAL_MOTOROLA is not set
+ # CONFIG_USB_SERIAL_NAVMAN is not set
+ CONFIG_USB_SERIAL_PL2303=m
+ # CONFIG_USB_SERIAL_OTI6858 is not set
+ # CONFIG_USB_SERIAL_SPCP8X5 is not set
+ # CONFIG_USB_SERIAL_HP4X is not set
+ # CONFIG_USB_SERIAL_SAFE is not set
+ # CONFIG_USB_SERIAL_SIEMENS_MPI is not set
+ # CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+ # CONFIG_USB_SERIAL_TI is not set
+ # CONFIG_USB_SERIAL_CYBERJACK is not set
+ # CONFIG_USB_SERIAL_XIRCOM is not set
+ # CONFIG_USB_SERIAL_OPTION is not set
+ # CONFIG_USB_SERIAL_OMNINET is not set
+ # CONFIG_USB_SERIAL_OPTICON is not set
+ # CONFIG_USB_SERIAL_DEBUG is not set
+ 
+ #
+ # USB Miscellaneous drivers
+ #
+ # CONFIG_USB_EMI62 is not set
+ # CONFIG_USB_EMI26 is not set
+ # CONFIG_USB_ADUTUX is not set
+ # CONFIG_USB_SEVSEG is not set
+ # CONFIG_USB_RIO500 is not set
+ # CONFIG_USB_LEGOTOWER is not set
+ # CONFIG_USB_LCD is not set
+ # CONFIG_USB_BERRY_CHARGE is not set
+ # CONFIG_USB_LED is not set
+ # CONFIG_USB_CYPRESS_CY7C63 is not set
+ # CONFIG_USB_CYTHERM is not set
+ # CONFIG_USB_PHIDGET is not set
+ # CONFIG_USB_IDMOUSE is not set
+ # CONFIG_USB_FTDI_ELAN is not set
+ # CONFIG_USB_APPLEDISPLAY is not set
+ # CONFIG_USB_LD is not set
+ # CONFIG_USB_TRANCEVIBRATOR is not set
+ # CONFIG_USB_IOWARRIOR is not set
+ # CONFIG_USB_TEST is not set
+ # CONFIG_USB_ISIGHTFW is not set
+ # CONFIG_USB_VST is not set
+ CONFIG_USB_GADGET=m
+ CONFIG_USB_GADGET_DEBUG=y
+ CONFIG_USB_GADGET_DEBUG_FILES=y
+ CONFIG_USB_GADGET_VBUS_DRAW=2
+ CONFIG_USB_GADGET_SELECTED=y
+ CONFIG_USB_GADGET_AT91=y
+ CONFIG_USB_AT91=m
+ # CONFIG_USB_GADGET_ATMEL_USBA is not set
+ # CONFIG_USB_GADGET_FSL_USB2 is not set
+ # CONFIG_USB_GADGET_LH7A40X is not set
+ # CONFIG_USB_GADGET_OMAP is not set
+ # CONFIG_USB_GADGET_PXA25X is not set
+ # CONFIG_USB_GADGET_PXA27X is not set
+ # CONFIG_USB_GADGET_S3C2410 is not set
+ # CONFIG_USB_GADGET_IMX is not set
+ # CONFIG_USB_GADGET_M66592 is not set
+ # CONFIG_USB_GADGET_AMD5536UDC is not set
+ # CONFIG_USB_GADGET_FSL_QE is not set
+ # CONFIG_USB_GADGET_CI13XXX is not set
+ # CONFIG_USB_GADGET_NET2280 is not set
+ # CONFIG_USB_GADGET_GOKU is not set
+ # CONFIG_USB_GADGET_DUMMY_HCD is not set
+ # CONFIG_USB_GADGET_DUALSPEED is not set
+ # CONFIG_USB_ZERO is not set
+ CONFIG_USB_ETH=m
+ CONFIG_USB_ETH_RNDIS=y
+ # CONFIG_USB_GADGETFS is not set
+ # CONFIG_USB_FILE_STORAGE is not set
+ CONFIG_USB_G_SERIAL=m
+ # CONFIG_USB_MIDI_GADGET is not set
+ # CONFIG_USB_G_PRINTER is not set
+ CONFIG_USB_CDC_COMPOSITE=m
+ 
+ #
+ # OTG and related infrastructure
+ #
+ # CONFIG_USB_GPIO_VBUS is not set
+ # CONFIG_MMC is not set
+ # CONFIG_MEMSTICK is not set
+ # CONFIG_ACCESSIBILITY is not set
+ CONFIG_NEW_LEDS=y
+ CONFIG_LEDS_CLASS=y
+ 
+ #
+ # LED drivers
+ #
+ # CONFIG_LEDS_ATMEL_PWM is not set
+ CONFIG_LEDS_LIABDIN_ADDON=y
+ # CONFIG_LEDS_PCA9532 is not set
+ CONFIG_LEDS_GPIO=y
+ # CONFIG_LEDS_PCA955X is not set
+ 
+ #
+ # LED Triggers
+ #
+ CONFIG_LEDS_TRIGGERS=y
+ CONFIG_LEDS_TRIGGER_TIMER=y
+ CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+ # CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+ # CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+ CONFIG_RTC_LIB=y
+ CONFIG_RTC_CLASS=y
+ CONFIG_RTC_HCTOSYS=y
+ CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+ # CONFIG_RTC_DEBUG is not set
+ 
+ #
+ # RTC interfaces
+ #
+ CONFIG_RTC_INTF_SYSFS=y
+ CONFIG_RTC_INTF_PROC=y
+ CONFIG_RTC_INTF_DEV=y
+ CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+ # CONFIG_RTC_DRV_TEST is not set
+ 
+ #
+ # I2C RTC drivers
+ #
+ CONFIG_RTC_DRV_DS1307=y
+ # CONFIG_RTC_DRV_DS1374 is not set
+ # CONFIG_RTC_DRV_DS1672 is not set
+ # CONFIG_RTC_DRV_MAX6900 is not set
+ # CONFIG_RTC_DRV_RS5C372 is not set
+ # CONFIG_RTC_DRV_ISL1208 is not set
+ # CONFIG_RTC_DRV_X1205 is not set
+ # CONFIG_RTC_DRV_PCF8563 is not set
+ # CONFIG_RTC_DRV_PCF8583 is not set
+ # CONFIG_RTC_DRV_M41T80 is not set
+ # CONFIG_RTC_DRV_S35390A is not set
+ # CONFIG_RTC_DRV_FM3130 is not set
+ # CONFIG_RTC_DRV_RX8581 is not set
+ 
+ #
+ # SPI RTC drivers
+ #
+ # CONFIG_RTC_DRV_M41T94 is not set
+ # CONFIG_RTC_DRV_DS1305 is not set
+ # CONFIG_RTC_DRV_DS1390 is not set
+ # CONFIG_RTC_DRV_MAX6902 is not set
+ # CONFIG_RTC_DRV_R9701 is not set
+ # CONFIG_RTC_DRV_RS5C348 is not set
+ # CONFIG_RTC_DRV_DS3234 is not set
+ 
+ #
+ # Platform RTC drivers
+ #
+ # CONFIG_RTC_DRV_CMOS is not set
+ # CONFIG_RTC_DRV_DS1286 is not set
+ # CONFIG_RTC_DRV_DS1511 is not set
+ # CONFIG_RTC_DRV_DS1553 is not set
+ # CONFIG_RTC_DRV_DS1742 is not set
+ # CONFIG_RTC_DRV_STK17TA8 is not set
+ # CONFIG_RTC_DRV_M48T86 is not set
+ # CONFIG_RTC_DRV_M48T35 is not set
+ # CONFIG_RTC_DRV_M48T59 is not set
+ # CONFIG_RTC_DRV_BQ4802 is not set
+ # CONFIG_RTC_DRV_V3020 is not set
+ 
+ #
+ # on-CPU RTC drivers
+ #
+ # CONFIG_RTC_DRV_AT91SAM9 is not set
+ # CONFIG_DMADEVICES is not set
+ # CONFIG_REGULATOR is not set
+ # CONFIG_UIO is not set
+ # CONFIG_STAGING is not set
+ 
+ #
+ # File systems
+ #
+ CONFIG_EXT2_FS=y
+ CONFIG_EXT2_FS_XATTR=y
+ CONFIG_EXT2_FS_POSIX_ACL=y
+ CONFIG_EXT2_FS_SECURITY=y
+ # CONFIG_EXT2_FS_XIP is not set
+ CONFIG_EXT3_FS=y
+ CONFIG_EXT3_FS_XATTR=y
+ CONFIG_EXT3_FS_POSIX_ACL=y
+ CONFIG_EXT3_FS_SECURITY=y
+ # CONFIG_EXT4_FS is not set
+ CONFIG_JBD=y
+ CONFIG_FS_MBCACHE=y
+ # CONFIG_REISERFS_FS is not set
+ # CONFIG_JFS_FS is not set
+ CONFIG_FS_POSIX_ACL=y
+ CONFIG_FILE_LOCKING=y
+ # CONFIG_XFS_FS is not set
+ # CONFIG_OCFS2_FS is not set
+ # CONFIG_BTRFS_FS is not set
+ # CONFIG_DNOTIFY is not set
+ # CONFIG_INOTIFY is not set
+ # CONFIG_QUOTA is not set
+ # CONFIG_AUTOFS_FS is not set
+ # CONFIG_AUTOFS4_FS is not set
+ # CONFIG_FUSE_FS is not set
+ 
+ #
+ # CD-ROM/DVD Filesystems
+ #
+ # CONFIG_ISO9660_FS is not set
+ # CONFIG_UDF_FS is not set
+ 
+ #
+ # DOS/FAT/NT Filesystems
+ #
+ CONFIG_FAT_FS=y
+ CONFIG_MSDOS_FS=y
+ CONFIG_VFAT_FS=y
+ CONFIG_FAT_DEFAULT_CODEPAGE=850
+ CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+ # CONFIG_NTFS_FS is not set
+ 
+ #
+ # Pseudo filesystems
+ #
+ CONFIG_PROC_FS=y
+ CONFIG_PROC_SYSCTL=y
+ CONFIG_PROC_PAGE_MONITOR=y
+ CONFIG_SYSFS=y
+ CONFIG_TMPFS=y
+ # CONFIG_TMPFS_POSIX_ACL is not set
+ # CONFIG_HUGETLB_PAGE is not set
+ # CONFIG_CONFIGFS_FS is not set
+ CONFIG_MISC_FILESYSTEMS=y
+ # CONFIG_ADFS_FS is not set
+ # CONFIG_AFFS_FS is not set
+ # CONFIG_HFS_FS is not set
+ # CONFIG_HFSPLUS_FS is not set
+ # CONFIG_BEFS_FS is not set
+ # CONFIG_BFS_FS is not set
+ # CONFIG_EFS_FS is not set
+ CONFIG_YAFFS_FS=y
+ CONFIG_YAFFS_YAFFS1=y
+ # CONFIG_YAFFS_9BYTE_TAGS is not set
+ # CONFIG_YAFFS_DOES_ECC is not set
+ CONFIG_YAFFS_YAFFS2=y
+ CONFIG_YAFFS_AUTO_YAFFS2=y
+ # CONFIG_YAFFS_DISABLE_TAGS_ECC is not set
+ # CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
+ # CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED is not set
+ CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
+ # CONFIG_YAFFS_EMPTY_LOST_AND_FOUND is not set
+ # CONFIG_YAFFS_DISABLE_BLOCK_REFRESHING is not set
+ # CONFIG_YAFFS_DISABLE_BACKGROUND is not set
+ CONFIG_JFFS2_FS=y
+ CONFIG_JFFS2_FS_DEBUG=0
+ CONFIG_JFFS2_FS_WRITEBUFFER=y
+ # CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+ # CONFIG_JFFS2_SUMMARY is not set
+ # CONFIG_JFFS2_FS_XATTR is not set
+ # CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+ CONFIG_JFFS2_ZLIB=y
+ # CONFIG_JFFS2_LZO is not set
+ CONFIG_JFFS2_RTIME=y
+ # CONFIG_JFFS2_RUBIN is not set
+ # CONFIG_CRAMFS is not set
+ # CONFIG_SQUASHFS is not set
+ # CONFIG_VXFS_FS is not set
+ # CONFIG_MINIX_FS is not set
+ # CONFIG_OMFS_FS is not set
+ # CONFIG_HPFS_FS is not set
+ # CONFIG_QNX4FS_FS is not set
+ # CONFIG_ROMFS_FS is not set
+ # CONFIG_SYSV_FS is not set
+ # CONFIG_UFS_FS is not set
+ CONFIG_NETWORK_FILESYSTEMS=y
+ CONFIG_NFS_FS=y
+ CONFIG_NFS_V3=y
+ # CONFIG_NFS_V3_ACL is not set
+ # CONFIG_NFS_V4 is not set
+ CONFIG_ROOT_NFS=y
+ # CONFIG_NFSD is not set
+ CONFIG_LOCKD=y
+ CONFIG_LOCKD_V4=y
+ CONFIG_NFS_COMMON=y
+ CONFIG_SUNRPC=y
+ # CONFIG_SUNRPC_REGISTER_V4 is not set
+ # CONFIG_RPCSEC_GSS_KRB5 is not set
+ # CONFIG_RPCSEC_GSS_SPKM3 is not set
+ # CONFIG_SMB_FS is not set
+ # CONFIG_CIFS is not set
+ # CONFIG_NCP_FS is not set
+ # CONFIG_CODA_FS is not set
+ # CONFIG_AFS_FS is not set
+ 
+ #
+ # Partition Types
+ #
+ # CONFIG_PARTITION_ADVANCED is not set
+ CONFIG_MSDOS_PARTITION=y
+ CONFIG_NLS=y
+ CONFIG_NLS_DEFAULT="iso8859-1"
+ # CONFIG_NLS_CODEPAGE_437 is not set
+ # CONFIG_NLS_CODEPAGE_737 is not set
+ # CONFIG_NLS_CODEPAGE_775 is not set
+ CONFIG_NLS_CODEPAGE_850=y
+ # CONFIG_NLS_CODEPAGE_852 is not set
+ # CONFIG_NLS_CODEPAGE_855 is not set
+ # CONFIG_NLS_CODEPAGE_857 is not set
+ # CONFIG_NLS_CODEPAGE_860 is not set
+ # CONFIG_NLS_CODEPAGE_861 is not set
+ # CONFIG_NLS_CODEPAGE_862 is not set
+ # CONFIG_NLS_CODEPAGE_863 is not set
+ # CONFIG_NLS_CODEPAGE_864 is not set
+ # CONFIG_NLS_CODEPAGE_865 is not set
+ # CONFIG_NLS_CODEPAGE_866 is not set
+ # CONFIG_NLS_CODEPAGE_869 is not set
+ # CONFIG_NLS_CODEPAGE_936 is not set
+ # CONFIG_NLS_CODEPAGE_950 is not set
+ # CONFIG_NLS_CODEPAGE_932 is not set
+ # CONFIG_NLS_CODEPAGE_949 is not set
+ # CONFIG_NLS_CODEPAGE_874 is not set
+ # CONFIG_NLS_ISO8859_8 is not set
+ # CONFIG_NLS_CODEPAGE_1250 is not set
+ # CONFIG_NLS_CODEPAGE_1251 is not set
+ # CONFIG_NLS_ASCII is not set
+ CONFIG_NLS_ISO8859_1=y
+ # CONFIG_NLS_ISO8859_2 is not set
+ # CONFIG_NLS_ISO8859_3 is not set
+ # CONFIG_NLS_ISO8859_4 is not set
+ # CONFIG_NLS_ISO8859_5 is not set
+ # CONFIG_NLS_ISO8859_6 is not set
+ # CONFIG_NLS_ISO8859_7 is not set
+ # CONFIG_NLS_ISO8859_9 is not set
+ # CONFIG_NLS_ISO8859_13 is not set
+ # CONFIG_NLS_ISO8859_14 is not set
+ # CONFIG_NLS_ISO8859_15 is not set
+ # CONFIG_NLS_KOI8_R is not set
+ # CONFIG_NLS_KOI8_U is not set
+ # CONFIG_NLS_UTF8 is not set
+ # CONFIG_DLM is not set
+ 
+ #
+ # Kernel hacking
+ #
+ # CONFIG_PRINTK_TIME is not set
+ CONFIG_ENABLE_WARN_DEPRECATED=y
+ CONFIG_ENABLE_MUST_CHECK=y
+ CONFIG_FRAME_WARN=1024
+ # CONFIG_MAGIC_SYSRQ is not set
+ # CONFIG_UNUSED_SYMBOLS is not set
+ # CONFIG_DEBUG_FS is not set
+ # CONFIG_HEADERS_CHECK is not set
+ CONFIG_DEBUG_KERNEL=y
+ # CONFIG_DEBUG_SHIRQ is not set
+ CONFIG_DETECT_SOFTLOCKUP=y
+ # CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+ CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+ CONFIG_SCHED_DEBUG=y
+ # CONFIG_SCHEDSTATS is not set
+ # CONFIG_TIMER_STATS is not set
+ # CONFIG_DEBUG_OBJECTS is not set
+ # CONFIG_DEBUG_SLAB is not set
+ CONFIG_DEBUG_PREEMPT=y
+ # CONFIG_DEBUG_RT_MUTEXES is not set
+ # CONFIG_RT_MUTEX_TESTER is not set
+ # CONFIG_DEBUG_SPINLOCK is not set
+ CONFIG_DEBUG_MUTEXES=y
+ # CONFIG_DEBUG_LOCK_ALLOC is not set
+ # CONFIG_PROVE_LOCKING is not set
+ # CONFIG_LOCK_STAT is not set
+ # CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+ # CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+ # CONFIG_DEBUG_KOBJECT is not set
+ # CONFIG_DEBUG_BUGVERBOSE is not set
+ # CONFIG_DEBUG_INFO is not set
+ # CONFIG_DEBUG_VM is not set
+ # CONFIG_DEBUG_WRITECOUNT is not set
+ # CONFIG_DEBUG_MEMORY_INIT is not set
+ # CONFIG_DEBUG_LIST is not set
+ # CONFIG_DEBUG_SG is not set
+ # CONFIG_DEBUG_NOTIFIERS is not set
+ CONFIG_FRAME_POINTER=y
+ # CONFIG_BOOT_PRINTK_DELAY is not set
+ # CONFIG_RCU_TORTURE_TEST is not set
+ # CONFIG_BACKTRACE_SELF_TEST is not set
+ # CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+ # CONFIG_FAULT_INJECTION is not set
+ # CONFIG_LATENCYTOP is not set
+ # CONFIG_SYSCTL_SYSCALL_CHECK is not set
+ CONFIG_HAVE_FUNCTION_TRACER=y
+ 
+ #
+ # Tracers
+ #
+ # CONFIG_FUNCTION_TRACER is not set
+ # CONFIG_IRQSOFF_TRACER is not set
+ # CONFIG_PREEMPT_TRACER is not set
+ # CONFIG_SCHED_TRACER is not set
+ # CONFIG_CONTEXT_SWITCH_TRACER is not set
+ # CONFIG_BOOT_TRACER is not set
+ # CONFIG_TRACE_BRANCH_PROFILING is not set
+ # CONFIG_STACK_TRACER is not set
+ # CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+ # CONFIG_SAMPLES is not set
+ CONFIG_HAVE_ARCH_KGDB=y
+ # CONFIG_KGDB is not set
+ # CONFIG_DEBUG_USER is not set
+ # CONFIG_DEBUG_ERRORS is not set
+ # CONFIG_DEBUG_STACK_USAGE is not set
+ CONFIG_DEBUG_LL=y
+ # CONFIG_DEBUG_ICEDCC is not set
+ 
+ #
+ # Security options
+ #
+ # CONFIG_KEYS is not set
+ # CONFIG_SECURITY is not set
+ # CONFIG_SECURITYFS is not set
+ # CONFIG_SECURITY_FILE_CAPABILITIES is not set
+ CONFIG_CRYPTO=y
+ 
+ #
+ # Crypto core or helper
+ #
+ # CONFIG_CRYPTO_FIPS is not set
+ CONFIG_CRYPTO_ALGAPI=y
+ CONFIG_CRYPTO_ALGAPI2=y
+ CONFIG_CRYPTO_AEAD2=y
+ CONFIG_CRYPTO_BLKCIPHER=y
+ CONFIG_CRYPTO_BLKCIPHER2=y
+ CONFIG_CRYPTO_HASH=y
+ CONFIG_CRYPTO_HASH2=y
+ CONFIG_CRYPTO_RNG2=y
+ CONFIG_CRYPTO_MANAGER=y
+ CONFIG_CRYPTO_MANAGER2=y
+ # CONFIG_CRYPTO_GF128MUL is not set
+ # CONFIG_CRYPTO_NULL is not set
+ # CONFIG_CRYPTO_CRYPTD is not set
+ # CONFIG_CRYPTO_AUTHENC is not set
+ # CONFIG_CRYPTO_TEST is not set
+ 
+ #
+ # Authenticated Encryption with Associated Data
+ #
+ # CONFIG_CRYPTO_CCM is not set
+ # CONFIG_CRYPTO_GCM is not set
+ # CONFIG_CRYPTO_SEQIV is not set
+ 
+ #
+ # Block modes
+ #
+ # CONFIG_CRYPTO_CBC is not set
+ # CONFIG_CRYPTO_CTR is not set
+ # CONFIG_CRYPTO_CTS is not set
+ CONFIG_CRYPTO_ECB=y
+ # CONFIG_CRYPTO_LRW is not set
+ # CONFIG_CRYPTO_PCBC is not set
+ # CONFIG_CRYPTO_XTS is not set
+ 
+ #
+ # Hash modes
+ #
+ # CONFIG_CRYPTO_HMAC is not set
+ # CONFIG_CRYPTO_XCBC is not set
+ 
+ #
+ # Digest
+ #
+ CONFIG_CRYPTO_CRC32C=y
+ # CONFIG_CRYPTO_MD4 is not set
+ # CONFIG_CRYPTO_MD5 is not set
+ # CONFIG_CRYPTO_MICHAEL_MIC is not set
+ # CONFIG_CRYPTO_RMD128 is not set
+ # CONFIG_CRYPTO_RMD160 is not set
+ # CONFIG_CRYPTO_RMD256 is not set
+ # CONFIG_CRYPTO_RMD320 is not set
+ CONFIG_CRYPTO_SHA1=y
+ # CONFIG_CRYPTO_SHA256 is not set
+ # CONFIG_CRYPTO_SHA512 is not set
+ # CONFIG_CRYPTO_TGR192 is not set
+ # CONFIG_CRYPTO_WP512 is not set
+ 
+ #
+ # Ciphers
+ #
+ CONFIG_CRYPTO_AES=y
+ # CONFIG_CRYPTO_ANUBIS is not set
+ CONFIG_CRYPTO_ARC4=y
+ # CONFIG_CRYPTO_BLOWFISH is not set
+ # CONFIG_CRYPTO_CAMELLIA is not set
+ # CONFIG_CRYPTO_CAST5 is not set
+ # CONFIG_CRYPTO_CAST6 is not set
+ # CONFIG_CRYPTO_DES is not set
+ # CONFIG_CRYPTO_FCRYPT is not set
+ # CONFIG_CRYPTO_KHAZAD is not set
+ # CONFIG_CRYPTO_SALSA20 is not set
+ # CONFIG_CRYPTO_SEED is not set
+ # CONFIG_CRYPTO_SERPENT is not set
+ # CONFIG_CRYPTO_TEA is not set
+ # CONFIG_CRYPTO_TWOFISH is not set
+ 
+ #
+ # Compression
+ #
+ # CONFIG_CRYPTO_DEFLATE is not set
+ # CONFIG_CRYPTO_LZO is not set
+ 
+ #
+ # Random Number Generation
+ #
+ # CONFIG_CRYPTO_ANSI_CPRNG is not set
+ CONFIG_CRYPTO_HW=y
+ 
+ #
+ # Library routines
+ #
+ CONFIG_BITREVERSE=y
+ CONFIG_GENERIC_FIND_LAST_BIT=y
+ CONFIG_CRC_CCITT=y
+ CONFIG_CRC16=y
+ # CONFIG_CRC_T10DIF is not set
+ CONFIG_CRC_ITU_T=y
+ CONFIG_CRC32=y
+ # CONFIG_CRC7 is not set
+ CONFIG_LIBCRC32C=y
+ CONFIG_ZLIB_INFLATE=y
+ CONFIG_ZLIB_DEFLATE=y
+ CONFIG_PLIST=y
+ CONFIG_HAS_IOMEM=y
+ CONFIG_HAS_IOPORT=y
+ CONFIG_HAS_DMA=y
diff -r -C3 -P linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.alias liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.alias
*** linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.alias	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.alias	2012-01-20 14:49:01.709306555 +0100
***************
*** 0 ****
--- 1,391 ----
+ # Aliases extracted from modules themselves.
+ alias usb:v*p*d*dc*dsc*dp*ic08isc06ip50* usb_storage
+ alias usb:v*p*d*dc*dsc*dp*ic08isc05ip50* usb_storage
+ alias usb:v*p*d*dc*dsc*dp*ic08isc04ip50* usb_storage
+ alias usb:v*p*d*dc*dsc*dp*ic08isc03ip50* usb_storage
+ alias usb:v*p*d*dc*dsc*dp*ic08isc02ip50* usb_storage
+ alias usb:v*p*d*dc*dsc*dp*ic08isc01ip50* usb_storage
+ alias usb:v*p*d*dc*dsc*dp*ic08isc06ip00* usb_storage
+ alias usb:v*p*d*dc*dsc*dp*ic08isc05ip00* usb_storage
+ alias usb:v*p*d*dc*dsc*dp*ic08isc04ip00* usb_storage
+ alias usb:v*p*d*dc*dsc*dp*ic08isc03ip00* usb_storage
+ alias usb:v*p*d*dc*dsc*dp*ic08isc02ip00* usb_storage
+ alias usb:v*p*d*dc*dsc*dp*ic08isc01ip00* usb_storage
+ alias usb:v*p*d*dc*dsc*dp*ic08isc06ip01* usb_storage
+ alias usb:v*p*d*dc*dsc*dp*ic08isc05ip01* usb_storage
+ alias usb:v*p*d*dc*dsc*dp*ic08isc04ip01* usb_storage
+ alias usb:v*p*d*dc*dsc*dp*ic08isc03ip01* usb_storage
+ alias usb:v*p*d*dc*dsc*dp*ic08isc02ip01* usb_storage
+ alias usb:v*p*d*dc*dsc*dp*ic08isc01ip01* usb_storage
+ alias usb:vED10p7636d0001dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:vED06p4500d0001dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v4146pBA01d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v4102p1020d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v3340pFFFFd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v2770p915Dd0010dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v2735p100Bd*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v22B8p6426d0101dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v22B8p3010d0001dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v2116p0320d0001dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v1652p6600d0201dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v152Dp2329d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v14CDp6600d0201dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v1370p6828d0110dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v132Bp000Bd0001dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p143Fd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p143Ed0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p143Dd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p143Cd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p143Bd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p143Ad0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1439d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1438d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1437d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1436d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1435d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1434d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1433d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1432d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1431d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1430d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p142Fd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p142Ed0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p142Dd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p142Cd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p142Bd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p142Ad0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1429d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1428d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1427d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1426d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1425d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1424d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1423d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1422d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1421d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1420d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p141Fd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p141Ed0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p141Dd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p141Cd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p141Bd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p141Ad0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1419d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1418d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1417d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1416d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1415d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1414d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1413d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1412d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1411d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1410d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p140Fd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p140Ed0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p140Dd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p140Cd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p140Bd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p140Ad0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1409d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1408d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1407d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1406d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1405d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1404d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1403d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1402d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1401d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1004d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1003d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v12D1p1001d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v1210p0003d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v1199p0FFFd*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v10D6p2200d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v1058p0704d*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v1019p0C55d00*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v1019p0C55d010*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v1019p0C55d0110dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0FCEpE092d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0FCEpE031d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0FCEpE030d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0FCEpD0E1d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0FCEpD008d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0F19p0105d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0F19p0103d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0ED1p7636d0103dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0EA0p6828d0110dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0EA0p2168d0110dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0ED1p6660d0[1-2]*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0ED1p6660d0300dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0E21p0520d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0DDAp0301d0012dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0DDAp0001d0012dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0DD8pD202d*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0DD8p1060d*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0DC4p0073d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0D96p5200d01*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0D96p5200d00[1-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0D96p5200d0200dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0D96p5200d000[1-9]dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0D96p410Ad[1-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0D96p410Ad0[1-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0D96p410Ad00[1-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0D96p410Ad000[1-9]dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0C45p1060d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0D49p7310d*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0BC2p3010d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0AF0p7501d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0AF0p7401d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0AF0p6971d*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0ACEp20FFd0101dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0ACEp2011d0101dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0A17p0004d1000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v090Cp1132d*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v090Ap1200d*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v090Ap1050d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v090Ap1001d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v08CAp3103d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v08BDp1100d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0851p1543d0200dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v084Dp0011d0110dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0840p0085d0001dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0840p0084d0001dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0840p0082d0001dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0839p000Ad0001dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v07CFp1001d[1-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v07C4pA4A5d*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v07C4pA400d*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v07AFp0006d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v07AFp0005d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v07AFp0004d01[0-2]*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v07AFp0004d013[0-3]dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v07ABpFCCDd*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0781p0100d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0781p0002d0009dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0781p0001d0200dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0727p0306d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v071Bp3203d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v071Bp32BBd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v071Bp3203d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v069Bp3004d0001dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0693p0005d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0686p4017d0001dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0686p4011d0001dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v067Bp3507d00[1-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v067Bp3507d010[0-1]dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v067Bp3507d000[1-9]dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v067Bp2507d00[1-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v067Bp2507d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v067Bp2507d000[1-9]dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v066Fp8000d0001dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0644p0000d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0636p0003d*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v05E3p0723d9451dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v05E3p0702d*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v05E3p0701d*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v05DCpB002d00*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v05DCpB002d010*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v05DCpB002d011[0-3]dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v05C6p1000d*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v05ACp120Ad*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v05ACp1205d*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v05ACp1204d*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v05ACp1203d*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v05ACp1202d*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v05ABp0060d1110dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v05ABp0060d110[4-9]dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v059Fp0643d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v059Bp0001d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0595p4343d[0-1]*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0595p4343d2[0-1]*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0595p4343d220*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0595p4343d2210dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v058Fp6387d0141dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v057Bp0022d*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v057Bp0000d[1-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v057Bp0000d0[3-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v057Bp0000d0[0-2]*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v055Dp2020d0[0-1]*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v055Dp2020d020*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v055Dp2020d0210dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v054Cp016Ad*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v054Cp0099d*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v054Cp006Dd*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v054Cp0069d*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v054Cp0058d*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v054Cp0032d*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v054Cp002Ed0500dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v054Cp002Ed02*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v054Cp002Ed030*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v054Cp002Ed01[1-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v054Cp002Ed0310dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v054Cp002Ed010[6-9]dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v054Cp002Dd0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v054Cp002Cd1*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v054Cp002Cd0[6-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v054Cp002Cd05[1-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v054Cp002Cd2000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v054Cp002Cd050[1-9]dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v054Cp0025d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v054Cp0010d05*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v054Cp0010d060*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v054Cp0010d0610dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v054Cp0010d0[2-3]*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v054Cp0010d04[0-4]*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v054Cp0010d01[1-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v054Cp0010d0450dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v054Cp0010d010[6-9]dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v052Bp1911d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v052Bp1905d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v052Bp1807d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v052Bp1804d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v052Bp1801d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0525pA4A5d*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0525pA140d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v050Dp0115d0133dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v04FCp80C2d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v04E8p507Cd0220dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v04E6p0101d0200dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v04E6p000Cd0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v04E6p000Bd0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v04E6p000Ad0200dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v04E6p0009d0200dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v04E6p0007d01*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v04E6p0007d0200dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v04E6p0006d0205dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v04E6p0006d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v04E6p0005d01*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v04E6p0005d020[0-8]dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v04E6p0002d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v04E6p0001d0200dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v04DAp2373d*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v04DAp2372d*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v04DAp0D05d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v04DAp0901d01*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v04DAp0901d0200dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v04CEp0002d0074dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v04CBp0100d[0-1]*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v04CBp0100d2[0-1]*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v04CBp0100d220*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v04CBp0100d2210dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v04B8p0602d0110dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v04B8p0601d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v04B3p4001d0110dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v04B0p0301d0010dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v04A5p3010d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v04A4p0004d0001dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0482p0107d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0482p0103d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0482p0101d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0482p0100d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v046BpFF40d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v045EpFFFFd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0457p0151d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0457p0150d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0451p5416d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0436p0005d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0424p0FDCd0210dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0421p0495d0370dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0421p0492d[1-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0421p0492d0[5-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0421p0492d04[6-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0421p0492d045[2-9]dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0421p047Cd0[4-5]*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0421p047Cd060*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0421p047Cd03[7-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0421p047Cd0610dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0421p044Ed0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0421p0446d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0421p0444d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0421p0434d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0421p0433d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0421p042Ed0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0421p0019d0592dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0420p0001d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0419pAAF6d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0419pAAF5d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0419pAACEd0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0419p0100d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0411p001Cd0113dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v040Dp6205d0003dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v0409p0040d*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v03F0p4002d0001dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v03F0p070Cd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v03F0p0107d0200dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v03EEp6906d0003dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v03EEp6901d0[0-1]*dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v03EEp6901d0200dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v03EBp2002d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ alias usb:v03F0p3524d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v5372p2303d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v05ADp0FBAd*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v07AAp002Ad*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v11F6p2001d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v058Fp9720d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v050Dp0257d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v0731p2003d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v0E55p110Bd*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v0413p2101d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v079Bp0027d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v10B5pAC70d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v078Bp1234d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v0745p0001d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v11F5p0005d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v11F5p0004d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v11F5p0003d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v11F5p0001d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v04E8p8001d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v11F7p02DFd*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v6189p2068d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v0731p0528d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v1453p4026d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v2478p2008d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v0584pB000d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v0DF7p0620d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v0EBAp2080d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v0EBAp1080d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v056Ep5004d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v056Ep5003d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v0547p2008d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v0557p2008d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v04BBp0A0Ed*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v04BBp0A03d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v067Bp0609d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v067Bp0612d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v067Bp0611d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v067BpAAA0d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v067BpAAA2d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v067Bp1234d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v067Bp04BBd*dc*dsc*dp*ic*isc*ip* pl2303
+ alias usb:v067Bp2303d*dc*dsc*dp*ic*isc*ip* pl2303
+ alias scsi:t-0x0e* sd_mod
+ alias scsi:t-0x07* sd_mod
+ alias scsi:t-0x00* sd_mod
+ alias block-major-135-* sd_mod
+ alias block-major-134-* sd_mod
+ alias block-major-133-* sd_mod
+ alias block-major-132-* sd_mod
+ alias block-major-131-* sd_mod
+ alias block-major-130-* sd_mod
+ alias block-major-129-* sd_mod
+ alias block-major-128-* sd_mod
+ alias block-major-71-* sd_mod
+ alias block-major-70-* sd_mod
+ alias block-major-69-* sd_mod
+ alias block-major-68-* sd_mod
+ alias block-major-67-* sd_mod
+ alias block-major-66-* sd_mod
+ alias block-major-65-* sd_mod
+ alias block-major-8-* sd_mod
+ alias nfct-helper-ftp nf_conntrack_ftp
+ alias ip_conntrack_ftp nf_conntrack_ftp
+ alias ip6t_tcp xt_tcpudp
+ alias ip6t_udp xt_tcpudp
+ alias ipt_tcp xt_tcpudp
+ alias ipt_udp xt_tcpudp
+ alias xt_udp xt_tcpudp
+ alias xt_tcp xt_tcpudp
+ alias ip6t_conntrack xt_conntrack
+ alias ipt_conntrack xt_conntrack
+ alias ip6t_state xt_state
+ alias ipt_state xt_state
diff -r -C3 -P linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.ccwmap liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.ccwmap
*** linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.ccwmap	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.ccwmap	2012-01-20 14:49:01.709306555 +0100
***************
*** 0 ****
--- 1 ----
+ # ccw module         match_flags cu_type cu_model dev_type dev_model
diff -r -C3 -P linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.dep liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.dep
*** linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.dep	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.dep	2012-01-20 14:49:01.709306555 +0100
***************
*** 0 ****
--- 1,17 ----
+ kernel/drivers/base/firmware_class.ko:
+ kernel/drivers/usb/storage/usb-storage.ko: kernel/drivers/scsi/scsi_mod.ko
+ kernel/drivers/usb/serial/usbserial.ko:
+ kernel/drivers/usb/serial/pl2303.ko: kernel/drivers/usb/serial/usbserial.ko
+ kernel/drivers/hid/hid-dummy.ko:
+ kernel/drivers/connector/cn.ko:
+ kernel/drivers/scsi/scsi_mod.ko:
+ kernel/drivers/scsi/sd_mod.ko: kernel/drivers/scsi/scsi_mod.ko
+ kernel/drivers/scsi/scsi_wait_scan.ko: kernel/drivers/scsi/scsi_mod.ko
+ kernel/net/netfilter/nf_conntrack.ko:
+ kernel/net/netfilter/nf_conntrack_ftp.ko: kernel/net/netfilter/nf_conntrack.ko
+ kernel/net/netfilter/x_tables.ko:
+ kernel/net/netfilter/xt_tcpudp.ko: kernel/net/netfilter/x_tables.ko
+ kernel/net/netfilter/xt_conntrack.ko: kernel/net/netfilter/nf_conntrack.ko kernel/net/netfilter/x_tables.ko
+ kernel/net/netfilter/xt_state.ko: kernel/net/netfilter/nf_conntrack.ko kernel/net/netfilter/x_tables.ko
+ kernel/net/ipv4/netfilter/ip_tables.ko: kernel/net/netfilter/x_tables.ko
+ kernel/net/ipv4/netfilter/iptable_filter.ko: kernel/net/ipv4/netfilter/ip_tables.ko kernel/net/netfilter/x_tables.ko
diff -r -C3 -P linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.ieee1394map liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.ieee1394map
*** linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.ieee1394map	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.ieee1394map	2012-01-20 14:49:01.709306555 +0100
***************
*** 0 ****
--- 1 ----
+ # ieee1394 module    match_flags vendor_id model_id specifier_id version
diff -r -C3 -P linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.inputmap liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.inputmap
*** linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.inputmap	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.inputmap	2012-01-20 14:49:01.709306555 +0100
***************
*** 0 ****
--- 1 ----
+ # module         matchBits bustype vendor product version evBits keyBits relBits absBits mscBits ledBits sndBits ffBits [swBits] driver_info
diff -r -C3 -P linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.isapnpmap liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.isapnpmap
*** linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.isapnpmap	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.isapnpmap	2012-01-20 14:49:01.709306555 +0100
***************
*** 0 ****
--- 1 ----
+ # isapnp module      cardvendor carddevice driver_data vendor     function   ...
diff -r -C3 -P linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.ofmap liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.ofmap
*** linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.ofmap	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.ofmap	2012-01-20 14:49:01.709306555 +0100
***************
*** 0 ****
--- 1 ----
+ # of module          name                 type                 compatible
diff -r -C3 -P linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.pcimap liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.pcimap
*** linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.pcimap	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.pcimap	2012-01-20 14:49:01.709306555 +0100
***************
*** 0 ****
--- 1 ----
+ # pci module         vendor     device     subvendor  subdevice  class      class_mask driver_data
diff -r -C3 -P linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.seriomap liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.seriomap
*** linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.seriomap	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.seriomap	2012-01-20 14:49:01.709306555 +0100
***************
*** 0 ****
--- 1 ----
+ # serio module       type extra id   proto
diff -r -C3 -P linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.symbols liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.symbols
*** linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.symbols	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.symbols	2012-01-20 14:49:01.709306555 +0100
***************
*** 0 ****
--- 1,233 ----
+ # Aliases for symbols, used by symbol_request().
+ alias symbol:scsi_sense_key_string scsi_mod
+ alias symbol:request_firmware firmware_class
+ alias symbol:scsi_execute scsi_mod
+ alias symbol:usb_serial_generic_write_bulk_callback usbserial
+ alias symbol:scsi_get_command scsi_mod
+ alias symbol:scsi_target_quiesce scsi_mod
+ alias symbol:nf_conntrack_l4proto_tcp4 nf_conntrack
+ alias symbol:xt_proto_fini x_tables
+ alias symbol:scsi_normalize_sense scsi_mod
+ alias symbol:cn_del_callback cn
+ alias symbol:nf_ct_l4proto_put nf_conntrack
+ alias symbol:nf_ct_l3proto_put nf_conntrack
+ alias symbol:scsicam_bios_param scsi_mod
+ alias symbol:scsi_reset_provider scsi_mod
+ alias symbol:scsi_extd_sense_format scsi_mod
+ alias symbol:nfnetlink_parse_nat_setup_hook nf_conntrack
+ alias symbol:scsi_flush_work scsi_mod
+ alias symbol:scsi_host_get scsi_mod
+ alias symbol:__nf_conntrack_confirm nf_conntrack
+ alias symbol:scsi_device_set_state scsi_mod
+ alias symbol:__scsi_device_lookup_by_target scsi_mod
+ alias symbol:nf_ct_unlink_expect nf_conntrack
+ alias symbol:usb_serial_register usbserial
+ alias symbol:nf_ct_invert_tuple nf_conntrack
+ alias symbol:nf_ct_l3proto_module_put nf_conntrack
+ alias symbol:xt_register_table x_tables
+ alias symbol:scsi_device_lookup_by_target scsi_mod
+ alias symbol:scsi_scan_target scsi_mod
+ alias symbol:scsi_setup_blk_pc_cmnd scsi_mod
+ alias symbol:sdev_evt_send scsi_mod
+ alias symbol:nf_ct_l3protos nf_conntrack
+ alias symbol:scsi_init_io scsi_mod
+ alias symbol:scsi_logging_level scsi_mod
+ alias symbol:scsi_rescan_device scsi_mod
+ alias symbol:scsi_device_quiesce scsi_mod
+ alias symbol:nf_ct_invert_tuplepr nf_conntrack
+ alias symbol:scsi_is_sdev_device scsi_mod
+ alias symbol:scsi_block_requests scsi_mod
+ alias symbol:print_tuple nf_conntrack
+ alias symbol:scsi_eh_restore_cmnd scsi_mod
+ alias symbol:__scsi_device_lookup scsi_mod
+ alias symbol:nf_ct_expect_init nf_conntrack
+ alias symbol:nf_conntrack_alter_reply nf_conntrack
+ alias symbol:request_firmware_nowait firmware_class
+ alias symbol:scsi_mode_sense scsi_mod
+ alias symbol:scsi_show_sense_hdr scsi_mod
+ alias symbol:nf_ct_get_tuple nf_conntrack
+ alias symbol:scsi_mode_select scsi_mod
+ alias symbol:__starget_for_each_device scsi_mod
+ alias symbol:xt_check_match x_tables
+ alias symbol:nf_ct_l3proto_try_module_get nf_conntrack
+ alias symbol:xt_unregister_matches x_tables
+ alias symbol:scsi_test_unit_ready scsi_mod
+ alias symbol:usb_serial_deregister usbserial
+ alias symbol:scsi_remove_target scsi_mod
+ alias symbol:scsi_show_result scsi_mod
+ alias symbol:usb_serial_suspend usbserial
+ alias symbol:nf_conntrack_chain nf_conntrack
+ alias symbol:xt_table_unlock x_tables
+ alias symbol:scsi_ioctl scsi_mod
+ alias symbol:scsi_report_device_reset scsi_mod
+ alias symbol:scsi_print_sense scsi_mod
+ alias symbol:nf_conntrack_l4proto_tcp6 nf_conntrack
+ alias symbol:__nf_ct_ext_add nf_conntrack
+ alias symbol:scsi_unregister scsi_mod
+ alias symbol:scsi_internal_device_unblock scsi_mod
+ alias symbol:scsi_host_alloc scsi_mod
+ alias symbol:xt_proto_init x_tables
+ alias symbol:nf_conntrack_l3proto_unregister nf_conntrack
+ alias symbol:nf_conntrack_l4proto_unregister nf_conntrack
+ alias symbol:scsi_eh_flush_done_q scsi_mod
+ alias symbol:scsi_remove_host scsi_mod
+ alias symbol:scsi_is_host_device scsi_mod
+ alias symbol:scsi_prep_state_check scsi_mod
+ alias symbol:scsi_target_block scsi_mod
+ alias symbol:scsilun_to_int scsi_mod
+ alias symbol:nf_ct_expect_chain nf_conntrack
+ alias symbol:nf_ct_remove_expectations nf_conntrack
+ alias symbol:nf_conntrack_in nf_conntrack
+ alias symbol:nf_conntrack_set_hashsize nf_conntrack
+ alias symbol:xt_find_match x_tables
+ alias symbol:nf_ct_unexpect_related nf_conntrack
+ alias symbol:scsi_release_buffers scsi_mod
+ alias symbol:scsi_scan_host scsi_mod
+ alias symbol:scsi_setup_fs_cmnd scsi_mod
+ alias symbol:scsi_track_queue_full scsi_mod
+ alias symbol:scsi_set_medium_removal scsi_mod
+ alias symbol:scsi_device_get scsi_mod
+ alias symbol:scsi_device_put scsi_mod
+ alias symbol:sdev_evt_alloc scsi_mod
+ alias symbol:nf_ct_expect_put nf_conntrack
+ alias symbol:xt_replace_table x_tables
+ alias symbol:nf_conntrack_lock nf_conntrack
+ alias symbol:cn_add_callback cn
+ alias symbol:xt_find_table_lock x_tables
+ alias symbol:xt_unregister_table x_tables
+ alias symbol:scsi_adjust_queue_depth scsi_mod
+ alias symbol:usb_serial_generic_read_bulk_callback usbserial
+ alias symbol:nf_ct_get_tuplepr nf_conntrack
+ alias symbol:nf_conntrack_find_get nf_conntrack
+ alias symbol:scsi_remove_device scsi_mod
+ alias symbol:scsi_free_host_dev scsi_mod
+ alias symbol:scsi_complete_async_scans scsi_mod
+ alias symbol:ipt_unregister_table ip_tables
+ alias symbol:xt_unregister_target x_tables
+ alias symbol:nf_conntrack_unregister_notifier nf_conntrack
+ alias symbol:nf_nat_ftp_hook nf_conntrack_ftp
+ alias symbol:scsi_dma_map scsi_mod
+ alias symbol:scsi_unblock_requests scsi_mod
+ alias symbol:nf_ct_deliver_cached_events nf_conntrack
+ alias symbol:nf_ct_expect_find_get nf_conntrack
+ alias symbol:xt_find_revision x_tables
+ alias symbol:nf_conntrack_flush nf_conntrack
+ alias symbol:nf_conntrack_l3proto_generic nf_conntrack
+ alias symbol:scsi_prep_return scsi_mod
+ alias symbol:scsi_print_command scsi_mod
+ alias symbol:nf_ct_expect_unregister_notifier nf_conntrack
+ alias symbol:__scsi_print_command scsi_mod
+ alias symbol:__scsi_get_command scsi_mod
+ alias symbol:__scsi_put_command scsi_mod
+ alias symbol:xt_check_target x_tables
+ alias symbol:__nf_ct_try_assign_helper nf_conntrack
+ alias symbol:scsi_command_normalize_sense scsi_mod
+ alias symbol:seq_print_acct nf_conntrack
+ alias symbol:ipt_register_table ip_tables
+ alias symbol:nf_conntrack_hash_insert nf_conntrack
+ alias symbol:nf_conntrack_helper_register nf_conntrack
+ alias symbol:usb_serial_probe usbserial
+ alias symbol:nf_conntrack_l4proto_udp4 nf_conntrack
+ alias symbol:nf_conntrack_free nf_conntrack
+ alias symbol:scsi_queue_work scsi_mod
+ alias symbol:nf_ct_expect_related nf_conntrack
+ alias symbol:nf_ct_l4proto_find_get nf_conntrack
+ alias symbol:nf_ct_l3proto_find_get nf_conntrack
+ alias symbol:usb_serial_port_softint usbserial
+ alias symbol:xt_request_find_target x_tables
+ alias symbol:scsi_bus_type scsi_mod
+ alias symbol:xt_free_table_info x_tables
+ alias symbol:cn_netlink_send cn
+ alias symbol:nf_ct_extend_register nf_conntrack
+ alias symbol:scsi_report_bus_reset scsi_mod
+ alias symbol:__nf_ct_kill_acct nf_conntrack
+ alias symbol:scsi_bios_ptable scsi_mod
+ alias symbol:xt_alloc_table_info x_tables
+ alias symbol:scsi_execute_req scsi_mod
+ alias symbol:scsi_add_host scsi_mod
+ alias symbol:scsi_schedule_eh scsi_mod
+ alias symbol:scsi_print_sense_hdr scsi_mod
+ alias symbol:scsi_host_lookup scsi_mod
+ alias symbol:nf_conntrack_max nf_conntrack
+ alias symbol:scsi_device_lookup scsi_mod
+ alias symbol:scsi_get_host_dev scsi_mod
+ alias symbol:scsi_add_device scsi_mod
+ alias symbol:scsi_kmap_atomic_sg scsi_mod
+ alias symbol:starget_for_each_device scsi_mod
+ alias symbol:scsi_allocate_command scsi_mod
+ alias symbol:scsi_get_sense_info_fld scsi_mod
+ alias symbol:scsi_kunmap_atomic_sg scsi_mod
+ alias symbol:scsi_block_when_processing_errors scsi_mod
+ alias symbol:scsi_register_interface scsi_mod
+ alias symbol:__nf_conntrack_helper_find_byname nf_conntrack
+ alias symbol:release_firmware firmware_class
+ alias symbol:scsi_register scsi_mod
+ alias symbol:nf_ct_extend_unregister nf_conntrack
+ alias symbol:xt_unregister_targets x_tables
+ alias symbol:nf_ct_expect_hsize nf_conntrack
+ alias symbol:nf_ct_alloc_hashtable nf_conntrack
+ alias symbol:scsi_eh_finish_cmd scsi_mod
+ alias symbol:__scsi_add_device scsi_mod
+ alias symbol:__scsi_print_sense scsi_mod
+ alias symbol:nf_conntrack_l4proto_udp6 nf_conntrack
+ alias symbol:nf_conntrack_l3proto_register nf_conntrack
+ alias symbol:nf_conntrack_l4proto_register nf_conntrack
+ alias symbol:usb_serial_resume usbserial
+ alias symbol:nf_ct_iterate_cleanup nf_conntrack
+ alias symbol:scsi_print_result scsi_mod
+ alias symbol:nf_ct_free_hashtable nf_conntrack
+ alias symbol:int_to_scsilun scsi_mod
+ alias symbol:__scsi_alloc_queue scsi_mod
+ alias symbol:scsi_finish_command scsi_mod
+ alias symbol:usb_serial_generic_open usbserial
+ alias symbol:__nf_ct_l4proto_find nf_conntrack
+ alias symbol:scsi_device_type scsi_mod
+ alias symbol:__nf_ct_event_cache_init nf_conntrack
+ alias symbol:scsi_dma_unmap scsi_mod
+ alias symbol:nf_conntrack_register_notifier nf_conntrack
+ alias symbol:need_conntrack nf_conntrack
+ alias symbol:scsi_nonblockable_ioctl scsi_mod
+ alias symbol:scsi_partsize scsi_mod
+ alias symbol:scsi_host_put scsi_mod
+ alias symbol:scsi_eh_get_sense scsi_mod
+ alias symbol:xt_register_match x_tables
+ alias symbol:scsi_cmd_print_sense_hdr scsi_mod
+ alias symbol:scsi_eh_ready_devs scsi_mod
+ alias symbol:__nf_ct_ext_destroy nf_conntrack
+ alias symbol:scsi_is_target_device scsi_mod
+ alias symbol:scsi_internal_device_block scsi_mod
+ alias symbol:__nf_ct_refresh_acct nf_conntrack
+ alias symbol:scsi_target_resume scsi_mod
+ alias symbol:nf_ct_expect_register_notifier nf_conntrack
+ alias symbol:nf_conntrack_untracked nf_conntrack
+ alias symbol:scsi_target_unblock scsi_mod
+ alias symbol:xt_unregister_match x_tables
+ alias symbol:__nf_conntrack_find nf_conntrack
+ alias symbol:scsi_free_command scsi_mod
+ alias symbol:scsi_execute_async scsi_mod
+ alias symbol:nf_ct_helper_ext_add nf_conntrack
+ alias symbol:nf_conntrack_helper_unregister nf_conntrack
+ alias symbol:scsi_print_status scsi_mod
+ alias symbol:scsi_put_command scsi_mod
+ alias symbol:sdev_evt_send_simple scsi_mod
+ alias symbol:nf_conntrack_tuple_taken nf_conntrack
+ alias symbol:scsi_build_sense_buffer scsi_mod
+ alias symbol:xt_register_matches x_tables
+ alias symbol:nf_ct_expect_related_report nf_conntrack
+ alias symbol:nf_conntrack_alloc nf_conntrack
+ alias symbol:__scsi_iterate_devices scsi_mod
+ alias symbol:scsi_sense_desc_find scsi_mod
+ alias symbol:nf_conntrack_htable_size nf_conntrack
+ alias symbol:scsi_show_extd_sense scsi_mod
+ alias symbol:xt_register_target x_tables
+ alias symbol:nf_ct_expect_alloc nf_conntrack
+ alias symbol:__nf_ct_expect_find nf_conntrack
+ alias symbol:scsi_device_resume scsi_mod
+ alias symbol:ipt_do_table ip_tables
+ alias symbol:scsi_calculate_bounce_limit scsi_mod
+ alias symbol:xt_find_target x_tables
+ alias symbol:usb_serial_disconnect usbserial
+ alias symbol:scsi_eh_prep_cmnd scsi_mod
+ alias symbol:xt_register_targets x_tables
+ alias symbol:scsi_register_driver scsi_mod
+ alias symbol:scsi_host_set_state scsi_mod
diff -r -C3 -P linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.usbmap liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.usbmap
*** linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.usbmap	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.usbmap	2012-01-20 14:49:01.709306555 +0100
***************
*** 0 ****
--- 1,310 ----
+ # usb module         match_flags idVendor idProduct bcdDevice_lo bcdDevice_hi bDeviceClass bDeviceSubClass bDeviceProtocol bInterfaceClass bInterfaceSubClass bInterfaceProtocol driver_info
+ usb-storage          0x000f      0x03eb   0x2002    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x03ee   0x6901    0x0000       0x0200       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x03ee   0x6906    0x0003       0x0003       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x03f0   0x0107    0x0200       0x0200       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x03f0   0x070c    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x03f0   0x4002    0x0001       0x0001       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0409   0x0040    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x040d   0x6205    0x0003       0x0003       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0411   0x001c    0x0113       0x0113       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0419   0x0100    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0419   0xaace    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0419   0xaaf5    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0419   0xaaf6    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0420   0x0001    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0421   0x0019    0x0592       0x0592       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0421   0x042e    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0421   0x0433    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0421   0x0434    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0421   0x0444    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0421   0x0446    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0421   0x044e    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0421   0x047c    0x0370       0x0610       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0421   0x0492    0x0452       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0421   0x0495    0x0370       0x0370       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0424   0x0fdc    0x0210       0x0210       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0436   0x0005    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0451   0x5416    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0457   0x0150    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0457   0x0151    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x045e   0xffff    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x046b   0xff40    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0482   0x0100    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0482   0x0101    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0482   0x0103    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0482   0x0107    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x04a4   0x0004    0x0001       0x0001       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x04a5   0x3010    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x04b0   0x0301    0x0010       0x0010       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x04b3   0x4001    0x0110       0x0110       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x04b8   0x0601    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x04b8   0x0602    0x0110       0x0110       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x04cb   0x0100    0x0000       0x2210       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x04ce   0x0002    0x0074       0x0074       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x04da   0x0901    0x0100       0x0200       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x04da   0x0d05    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x04da   0x2372    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x04da   0x2373    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x04e6   0x0001    0x0200       0x0200       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x04e6   0x0002    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x04e6   0x0005    0x0100       0x0208       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x04e6   0x0006    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x04e6   0x0006    0x0205       0x0205       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x04e6   0x0007    0x0100       0x0200       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x04e6   0x0009    0x0200       0x0200       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x04e6   0x000a    0x0200       0x0200       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x04e6   0x000b    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x04e6   0x000c    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x04e6   0x0101    0x0200       0x0200       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x04e8   0x507c    0x0220       0x0220       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x04fc   0x80c2    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x050d   0x0115    0x0133       0x0133       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0525   0xa140    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0525   0xa4a5    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x052b   0x1801    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x052b   0x1804    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x052b   0x1807    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x052b   0x1905    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x052b   0x1911    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x054c   0x0010    0x0106       0x0450       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x054c   0x0010    0x0500       0x0610       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x054c   0x0025    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x054c   0x002c    0x0501       0x2000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x054c   0x002d    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x054c   0x002e    0x0106       0x0310       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x054c   0x002e    0x0500       0x0500       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x054c   0x0032    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x054c   0x0058    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x054c   0x0069    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x054c   0x006d    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x054c   0x0099    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x054c   0x016a    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x055d   0x2020    0x0000       0x0210       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x057b   0x0000    0x0000       0x0299       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x057b   0x0000    0x0300       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x057b   0x0022    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x058f   0x6387    0x0141       0x0141       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0595   0x4343    0x0000       0x2210       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x059b   0x0001    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x059f   0x0643    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x05ab   0x0060    0x1104       0x1110       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x05ac   0x1202    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x05ac   0x1203    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x05ac   0x1204    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x05ac   0x1205    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x05ac   0x120a    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x05c6   0x1000    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x05dc   0xb002    0x0000       0x0113       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x05e3   0x0701    0x0000       0xffff       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x05e3   0x0702    0x0000       0xffff       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x05e3   0x0723    0x9451       0x9451       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0636   0x0003    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0644   0x0000    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x066f   0x8000    0x0001       0x0001       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x067b   0x2507    0x0001       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x067b   0x3507    0x0001       0x0101       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0686   0x4011    0x0001       0x0001       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0686   0x4017    0x0001       0x0001       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0693   0x0005    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x069b   0x3004    0x0001       0x0001       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x071b   0x3203    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x071b   0x32bb    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x071b   0x3203    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0727   0x0306    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0781   0x0001    0x0200       0x0200       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0781   0x0002    0x0009       0x0009       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0781   0x0100    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x07ab   0xfccd    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x07af   0x0004    0x0100       0x0133       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x07af   0x0005    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x07af   0x0006    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x07c4   0xa400    0x0000       0xffff       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x07c4   0xa4a5    0x0000       0xffff       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x07cf   0x1001    0x1000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0839   0x000a    0x0001       0x0001       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0840   0x0082    0x0001       0x0001       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0840   0x0084    0x0001       0x0001       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0840   0x0085    0x0001       0x0001       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x084d   0x0011    0x0110       0x0110       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0851   0x1543    0x0200       0x0200       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x08bd   0x1100    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x08ca   0x3103    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x090a   0x1001    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x090a   0x1050    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x090a   0x1200    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x090c   0x1132    0x0000       0xffff       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0a17   0x0004    0x1000       0x1000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0ace   0x2011    0x0101       0x0101       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0ace   0x20ff    0x0101       0x0101       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0af0   0x6971    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0af0   0x7401    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0af0   0x7501    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0bc2   0x3010    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0d49   0x7310    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0c45   0x1060    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0d96   0x410a    0x0001       0xffff       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0d96   0x5200    0x0001       0x0200       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0dc4   0x0073    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0dd8   0x1060    0x0000       0xffff       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0dd8   0xd202    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0dda   0x0001    0x0012       0x0012       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0dda   0x0301    0x0012       0x0012       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0e21   0x0520    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0ed1   0x6660    0x0100       0x0300       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0ea0   0x2168    0x0110       0x0110       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0ea0   0x6828    0x0110       0x0110       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0ed1   0x7636    0x0103       0x0103       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0f19   0x0103    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0f19   0x0105    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0fce   0xd008    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0fce   0xd0e1    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0fce   0xe030    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0fce   0xe031    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x0fce   0xe092    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x1019   0x0c55    0x0000       0x0110       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x1058   0x0704    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x10d6   0x2200    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x1199   0x0fff    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x1210   0x0003    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1001    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1003    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1004    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1401    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1402    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1403    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1404    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1405    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1406    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1407    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1408    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1409    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x140a    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x140b    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x140c    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x140d    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x140e    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x140f    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1410    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1411    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1412    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1413    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1414    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1415    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1416    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1417    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1418    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1419    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x141a    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x141b    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x141c    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x141d    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x141e    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x141f    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1420    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1421    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1422    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1423    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1424    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1425    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1426    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1427    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1428    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1429    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x142a    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x142b    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x142c    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x142d    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x142e    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x142f    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1430    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1431    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1432    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1433    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1434    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1435    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1436    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1437    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1438    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x1439    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x143a    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x143b    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x143c    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x143d    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x143e    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x12d1   0x143f    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x132b   0x000b    0x0001       0x0001       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x1370   0x6828    0x0110       0x0110       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x14cd   0x6600    0x0201       0x0201       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x152d   0x2329    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x1652   0x6600    0x0201       0x0201       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x2116   0x0320    0x0001       0x0001       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x22b8   0x3010    0x0001       0x0001       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x22b8   0x6426    0x0101       0x0101       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x2735   0x100b    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x2770   0x915d    0x0010       0x0010       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x3340   0xffff    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x4102   0x1020    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0x4146   0xba01    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0xed06   0x4500    0x0001       0x0001       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x000f      0xed10   0x7636    0x0001       0x0001       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x01               0x01               0x0
+ usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x02               0x01               0x0
+ usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x03               0x01               0x0
+ usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x04               0x01               0x0
+ usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x05               0x01               0x0
+ usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x06               0x01               0x0
+ usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x01               0x00               0x0
+ usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x02               0x00               0x0
+ usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x03               0x00               0x0
+ usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x04               0x00               0x0
+ usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x05               0x00               0x0
+ usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x06               0x00               0x0
+ usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x01               0x50               0x0
+ usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x02               0x50               0x0
+ usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x03               0x50               0x0
+ usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x04               0x50               0x0
+ usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x05               0x50               0x0
+ usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x06               0x50               0x0
+ pl2303               0x0003      0x067b   0x2303    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x067b   0x04bb    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x067b   0x1234    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x067b   0xaaa2    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x067b   0xaaa0    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x067b   0x0611    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x067b   0x0612    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x067b   0x0609    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x04bb   0x0a03    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x04bb   0x0a0e    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x0557   0x2008    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x0547   0x2008    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x056e   0x5003    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x056e   0x5004    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x0eba   0x1080    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x0eba   0x2080    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x0df7   0x0620    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x0584   0xb000    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x2478   0x2008    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x1453   0x4026    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x0731   0x0528    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x6189   0x2068    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x11f7   0x02df    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x04e8   0x8001    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x11f5   0x0001    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x11f5   0x0003    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x11f5   0x0004    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x11f5   0x0005    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x0745   0x0001    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x078b   0x1234    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x10b5   0xac70    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x079b   0x0027    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x0413   0x2101    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x0e55   0x110b    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x0731   0x2003    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x050d   0x0257    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x058f   0x9720    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x11f6   0x2001    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x07aa   0x002a    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x05ad   0x0fba    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x5372   0x2303    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ pl2303               0x0003      0x03f0   0x3524    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
diff -r -C3 -P linux-2.6.29.4/drivers/gpio/pca953x.c liab-linux-2.6.29.4/drivers/gpio/pca953x.c
*** linux-2.6.29.4/drivers/gpio/pca953x.c	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/drivers/gpio/pca953x.c	2012-01-20 14:49:35.993307005 +0100
***************
*** 201,206 ****
--- 201,208 ----
  	struct pca953x_chip *chip;
  	int ret;
  
+     printk(KERN_ERR "pca953x_probe\n");
+ 
  	pdata = client->dev.platform_data;
  	if (pdata == NULL) {
  		dev_dbg(&client->dev, "no platform data\n");
***************
*** 246,254 ****
--- 248,258 ----
  	}
  
  	i2c_set_clientdata(client, chip);
+     printk(KERN_ERR "init PCA953X base %d success\n", pdata->gpio_base);
  	return 0;
  
  out_failed:
+     printk(KERN_ERR "Failed to init PCA953X base %d\n", pdata->gpio_base);
  	kfree(chip);
  	return ret;
  }
***************
*** 291,297 ****
  
  static int __init pca953x_init(void)
  {
! 	return i2c_add_driver(&pca953x_driver);
  }
  /* register after i2c postcore initcall and before
   * subsys initcalls that may rely on these GPIOs
--- 295,301 ----
  
  static int __init pca953x_init(void)
  {
!     return i2c_add_driver(&pca953x_driver);
  }
  /* register after i2c postcore initcall and before
   * subsys initcalls that may rely on these GPIOs
diff -r -C3 -P linux-2.6.29.4/drivers/i2c/chips/pca9539.c liab-linux-2.6.29.4/drivers/i2c/chips/pca9539.c
*** linux-2.6.29.4/drivers/i2c/chips/pca9539.c	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/drivers/i2c/chips/pca9539.c	2012-01-20 14:49:42.813307094 +0100
***************
*** 15,21 ****
  #include <linux/hwmon-sysfs.h>
  
  /* Addresses to scan: none, device is not autodetected */
! static const unsigned short normal_i2c[] = { I2C_CLIENT_END };
  
  /* Insmod parameters */
  I2C_CLIENT_INSMOD_1(pca9539);
--- 15,22 ----
  #include <linux/hwmon-sysfs.h>
  
  /* Addresses to scan: none, device is not autodetected */
! //static const unsigned short normal_i2c[] = { I2C_CLIENT_END };
! static unsigned short normal_i2c[] = {0x20, 0x21, I2C_CLIENT_END};
  
  /* Insmod parameters */
  I2C_CLIENT_INSMOD_1(pca9539);
diff -r -C3 -P linux-2.6.29.4/drivers/input/keyboard/gpio_keys.c liab-linux-2.6.29.4/drivers/input/keyboard/gpio_keys.c
*** linux-2.6.29.4/drivers/input/keyboard/gpio_keys.c	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/drivers/input/keyboard/gpio_keys.c	2012-01-20 14:49:11.937306687 +0100
***************
*** 115,120 ****
--- 115,122 ----
  		setup_timer(&bdata->timer,
  			    gpio_check_button, (unsigned long)bdata);
  
+         printk(KERN_ERR "add gpio %d as input\n",  button->gpio);
+ 
  		error = gpio_request(button->gpio, button->desc ?: "gpio_keys");
  		if (error < 0) {
  			pr_err("gpio-keys: failed to request GPIO %d,"
***************
*** 157,162 ****
--- 159,166 ----
  			wakeup = 1;
  
  		input_set_capability(input, type, button->code);
+ 		/* msawh - Report an event to get things going! */
+ 		gpio_keys_report_event(bdata);
  	}
  
  	error = input_register_device(input);
diff -r -C3 -P linux-2.6.29.4/drivers/Kconfig liab-linux-2.6.29.4/drivers/Kconfig
*** linux-2.6.29.4/drivers/Kconfig	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/drivers/Kconfig	2012-01-20 14:49:42.829307094 +0100
***************
*** 88,93 ****
--- 88,95 ----
  
  source "drivers/leds/Kconfig"
  
+ source "drivers/liab/Kconfig"
+ 
  source "drivers/accessibility/Kconfig"
  
  source "drivers/infiniband/Kconfig"
***************
*** 109,112 ****
--- 111,116 ----
  source "drivers/staging/Kconfig"
  
  source "drivers/platform/Kconfig"
+ 
+ 
  endmenu
diff -r -C3 -P linux-2.6.29.4/drivers/leds/Kconfig liab-linux-2.6.29.4/drivers/leds/Kconfig
*** linux-2.6.29.4/drivers/leds/Kconfig	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/drivers/leds/Kconfig	2012-01-20 14:49:33.621306974 +0100
***************
*** 19,29 ****
  
  config LEDS_ATMEL_PWM
  	tristate "LED Support using Atmel PWM outputs"
! 	depends on LEDS_CLASS && ATMEL_PWM
  	help
  	  This option enables support for LEDs driven using outputs
  	  of the dedicated PWM controller found on newer Atmel SOCs.
  
  config LEDS_LOCOMO
  	tristate "LED Support for Locomo device"
  	depends on LEDS_CLASS && SHARP_LOCOMO
--- 19,37 ----
  
  config LEDS_ATMEL_PWM
  	tristate "LED Support using Atmel PWM outputs"
! 	depends on LEDS_CLASS && (ATMEL_PWM || AT91_PWM)
  	help
  	  This option enables support for LEDs driven using outputs
  	  of the dedicated PWM controller found on newer Atmel SOCs.
  
+ config LEDS_LIABDIN_ADDON
+ 	tristate "LED on the LIABDIN addon"
+ 	depends on LEDS_CLASS
+ 	help
+ 	  This option enables support for LEDs driven using outputs
+ 	  of the dedicated PWM controller found on newer Atmel SOCs.
+ 
+ 
  config LEDS_LOCOMO
  	tristate "LED Support for Locomo device"
  	depends on LEDS_CLASS && SHARP_LOCOMO
diff -r -C3 -P linux-2.6.29.4/drivers/leds/leds-atmel-pwm.c liab-linux-2.6.29.4/drivers/leds/leds-atmel-pwm.c
*** linux-2.6.29.4/drivers/leds/leds-atmel-pwm.c	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/drivers/leds/leds-atmel-pwm.c	2012-01-20 14:49:33.621306974 +0100
***************
*** 2,8 ****
  #include <linux/platform_device.h>
  #include <linux/leds.h>
  #include <linux/io.h>
! #include <linux/atmel_pwm.h>
  
  
  struct pwmled {
--- 2,8 ----
  #include <linux/platform_device.h>
  #include <linux/leds.h>
  #include <linux/io.h>
! #include <linux/at91_pwm.h>
  
  
  struct pwmled {
***************
*** 43,49 ****
  	pdata = pdev->dev.platform_data;
  	if (!pdata || pdata->num_leds < 1)
  		return -ENODEV;
- 
  	leds = kcalloc(pdata->num_leds, sizeof(*leds), GFP_KERNEL);
  	if (!leds)
  		return -ENOMEM;
--- 43,48 ----
***************
*** 64,69 ****
--- 63,70 ----
  		if (status < 0)
  			goto err;
  
+                 printk("%04d : %s() - pwm channel alloc ok\n",__LINE__, __FUNCTION__);
+ 
  		/*
  		 * Prescale clock by 2^x, so PWM counts in low MHz.
  		 * Start each cycle with the LED active, so increasing
***************
*** 94,99 ****
--- 95,103 ----
  			pwm_channel_free(&led->pwmc);
  			goto err;
  		}
+ 
+               printk("%04d : %s() - handover ok\n",__LINE__, __FUNCTION__);
+ 
  	}
  
  	platform_set_drvdata(pdev, leds);
diff -r -C3 -P linux-2.6.29.4/drivers/leds/leds-liabdin-addon.c liab-linux-2.6.29.4/drivers/leds/leds-liabdin-addon.c
*** linux-2.6.29.4/drivers/leds/leds-liabdin-addon.c	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/drivers/leds/leds-liabdin-addon.c	2012-01-20 14:49:33.621306974 +0100
***************
*** 0 ****
--- 1,212 ----
+ /*
+  * LEDs driver for GPIOs
+  *
+  * Copyright (C) 2007 8D Technologies inc.
+  * Raphael Assenat <raph@8d.com>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2 as
+  * published by the Free Software Foundation.
+  *
+  */
+ #include <linux/kernel.h>
+ #include <linux/init.h>
+ #include <linux/platform_device.h>
+ #include <linux/leds.h>
+ #include <linux/workqueue.h>
+ #include <linux/delay.h>
+ 
+ #include <asm/gpio.h>
+ 
+ #define NO_LED 15
+ 
+ struct liabdin_led_data {
+   struct led_classdev cdev;
+   struct work_struct work;
+   u8 level;
+   u8 pos;
+ };
+ 
+ #define STROBE 0
+ #define DATA 1
+ #define CLOCK 2
+ #define RESET 3
+ #define NO_PINS 4
+ 
+ struct addon_ctrl {
+   unsigned gpio;
+   char *name;
+   u8 level;
+ };
+ 
+ struct addon_ctrl gpio_pins[NO_PINS] = {
+   {AT91_PIN_PB2, "addon-strobe"},
+   {AT91_PIN_PD19, "addon-data"},
+   {AT91_PIN_PD20, "addon-clock"},
+   {AT91_PIN_PC12, "addon-reset"},
+ };
+ 
+ static ulong led_val=0;
+ spinlock_t lock;
+ 
+ void inline __set_strobe(int state)
+ {
+   if(state)
+     at91_set_gpio_value(gpio_pins[STROBE].gpio, 0);
+   else
+     at91_set_gpio_value(gpio_pins[STROBE].gpio, 1);
+ }
+ 
+ void inline __shift_value(int state)
+ {
+   at91_set_gpio_value(gpio_pins[CLOCK].gpio, 0);
+   if(state)
+     at91_set_gpio_value(gpio_pins[DATA].gpio, 0);
+   else
+     at91_set_gpio_value(gpio_pins[DATA].gpio, 1);
+   at91_set_gpio_value(gpio_pins[CLOCK].gpio, 1);
+ }
+ 
+ void inline __reset(void)
+ {
+   at91_set_gpio_value(gpio_pins[RESET].gpio, 0);
+   udelay(100);
+   at91_set_gpio_value(gpio_pins[RESET].gpio, 1);
+ }
+ 
+ 
+ 
+ static void addon_led_set(struct led_classdev *led_cdev,
+ 	enum led_brightness value)
+ {
+   ulong led;
+   int i;
+ 	struct liabdin_led_data *led_dat =
+ 		container_of(led_cdev, struct liabdin_led_data, cdev);
+ 
+   led = led_val;
+ 
+ 	if (value == LED_OFF)
+     led = ~(~led | (1 << (led_dat->pos > 7 ? led_dat->pos+1 : led_dat->pos) ));
+   else
+     led = led | (1 << (led_dat->pos > 7 ? led_dat->pos+1 : led_dat->pos) );
+ 
+   /* Make this uninterrruptible */
+   spin_lock_irq(&lock); 
+   /* Blank leds */
+   __set_strobe(0);
+   /* Shift out bits */
+   for(i=0; i<NO_LED+2; i++) {
+     __shift_value((~led >> i)&0x1 ? 1 : 0);
+   }
+   __set_strobe(1);
+   spin_unlock_irq(&lock); 
+ 
+   led_val = led;
+ }
+ 
+ static int liabdin_led_probe(struct platform_device *pdev)
+ {
+ 	int i, ret = 0;
+   struct liabdin_led_data *led_data;
+   struct gpio_led_platform_data *pdata = pdev->dev.platform_data;
+ 
+ 
+   if(!pdata)
+     return -EBUSY;
+ 
+   led_data = kzalloc(sizeof(struct liabdin_led_data)*pdata->num_leds, GFP_KERNEL); 
+ 	if (!led_data)
+ 		return -ENOMEM;
+ 
+   spin_lock_init(&lock);
+   
+   for(i=0; i<pdata->num_leds; i++) {
+     /* LED name */
+     led_data[i].cdev.name = pdata->leds[i].name;
+     /* Set callback */
+     led_data[i].cdev.brightness_set = addon_led_set;
+ 		led_data[i].cdev.brightness = LED_OFF;
+ 		led_data[i].cdev.flags |= LED_CORE_SUSPENDRESUME;
+     led_data[i].cdev.default_trigger = pdata->leds[i].default_trigger;
+     led_data[i].pos = i;
+     /* Add the led device */
+     ret = led_classdev_register(&pdev->dev, &led_data[i].cdev);
+ 		if (ret < 0) {
+ 			goto err_cdev;
+ 		}
+   }
+ 
+   /* Set up gpio */
+   for(i=0; i<NO_PINS; i++) {
+     ret = gpio_request(gpio_pins[i].gpio, gpio_pins[i].name);
+ 		if (ret < 0)
+ 			goto err_pins;
+     at91_set_gpio_output(gpio_pins[i].gpio, 1);
+   }
+ 
+ 	platform_set_drvdata(pdev, led_data);
+ 
+ 	return 0;
+ 
+  err_pins:
+   for(i=0; i<NO_PINS; i++) {
+     gpio_free(gpio_pins[i].gpio);
+   }
+ err_cdev:
+   for(i=0; i<pdata->num_leds; i++) {
+     led_classdev_unregister(&led_data[i].cdev);
+   }
+ 
+   kfree(led_data);
+ 
+ 	return ret;
+ }
+ 
+ static int __devexit liabdin_led_remove(struct platform_device *pdev)
+ {
+ 	int i;
+   struct liabdin_led_data *led_data;
+   struct gpio_led_platform_data *pdata = pdev->dev.platform_data;
+ 
+   led_data = platform_get_drvdata(pdev);
+ 
+   for(i=0; i<pdata->num_leds; i++) {
+     led_classdev_unregister(&led_data[i].cdev);
+   }
+ 
+   for(i=0; i<NO_PINS; i++) {
+     gpio_free(gpio_pins[i].gpio);
+   }
+ 
+   kfree(led_data);
+ 
+ 	return 0;
+ }
+ 
+ static struct platform_driver liabdin_led_driver = {
+ 	.probe		= liabdin_led_probe,
+ 	.remove		= __devexit_p(liabdin_led_remove),
+ 	.driver		= {
+ 		.name	= "leds-liabdin-addon",
+ 		.owner	= THIS_MODULE,
+ 	},
+ };
+ 
+ static int __init liabdin_led_init(void)
+ {
+ 	return platform_driver_register(&liabdin_led_driver);
+ }
+ 
+ static void __exit liabdin_led_exit(void)
+ {
+ 	platform_driver_unregister(&liabdin_led_driver);
+ }
+ 
+ module_init(liabdin_led_init);
+ module_exit(liabdin_led_exit);
+ 
+ MODULE_AUTHOR("Raphael Assenat <raph@8d.com>");
+ MODULE_DESCRIPTION("GPIO LED driver");
+ MODULE_LICENSE("GPL");
+ MODULE_ALIAS("platform:leds-gpio");
diff -r -C3 -P linux-2.6.29.4/drivers/leds/Makefile liab-linux-2.6.29.4/drivers/leds/Makefile
*** linux-2.6.29.4/drivers/leds/Makefile	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/drivers/leds/Makefile	2012-01-20 14:49:33.621306974 +0100
***************
*** 24,29 ****
--- 24,30 ----
  obj-$(CONFIG_LEDS_PCA955X)		+= leds-pca955x.o
  obj-$(CONFIG_LEDS_DA903X)		+= leds-da903x.o
  obj-$(CONFIG_LEDS_WM8350)		+= leds-wm8350.o
+ obj-$(CONFIG_LEDS_LIABDIN_ADDON)		+= leds-liabdin-addon.o
  
  # LED Triggers
  obj-$(CONFIG_LEDS_TRIGGER_TIMER)	+= ledtrig-timer.o
diff -r -C3 -P linux-2.6.29.4/drivers/liab/Kconfig liab-linux-2.6.29.4/drivers/liab/Kconfig
*** linux-2.6.29.4/drivers/liab/Kconfig	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/drivers/liab/Kconfig	2012-01-20 14:49:42.529307090 +0100
***************
*** 0 ****
--- 1,6 ----
+ menuconfig LIAB
+ 	bool "LIAB support"
+ 	help
+ 	  Say Y to enable LIAB support functions and modules. 
+ 	  This allows various LIAB units 
+ 
diff -r -C3 -P linux-2.6.29.4/drivers/liab/liab.c liab-linux-2.6.29.4/drivers/liab/liab.c
*** linux-2.6.29.4/drivers/liab/liab.c	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/drivers/liab/liab.c	2012-01-20 14:49:42.529307090 +0100
***************
*** 0 ****
--- 1,73 ----
+ #include <linux/module.h>
+ #include <linux/init.h>
+ #include <linux/slab.h>
+ #include <linux/delay.h>
+ #include <linux/device.h>
+ #include <linux/mutex.h>
+ #include <linux/jiffies.h>
+ #include <linux/timer.h>
+ #include <linux/spi/spi.h>
+ #include <linux/interrupt.h>
+ #include <linux/cdev.h>
+ #include <linux/ioctl.h>
+ #include <linux/fs.h>
+ #include <linux/poll.h>
+ #include <linux/list.h>
+ #include <linux/gpio.h>
+ 
+ #include <linux/platform_device.h>
+ #include <linux/clk.h>
+ 
+ 
+ #define PRINT_DBG(str,arg...) printk(KERN_INFO "%s: "str"\n",__FUNCTION__, ## arg)
+ 
+ 
+ static struct class *liab_class;
+ 
+ 
+ struct device *liab_device_create(struct device *parent,
+ 			     dev_t devt, void *drvdata, const char *fmt, ...)
+ {
+     va_list vargs;
+     struct device *dev;
+     va_start(vargs, fmt);
+     dev = device_create_vargs(liab_class, parent, devt, drvdata, fmt, vargs);
+     va_end(vargs);
+     return dev;
+ }
+ EXPORT_SYMBOL_GPL(liab_device_create);
+ 
+ void liab_device_unregister(struct device *dev)
+ {
+     device_unregister(dev);
+ }
+ 
+ EXPORT_SYMBOL_GPL(liab_device_unregister);
+ 
+ static int __init liab_init(void)
+ {
+     int err;
+ 
+     liab_class = class_create(THIS_MODULE, "liab");
+ 
+     err = PTR_ERR(liab_class);
+     if (IS_ERR(liab_class))
+ 	goto fail_remove;
+ 
+     return 0;
+ 
+   fail_remove:
+     return err;
+ 
+ }
+ module_init(liab_init);
+ 
+ static void __exit liab_exit(void)
+ {
+     class_destroy(liab_class);
+ }
+ module_exit(liab_exit);
+ 
+ MODULE_DESCRIPTION("The LIAB module");
+ MODULE_AUTHOR("LIAB ApS. <http://www.liab.dk>");
+ MODULE_LICENSE("GPL");
diff -r -C3 -P linux-2.6.29.4/drivers/liab/Makefile liab-linux-2.6.29.4/drivers/liab/Makefile
*** linux-2.6.29.4/drivers/liab/Makefile	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/drivers/liab/Makefile	2012-01-20 14:49:42.529307090 +0100
***************
*** 0 ****
--- 1,4 ----
+ 
+ # LED Core
+ obj-$(CONFIG_LIAB)			+= liab.o
+ 
diff -r -C3 -P linux-2.6.29.4/drivers/Makefile liab-linux-2.6.29.4/drivers/Makefile
*** linux-2.6.29.4/drivers/Makefile	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/drivers/Makefile	2012-01-20 14:49:42.829307094 +0100
***************
*** 106,108 ****
--- 106,109 ----
  obj-$(CONFIG_VIRTIO)		+= virtio/
  obj-$(CONFIG_STAGING)		+= staging/
  obj-y				+= platform/
+ obj-$(CONFIG_LIAB)		+= liab/
\ No newline at end of file
diff -r -C3 -P linux-2.6.29.4/drivers/misc/at91_pwm.c liab-linux-2.6.29.4/drivers/misc/at91_pwm.c
*** linux-2.6.29.4/drivers/misc/at91_pwm.c	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/drivers/misc/at91_pwm.c	2012-01-20 14:49:15.281306733 +0100
***************
*** 0 ****
--- 1,550 ----
+ #include <linux/module.h>
+ #include <linux/clk.h>
+ #include <linux/err.h>
+ #include <linux/io.h>
+ #include <linux/interrupt.h>
+ #include <linux/platform_device.h>
+ #include <linux/at91_pwm.h>
+ #include <mach/at91_tc.h>
+ #include <mach/gpio.h>
+ 
+ 
+ /*
+  * This is a simple driver for generating PWM signals, using the
+  * timer/counter registers on the Atmel AT91 series processors.
+  *
+  * The timers are mapped pair wise. For example, on the at91sam9260,
+  * there are TIOA0-2 TIOB0-2, i.e. 6 pins that can beused to
+  * genererate PWM output. Since they at mapped pair-wise, e.g. TIOA0
+  * and TIOB0 uses the same period time but can have individual
+  * duty-cycles.
+  *
+  * LIAB ApS 2008 (msa)
+  *
+  */
+ 
+ #define PWM_NCHAN 6
+ 
+ struct pwm {
+   spinlock_t		lock;
+   struct platform_device	*pdev;
+   u32			mask;
+   int			irq;
+   void __iomem		*base[3];
+   struct clk		*clk[3];
+   struct pwm_channel	*channel[PWM_NCHAN];
+   void			(*handler[PWM_NCHAN])(struct pwm_channel *);
+ };
+ 
+ struct pin_mapping {
+   u8     timer;
+   u32    gpio;
+   u8     flags;
+   u8     is_active_low;
+ };
+ 
+ #ifdef CONFIG_ARCH_AT91RM9200
+ static struct pin_mapping channel_map[PWM_NCHAN] = 
+   {
+     { /* TIOA0*/
+       .timer         = 0,
+       .gpio          = AT91_PIN_PA17,
+       .flags         = AT91_TC_RA,
+       .is_active_low = 1,
+     },
+     { /* TIOA1*/
+       .timer         = 1,
+       .gpio          = AT91_PIN_PA19,
+       .flags         = AT91_TC_RA,
+       .is_active_low = 1,
+     },
+     { /* TIOA2*/
+       .timer         = 2,
+       .gpio          = AT91_PIN_PA21,
+       .flags         = AT91_TC_RA,
+       .is_active_low = 1,
+     },
+     { /* TIOB0*/
+       .timer         = 0,
+       .gpio          = AT91_PIN_PA18,
+       .flags         = AT91_TC_RB,
+       .is_active_low = 1,
+     },
+     { /* TIOB1*/
+       .timer         = 1,
+       .gpio          = AT91_PIN_PA20,
+       .flags         = AT91_TC_RB,
+       .is_active_low = 1,
+     },
+     { /* TIOB2*/
+       .timer         = 2,
+       .gpio          = AT91_PIN_PA22,
+       .flags         = AT91_TC_RB,
+       .is_active_low = 1,
+     },
+   };
+ #else
+ static struct pin_mapping channel_map[PWM_NCHAN] = 
+   {
+     { /* TIOA0*/
+       .timer         = 0,
+       .gpio          = AT91_PIN_PA26,
+       .flags         = AT91_TC_RA,
+       .is_active_low = 1,
+     },
+     { /* TIOA1*/
+       .timer         = 1,
+       .gpio          = AT91_PIN_PA27,
+       .flags         = AT91_TC_RA,
+       .is_active_low = 1,
+     },
+     { /* TIOA2*/
+       .timer         = 2,
+       .gpio          = AT91_PIN_PA28,
+       .flags         = AT91_TC_RA,
+       .is_active_low = 1,
+     },
+     { /* TIOB0*/
+       .timer         = 0,
+       .gpio          = AT91_PIN_PC9,
+       .flags         = AT91_TC_RB,
+       .is_active_low = 1,
+     },
+     { /* TIOB1*/
+       .timer         = 1,
+       .gpio          = AT91_PIN_PC7,
+       .flags         = AT91_TC_RB,
+       .is_active_low = 1,
+     },
+     { /* TIOB2*/
+       .timer         = 2,
+       .gpio          = AT91_PIN_PC6,
+       .flags         = AT91_TC_RB,
+       .is_active_low = 1,
+     },
+   };
+ #endif
+ 
+ int get_channel_from_gpio(u32 gpio) 
+ {
+   int i;
+   for(i=0; i<PWM_NCHAN; i++) {
+     if(channel_map[i].gpio == gpio) {
+       //printk("%04d : %s() - returning %d\n", __LINE__, __FUNCTION__, i);
+       return i;      
+     }
+   }
+   //  printk("%04d : %s() - returning %d\n", __LINE__, __FUNCTION__, -1);
+   return -1;
+ }
+ 
+ /* global PWM controller registers */
+ #define PWM_MR		0x00
+ #define PWM_ENA		0x04
+ #define PWM_DIS		0x08
+ #define PWM_SR		0x0c
+ #define PWM_IER		0x10
+ #define PWM_IDR		0x14
+ #define PWM_IMR		0x18
+ #define PWM_ISR		0x1c
+ 
+ static inline void pwm_writel(const struct pwm *p, unsigned offset, u32 val)
+ {
+   //	__raw_writel(val, p->base + offset);
+ }
+ 
+ static inline u32 pwm_readl(const struct pwm *p, unsigned offset)
+ {
+   //	return __raw_readl(p->base + offset);
+   return 0;
+ }
+ 
+ static inline void __iomem *pwmc_regs(const struct pwm *p, int index)
+ {
+   //  return p->base + 0x200 + index * 0x20;
+   return NULL;
+ }
+ 
+ static inline void timer_writel(const struct pwm *p, u8 timer, unsigned offset, u32 val)
+ {
+   __raw_writel(val, p->base[timer] + offset);
+ }
+ 
+ static inline u32 timer_readl(const struct pwm *p, u8 timer,  unsigned offset)
+ {
+   return __raw_readl(p->base[timer] + offset);
+ }
+ 
+ 
+ static char *clocks[3] = {"tc0_clk", "tc1_clk", "tc2_clk"};
+ 
+ static struct pwm *pwm = NULL;
+ 
+ 
+ static void pwm_dumpregs(struct pwm_channel *ch, char *tag)
+ {
+   struct device	*dev = &pwm->pdev->dev;
+ 
+   dev_dbg(dev, "%s: mr %08x, sr %08x, imr %08x\n",
+           tag,
+           pwm_readl(pwm, PWM_MR),
+           pwm_readl(pwm, PWM_SR),
+           pwm_readl(pwm, PWM_IMR));
+   dev_dbg(dev,
+           "pwm ch%d - mr %08x, dty %u, prd %u, cnt %u\n",
+           ch->index,
+           pwm_channel_readl(ch, PWM_CMR),
+           pwm_channel_readl(ch, PWM_CDTY),
+           pwm_channel_readl(ch, PWM_CPRD),
+           pwm_channel_readl(ch, PWM_CCNT));
+ }
+ 
+ void
+ pwm_channel_writel(struct pwm_channel *pwmc, unsigned offset, u32 val)
+ {
+   int idx;
+ 
+   if((idx = get_channel_from_gpio(pwmc->index)) < 0)
+     return;
+ 
+   if(offset == PWM_CUPD) {
+     if(channel_map[idx].is_active_low) {
+       timer_writel(pwm, channel_map[idx].timer, channel_map[idx].flags, 255-val);
+     } else {
+       timer_writel(pwm, channel_map[idx].timer, channel_map[idx].flags, val);
+     }
+     /*
+     printk("%s() - TIO%c%d %d   %d\n", __FUNCTION__, 
+            channel_map[idx].flags&AT91_TC_RA ? 'A' : 'B',
+            channel_map[idx].timer,
+            timer_readl(pwm, channel_map[idx].timer, channel_map[idx].flags),
+            timer_readl(pwm, channel_map[idx].timer, AT91_TC_RC));
+     */
+   } 
+ }
+ EXPORT_SYMBOL(pwm_channel_writel);
+ 
+ u32 pwm_channel_readl(struct pwm_channel *pwmc, unsigned offset)
+ {
+   int idx;
+ 
+   if((idx = get_channel_from_gpio(pwmc->index)) < 0)
+     return -1;
+ 
+   if(offset == PWM_CUPD) {
+     return timer_readl(pwm, channel_map[idx].timer, channel_map[idx].flags);
+   } else {
+     return 0;
+   }
+ }
+ 
+ 
+ /**
+  * pwm_channel_alloc - allocate an unused PWM channel
+  * @index: identifies the channel
+  * @ch: structure to be initialized
+  *
+  * Drivers allocate PWM channels according to the board's wiring, and
+  * matching board-specific setup code.  Returns zero or negative errno.
+  */
+ int pwm_channel_alloc(int index, struct pwm_channel *ch)
+ {
+   unsigned long	flags;
+   int		status = 0;
+   u32 tcval;
+   int idx;
+ 
+   /* insist on PWM init, with this signal pinned out */
+   //  if (!pwm || !(pwm->mask & 1 << index)) {
+   if (!pwm) {
+     //printk("at91_pwm - %s(): pwm is NULL\n", __FUNCTION__);
+     return -ENODEV;
+   }
+ 
+   if((idx = get_channel_from_gpio(index)) < 0)
+     return -EINVAL;
+ 
+   memset(ch, 0, sizeof *ch);
+ 
+   spin_lock_irqsave(&pwm->lock, flags);
+   // if (pwm->channel[index])
+   //  status = -EBUSY;
+   //else {
+     
+   /*
+     printk("at91_pwm - allocating PWM timer TIO%c%d on PIO 0x%08x\n", 
+            (channel_map[idx].flags == AT91_TC_RA) ? 'A' : 'B',
+            channel_map[idx].timer,
+            index);
+   */
+     ch->index = index;
+ 
+     clk_enable(pwm->clk[channel_map[idx].timer]);
+ 
+     pwm->channel[index] = ch;
+     pwm->handler[index] = NULL;
+ 
+     tcval = 
+       AT91_TC_BCPC_SET | AT91_TC_BCPB_CLEAR | 
+       AT91_TC_ACPC_SET | AT91_TC_ACPA_CLEAR | 
+       AT91_TC_WAVE | AT91_TC_WAVESEL_UP_AUTO | 
+       AT91_TC_ABETRG | (channel_map[idx].timer << 0);
+     /*
+     printk("%s() - CMR%d: 0x%08x\n", __FUNCTION__, 
+            channel_map[idx].timer, tcval);
+     */
+     /* Setup tio */
+     timer_writel(pwm, channel_map[idx].timer, AT91_TC_CMR, tcval);
+     timer_writel(pwm, channel_map[idx].timer, channel_map[idx].flags, 155);
+ 
+     /* Fixed 255 period time */
+     timer_writel(pwm, channel_map[idx].timer, AT91_TC_RC, 255); 
+     timer_writel(pwm, channel_map[idx].timer, AT91_TC_CCR, 
+                  (AT91_TC_CLKEN | AT91_TC_SWTRG));
+     //}
+   spin_unlock_irqrestore(&pwm->lock, flags);
+   return status;
+ }
+ EXPORT_SYMBOL(pwm_channel_alloc);
+ 
+ static int pwmcheck(struct pwm_channel *ch)
+ {
+   int		index;
+ 
+   //  printk("at91_pwm - %s()\n", __FUNCTION__);
+ 
+   if (!pwm)
+     return -ENODEV;
+   if (!ch)
+     return -EINVAL;
+   index = ch->index;
+   if (index < 0 || index >= PWM_NCHAN || pwm->channel[index] != ch)
+     return -EINVAL;
+ 
+   return index;
+ }
+ 
+ /**
+  * pwm_channel_free - release a previously allocated channel
+  * @ch: the channel being released
+  *
+  * The channel is completely shut down (counter and IRQ disabled),
+  * and made available for re-use.  Returns zero, or negative errno.
+  */
+ int pwm_channel_free(struct pwm_channel *ch)
+ {
+   unsigned long	flags;
+   int		t;
+ 
+   //  printk("at91_pwm - %s()\n", __FUNCTION__);
+ 
+   spin_lock_irqsave(&pwm->lock, flags);
+   t = pwmcheck(ch);
+   if (t >= 0) {
+     pwm->channel[t] = NULL;
+     pwm->handler[t] = NULL;
+ 
+     /* channel and irq are always disabled when we return */
+     pwm_writel(pwm, PWM_DIS, 1 << t);
+     pwm_writel(pwm, PWM_IDR, 1 << t);
+ 
+     /*
+     clk_disable(pwm->clk0);
+     clk_disable(pwm->clk1);
+     clk_disable(pwm->clk2);
+     */
+     t = 0;
+   }
+   spin_unlock_irqrestore(&pwm->lock, flags);
+   return t;
+ }
+ EXPORT_SYMBOL(pwm_channel_free);
+ 
+ int __pwm_channel_onoff(struct pwm_channel *ch, int enabled)
+ {
+   unsigned long	flags;
+   int		t;
+ 
+   /* OMITTED FUNCTIONALITY:  starting several channels in synch */
+ 
+   //printk("at91_pwm - %s()\n", __FUNCTION__);
+ 
+   spin_lock_irqsave(&pwm->lock, flags);
+   t = pwmcheck(ch);
+   if (t >= 0) {
+     pwm_writel(pwm, enabled ? PWM_ENA : PWM_DIS, 1 << t);
+     t = 0;
+ 
+   }
+   spin_unlock_irqrestore(&pwm->lock, flags);
+ 
+   return t;
+ }
+ EXPORT_SYMBOL(__pwm_channel_onoff);
+ 
+ /**
+  * pwm_clk_alloc - allocate and configure CLKA or CLKB
+  * @prescale: from 0..10, the power of two used to divide MCK
+  * @div: from 1..255, the linear divisor to use
+  *
+  * Returns PWM_CPR_CLKA, PWM_CPR_CLKB, or negative errno.  The allocated
+  * clock will run with a period of (2^prescale * div) / MCK, or twice as
+  * long if center aligned PWM output is used.  The clock must later be
+  * deconfigured using pwm_clk_free().
+  */
+ int pwm_clk_alloc(unsigned prescale, unsigned div)
+ {
+   //  printk("at91_pwm - %s()\n", __FUNCTION__);
+   return 1;
+ }
+ EXPORT_SYMBOL(pwm_clk_alloc);
+ 
+ /**
+  * pwm_clk_free - deconfigure and release CLKA or CLKB
+  *
+  * Reverses the effect of pwm_clk_alloc().
+  */
+ void pwm_clk_free(unsigned clk)
+ {
+   //printk("at91_pwm - %s()\n", __FUNCTION__);
+   return;
+ }
+ EXPORT_SYMBOL(pwm_clk_free);
+ 
+ /**
+  * pwm_channel_handler - manage channel's IRQ handler
+  * @ch: the channel
+  * @handler: the handler to use, possibly NULL
+  *
+  * If the handler is non-null, the handler will be called after every
+  * period of this PWM channel.  If the handler is null, this channel
+  * won't generate an IRQ.
+  */
+ int pwm_channel_handler(struct pwm_channel *ch,
+                         void (*handler)(struct pwm_channel *ch))
+ {
+   //  printk("at91_pwm - %s()\n", __FUNCTION__);
+   return 0;
+ }
+ EXPORT_SYMBOL(pwm_channel_handler);
+ 
+ 
+ static int __init pwm_probe(struct platform_device *pdev)
+ {
+   int i;
+   struct resource *r;
+   u32 *mp = pdev->dev.platform_data;
+   struct pwm *p;
+   int status = -EIO;
+ 
+   //  printk("%04d : %s()\n",__LINE__, __FUNCTION__);
+   if (pwm)
+     return -EBUSY;
+   if (!mp || !*mp)
+     return -ENODEV;
+   /*
+   if (*mp & ~((1<<PWM_NCHAN)-1)) {
+     dev_warn(&pdev->dev, "mask 0x%x ... more than %d channels\n",
+              *mp, PWM_NCHAN);
+     return -EINVAL;
+   }
+   */
+ 
+   //  printk("%04d : %s()\n",__LINE__, __FUNCTION__);
+   
+   p = kzalloc(sizeof(*p), GFP_KERNEL);
+   if (!p)
+     return -ENOMEM;
+ 
+   spin_lock_init(&p->lock);
+   p->pdev = pdev;
+   p->mask = *mp;
+ 
+   for(i=0; i<3; i++) {
+     r = platform_get_resource(pdev, IORESOURCE_MEM, i);
+     if(!r) {
+       //      printk("at91_pwm - %s(): resource fail\n", __FUNCTION__);
+       goto fail;
+     }
+     p->base[i] = ioremap(r->start, r->end - r->start + 1);
+     if (!p->base[i])
+       goto fail;
+   }
+   //printk("%04d : %s() - ressource ok\n",__LINE__, __FUNCTION__);
+   for(i=0; i<3; i++) {
+     p->clk[i] = clk_get(&pdev->dev, clocks[i]);
+     if (IS_ERR(p->clk[i])) {
+       status = PTR_ERR(p->clk[i]);
+       p->clk[i] = NULL;
+       //printk("at91_pwm - %s(): %s fail\n", __FUNCTION__, clocks[i]);
+       goto fail;
+     }
+   }
+ 
+   //printk("%04d : %s() - clk ok\n",__LINE__, __FUNCTION__);
+   pwm = p;
+ 
+   platform_set_drvdata(pdev, p);
+ 
+   return 0;
+ 
+  fail:
+   for(i=0; i<3; i++) {
+     if (p->clk[i])
+     clk_put(p->clk[i]);
+   }
+   if (p->base)
+     iounmap(p->base);
+ 
+   kfree(p);
+   return status;
+ }
+ 
+ static int __exit pwm_remove(struct platform_device *pdev)
+ {
+   int i;
+   struct pwm *p = platform_get_drvdata(pdev);
+ 
+   //printk("at91_pwm - %s()\n", __FUNCTION__);
+ 
+   if (p != pwm)
+     return -EINVAL;
+ 
+   for(i=0; i<3; i++) {
+     if (p->clk[i])
+       clk_put(p->clk[i]);
+   }
+   
+   pwm = NULL;
+ 
+   iounmap(p->base);
+   kfree(p);
+ 
+   return 0;
+ }
+ 
+ static struct platform_driver at91_pwm_driver = {
+   .driver = {
+     .name = "at91_pwm",
+     .owner = THIS_MODULE,
+   },
+   .remove = __exit_p(pwm_remove),
+ };
+ 
+ static int __init pwm_init(void)
+ {
+   printk("at91_pwm - %s()\n", __FUNCTION__);
+   return platform_driver_probe(&at91_pwm_driver, pwm_probe);
+ }
+ module_init(pwm_init);
+ 
+ static void __exit pwm_exit(void)
+ {
+   printk("at91_pwm - %s()\n", __FUNCTION__);
+   platform_driver_unregister(&at91_pwm_driver);
+ }
+ module_exit(pwm_exit);
+ 
+ MODULE_DESCRIPTION("Driver for AT91 PWM module");
+ MODULE_LICENSE("GPL");
+ MODULE_ALIAS("platform:at91_pwm");
diff -r -C3 -P linux-2.6.29.4/drivers/misc/Kconfig liab-linux-2.6.29.4/drivers/misc/Kconfig
*** linux-2.6.29.4/drivers/misc/Kconfig	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/drivers/misc/Kconfig	2012-01-20 14:49:15.281306733 +0100
***************
*** 55,60 ****
--- 55,67 ----
  	  TC can be used for other purposes, such as PWM generation and
  	  interval timing.
  
+ config AT91_PWM
+ 	tristate "Atmel AT91 PWM support"
+ 	depends on ARCH_AT91
+ 	help
+ 	  This option enables device driver support for the PWM channels
+ 	  on certain Atmel processors by using the TIOA/B timer banks.
+ 
  config IBM_ASM
  	tristate "Device driver for IBM RSA service processor"
  	depends on X86 && PCI && INPUT && EXPERIMENTAL
diff -r -C3 -P linux-2.6.29.4/drivers/misc/Makefile liab-linux-2.6.29.4/drivers/misc/Makefile
*** linux-2.6.29.4/drivers/misc/Makefile	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/drivers/misc/Makefile	2012-01-20 14:49:15.285306733 +0100
***************
*** 5,10 ****
--- 5,11 ----
  obj-$(CONFIG_IBM_ASM)		+= ibmasm/
  obj-$(CONFIG_HDPU_FEATURES)	+= hdpuftrs/
  obj-$(CONFIG_ATMEL_PWM)		+= atmel_pwm.o
+ obj-$(CONFIG_AT91_PWM)		+= at91_pwm.o
  obj-$(CONFIG_ATMEL_SSC)		+= atmel-ssc.o
  obj-$(CONFIG_ATMEL_TCLIB)	+= atmel_tclib.o
  obj-$(CONFIG_ICS932S401)	+= ics932s401.o
diff -r -C3 -P linux-2.6.29.4/drivers/mtd/maps/Kconfig liab-linux-2.6.29.4/drivers/mtd/maps/Kconfig
*** linux-2.6.29.4/drivers/mtd/maps/Kconfig	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/drivers/mtd/maps/Kconfig	2012-01-20 14:49:08.641306646 +0100
***************
*** 542,547 ****
--- 542,604 ----
  	  Map driver for a NOR flash bank located on the Expansion Bus of the
  	  Intel Vermilion Range chipset.
  
+ # -----------------------------------------------------
+ config MTD_LIABARM
+ 	bool "CFI Flash device mapped on a LIABARM series product"
+ 	depends on MTD_CFI && MACH_LIABARM && MTD_PARTITIONS
+ 	help
+     Use this if you have either a LIABARM9200 or a nanoLIAB board.
+ 
+ config MTD_LIAB_FLASH_SIZE
+ 	int "FLASH chip size (KB)"
+ 	depends on MTD_LIABARM
+   default "16384"
+ 	help
+     The size of the individual FLASH chips on the board.
+ 
+ config MTD_LIAB_NOFLASH
+   int "Number of FLASH chips on the board"
+ 	depends on MTD_LIABARM
+ 	default "1"
+ 	help
+     This would typically be 1 or 2 for LIABARM9200 and 1 for nanoLIAB.
+ 
+ config MTD_LIABARM_BOOTSIZE
+ 	int "Size of bootloader partition (KB)"
+ 	depends on MTD_LIABARM
+ 	default "128"
+ 	help
+     This is the size in kilobytes of the LIAB ApS bootloader
+     partition.
+ 
+ config MTD_LIABARM_KERNELSIZE
+ 	int "Size of kernel partition (KB)"
+ 	depends on MTD_LIABARM
+ 	default "1536"
+ 	help
+     This is the size in kilobytes of the kernel partition.
+ 
+ config MTD_LIABARM_ROOTSIZE
+ 	int "Size of root partition (KB)"
+ 	depends on MTD_LIABARM
+ 	default "4480"
+ 	help
+     This is the size in kilobytes of the root (initrd) partition.
+ 
+ config MTD_LIABARM_PARAMSIZE
+   int "Size of parameters partition (KB)"
+   depends on MTD_LIABARM
+   default "128"
+   help
+     This is the size in kilobytes of the parameters partition.
+ 
+ config MTD_LIABARM_JFFS2SIZE
+ 	int "Size of jffs2 partition (KB)"
+ 	depends on MTD_LIABARM
+ 	default "10112"
+ 	help
+     This is the size in kilobytes of the JFFS2 filesystem partition.
+ 
  config MTD_PLATRAM
  	tristate "Map driver for platform device RAM (mtd-ram)"
  	select MTD_RAM
diff -r -C3 -P linux-2.6.29.4/drivers/mtd/maps/Makefile liab-linux-2.6.29.4/drivers/mtd/maps/Makefile
*** linux-2.6.29.4/drivers/mtd/maps/Makefile	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/drivers/mtd/maps/Makefile	2012-01-20 14:49:08.645306646 +0100
***************
*** 61,63 ****
--- 61,64 ----
  obj-$(CONFIG_MTD_OMAP_NOR)	+= omap_nor.o
  obj-$(CONFIG_MTD_INTEL_VR_NOR)	+= intel_vr_nor.o
  obj-$(CONFIG_MTD_BFIN_ASYNC)	+= bfin-async-flash.o
+ obj-$(CONFIG_MTD_LIABARM)	+= nanoliab.o
\ No newline at end of file
diff -r -C3 -P linux-2.6.29.4/drivers/mtd/maps/nanoliab.c liab-linux-2.6.29.4/drivers/mtd/maps/nanoliab.c
*** linux-2.6.29.4/drivers/mtd/maps/nanoliab.c	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/drivers/mtd/maps/nanoliab.c	2012-01-20 14:49:08.645306646 +0100
***************
*** 0 ****
--- 1,195 ----
+ /*
+  * Flash on Cirrus CDB89712
+  *
+  * $Id: cdb89712.c,v 1.10 2004/11/04 13:24:14 gleixner Exp $
+  */
+ 
+ #include <linux/module.h>
+ #include <linux/types.h>
+ #include <linux/kernel.h>
+ #include <linux/ioport.h>
+ #include <linux/init.h>
+ #include <asm/io.h>
+ #include <mach/hardware.h>
+ #include <linux/mtd/mtd.h>
+ #include <linux/mtd/map.h>
+ #include <linux/mtd/partitions.h>
+ 
+ static struct mtd_info *flash0_mtd;
+ 
+ #define LIAB_FLASH0_START           (0x10000000)
+ #define MEGABYTE                    (1024)
+ #define FLASHMAXSIZE                (CONFIG_MTD_LIAB_FLASH_SIZE)
+ #define NANOLIABBANKWIDTH           (2)
+ 
+ struct map_info liab_flash0_map = 
+ {
+ 	.name = "flash0",
+ 	.size =      (CONFIG_MTD_LIAB_FLASH_SIZE)*1024,
+ 	.bankwidth = NANOLIABBANKWIDTH,
+ 	.phys =      LIAB_FLASH0_START,
+ };
+ 
+ struct resource liab_flash0_resource = 
+ {
+ 	.name =   "Flash0",
+ 	.start =  LIAB_FLASH0_START,
+ 	.end =    LIAB_FLASH0_START+(CONFIG_MTD_LIAB_FLASH_SIZE)*1024-1,
+ 	.flags =  IORESOURCE_IO | IORESOURCE_BUSY,
+ };
+ 
+ #define NUM_PARTITIONS 5
+ 
+ /*    Physical partition order: */
+ /*    mtdblock 1: 'FLASH Boot partition'   */
+ /*    mtdblock 2: 'FLASH Kernel partition' */
+ /*    mtdblock 0: 'FLASH Root partition'   */
+ /*    mtdblock 3: 'FLASH Param partition'  */
+ /*    mtdblock 4: 'FLASH JFFS2 partition'  */
+ 
+ /*    Logical partition order: */
+ /*    mtdblock 0: 'FLASH Root partition'   */
+ /*    mtdblock 1: 'FLASH Boot partition'   */
+ /*    mtdblock 2: 'FLASH Kernel partition' */
+ /*    mtdblock 3: 'FLASH Param partition'  */
+ /*    mtdblock 4: 'FLASH JFFS2 partition'  */
+ 
+ #define OFFSET_BOOTSIZE   0
+ #define OFFSET_KERNELSIZE (OFFSET_BOOTSIZE   + CONFIG_MTD_LIABARM_BOOTSIZE)
+ #define OFFSET_ROOTSIZE   (OFFSET_KERNELSIZE + CONFIG_MTD_LIABARM_KERNELSIZE)
+ #define OFFSET_JFFS2SIZE  (OFFSET_ROOTSIZE   + CONFIG_MTD_LIABARM_ROOTSIZE)
+ #define OFFSET_PARAMSIZE  (OFFSET_JFFS2SIZE  + CONFIG_MTD_LIABARM_JFFS2SIZE)
+ #define TOTALSIZE         (OFFSET_PARAMSIZE  + CONFIG_MTD_LIABARM_PARAMSIZE)
+ 
+ /* partition_info gives details on the logical partitions that the 
+  * single flash device is split into. */
+ static struct mtd_partition flash0_partition_info[]={
+   {
+     name:   "NANOLIAB FLASH Root partition", 
+     offset: OFFSET_ROOTSIZE*1024,
+     size: CONFIG_MTD_LIABARM_ROOTSIZE*1024
+   },
+   {
+     name:   "NANOLIAB FLASH Boot partition", 
+     offset: OFFSET_BOOTSIZE*1024,
+     size: CONFIG_MTD_LIABARM_BOOTSIZE*1024
+   },
+   {
+     name:   "NANOLIAB FLASH Kernel partition", 
+     offset: OFFSET_KERNELSIZE*1024,
+     size: CONFIG_MTD_LIABARM_KERNELSIZE*1024
+   },
+   {
+     name:   "NANOLIAB FLASH Param partition", 
+     offset: OFFSET_PARAMSIZE*1024,
+     size: CONFIG_MTD_LIABARM_PARAMSIZE*1024
+   },
+   {
+     name:   "NANOLIAB FLASH JFFS2 partition", 
+     offset: OFFSET_JFFS2SIZE*1024,
+     size: CONFIG_MTD_LIABARM_JFFS2SIZE*1024
+   },
+ };
+ 
+ #if TOTALSIZE > FLASHMAXSIZE
+ #error NANOLIAB FLASH: Total size of all MTD FLASH partitions too large!
+ #endif
+ #if TOTALSIZE < FLASHMAXSIZE
+ #error NANOLIAB FLASH: Total size of all MTD FLASH partitions too small!
+ #endif
+ 
+ static int __init init_liab_flash (void)
+ {
+ 	int err;
+ 	
+ 	if (request_resource (&ioport_resource, &liab_flash0_resource))
+     {
+ 		printk(KERN_NOTICE "Failed to reserve NANOLIAB FLASH0 space\n");
+ 		err = -EBUSY;
+ 		goto out;
+ 	}
+     
+   /* init flash0 */	
+ 
+ 	liab_flash0_map.virt = ioremap(LIAB_FLASH0_START, 
+ 																 CONFIG_MTD_LIAB_FLASH_SIZE*1024);
+ 	if (!liab_flash0_map.virt) 
+     {
+ 		printk(KERN_NOTICE "Failed to ioremap NANOLIAB FLASH0 space\n");
+ 		err = -EIO;
+ 		goto out_resource;
+ 	}
+ 
+ 	simple_map_init(&liab_flash0_map);
+ 
+ 	flash0_mtd = do_map_probe("cfi_probe", &liab_flash0_map);
+ 
+     printk("--> 0x%08x 0x%08x\n", liab_flash0_map.virt, flash0_mtd);
+ 
+ #ifdef undef
+ 	if (!flash0_mtd) 
+     {
+ 		flash0_mtd = do_map_probe("map_rom", &liab_flash0_map);
+ 		if (flash0_mtd)
+ 			flash0_mtd->erasesize = 0x10000;
+ 	}
+ #endif
+ 
+ 	if (!flash0_mtd) 
+     {
+ 		printk("FLASH probe failed\n");
+ 		err = -ENXIO;
+ 		goto out_ioremap;
+ 	}
+ 
+ 	flash0_mtd->owner = THIS_MODULE;
+     
+   /* Add partitions */
+     if (add_mtd_partitions(flash0_mtd,  flash0_partition_info, 
+                          ARRAY_SIZE( flash0_partition_info)))
+     {
+         printk("FLASH0 device partition addition failed\n");
+         err = -ENOMEM;
+         goto out_probe;
+     }
+ 	return 0;
+   
+  out_probe:
+ 	map_destroy(flash0_mtd);
+ 	flash0_mtd = 0;
+  out_ioremap:
+ 	iounmap((void *)liab_flash0_map.virt);
+  out_resource:
+ 	release_resource (&liab_flash0_resource);
+  out:
+ 	return err;
+ }
+ 
+ 
+ static int __init init_nanoliab_maps(void)
+ {
+     printk(KERN_INFO "NANOLIAB MTD FLASH device %d "
+                      "KB at physical offset 0x%x\n", 
+ 					 CONFIG_MTD_LIAB_FLASH_SIZE, LIAB_FLASH0_START);
+ 	init_liab_flash();
+ 	return 0;
+ }
+ 	
+ 
+ static void __exit cleanup_nanoliab_maps(void)
+ {
+ 	if (flash0_mtd) 
+     {
+       del_mtd_device(flash0_mtd);
+       map_destroy(flash0_mtd);
+       iounmap((void *)liab_flash0_map.virt);
+       release_resource (&liab_flash0_resource);
+     }
+ }
+ 
+ module_init(init_nanoliab_maps);
+ module_exit(cleanup_nanoliab_maps);
+ 
+ MODULE_AUTHOR("LIAB ApS <www.liab.dk>");
+ MODULE_DESCRIPTION("NANOLIAB mtdmap driver");
+ MODULE_LICENSE("GPL");
diff -r -C3 -P linux-2.6.29.4/drivers/net/dm9000.c liab-linux-2.6.29.4/drivers/net/dm9000.c
*** linux-2.6.29.4/drivers/net/dm9000.c	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/drivers/net/dm9000.c	2012-01-20 14:49:33.569306975 +0100
***************
*** 76,81 ****
--- 76,82 ----
   * devices, DM9000A and DM9000B.
   */
  
+ 
  enum dm9000_type {
  	TYPE_DM9000E,	/* original DM9000 */
  	TYPE_DM9000A,
***************
*** 128,133 ****
--- 129,136 ----
  
  /* debug code */
  
+ u8 mac_addr[6] = {0x00, 0x15, 0x8c, 0x00, 0x18, 0x01};
+ 
  #define dm9000_dbg(db, lev, msg...) do {		\
  	if ((lev) < CONFIG_DM9000_DEBUGLEVEL &&		\
  	    (lev) < db->debug_level) {			\
***************
*** 1000,1032 ****
  {
  	board_info_t *db = netdev_priv(dev);
  	unsigned long irqflags = db->irq_res->flags & IRQF_TRIGGER_MASK;
! 
  	if (netif_msg_ifup(db))
  		dev_dbg(db->dev, "enabling %s\n", dev->name);
  
  	/* If there is no IRQ type specified, default to something that
  	 * may work, and tell the user that this is a problem */
  
  	if (irqflags == IRQF_TRIGGER_NONE)
  		dev_warn(db->dev, "WARNING: no IRQ resource flags set.\n");
! 
  	irqflags |= IRQF_SHARED;
! 
  	if (request_irq(dev->irq, &dm9000_interrupt, irqflags, dev->name, dev))
  		return -EAGAIN;
! 
  	/* Initialize DM9000 board */
  	dm9000_reset(db);
  	dm9000_init_dm9000(dev);
  
  	/* Init driver variable */
  	db->dbug_cnt = 0;
  
  	mii_check_media(&db->mii, netif_msg_link(db), 1);
  	netif_start_queue(dev);
  	
  	dm9000_schedule_poll(db);
  
  	return 0;
  }
  
--- 1003,1040 ----
  {
  	board_info_t *db = netdev_priv(dev);
  	unsigned long irqflags = db->irq_res->flags & IRQF_TRIGGER_MASK;
!   printk("%s():%d - here\n", __FUNCTION__, __LINE__);
  	if (netif_msg_ifup(db))
  		dev_dbg(db->dev, "enabling %s\n", dev->name);
  
+   printk("%s():%d - here\n", __FUNCTION__, __LINE__);
  	/* If there is no IRQ type specified, default to something that
  	 * may work, and tell the user that this is a problem */
  
  	if (irqflags == IRQF_TRIGGER_NONE)
  		dev_warn(db->dev, "WARNING: no IRQ resource flags set.\n");
!   printk("%s():%d - here\n", __FUNCTION__, __LINE__);
  	irqflags |= IRQF_SHARED;
!   printk("%s():%d - here\n", __FUNCTION__, __LINE__);
  	if (request_irq(dev->irq, &dm9000_interrupt, irqflags, dev->name, dev))
  		return -EAGAIN;
!   printk("%s():%d - here\n", __FUNCTION__, __LINE__);
  	/* Initialize DM9000 board */
  	dm9000_reset(db);
  	dm9000_init_dm9000(dev);
  
+   printk("%s():%d - here\n", __FUNCTION__, __LINE__);
  	/* Init driver variable */
  	db->dbug_cnt = 0;
  
+   printk("%s():%d - here\n", __FUNCTION__, __LINE__);
  	mii_check_media(&db->mii, netif_msg_link(db), 1);
  	netif_start_queue(dev);
  	
+   printk("%s():%d - here\n", __FUNCTION__, __LINE__);
  	dm9000_schedule_poll(db);
  
+   printk("%s():%d - here\n", __FUNCTION__, __LINE__);
  	return 0;
  }
  
***************
*** 1380,1385 ****
--- 1388,1398 ----
  			ndev->dev_addr[i] = ior(db, i+DM9000_PAR);
  	}
  
+   /* msawh*/
+   for (i = 0; i < 6; i++)
+     ndev->dev_addr[i] = mac_addr[i];
+ 
+ 
  	if (!is_valid_ether_addr(ndev->dev_addr))
  		dev_warn(db->dev, "%s: Invalid ethernet MAC address. Please "
  			 "set using ifconfig\n", ndev->name);
diff -r -C3 -P linux-2.6.29.4/drivers/rtc/rtc-ds1307.c liab-linux-2.6.29.4/drivers/rtc/rtc-ds1307.c
*** linux-2.6.29.4/drivers/rtc/rtc-ds1307.c	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/drivers/rtc/rtc-ds1307.c	2012-01-20 14:49:17.549306762 +0100
***************
*** 18,24 ****
  #include <linux/bcd.h>
  
  
- 
  /* We can't determine type by probing, but if we expect pre-Linux code
   * to have set the chip up as a clock (turning on the oscillator and
   * setting the date and time), Linux can ignore the non-clock features.
--- 18,23 ----
diff -r -C3 -P linux-2.6.29.4/drivers/serial/atmel_serial.c liab-linux-2.6.29.4/drivers/serial/atmel_serial.c
*** linux-2.6.29.4/drivers/serial/atmel_serial.c	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/drivers/serial/atmel_serial.c	2012-01-20 14:49:05.109306601 +0100
***************
*** 147,152 ****
--- 147,154 ----
  	unsigned int		irq_status_prev;
  
  	struct circ_buf		rx_ring;
+ 
+     short      rs485_mode;
  };
  
  static struct atmel_uart_port atmel_ports[ATMEL_MAX_UART];
***************
*** 1017,1022 ****
--- 1019,1025 ----
  {
  	unsigned long flags;
  	unsigned int mode, imr, quot, baud;
+ 	struct atmel_uart_port *atmel_port = to_atmel_uart_port(port);
  
  	/* Get current mode register */
  	mode = UART_GET_MR(port) & ~(ATMEL_US_USCLKS | ATMEL_US_CHRL
***************
*** 1065,1070 ****
--- 1068,1078 ----
  	} else
  		mode |= ATMEL_US_PAR_NONE;
  
+     if(atmel_port->rs485_mode) {
+         //printk("/dev/ttyS%d is RS485 mode\n", port->line);
+         mode |= ATMEL_US_USMODE_RS485;
+     }
+ 
  	spin_lock_irqsave(&port->lock, flags);
  
  	port->read_status_mask = ATMEL_US_OVRE;
***************
*** 1268,1273 ****
--- 1276,1284 ----
  
  	atmel_port->use_dma_rx = data->use_dma_rx;
  	atmel_port->use_dma_tx = data->use_dma_tx;
+     
+     atmel_port->rs485_mode = data->rs485_mode;
+ 
  	if (atmel_use_dma_tx(port))
  		port->fifosize = PDC_BUFFER_SIZE;
  }
diff -r -C3 -P linux-2.6.29.4/drivers/usb/serial/pl2303.h liab-linux-2.6.29.4/drivers/usb/serial/pl2303.h
*** linux-2.6.29.4/drivers/usb/serial/pl2303.h	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/drivers/usb/serial/pl2303.h	2012-01-20 14:49:34.525306984 +0100
***************
*** 60,65 ****
--- 60,67 ----
  #define SAMSUNG_PRODUCT_ID	0x8001
  
  #define SIEMENS_VENDOR_ID	0x11f5
+ #define SIEMENS2_VENDOR_ID	0x0681
+ #define SIEMENS_PRODUCT_ID_HC25	0x0041
  #define SIEMENS_PRODUCT_ID_SX1	0x0001
  #define SIEMENS_PRODUCT_ID_X65	0x0003
  #define SIEMENS_PRODUCT_ID_X75	0x0004
diff -r -C3 -P linux-2.6.29.4/drivers/video/Kconfig liab-linux-2.6.29.4/drivers/video/Kconfig
*** linux-2.6.29.4/drivers/video/Kconfig	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/drivers/video/Kconfig	2012-01-20 14:49:13.985306716 +0100
***************
*** 940,945 ****
--- 940,951 ----
  	help
  	  This enables support for the AT91/AT32 LCD Controller.
  
+ config FB_MIKKEL
+        depends on FB
+ 	tristate "Mikkel LCD Controller support"
+ 	help
+ 	  This enables support for the AT91/AT32 LCD Controller.
+ 
  config FB_INTSRAM
  	bool "Frame Buffer in internal SRAM"
  	depends on FB_ATMEL && ARCH_AT91SAM9261
diff -r -C3 -P linux-2.6.29.4/drivers/watchdog/at91rm9200_wdt.c liab-linux-2.6.29.4/drivers/watchdog/at91rm9200_wdt.c
*** linux-2.6.29.4/drivers/watchdog/at91rm9200_wdt.c	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/drivers/watchdog/at91rm9200_wdt.c	2012-01-20 14:49:12.221306693 +0100
***************
*** 24,30 ****
  #include <linux/uaccess.h>
  #include <mach/at91_st.h>
  
! #define WDT_DEFAULT_TIME	5	/* seconds */
  #define WDT_MAX_TIME		256	/* seconds */
  
  static int wdt_time = WDT_DEFAULT_TIME;
--- 24,30 ----
  #include <linux/uaccess.h>
  #include <mach/at91_st.h>
  
! #define WDT_DEFAULT_TIME 60	/* seconds */
  #define WDT_MAX_TIME		256	/* seconds */
  
  static int wdt_time = WDT_DEFAULT_TIME;
diff -r -C3 -P linux-2.6.29.4/fs/Kconfig liab-linux-2.6.29.4/fs/Kconfig
*** linux-2.6.29.4/fs/Kconfig	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/fs/Kconfig	2012-01-20 14:48:24.065306062 +0100
***************
*** 209,214 ****
--- 209,218 ----
  source "fs/befs/Kconfig"
  source "fs/bfs/Kconfig"
  source "fs/efs/Kconfig"
+ 
+ # Patched by YAFFS
+ source "fs/yaffs2/Kconfig"
+ 
  source "fs/jffs2/Kconfig"
  # UBIFS File system configuration
  source "fs/ubifs/Kconfig"
diff -r -C3 -P linux-2.6.29.4/fs/Makefile liab-linux-2.6.29.4/fs/Makefile
*** linux-2.6.29.4/fs/Makefile	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/fs/Makefile	2012-01-20 14:48:24.069306062 +0100
***************
*** 124,126 ****
--- 124,129 ----
  obj-$(CONFIG_OCFS2_FS)		+= ocfs2/
  obj-$(CONFIG_BTRFS_FS)		+= btrfs/
  obj-$(CONFIG_GFS2_FS)           += gfs2/
+ 
+ # Patched by YAFFS
+ obj-$(CONFIG_YAFFS_FS)		+= yaffs2/
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/devextras.h liab-linux-2.6.29.4/fs/yaffs2/devextras.h
*** linux-2.6.29.4/fs/yaffs2/devextras.h	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/devextras.h	2012-01-20 14:48:21.861306032 +0100
***************
*** 0 ****
--- 1,196 ----
+ /*
+  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+  *
+  * Copyright (C) 2002-2010 Aleph One Ltd.
+  *   for Toby Churchill Ltd and Brightstar Engineering
+  *
+  * Created by Charles Manning <charles@aleph1.co.uk>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU Lesser General Public License version 2.1 as
+  * published by the Free Software Foundation.
+  *
+  * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+  */
+ 
+ /*
+  * This file is just holds extra declarations of macros that would normally
+  * be providesd in the Linux kernel. These macros have been written from
+  * scratch but are functionally equivalent to the Linux ones.
+  *
+  */
+ 
+ #ifndef __EXTRAS_H__
+ #define __EXTRAS_H__
+ 
+ 
+ #if !(defined __KERNEL__)
+ 
+ /* Definition of types */
+ typedef unsigned char __u8;
+ typedef unsigned short __u16;
+ typedef unsigned __u32;
+ 
+ #endif
+ 
+ /*
+  * This is a simple doubly linked list implementation that matches the
+  * way the Linux kernel doubly linked list implementation works.
+  */
+ 
+ struct ylist_head {
+ 	struct ylist_head *next; /* next in chain */
+ 	struct ylist_head *prev; /* previous in chain */
+ };
+ 
+ 
+ /* Initialise a static list */
+ #define YLIST_HEAD(name) \
+ struct ylist_head name = { &(name), &(name)}
+ 
+ 
+ 
+ /* Initialise a list head to an empty list */
+ #define YINIT_LIST_HEAD(p) \
+ do { \
+ 	(p)->next = (p);\
+ 	(p)->prev = (p); \
+ } while (0)
+ 
+ 
+ /* Add an element to a list */
+ static __inline__ void ylist_add(struct ylist_head *newEntry,
+ 				struct ylist_head *list)
+ {
+ 	struct ylist_head *listNext = list->next;
+ 
+ 	list->next = newEntry;
+ 	newEntry->prev = list;
+ 	newEntry->next = listNext;
+ 	listNext->prev = newEntry;
+ 
+ }
+ 
+ static __inline__ void ylist_add_tail(struct ylist_head *newEntry,
+ 				 struct ylist_head *list)
+ {
+ 	struct ylist_head *listPrev = list->prev;
+ 
+ 	list->prev = newEntry;
+ 	newEntry->next = list;
+ 	newEntry->prev = listPrev;
+ 	listPrev->next = newEntry;
+ 
+ }
+ 
+ 
+ /* Take an element out of its current list, with or without
+  * reinitialising the links.of the entry*/
+ static __inline__ void ylist_del(struct ylist_head *entry)
+ {
+ 	struct ylist_head *listNext = entry->next;
+ 	struct ylist_head *listPrev = entry->prev;
+ 
+ 	listNext->prev = listPrev;
+ 	listPrev->next = listNext;
+ 
+ }
+ 
+ static __inline__ void ylist_del_init(struct ylist_head *entry)
+ {
+ 	ylist_del(entry);
+ 	entry->next = entry->prev = entry;
+ }
+ 
+ 
+ /* Test if the list is empty */
+ static __inline__ int ylist_empty(struct ylist_head *entry)
+ {
+ 	return (entry->next == entry);
+ }
+ 
+ 
+ /* ylist_entry takes a pointer to a list entry and offsets it to that
+  * we can find a pointer to the object it is embedded in.
+  */
+ 
+ 
+ #define ylist_entry(entry, type, member) \
+ 	((type *)((char *)(entry)-(unsigned long)(&((type *)NULL)->member)))
+ 
+ 
+ /* ylist_for_each and list_for_each_safe  iterate over lists.
+  * ylist_for_each_safe uses temporary storage to make the list delete safe
+  */
+ 
+ #define ylist_for_each(itervar, list) \
+ 	for (itervar = (list)->next; itervar != (list); itervar = itervar->next)
+ 
+ #define ylist_for_each_safe(itervar, saveVar, list) \
+ 	for (itervar = (list)->next, saveVar = (list)->next->next; \
+ 		itervar != (list); itervar = saveVar, saveVar = saveVar->next)
+ 
+ 
+ #if !(defined __KERNEL__)
+ 
+ 
+ #ifndef WIN32
+ #include <sys/stat.h>
+ #endif
+ 
+ 
+ #ifdef CONFIG_YAFFS_PROVIDE_DEFS
+ /* File types */
+ 
+ 
+ #define DT_UNKNOWN	0
+ #define DT_FIFO		1
+ #define DT_CHR		2
+ #define DT_DIR		4
+ #define DT_BLK		6
+ #define DT_REG		8
+ #define DT_LNK		10
+ #define DT_SOCK		12
+ #define DT_WHT		14
+ 
+ 
+ #ifndef WIN32
+ #include <sys/stat.h>
+ #endif
+ 
+ /*
+  * Attribute flags.  These should be or-ed together to figure out what
+  * has been changed!
+  */
+ #define ATTR_MODE	1
+ #define ATTR_UID	2
+ #define ATTR_GID	4
+ #define ATTR_SIZE	8
+ #define ATTR_ATIME	16
+ #define ATTR_MTIME	32
+ #define ATTR_CTIME	64
+ 
+ struct iattr {
+ 	unsigned int ia_valid;
+ 	unsigned ia_mode;
+ 	unsigned ia_uid;
+ 	unsigned ia_gid;
+ 	unsigned ia_size;
+ 	unsigned ia_atime;
+ 	unsigned ia_mtime;
+ 	unsigned ia_ctime;
+ 	unsigned int ia_attr_flags;
+ };
+ 
+ #endif
+ 
+ #else
+ 
+ #include <linux/types.h>
+ #include <linux/fs.h>
+ #include <linux/stat.h>
+ 
+ #endif
+ 
+ 
+ #endif
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/Kconfig liab-linux-2.6.29.4/fs/yaffs2/Kconfig
*** linux-2.6.29.4/fs/yaffs2/Kconfig	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/Kconfig	2012-01-20 14:48:21.861306032 +0100
***************
*** 0 ****
--- 1,180 ----
+ #
+ # YAFFS file system configurations
+ #
+ 
+ config YAFFS_FS
+ 	tristate "YAFFS2 file system support"
+ 	default n
+ 	depends on MTD_BLOCK
+ 	select YAFFS_YAFFS1
+ 	select YAFFS_YAFFS2
+ 	help
+ 	  YAFFS2, or Yet Another Flash Filing System, is a filing system
+ 	  optimised for NAND Flash chips.
+ 
+ 	  To compile the YAFFS2 file system support as a module, choose M
+ 	  here: the module will be called yaffs2.
+ 
+ 	  If unsure, say N.
+ 
+ 	  Further information on YAFFS2 is available at
+ 	  <http://www.aleph1.co.uk/yaffs/>.
+ 
+ config YAFFS_YAFFS1
+ 	bool "512 byte / page devices"
+ 	depends on YAFFS_FS
+ 	default y
+ 	help
+ 	  Enable YAFFS1 support -- yaffs for 512 byte / page devices
+ 
+ 	  Not needed for 2K-page devices.
+ 
+ 	  If unsure, say Y.
+ 
+ config YAFFS_9BYTE_TAGS
+ 	bool "Use older-style on-NAND data format with pageStatus byte"
+ 	depends on YAFFS_YAFFS1
+ 	default n
+ 	help
+ 
+ 	  Older-style on-NAND data format has a "pageStatus" byte to record
+ 	  chunk/page state.  This byte is zero when the page is discarded.
+ 	  Choose this option if you have existing on-NAND data using this
+ 	  format that you need to continue to support.  New data written
+ 	  also uses the older-style format.  Note: Use of this option
+ 	  generally requires that MTD's oob layout be adjusted to use the
+ 	  older-style format.  See notes on tags formats and MTD versions
+ 	  in yaffs_mtdif1.c.
+ 
+ 	  If unsure, say N.
+ 
+ config YAFFS_DOES_ECC
+ 	bool "Lets Yaffs do its own ECC"
+ 	depends on YAFFS_FS && YAFFS_YAFFS1 && !YAFFS_9BYTE_TAGS
+ 	default n
+ 	help
+ 	  This enables Yaffs to use its own ECC functions instead of using
+ 	  the ones from the generic MTD-NAND driver.
+ 
+ 	  If unsure, say N.
+ 
+ config YAFFS_ECC_WRONG_ORDER
+ 	bool "Use the same ecc byte order as Steven Hill's nand_ecc.c"
+ 	depends on YAFFS_FS && YAFFS_DOES_ECC && !YAFFS_9BYTE_TAGS
+ 	default n
+ 	help
+ 	  This makes yaffs_ecc.c use the same ecc byte order as Steven
+ 	  Hill's nand_ecc.c. If not set, then you get the same ecc byte
+ 	  order as SmartMedia.
+ 
+ 	  If unsure, say N.
+ 
+ config YAFFS_YAFFS2
+ 	bool "2048 byte (or larger) / page devices"
+ 	depends on YAFFS_FS
+ 	default y
+ 	help
+ 	  Enable YAFFS2 support -- yaffs for >= 2K bytes per page devices
+ 
+ 	  If unsure, say Y.
+ 
+ config YAFFS_AUTO_YAFFS2
+ 	bool "Autoselect yaffs2 format"
+ 	depends on YAFFS_YAFFS2
+ 	default y
+ 	help
+ 	  Without this, you need to explicitely use yaffs2 as the file
+ 	  system type. With this, you can say "yaffs" and yaffs or yaffs2
+ 	  will be used depending on the device page size (yaffs on
+ 	  512-byte page devices, yaffs2 on 2K page devices).
+ 
+ 	  If unsure, say Y.
+ 
+ config YAFFS_DISABLE_TAGS_ECC
+ 	bool "Disable YAFFS from doing ECC on tags by default"
+ 	depends on YAFFS_FS && YAFFS_YAFFS2
+ 	default n
+ 	help
+ 	  This defaults Yaffs to using its own ECC calculations on tags instead of
+ 	  just relying on the MTD.
+ 	  This behavior can also be overridden with tags_ecc_on and
+ 	  tags_ecc_off mount options.
+ 
+ 	  If unsure, say N.
+ 
+ 
+ config YAFFS_DISABLE_WIDE_TNODES
+ 	bool "Turn off wide tnodes"
+ 	depends on YAFFS_FS
+ 	default n
+ 	help
+ 	  Wide tnodes are only used for NAND arrays >=32MB for 512-byte
+ 	  page devices and >=128MB for 2k page devices. They use slightly
+ 	  more RAM but are faster since they eliminate chunk group
+ 	  searching.
+ 
+ 	  Setting this to 'y' will force tnode width to 16 bits and save
+ 	  memory but make large arrays slower.
+ 
+ 	  If unsure, say N.
+ 
+ config YAFFS_ALWAYS_CHECK_CHUNK_ERASED
+ 	bool "Force chunk erase check"
+ 	depends on YAFFS_FS
+ 	default n
+ 	help
+           Normally YAFFS only checks chunks before writing until an erased
+ 	  chunk is found. This helps to detect any partially written
+ 	  chunks that might have happened due to power loss.
+ 
+ 	  Enabling this forces on the test that chunks are erased in flash
+ 	  before writing to them. This takes more time but is potentially
+ 	  a bit more secure.
+ 
+ 	  Suggest setting Y during development and ironing out driver
+ 	  issues etc. Suggest setting to N if you want faster writing.
+ 
+ 	  If unsure, say Y.
+ 
+ config YAFFS_SHORT_NAMES_IN_RAM
+ 	bool "Cache short names in RAM"
+ 	depends on YAFFS_FS
+ 	default y
+ 	help
+ 	  If this config is set, then short names are stored with the
+ 	  yaffs_Object.  This costs an extra 16 bytes of RAM per object,
+ 	  but makes look-ups faster.
+ 
+ 	  If unsure, say Y.
+ 
+ config YAFFS_EMPTY_LOST_AND_FOUND
+ 	bool "Empty lost and found on boot"
+ 	depends on YAFFS_FS
+ 	default n
+ 	help
+ 	  If this is enabled then the contents of lost and found is
+ 	  automatically dumped at mount.
+ 
+ 	  If unsure, say N.
+ 
+ config YAFFS_DISABLE_BLOCK_REFRESHING
+ 	bool "Disable yaffs2 block refreshing"
+ 	depends on YAFFS_FS
+ 	default n
+ 	help
+ 	 If this is set, then block refreshing is disabled.
+ 	 Block refreshing infrequently refreshes the oldest block in
+ 	 a yaffs2 file system. This mechanism helps to refresh flash to
+ 	 mitigate against data loss. This is particularly useful for MLC.
+ 
+ 	  If unsure, say N.
+ 
+ config YAFFS_DISABLE_BACKGROUND
+ 	bool "Disable yaffs2 background processing"
+ 	depends on YAFFS_FS
+ 	default n
+ 	help
+ 	 If this is set, then background processing is disabled.
+ 	 Background processing makes many foreground activities faster.
+ 
+ 	  If unsure, say N.
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/Makefile liab-linux-2.6.29.4/fs/yaffs2/Makefile
*** linux-2.6.29.4/fs/yaffs2/Makefile	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/Makefile	2012-01-20 14:48:21.865306031 +0100
***************
*** 0 ****
--- 1,10 ----
+ #
+ # Makefile for the linux YAFFS filesystem routines.
+ #
+ 
+ obj-$(CONFIG_YAFFS_FS) += yaffs.o
+ 
+ yaffs-y := yaffs_ecc.o yaffs_fs.o yaffs_guts.o yaffs_checkptrw.o
+ yaffs-y += yaffs_packedtags1.o yaffs_packedtags2.o yaffs_nand.o yaffs_qsort.o
+ yaffs-y += yaffs_tagscompat.o yaffs_tagsvalidity.o
+ yaffs-y += yaffs_mtdif.o yaffs_mtdif1.o yaffs_mtdif2.o
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/moduleconfig.h liab-linux-2.6.29.4/fs/yaffs2/moduleconfig.h
*** linux-2.6.29.4/fs/yaffs2/moduleconfig.h	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/moduleconfig.h	2012-01-20 14:48:21.869306031 +0100
***************
*** 0 ****
--- 1,82 ----
+ /*
+  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+  *
+  * Copyright (C) 2002-2010 Aleph One Ltd.
+  *   for Toby Churchill Ltd and Brightstar Engineering
+  *
+  * Created by Martin Fouts <Martin.Fouts@palmsource.com>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU Lesser General Public License version 2.1 as
+  * published by the Free Software Foundation.
+  *
+  * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+  */
+ 
+ #ifndef __YAFFS_CONFIG_H__
+ #define __YAFFS_CONFIG_H__
+ 
+ #ifdef YAFFS_OUT_OF_TREE
+ 
+ /* DO NOT UNSET THESE THREE. YAFFS2 will not compile if you do. */
+ #define CONFIG_YAFFS_FS
+ #define CONFIG_YAFFS_YAFFS1
+ #define CONFIG_YAFFS_YAFFS2
+ 
+ /* These options are independent of each other.  Select those that matter. */
+ 
+ /* Default: Not selected */
+ /* Meaning: Yaffs does its own ECC, rather than using MTD ECC */
+ /* #define CONFIG_YAFFS_DOES_ECC */
+ 
+ /* Default: Selected */
+ /* Meaning: Yaffs does its own ECC on tags for packed tags rather than use mtd */
+ #define CONFIG_YAFFS_DOES_TAGS_ECC
+ 
+ /* Default: Not selected */
+ /* Meaning: ECC byte order is 'wrong'.  Only meaningful if */
+ /*          CONFIG_YAFFS_DOES_ECC is set */
+ /* #define CONFIG_YAFFS_ECC_WRONG_ORDER */
+ 
+ /* Default: Not selected */
+ /* Meaning: Always test whether chunks are erased before writing to them.
+ 	    Use during mtd debugging and init. */
+ /* #define CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED */
+ 
+ /* Default: Not Selected */
+ /* Meaning: At mount automatically empty all files from lost and found. */
+ /* This is done to fix an old problem where rmdir was not checking for an */
+ /* empty directory. This can also be achieved with a mount option. */
+ #define CONFIG_YAFFS_EMPTY_LOST_AND_FOUND
+ 
+ /* Default: Selected */
+ /* Meaning: Cache short names, taking more RAM, but faster look-ups */
+ #define CONFIG_YAFFS_SHORT_NAMES_IN_RAM
+ 
+ /* Default: Unselected */
+ /* Meaning: Select to disable block refreshing. */
+ /* Block Refreshing periodically rewrites the oldest block. */
+ /* #define CONFIG_DISABLE_BLOCK_REFRESHING */
+ 
+ /* Default: Unselected */
+ /* Meaning: Select to disable background processing */
+ /* #define CONFIG_DISABLE_BACKGROUND */
+ 
+ 
+ /*
+ Older-style on-NAND data format has a "pageStatus" byte to record
+ chunk/page state.  This byte is zeroed when the page is discarded.
+ Choose this option if you have existing on-NAND data in this format
+ that you need to continue to support.  New data written also uses the
+ older-style format.
+ Note: Use of this option generally requires that MTD's oob layout be
+ adjusted to use the older-style format.  See notes on tags formats and
+ MTD versions in yaffs_mtdif1.c.
+ */
+ /* Default: Not selected */
+ /* Meaning: Use older-style on-NAND data format with pageStatus byte */
+ /* #define CONFIG_YAFFS_9BYTE_TAGS */
+ 
+ #endif /* YAFFS_OUT_OF_TREE */
+ 
+ #endif /* __YAFFS_CONFIG_H__ */
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/yaffs_checkptrw.c liab-linux-2.6.29.4/fs/yaffs2/yaffs_checkptrw.c
*** linux-2.6.29.4/fs/yaffs2/yaffs_checkptrw.c	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/yaffs_checkptrw.c	2012-01-20 14:48:21.869306031 +0100
***************
*** 0 ****
--- 1,401 ----
+ /*
+  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+  *
+  * Copyright (C) 2002-2010 Aleph One Ltd.
+  *   for Toby Churchill Ltd and Brightstar Engineering
+  *
+  * Created by Charles Manning <charles@aleph1.co.uk>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2 as
+  * published by the Free Software Foundation.
+  */
+ 
+ #include "yaffs_checkptrw.h"
+ #include "yaffs_getblockinfo.h"
+ 
+ static int yaffs_CheckpointSpaceOk(yaffs_Device *dev)
+ {
+ 	int blocksAvailable = dev->nErasedBlocks - dev->param.nReservedBlocks;
+ 
+ 	T(YAFFS_TRACE_CHECKPOINT,
+ 		(TSTR("checkpt blocks available = %d" TENDSTR),
+ 		blocksAvailable));
+ 
+ 	return (blocksAvailable <= 0) ? 0 : 1;
+ }
+ 
+ 
+ static int yaffs_CheckpointErase(yaffs_Device *dev)
+ {
+ 	int i;
+ 
+ 	if (!dev->param.eraseBlockInNAND)
+ 		return 0;
+ 	T(YAFFS_TRACE_CHECKPOINT, (TSTR("checking blocks %d to %d"TENDSTR),
+ 		dev->internalStartBlock, dev->internalEndBlock));
+ 
+ 	for (i = dev->internalStartBlock; i <= dev->internalEndBlock; i++) {
+ 		yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, i);
+ 		if (bi->blockState == YAFFS_BLOCK_STATE_CHECKPOINT) {
+ 			T(YAFFS_TRACE_CHECKPOINT, (TSTR("erasing checkpt block %d"TENDSTR), i));
+ 
+ 			dev->nBlockErasures++;
+ 
+ 			if (dev->param.eraseBlockInNAND(dev, i - dev->blockOffset /* realign */)) {
+ 				bi->blockState = YAFFS_BLOCK_STATE_EMPTY;
+ 				dev->nErasedBlocks++;
+ 				dev->nFreeChunks += dev->param.nChunksPerBlock;
+ 			} else {
+ 				dev->param.markNANDBlockBad(dev, i);
+ 				bi->blockState = YAFFS_BLOCK_STATE_DEAD;
+ 			}
+ 		}
+ 	}
+ 
+ 	dev->blocksInCheckpoint = 0;
+ 
+ 	return 1;
+ }
+ 
+ 
+ static void yaffs_CheckpointFindNextErasedBlock(yaffs_Device *dev)
+ {
+ 	int  i;
+ 	int blocksAvailable = dev->nErasedBlocks - dev->param.nReservedBlocks;
+ 	T(YAFFS_TRACE_CHECKPOINT,
+ 		(TSTR("allocating checkpt block: erased %d reserved %d avail %d next %d "TENDSTR),
+ 		dev->nErasedBlocks, dev->param.nReservedBlocks, blocksAvailable, dev->checkpointNextBlock));
+ 
+ 	if (dev->checkpointNextBlock >= 0 &&
+ 			dev->checkpointNextBlock <= dev->internalEndBlock &&
+ 			blocksAvailable > 0) {
+ 
+ 		for (i = dev->checkpointNextBlock; i <= dev->internalEndBlock; i++) {
+ 			yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, i);
+ 			if (bi->blockState == YAFFS_BLOCK_STATE_EMPTY) {
+ 				dev->checkpointNextBlock = i + 1;
+ 				dev->checkpointCurrentBlock = i;
+ 				T(YAFFS_TRACE_CHECKPOINT, (TSTR("allocating checkpt block %d"TENDSTR), i));
+ 				return;
+ 			}
+ 		}
+ 	}
+ 	T(YAFFS_TRACE_CHECKPOINT, (TSTR("out of checkpt blocks"TENDSTR)));
+ 
+ 	dev->checkpointNextBlock = -1;
+ 	dev->checkpointCurrentBlock = -1;
+ }
+ 
+ static void yaffs_CheckpointFindNextCheckpointBlock(yaffs_Device *dev)
+ {
+ 	int  i;
+ 	yaffs_ExtendedTags tags;
+ 
+ 	T(YAFFS_TRACE_CHECKPOINT, (TSTR("find next checkpt block: start:  blocks %d next %d" TENDSTR),
+ 		dev->blocksInCheckpoint, dev->checkpointNextBlock));
+ 
+ 	if (dev->blocksInCheckpoint < dev->checkpointMaxBlocks)
+ 		for (i = dev->checkpointNextBlock; i <= dev->internalEndBlock; i++) {
+ 			int chunk = i * dev->param.nChunksPerBlock;
+ 			int realignedChunk = chunk - dev->chunkOffset;
+ 
+ 			dev->param.readChunkWithTagsFromNAND(dev, realignedChunk,
+ 					NULL, &tags);
+ 			T(YAFFS_TRACE_CHECKPOINT, (TSTR("find next checkpt block: search: block %d oid %d seq %d eccr %d" TENDSTR),
+ 				i, tags.objectId, tags.sequenceNumber, tags.eccResult));
+ 
+ 			if (tags.sequenceNumber == YAFFS_SEQUENCE_CHECKPOINT_DATA) {
+ 				/* Right kind of block */
+ 				dev->checkpointNextBlock = tags.objectId;
+ 				dev->checkpointCurrentBlock = i;
+ 				dev->checkpointBlockList[dev->blocksInCheckpoint] = i;
+ 				dev->blocksInCheckpoint++;
+ 				T(YAFFS_TRACE_CHECKPOINT, (TSTR("found checkpt block %d"TENDSTR), i));
+ 				return;
+ 			}
+ 		}
+ 
+ 	T(YAFFS_TRACE_CHECKPOINT, (TSTR("found no more checkpt blocks"TENDSTR)));
+ 
+ 	dev->checkpointNextBlock = -1;
+ 	dev->checkpointCurrentBlock = -1;
+ }
+ 
+ 
+ int yaffs_CheckpointOpen(yaffs_Device *dev, int forWriting)
+ {
+ 
+ 
+ 	dev->checkpointOpenForWrite = forWriting;
+ 
+ 	/* Got the functions we need? */
+ 	if (!dev->param.writeChunkWithTagsToNAND ||
+ 		!dev->param.readChunkWithTagsFromNAND ||
+ 		!dev->param.eraseBlockInNAND ||
+ 		!dev->param.markNANDBlockBad)
+ 		return 0;
+ 
+ 	if (forWriting && !yaffs_CheckpointSpaceOk(dev))
+ 		return 0;
+ 
+ 	if (!dev->checkpointBuffer)
+ 		dev->checkpointBuffer = YMALLOC_DMA(dev->param.totalBytesPerChunk);
+ 	if (!dev->checkpointBuffer)
+ 		return 0;
+ 
+ 
+ 	dev->checkpointPageSequence = 0;
+ 	dev->checkpointByteCount = 0;
+ 	dev->checkpointSum = 0;
+ 	dev->checkpointXor = 0;
+ 	dev->checkpointCurrentBlock = -1;
+ 	dev->checkpointCurrentChunk = -1;
+ 	dev->checkpointNextBlock = dev->internalStartBlock;
+ 
+ 	/* Erase all the blocks in the checkpoint area */
+ 	if (forWriting) {
+ 		memset(dev->checkpointBuffer, 0, dev->nDataBytesPerChunk);
+ 		dev->checkpointByteOffset = 0;
+ 		return yaffs_CheckpointErase(dev);
+ 	} else {
+ 		int i;
+ 		/* Set to a value that will kick off a read */
+ 		dev->checkpointByteOffset = dev->nDataBytesPerChunk;
+ 		/* A checkpoint block list of 1 checkpoint block per 16 block is (hopefully)
+ 		 * going to be way more than we need */
+ 		dev->blocksInCheckpoint = 0;
+ 		dev->checkpointMaxBlocks = (dev->internalEndBlock - dev->internalStartBlock)/16 + 2;
+ 		dev->checkpointBlockList = YMALLOC(sizeof(int) * dev->checkpointMaxBlocks);
+ 		if(!dev->checkpointBlockList)
+ 			return 0;
+ 
+ 		for (i = 0; i < dev->checkpointMaxBlocks; i++)
+ 			dev->checkpointBlockList[i] = -1;
+ 	}
+ 
+ 	return 1;
+ }
+ 
+ int yaffs_GetCheckpointSum(yaffs_Device *dev, __u32 *sum)
+ {
+ 	__u32 compositeSum;
+ 	compositeSum =  (dev->checkpointSum << 8) | (dev->checkpointXor & 0xFF);
+ 	*sum = compositeSum;
+ 	return 1;
+ }
+ 
+ static int yaffs_CheckpointFlushBuffer(yaffs_Device *dev)
+ {
+ 	int chunk;
+ 	int realignedChunk;
+ 
+ 	yaffs_ExtendedTags tags;
+ 
+ 	if (dev->checkpointCurrentBlock < 0) {
+ 		yaffs_CheckpointFindNextErasedBlock(dev);
+ 		dev->checkpointCurrentChunk = 0;
+ 	}
+ 
+ 	if (dev->checkpointCurrentBlock < 0)
+ 		return 0;
+ 
+ 	tags.chunkDeleted = 0;
+ 	tags.objectId = dev->checkpointNextBlock; /* Hint to next place to look */
+ 	tags.chunkId = dev->checkpointPageSequence + 1;
+ 	tags.sequenceNumber =  YAFFS_SEQUENCE_CHECKPOINT_DATA;
+ 	tags.byteCount = dev->nDataBytesPerChunk;
+ 	if (dev->checkpointCurrentChunk == 0) {
+ 		/* First chunk we write for the block? Set block state to
+ 		   checkpoint */
+ 		yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, dev->checkpointCurrentBlock);
+ 		bi->blockState = YAFFS_BLOCK_STATE_CHECKPOINT;
+ 		dev->blocksInCheckpoint++;
+ 	}
+ 
+ 	chunk = dev->checkpointCurrentBlock * dev->param.nChunksPerBlock + dev->checkpointCurrentChunk;
+ 
+ 
+ 	T(YAFFS_TRACE_CHECKPOINT, (TSTR("checkpoint wite buffer nand %d(%d:%d) objid %d chId %d" TENDSTR),
+ 		chunk, dev->checkpointCurrentBlock, dev->checkpointCurrentChunk, tags.objectId, tags.chunkId));
+ 
+ 	realignedChunk = chunk - dev->chunkOffset;
+ 
+ 	dev->nPageWrites++;
+ 
+ 	dev->param.writeChunkWithTagsToNAND(dev, realignedChunk,
+ 			dev->checkpointBuffer, &tags);
+ 	dev->checkpointByteOffset = 0;
+ 	dev->checkpointPageSequence++;
+ 	dev->checkpointCurrentChunk++;
+ 	if (dev->checkpointCurrentChunk >= dev->param.nChunksPerBlock) {
+ 		dev->checkpointCurrentChunk = 0;
+ 		dev->checkpointCurrentBlock = -1;
+ 	}
+ 	memset(dev->checkpointBuffer, 0, dev->nDataBytesPerChunk);
+ 
+ 	return 1;
+ }
+ 
+ 
+ int yaffs_CheckpointWrite(yaffs_Device *dev, const void *data, int nBytes)
+ {
+ 	int i = 0;
+ 	int ok = 1;
+ 
+ 
+ 	__u8 * dataBytes = (__u8 *)data;
+ 
+ 
+ 
+ 	if (!dev->checkpointBuffer)
+ 		return 0;
+ 
+ 	if (!dev->checkpointOpenForWrite)
+ 		return -1;
+ 
+ 	while (i < nBytes && ok) {
+ 		dev->checkpointBuffer[dev->checkpointByteOffset] = *dataBytes;
+ 		dev->checkpointSum += *dataBytes;
+ 		dev->checkpointXor ^= *dataBytes;
+ 
+ 		dev->checkpointByteOffset++;
+ 		i++;
+ 		dataBytes++;
+ 		dev->checkpointByteCount++;
+ 
+ 
+ 		if (dev->checkpointByteOffset < 0 ||
+ 		   dev->checkpointByteOffset >= dev->nDataBytesPerChunk)
+ 			ok = yaffs_CheckpointFlushBuffer(dev);
+ 	}
+ 
+ 	return i;
+ }
+ 
+ int yaffs_CheckpointRead(yaffs_Device *dev, void *data, int nBytes)
+ {
+ 	int i = 0;
+ 	int ok = 1;
+ 	yaffs_ExtendedTags tags;
+ 
+ 
+ 	int chunk;
+ 	int realignedChunk;
+ 
+ 	__u8 *dataBytes = (__u8 *)data;
+ 
+ 	if (!dev->checkpointBuffer)
+ 		return 0;
+ 
+ 	if (dev->checkpointOpenForWrite)
+ 		return -1;
+ 
+ 	while (i < nBytes && ok) {
+ 
+ 
+ 		if (dev->checkpointByteOffset < 0 ||
+ 			dev->checkpointByteOffset >= dev->nDataBytesPerChunk) {
+ 
+ 			if (dev->checkpointCurrentBlock < 0) {
+ 				yaffs_CheckpointFindNextCheckpointBlock(dev);
+ 				dev->checkpointCurrentChunk = 0;
+ 			}
+ 
+ 			if (dev->checkpointCurrentBlock < 0)
+ 				ok = 0;
+ 			else {
+ 				chunk = dev->checkpointCurrentBlock *
+ 					dev->param.nChunksPerBlock +
+ 					dev->checkpointCurrentChunk;
+ 
+ 				realignedChunk = chunk - dev->chunkOffset;
+ 				
+ 				dev->nPageReads++;
+ 
+ 				/* read in the next chunk */
+ 				/* printf("read checkpoint page %d\n",dev->checkpointPage); */
+ 				dev->param.readChunkWithTagsFromNAND(dev,
+ 						realignedChunk,
+ 						dev->checkpointBuffer,
+ 						&tags);
+ 
+ 				if (tags.chunkId != (dev->checkpointPageSequence + 1) ||
+ 					tags.eccResult > YAFFS_ECC_RESULT_FIXED ||
+ 					tags.sequenceNumber != YAFFS_SEQUENCE_CHECKPOINT_DATA)
+ 					ok = 0;
+ 
+ 				dev->checkpointByteOffset = 0;
+ 				dev->checkpointPageSequence++;
+ 				dev->checkpointCurrentChunk++;
+ 
+ 				if (dev->checkpointCurrentChunk >= dev->param.nChunksPerBlock)
+ 					dev->checkpointCurrentBlock = -1;
+ 			}
+ 		}
+ 
+ 		if (ok) {
+ 			*dataBytes = dev->checkpointBuffer[dev->checkpointByteOffset];
+ 			dev->checkpointSum += *dataBytes;
+ 			dev->checkpointXor ^= *dataBytes;
+ 			dev->checkpointByteOffset++;
+ 			i++;
+ 			dataBytes++;
+ 			dev->checkpointByteCount++;
+ 		}
+ 	}
+ 
+ 	return 	i;
+ }
+ 
+ int yaffs_CheckpointClose(yaffs_Device *dev)
+ {
+ 
+ 	if (dev->checkpointOpenForWrite) {
+ 		if (dev->checkpointByteOffset != 0)
+ 			yaffs_CheckpointFlushBuffer(dev);
+ 	} else if(dev->checkpointBlockList){
+ 		int i;
+ 		for (i = 0; i < dev->blocksInCheckpoint && dev->checkpointBlockList[i] >= 0; i++) {
+ 			int blk = dev->checkpointBlockList[i];
+ 			yaffs_BlockInfo *bi = NULL;
+ 			if( dev->internalStartBlock <= blk && blk <= dev->internalEndBlock)
+ 				bi = yaffs_GetBlockInfo(dev, blk);
+ 			if (bi && bi->blockState == YAFFS_BLOCK_STATE_EMPTY)
+ 				bi->blockState = YAFFS_BLOCK_STATE_CHECKPOINT;
+ 			else {
+ 				/* Todo this looks odd... */
+ 			}
+ 		}
+ 		YFREE(dev->checkpointBlockList);
+ 		dev->checkpointBlockList = NULL;
+ 	}
+ 
+ 	dev->nFreeChunks -= dev->blocksInCheckpoint * dev->param.nChunksPerBlock;
+ 	dev->nErasedBlocks -= dev->blocksInCheckpoint;
+ 
+ 
+ 	T(YAFFS_TRACE_CHECKPOINT, (TSTR("checkpoint byte count %d" TENDSTR),
+ 			dev->checkpointByteCount));
+ 
+ 	if (dev->checkpointBuffer) {
+ 		/* free the buffer */
+ 		YFREE(dev->checkpointBuffer);
+ 		dev->checkpointBuffer = NULL;
+ 		return 1;
+ 	} else
+ 		return 0;
+ }
+ 
+ int yaffs_CheckpointInvalidateStream(yaffs_Device *dev)
+ {
+ 	/* Erase the checkpoint data */
+ 
+ 	T(YAFFS_TRACE_CHECKPOINT, (TSTR("checkpoint invalidate of %d blocks"TENDSTR),
+ 		dev->blocksInCheckpoint));
+ 
+ 	return yaffs_CheckpointErase(dev);
+ }
+ 
+ 
+ 
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/yaffs_checkptrw.h liab-linux-2.6.29.4/fs/yaffs2/yaffs_checkptrw.h
*** linux-2.6.29.4/fs/yaffs2/yaffs_checkptrw.h	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/yaffs_checkptrw.h	2012-01-20 14:48:21.869306031 +0100
***************
*** 0 ****
--- 1,34 ----
+ /*
+  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+  *
+  * Copyright (C) 2002-2010 Aleph One Ltd.
+  *   for Toby Churchill Ltd and Brightstar Engineering
+  *
+  * Created by Charles Manning <charles@aleph1.co.uk>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU Lesser General Public License version 2.1 as
+  * published by the Free Software Foundation.
+  *
+  * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+  */
+ 
+ #ifndef __YAFFS_CHECKPTRW_H__
+ #define __YAFFS_CHECKPTRW_H__
+ 
+ #include "yaffs_guts.h"
+ 
+ int yaffs_CheckpointOpen(yaffs_Device *dev, int forWriting);
+ 
+ int yaffs_CheckpointWrite(yaffs_Device *dev, const void *data, int nBytes);
+ 
+ int yaffs_CheckpointRead(yaffs_Device *dev, void *data, int nBytes);
+ 
+ int yaffs_GetCheckpointSum(yaffs_Device *dev, __u32 *sum);
+ 
+ int yaffs_CheckpointClose(yaffs_Device *dev);
+ 
+ int yaffs_CheckpointInvalidateStream(yaffs_Device *dev);
+ 
+ 
+ #endif
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/yaffs_ecc.c liab-linux-2.6.29.4/fs/yaffs2/yaffs_ecc.c
*** linux-2.6.29.4/fs/yaffs2/yaffs_ecc.c	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/yaffs_ecc.c	2012-01-20 14:48:21.861306032 +0100
***************
*** 0 ****
--- 1,323 ----
+ /*
+  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+  *
+  * Copyright (C) 2002-2010 Aleph One Ltd.
+  *   for Toby Churchill Ltd and Brightstar Engineering
+  *
+  * Created by Charles Manning <charles@aleph1.co.uk>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2 as
+  * published by the Free Software Foundation.
+  */
+ 
+ /*
+  * This code implements the ECC algorithm used in SmartMedia.
+  *
+  * The ECC comprises 22 bits of parity information and is stuffed into 3 bytes.
+  * The two unused bit are set to 1.
+  * The ECC can correct single bit errors in a 256-byte page of data. Thus, two such ECC
+  * blocks are used on a 512-byte NAND page.
+  *
+  */
+ 
+ /* Table generated by gen-ecc.c
+  * Using a table means we do not have to calculate p1..p4 and p1'..p4'
+  * for each byte of data. These are instead provided in a table in bits7..2.
+  * Bit 0 of each entry indicates whether the entry has an odd or even parity, and therefore
+  * this bytes influence on the line parity.
+  */
+ 
+ #include "yportenv.h"
+ 
+ #include "yaffs_ecc.h"
+ 
+ static const unsigned char column_parity_table[] = {
+ 	0x00, 0x55, 0x59, 0x0c, 0x65, 0x30, 0x3c, 0x69,
+ 	0x69, 0x3c, 0x30, 0x65, 0x0c, 0x59, 0x55, 0x00,
+ 	0x95, 0xc0, 0xcc, 0x99, 0xf0, 0xa5, 0xa9, 0xfc,
+ 	0xfc, 0xa9, 0xa5, 0xf0, 0x99, 0xcc, 0xc0, 0x95,
+ 	0x99, 0xcc, 0xc0, 0x95, 0xfc, 0xa9, 0xa5, 0xf0,
+ 	0xf0, 0xa5, 0xa9, 0xfc, 0x95, 0xc0, 0xcc, 0x99,
+ 	0x0c, 0x59, 0x55, 0x00, 0x69, 0x3c, 0x30, 0x65,
+ 	0x65, 0x30, 0x3c, 0x69, 0x00, 0x55, 0x59, 0x0c,
+ 	0xa5, 0xf0, 0xfc, 0xa9, 0xc0, 0x95, 0x99, 0xcc,
+ 	0xcc, 0x99, 0x95, 0xc0, 0xa9, 0xfc, 0xf0, 0xa5,
+ 	0x30, 0x65, 0x69, 0x3c, 0x55, 0x00, 0x0c, 0x59,
+ 	0x59, 0x0c, 0x00, 0x55, 0x3c, 0x69, 0x65, 0x30,
+ 	0x3c, 0x69, 0x65, 0x30, 0x59, 0x0c, 0x00, 0x55,
+ 	0x55, 0x00, 0x0c, 0x59, 0x30, 0x65, 0x69, 0x3c,
+ 	0xa9, 0xfc, 0xf0, 0xa5, 0xcc, 0x99, 0x95, 0xc0,
+ 	0xc0, 0x95, 0x99, 0xcc, 0xa5, 0xf0, 0xfc, 0xa9,
+ 	0xa9, 0xfc, 0xf0, 0xa5, 0xcc, 0x99, 0x95, 0xc0,
+ 	0xc0, 0x95, 0x99, 0xcc, 0xa5, 0xf0, 0xfc, 0xa9,
+ 	0x3c, 0x69, 0x65, 0x30, 0x59, 0x0c, 0x00, 0x55,
+ 	0x55, 0x00, 0x0c, 0x59, 0x30, 0x65, 0x69, 0x3c,
+ 	0x30, 0x65, 0x69, 0x3c, 0x55, 0x00, 0x0c, 0x59,
+ 	0x59, 0x0c, 0x00, 0x55, 0x3c, 0x69, 0x65, 0x30,
+ 	0xa5, 0xf0, 0xfc, 0xa9, 0xc0, 0x95, 0x99, 0xcc,
+ 	0xcc, 0x99, 0x95, 0xc0, 0xa9, 0xfc, 0xf0, 0xa5,
+ 	0x0c, 0x59, 0x55, 0x00, 0x69, 0x3c, 0x30, 0x65,
+ 	0x65, 0x30, 0x3c, 0x69, 0x00, 0x55, 0x59, 0x0c,
+ 	0x99, 0xcc, 0xc0, 0x95, 0xfc, 0xa9, 0xa5, 0xf0,
+ 	0xf0, 0xa5, 0xa9, 0xfc, 0x95, 0xc0, 0xcc, 0x99,
+ 	0x95, 0xc0, 0xcc, 0x99, 0xf0, 0xa5, 0xa9, 0xfc,
+ 	0xfc, 0xa9, 0xa5, 0xf0, 0x99, 0xcc, 0xc0, 0x95,
+ 	0x00, 0x55, 0x59, 0x0c, 0x65, 0x30, 0x3c, 0x69,
+ 	0x69, 0x3c, 0x30, 0x65, 0x0c, 0x59, 0x55, 0x00,
+ };
+ 
+ /* Count the bits in an unsigned char or a U32 */
+ 
+ static int yaffs_CountBits(unsigned char x)
+ {
+ 	int r = 0;
+ 	while (x) {
+ 		if (x & 1)
+ 			r++;
+ 		x >>= 1;
+ 	}
+ 	return r;
+ }
+ 
+ static int yaffs_CountBits32(unsigned x)
+ {
+ 	int r = 0;
+ 	while (x) {
+ 		if (x & 1)
+ 			r++;
+ 		x >>= 1;
+ 	}
+ 	return r;
+ }
+ 
+ /* Calculate the ECC for a 256-byte block of data */
+ void yaffs_ECCCalculate(const unsigned char *data, unsigned char *ecc)
+ {
+ 	unsigned int i;
+ 
+ 	unsigned char col_parity = 0;
+ 	unsigned char line_parity = 0;
+ 	unsigned char line_parity_prime = 0;
+ 	unsigned char t;
+ 	unsigned char b;
+ 
+ 	for (i = 0; i < 256; i++) {
+ 		b = column_parity_table[*data++];
+ 		col_parity ^= b;
+ 
+ 		if (b & 0x01) {		/* odd number of bits in the byte */
+ 			line_parity ^= i;
+ 			line_parity_prime ^= ~i;
+ 		}
+ 	}
+ 
+ 	ecc[2] = (~col_parity) | 0x03;
+ 
+ 	t = 0;
+ 	if (line_parity & 0x80)
+ 		t |= 0x80;
+ 	if (line_parity_prime & 0x80)
+ 		t |= 0x40;
+ 	if (line_parity & 0x40)
+ 		t |= 0x20;
+ 	if (line_parity_prime & 0x40)
+ 		t |= 0x10;
+ 	if (line_parity & 0x20)
+ 		t |= 0x08;
+ 	if (line_parity_prime & 0x20)
+ 		t |= 0x04;
+ 	if (line_parity & 0x10)
+ 		t |= 0x02;
+ 	if (line_parity_prime & 0x10)
+ 		t |= 0x01;
+ 	ecc[1] = ~t;
+ 
+ 	t = 0;
+ 	if (line_parity & 0x08)
+ 		t |= 0x80;
+ 	if (line_parity_prime & 0x08)
+ 		t |= 0x40;
+ 	if (line_parity & 0x04)
+ 		t |= 0x20;
+ 	if (line_parity_prime & 0x04)
+ 		t |= 0x10;
+ 	if (line_parity & 0x02)
+ 		t |= 0x08;
+ 	if (line_parity_prime & 0x02)
+ 		t |= 0x04;
+ 	if (line_parity & 0x01)
+ 		t |= 0x02;
+ 	if (line_parity_prime & 0x01)
+ 		t |= 0x01;
+ 	ecc[0] = ~t;
+ 
+ #ifdef CONFIG_YAFFS_ECC_WRONG_ORDER
+ 	/* Swap the bytes into the wrong order */
+ 	t = ecc[0];
+ 	ecc[0] = ecc[1];
+ 	ecc[1] = t;
+ #endif
+ }
+ 
+ 
+ /* Correct the ECC on a 256 byte block of data */
+ 
+ int yaffs_ECCCorrect(unsigned char *data, unsigned char *read_ecc,
+ 		     const unsigned char *test_ecc)
+ {
+ 	unsigned char d0, d1, d2;	/* deltas */
+ 
+ 	d0 = read_ecc[0] ^ test_ecc[0];
+ 	d1 = read_ecc[1] ^ test_ecc[1];
+ 	d2 = read_ecc[2] ^ test_ecc[2];
+ 
+ 	if ((d0 | d1 | d2) == 0)
+ 		return 0; /* no error */
+ 
+ 	if (((d0 ^ (d0 >> 1)) & 0x55) == 0x55 &&
+ 	    ((d1 ^ (d1 >> 1)) & 0x55) == 0x55 &&
+ 	    ((d2 ^ (d2 >> 1)) & 0x54) == 0x54) {
+ 		/* Single bit (recoverable) error in data */
+ 
+ 		unsigned byte;
+ 		unsigned bit;
+ 
+ #ifdef CONFIG_YAFFS_ECC_WRONG_ORDER
+ 		/* swap the bytes to correct for the wrong order */
+ 		unsigned char t;
+ 
+ 		t = d0;
+ 		d0 = d1;
+ 		d1 = t;
+ #endif
+ 
+ 		bit = byte = 0;
+ 
+ 		if (d1 & 0x80)
+ 			byte |= 0x80;
+ 		if (d1 & 0x20)
+ 			byte |= 0x40;
+ 		if (d1 & 0x08)
+ 			byte |= 0x20;
+ 		if (d1 & 0x02)
+ 			byte |= 0x10;
+ 		if (d0 & 0x80)
+ 			byte |= 0x08;
+ 		if (d0 & 0x20)
+ 			byte |= 0x04;
+ 		if (d0 & 0x08)
+ 			byte |= 0x02;
+ 		if (d0 & 0x02)
+ 			byte |= 0x01;
+ 
+ 		if (d2 & 0x80)
+ 			bit |= 0x04;
+ 		if (d2 & 0x20)
+ 			bit |= 0x02;
+ 		if (d2 & 0x08)
+ 			bit |= 0x01;
+ 
+ 		data[byte] ^= (1 << bit);
+ 
+ 		return 1; /* Corrected the error */
+ 	}
+ 
+ 	if ((yaffs_CountBits(d0) +
+ 	     yaffs_CountBits(d1) +
+ 	     yaffs_CountBits(d2)) ==  1) {
+ 		/* Reccoverable error in ecc */
+ 
+ 		read_ecc[0] = test_ecc[0];
+ 		read_ecc[1] = test_ecc[1];
+ 		read_ecc[2] = test_ecc[2];
+ 
+ 		return 1; /* Corrected the error */
+ 	}
+ 
+ 	/* Unrecoverable error */
+ 
+ 	return -1;
+ 
+ }
+ 
+ 
+ /*
+  * ECCxxxOther does ECC calcs on arbitrary n bytes of data
+  */
+ void yaffs_ECCCalculateOther(const unsigned char *data, unsigned nBytes,
+ 				yaffs_ECCOther *eccOther)
+ {
+ 	unsigned int i;
+ 
+ 	unsigned char col_parity = 0;
+ 	unsigned line_parity = 0;
+ 	unsigned line_parity_prime = 0;
+ 	unsigned char b;
+ 
+ 	for (i = 0; i < nBytes; i++) {
+ 		b = column_parity_table[*data++];
+ 		col_parity ^= b;
+ 
+ 		if (b & 0x01)	 {
+ 			/* odd number of bits in the byte */
+ 			line_parity ^= i;
+ 			line_parity_prime ^= ~i;
+ 		}
+ 
+ 	}
+ 
+ 	eccOther->colParity = (col_parity >> 2) & 0x3f;
+ 	eccOther->lineParity = line_parity;
+ 	eccOther->lineParityPrime = line_parity_prime;
+ }
+ 
+ int yaffs_ECCCorrectOther(unsigned char *data, unsigned nBytes,
+ 			yaffs_ECCOther *read_ecc,
+ 			const yaffs_ECCOther *test_ecc)
+ {
+ 	unsigned char cDelta;	/* column parity delta */
+ 	unsigned lDelta;	/* line parity delta */
+ 	unsigned lDeltaPrime;	/* line parity delta */
+ 	unsigned bit;
+ 
+ 	cDelta = read_ecc->colParity ^ test_ecc->colParity;
+ 	lDelta = read_ecc->lineParity ^ test_ecc->lineParity;
+ 	lDeltaPrime = read_ecc->lineParityPrime ^ test_ecc->lineParityPrime;
+ 
+ 	if ((cDelta | lDelta | lDeltaPrime) == 0)
+ 		return 0; /* no error */
+ 
+ 	if (lDelta == ~lDeltaPrime &&
+ 	    (((cDelta ^ (cDelta >> 1)) & 0x15) == 0x15)) {
+ 		/* Single bit (recoverable) error in data */
+ 
+ 		bit = 0;
+ 
+ 		if (cDelta & 0x20)
+ 			bit |= 0x04;
+ 		if (cDelta & 0x08)
+ 			bit |= 0x02;
+ 		if (cDelta & 0x02)
+ 			bit |= 0x01;
+ 
+ 		if (lDelta >= nBytes)
+ 			return -1;
+ 
+ 		data[lDelta] ^= (1 << bit);
+ 
+ 		return 1; /* corrected */
+ 	}
+ 
+ 	if ((yaffs_CountBits32(lDelta) + yaffs_CountBits32(lDeltaPrime) +
+ 			yaffs_CountBits(cDelta)) == 1) {
+ 		/* Reccoverable error in ecc */
+ 
+ 		*read_ecc = *test_ecc;
+ 		return 1; /* corrected */
+ 	}
+ 
+ 	/* Unrecoverable error */
+ 
+ 	return -1;
+ }
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/yaffs_ecc.h liab-linux-2.6.29.4/fs/yaffs2/yaffs_ecc.h
*** linux-2.6.29.4/fs/yaffs2/yaffs_ecc.h	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/yaffs_ecc.h	2012-01-20 14:48:21.865306031 +0100
***************
*** 0 ****
--- 1,44 ----
+ /*
+  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+  *
+  * Copyright (C) 2002-2010 Aleph One Ltd.
+  *   for Toby Churchill Ltd and Brightstar Engineering
+  *
+  * Created by Charles Manning <charles@aleph1.co.uk>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU Lesser General Public License version 2.1 as
+  * published by the Free Software Foundation.
+  *
+  * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+  */
+ 
+ /*
+  * This code implements the ECC algorithm used in SmartMedia.
+  *
+  * The ECC comprises 22 bits of parity information and is stuffed into 3 bytes.
+  * The two unused bit are set to 1.
+  * The ECC can correct single bit errors in a 256-byte page of data. Thus, two such ECC
+  * blocks are used on a 512-byte NAND page.
+  *
+  */
+ 
+ #ifndef __YAFFS_ECC_H__
+ #define __YAFFS_ECC_H__
+ 
+ typedef struct {
+ 	unsigned char colParity;
+ 	unsigned lineParity;
+ 	unsigned lineParityPrime;
+ } yaffs_ECCOther;
+ 
+ void yaffs_ECCCalculate(const unsigned char *data, unsigned char *ecc);
+ int yaffs_ECCCorrect(unsigned char *data, unsigned char *read_ecc,
+ 		const unsigned char *test_ecc);
+ 
+ void yaffs_ECCCalculateOther(const unsigned char *data, unsigned nBytes,
+ 			yaffs_ECCOther *ecc);
+ int yaffs_ECCCorrectOther(unsigned char *data, unsigned nBytes,
+ 			yaffs_ECCOther *read_ecc,
+ 			const yaffs_ECCOther *test_ecc);
+ #endif
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/yaffs_fs.c liab-linux-2.6.29.4/fs/yaffs2/yaffs_fs.c
*** linux-2.6.29.4/fs/yaffs2/yaffs_fs.c	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/yaffs_fs.c	2012-01-20 14:48:21.865306031 +0100
***************
*** 0 ****
--- 1,3268 ----
+ /*
+  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+  *
+  * Copyright (C) 2002-2010 Aleph One Ltd.
+  *   for Toby Churchill Ltd and Brightstar Engineering
+  *
+  * Created by Charles Manning <charles@aleph1.co.uk>
+  * Acknowledgements:
+  * Luc van OostenRyck for numerous patches.
+  * Nick Bane for numerous patches.
+  * Nick Bane for 2.5/2.6 integration.
+  * Andras Toth for mknod rdev issue.
+  * Michael Fischer for finding the problem with inode inconsistency.
+  * Some code bodily lifted from JFFS
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2 as
+  * published by the Free Software Foundation.
+  */
+ 
+ /*
+  *
+  * This is the file system front-end to YAFFS that hooks it up to
+  * the VFS.
+  *
+  * Special notes:
+  * >> 2.4: sb->u.generic_sbp points to the yaffs_Device associated with
+  *         this superblock
+  * >> 2.6: sb->s_fs_info  points to the yaffs_Device associated with this
+  *         superblock
+  * >> inode->u.generic_ip points to the associated yaffs_Object.
+  */
+ 
+ #include <linux/version.h>
+ 
+ #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 10))
+ #define YAFFS_COMPILE_BACKGROUND
+ #endif
+ 
+ #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28))
+ #define YAFFS_COMPILE_EXPORTFS
+ #endif
+ 
+ 
+ #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+ #include <linux/config.h>
+ #endif
+ 
+ #include <linux/kernel.h>
+ #include <linux/module.h>
+ #include <linux/slab.h>
+ #include <linux/init.h>
+ #include <linux/fs.h>
+ #include <linux/proc_fs.h>
+ #include <linux/smp_lock.h>
+ #include <linux/pagemap.h>
+ #include <linux/mtd/mtd.h>
+ #include <linux/interrupt.h>
+ #include <linux/string.h>
+ #include <linux/ctype.h>
+ 
+ #ifdef YAFFS_COMPILE_EXPORTFS
+ #include <linux/exportfs.h>
+ #endif
+ 
+ #ifdef YAFFS_COMPILE_BACKGROUND
+ #include <linux/kthread.h>
+ #include <linux/delay.h>
+ #include <linux/freezer.h>
+ #endif
+ 
+ #include <asm/div64.h>
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+ 
+ #include <linux/statfs.h>
+ 
+ #define UnlockPage(p) unlock_page(p)
+ #define Page_Uptodate(page)	test_bit(PG_uptodate, &(page)->flags)
+ 
+ /* FIXME: use sb->s_id instead ? */
+ #define yaffs_devname(sb, buf)	bdevname(sb->s_bdev, buf)
+ 
+ #else
+ 
+ #include <linux/locks.h>
+ #define	BDEVNAME_SIZE		0
+ #define	yaffs_devname(sb, buf)	kdevname(sb->s_dev)
+ 
+ #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0))
+ /* added NCB 26/5/2006 for 2.4.25-vrs2-tcl1 kernel */
+ #define __user
+ #endif
+ 
+ #endif
+ 
+ #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26))
+ #define YPROC_ROOT  (&proc_root)
+ #else
+ #define YPROC_ROOT  NULL
+ #endif
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+ #define WRITE_SIZE_STR "writesize"
+ #define WRITE_SIZE(mtd) ((mtd)->writesize)
+ #else
+ #define WRITE_SIZE_STR "oobblock"
+ #define WRITE_SIZE(mtd) ((mtd)->oobblock)
+ #endif
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 27))
+ #define YAFFS_USE_WRITE_BEGIN_END 1
+ #else
+ #define YAFFS_USE_WRITE_BEGIN_END 0
+ #endif
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 28))
+ static uint32_t YCALCBLOCKS(uint64_t partition_size, uint32_t block_size)
+ {
+ 	uint64_t result = partition_size;
+ 	do_div(result, block_size);
+ 	return (uint32_t)result;
+ }
+ #else
+ #define YCALCBLOCKS(s, b) ((s)/(b))
+ #endif
+ 
+ #include <linux/uaccess.h>
+ #include <linux/mtd/mtd.h>
+ 
+ #include "yportenv.h"
+ #include "yaffs_trace.h"
+ #include "yaffs_guts.h"
+ 
+ #include "yaffs_linux.h"
+ 
+ #include "yaffs_mtdif.h"
+ #include "yaffs_mtdif1.h"
+ #include "yaffs_mtdif2.h"
+ 
+ unsigned int yaffs_traceMask = YAFFS_TRACE_BAD_BLOCKS | YAFFS_TRACE_ALWAYS;
+ unsigned int yaffs_wr_attempts = YAFFS_WR_ATTEMPTS;
+ unsigned int yaffs_auto_checkpoint = 1;
+ unsigned int yaffs_gc_control = 1;
+ 
+ /* Module Parameters */
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+ module_param(yaffs_traceMask, uint, 0644);
+ module_param(yaffs_wr_attempts, uint, 0644);
+ module_param(yaffs_auto_checkpoint, uint, 0644);
+ module_param(yaffs_gc_control, uint, 0644);
+ #else
+ MODULE_PARM(yaffs_traceMask, "i");
+ MODULE_PARM(yaffs_wr_attempts, "i");
+ MODULE_PARM(yaffs_auto_checkpoint, "i");
+ MODULE_PARM(yaffs_gc_control, "i");
+ #endif
+ 
+ #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25))
+ /* use iget and read_inode */
+ #define Y_IGET(sb, inum) iget((sb), (inum))
+ static void yaffs_read_inode(struct inode *inode);
+ 
+ #else
+ /* Call local equivalent */
+ #define YAFFS_USE_OWN_IGET
+ #define Y_IGET(sb, inum) yaffs_iget((sb), (inum))
+ 
+ static struct inode *yaffs_iget(struct super_block *sb, unsigned long ino);
+ #endif
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18))
+ #define yaffs_InodeToObjectLV(iptr) ((iptr)->i_private)
+ #else
+ #define yaffs_InodeToObjectLV(iptr) ((iptr)->u.generic_ip)
+ #endif
+ 
+ #define yaffs_InodeToObject(iptr) ((yaffs_Object *)(yaffs_InodeToObjectLV(iptr)))
+ #define yaffs_DentryToObject(dptr) yaffs_InodeToObject((dptr)->d_inode)
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+ #define yaffs_SuperToDevice(sb)	((yaffs_Device *)sb->s_fs_info)
+ #else
+ #define yaffs_SuperToDevice(sb)	((yaffs_Device *)sb->u.generic_sbp)
+ #endif
+ 
+ 
+ #define update_dir_time(dir) do {\
+ 			(dir)->i_ctime = (dir)->i_mtime = CURRENT_TIME; \
+ 		} while(0)
+ 		
+ static void yaffs_put_super(struct super_block *sb);
+ 
+ static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,
+ 				loff_t *pos);
+ static ssize_t yaffs_hold_space(struct file *f);
+ static void yaffs_release_space(struct file *f);
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+ static int yaffs_file_flush(struct file *file, fl_owner_t id);
+ #else
+ static int yaffs_file_flush(struct file *file);
+ #endif
+ 
+ static int yaffs_sync_object(struct file *file, struct dentry *dentry,
+ 				int datasync);
+ 
+ static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir);
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+ static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode,
+ 			struct nameidata *n);
+ static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,
+ 					struct nameidata *n);
+ #else
+ static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode);
+ static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry);
+ #endif
+ static int yaffs_link(struct dentry *old_dentry, struct inode *dir,
+ 			struct dentry *dentry);
+ static int yaffs_unlink(struct inode *dir, struct dentry *dentry);
+ static int yaffs_symlink(struct inode *dir, struct dentry *dentry,
+ 			const char *symname);
+ static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, int mode);
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+ static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+ 			dev_t dev);
+ #else
+ static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+ 			int dev);
+ #endif
+ static int yaffs_rename(struct inode *old_dir, struct dentry *old_dentry,
+ 			struct inode *new_dir, struct dentry *new_dentry);
+ static int yaffs_setattr(struct dentry *dentry, struct iattr *attr);
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+ static int yaffs_sync_fs(struct super_block *sb, int wait);
+ static void yaffs_write_super(struct super_block *sb);
+ #else
+ static int yaffs_sync_fs(struct super_block *sb);
+ static int yaffs_write_super(struct super_block *sb);
+ #endif
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+ static int yaffs_statfs(struct dentry *dentry, struct kstatfs *buf);
+ #elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+ static int yaffs_statfs(struct super_block *sb, struct kstatfs *buf);
+ #else
+ static int yaffs_statfs(struct super_block *sb, struct statfs *buf);
+ #endif
+ 
+ #ifdef YAFFS_HAS_PUT_INODE
+ static void yaffs_put_inode(struct inode *inode);
+ #endif
+ 
+ static void yaffs_delete_inode(struct inode *);
+ static void yaffs_clear_inode(struct inode *);
+ 
+ static int yaffs_readpage(struct file *file, struct page *page);
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+ static int yaffs_writepage(struct page *page, struct writeback_control *wbc);
+ #else
+ static int yaffs_writepage(struct page *page);
+ #endif
+ 
+ 
+ #if (YAFFS_USE_WRITE_BEGIN_END != 0)
+ static int yaffs_write_begin(struct file *filp, struct address_space *mapping,
+ 				loff_t pos, unsigned len, unsigned flags,
+ 				struct page **pagep, void **fsdata);
+ static int yaffs_write_end(struct file *filp, struct address_space *mapping,
+ 				loff_t pos, unsigned len, unsigned copied,
+ 				struct page *pg, void *fsdadata);
+ #else
+ static int yaffs_prepare_write(struct file *f, struct page *pg,
+ 				unsigned offset, unsigned to);
+ static int yaffs_commit_write(struct file *f, struct page *pg, unsigned offset,
+ 				unsigned to);
+ 
+ #endif
+ 
+ static int yaffs_readlink(struct dentry *dentry, char __user *buffer,
+ 				int buflen);
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13))
+ static void *yaffs_follow_link(struct dentry *dentry, struct nameidata *nd);
+ #else
+ static int yaffs_follow_link(struct dentry *dentry, struct nameidata *nd);
+ #endif
+ static loff_t yaffs_dir_llseek(struct file *file, loff_t offset, int origin);
+ 
+ static struct address_space_operations yaffs_file_address_operations = {
+ 	.readpage = yaffs_readpage,
+ 	.writepage = yaffs_writepage,
+ #if (YAFFS_USE_WRITE_BEGIN_END > 0)
+ 	.write_begin = yaffs_write_begin,
+ 	.write_end = yaffs_write_end,
+ #else
+ 	.prepare_write = yaffs_prepare_write,
+ 	.commit_write = yaffs_commit_write,
+ #endif
+ };
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 22))
+ static const struct file_operations yaffs_file_operations = {
+ 	.read = do_sync_read,
+ 	.write = do_sync_write,
+ 	.aio_read = generic_file_aio_read,
+ 	.aio_write = generic_file_aio_write,
+ 	.mmap = generic_file_mmap,
+ 	.flush = yaffs_file_flush,
+ 	.fsync = yaffs_sync_object,
+ 	.splice_read = generic_file_splice_read,
+ 	.splice_write = generic_file_splice_write,
+ 	.llseek = generic_file_llseek,
+ };
+ 
+ #elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18))
+ 
+ static const struct file_operations yaffs_file_operations = {
+ 	.read = do_sync_read,
+ 	.write = do_sync_write,
+ 	.aio_read = generic_file_aio_read,
+ 	.aio_write = generic_file_aio_write,
+ 	.mmap = generic_file_mmap,
+ 	.flush = yaffs_file_flush,
+ 	.fsync = yaffs_sync_object,
+ 	.sendfile = generic_file_sendfile,
+ };
+ 
+ #else
+ 
+ static const struct file_operations yaffs_file_operations = {
+ 	.read = generic_file_read,
+ 	.write = generic_file_write,
+ 	.mmap = generic_file_mmap,
+ 	.flush = yaffs_file_flush,
+ 	.fsync = yaffs_sync_object,
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+ 	.sendfile = generic_file_sendfile,
+ #endif
+ };
+ #endif
+ 
+ #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25))
+ static void zero_user_segment(struct page *page, unsigned start, unsigned end)
+ {
+ 	void * kaddr = kmap_atomic(page, KM_USER0);
+ 	memset(kaddr + start, 0, end - start);
+ 	kunmap_atomic(kaddr, KM_USER0);
+ 	flush_dcache_page(page);
+ }
+ #endif
+ 
+ 
+ static const struct inode_operations yaffs_file_inode_operations = {
+ 	.setattr = yaffs_setattr,
+ };
+ 
+ static const struct inode_operations yaffs_symlink_inode_operations = {
+ 	.readlink = yaffs_readlink,
+ 	.follow_link = yaffs_follow_link,
+ 	.setattr = yaffs_setattr,
+ };
+ 
+ static const struct inode_operations yaffs_dir_inode_operations = {
+ 	.create = yaffs_create,
+ 	.lookup = yaffs_lookup,
+ 	.link = yaffs_link,
+ 	.unlink = yaffs_unlink,
+ 	.symlink = yaffs_symlink,
+ 	.mkdir = yaffs_mkdir,
+ 	.rmdir = yaffs_unlink,
+ 	.mknod = yaffs_mknod,
+ 	.rename = yaffs_rename,
+ 	.setattr = yaffs_setattr,
+ };
+ 
+ static const struct file_operations yaffs_dir_operations = {
+ 	.read = generic_read_dir,
+ 	.readdir = yaffs_readdir,
+ 	.fsync = yaffs_sync_object,
+ 	.llseek = yaffs_dir_llseek,
+ };
+ 
+ static const struct super_operations yaffs_super_ops = {
+ 	.statfs = yaffs_statfs,
+ 
+ #ifndef YAFFS_USE_OWN_IGET
+ 	.read_inode = yaffs_read_inode,
+ #endif
+ #ifdef YAFFS_HAS_PUT_INODE
+ 	.put_inode = yaffs_put_inode,
+ #endif
+ 	.put_super = yaffs_put_super,
+ 	.delete_inode = yaffs_delete_inode,
+ 	.clear_inode = yaffs_clear_inode,
+ 	.sync_fs = yaffs_sync_fs,
+ 	.write_super = yaffs_write_super,
+ };
+ 
+ static unsigned yaffs_gc_control_callback(yaffs_Device *dev)
+ {
+ 	return yaffs_gc_control;
+ }
+                 	                                                                                          	
+ static void yaffs_GrossLock(yaffs_Device *dev)
+ {
+ 	T(YAFFS_TRACE_LOCK, (TSTR("yaffs locking %p\n"), current));
+ 	down(&(yaffs_DeviceToContext(dev)->grossLock));
+ 	T(YAFFS_TRACE_LOCK, (TSTR("yaffs locked %p\n"), current));
+ }
+ 
+ static void yaffs_GrossUnlock(yaffs_Device *dev)
+ {
+ 	T(YAFFS_TRACE_LOCK, (TSTR("yaffs unlocking %p\n"), current));
+ 	up(&(yaffs_DeviceToContext(dev)->grossLock));
+ }
+ 
+ #ifdef YAFFS_COMPILE_EXPORTFS
+ 
+ static struct inode *
+ yaffs2_nfs_get_inode(struct super_block *sb, uint64_t ino, uint32_t generation)
+ {
+ 	return Y_IGET(sb, ino);
+ }
+ 
+ static struct dentry *
+ yaffs2_fh_to_dentry(struct super_block *sb, struct fid *fid, int fh_len, int fh_type)
+ {
+ 	return generic_fh_to_dentry(sb, fid, fh_len, fh_type, yaffs2_nfs_get_inode) ;
+ }
+ 
+ static struct dentry *
+  yaffs2_fh_to_parent(struct super_block *sb, struct fid *fid, int fh_len, int fh_type)
+ {
+ 	return generic_fh_to_parent(sb, fid, fh_len, fh_type, yaffs2_nfs_get_inode);
+ }
+ 
+ struct dentry *yaffs2_get_parent(struct dentry *dentry)
+ {
+ 
+ 	struct super_block *sb = dentry->d_inode->i_sb;
+ 	struct dentry *parent = ERR_PTR(-ENOENT);
+ 	struct inode *inode;
+ 	unsigned long parent_ino;
+ 	yaffs_Object *d_obj;
+ 	yaffs_Object *parent_obj;
+ 
+ 	d_obj = yaffs_InodeToObject(dentry->d_inode);
+ 
+ 	if (d_obj) {
+ 		parent_obj = d_obj->parent;
+ 		if (parent_obj) {
+ 			parent_ino = yaffs_GetObjectInode(parent_obj);
+ 			inode = Y_IGET(sb, parent_ino);
+ 
+ 			if (IS_ERR(inode)) {
+ 				parent = ERR_CAST(inode);
+ 			} else {
+ 				parent = d_obtain_alias(inode);
+ 				if (!IS_ERR(parent)) {
+ 					parent = ERR_PTR(-ENOMEM);
+ 					iput(inode);
+ 				}
+ 			}
+ 		}
+ 	}
+ 
+ 	return parent;
+ }
+ 
+ /* Just declare a zero structure as a NULL value implies
+  * using the default functions of exportfs.
+  */
+ 
+ static struct export_operations yaffs_export_ops =
+ {
+ 	.fh_to_dentry = yaffs2_fh_to_dentry,
+ 	.fh_to_parent = yaffs2_fh_to_parent,
+ 	.get_parent = yaffs2_get_parent,
+ } ;
+ 
+ #endif
+ 
+ /*-----------------------------------------------------------------*/
+ /* Directory search context allows us to unlock access to yaffs during
+  * filldir without causing problems with the directory being modified.
+  * This is similar to the tried and tested mechanism used in yaffs direct.
+  *
+  * A search context iterates along a doubly linked list of siblings in the
+  * directory. If the iterating object is deleted then this would corrupt
+  * the list iteration, likely causing a crash. The search context avoids
+  * this by using the removeObjectCallback to move the search context to the
+  * next object before the object is deleted.
+  *
+  * Many readdirs (and thus seach conexts) may be alive simulateously so
+  * each yaffs_Device has a list of these.
+  *
+  * A seach context lives for the duration of a readdir.
+  *
+  * All these functions must be called while yaffs is locked.
+  */
+ 
+ struct yaffs_SearchContext {
+ 	yaffs_Device *dev;
+ 	yaffs_Object *dirObj;
+ 	yaffs_Object *nextReturn;
+ 	struct ylist_head others;
+ };
+ 
+ /*
+  * yaffs_NewSearch() creates a new search context, initialises it and
+  * adds it to the device's search context list.
+  *
+  * Called at start of readdir.
+  */
+ static struct yaffs_SearchContext * yaffs_NewSearch(yaffs_Object *dir)
+ {
+ 	yaffs_Device *dev = dir->myDev;
+ 	struct yaffs_SearchContext *sc = YMALLOC(sizeof(struct yaffs_SearchContext));
+ 	if(sc){
+ 		sc->dirObj = dir;
+ 		sc->dev = dev;
+ 		if( ylist_empty(&sc->dirObj->variant.directoryVariant.children))
+ 			sc->nextReturn = NULL;
+ 		else
+ 			sc->nextReturn = ylist_entry(
+                                 dir->variant.directoryVariant.children.next,
+ 				yaffs_Object,siblings);
+ 		YINIT_LIST_HEAD(&sc->others);
+ 		ylist_add(&sc->others,&(yaffs_DeviceToContext(dev)->searchContexts));
+ 	}
+ 	return sc;
+ }
+ 
+ /*
+  * yaffs_EndSearch() disposes of a search context and cleans up.
+  */
+ static void yaffs_EndSearch(struct yaffs_SearchContext * sc)
+ {
+ 	if(sc){
+ 		ylist_del(&sc->others);
+ 		YFREE(sc);
+ 	}
+ }
+ 
+ /*
+  * yaffs_SearchAdvance() moves a search context to the next object.
+  * Called when the search iterates or when an object removal causes
+  * the search context to be moved to the next object.
+  */
+ static void yaffs_SearchAdvance(struct yaffs_SearchContext *sc)
+ {
+         if(!sc)
+                 return;
+ 
+         if( sc->nextReturn == NULL ||
+                 ylist_empty(&sc->dirObj->variant.directoryVariant.children))
+                 sc->nextReturn = NULL;
+         else {
+                 struct ylist_head *next = sc->nextReturn->siblings.next;
+ 
+                 if( next == &sc->dirObj->variant.directoryVariant.children)
+                         sc->nextReturn = NULL; /* end of list */
+                 else
+                         sc->nextReturn = ylist_entry(next,yaffs_Object,siblings);
+         }
+ }
+ 
+ /*
+  * yaffs_RemoveObjectCallback() is called when an object is unlinked.
+  * We check open search contexts and advance any which are currently
+  * on the object being iterated.
+  */
+ static void yaffs_RemoveObjectCallback(yaffs_Object *obj)
+ {
+ 
+         struct ylist_head *i;
+         struct yaffs_SearchContext *sc;
+         struct ylist_head *search_contexts = &(yaffs_DeviceToContext(obj->myDev)->searchContexts);
+ 
+ 
+         /* Iterate through the directory search contexts.
+          * If any are currently on the object being removed, then advance
+          * the search context to the next object to prevent a hanging pointer.
+          */
+          ylist_for_each(i, search_contexts) {
+                 if (i) {
+                         sc = ylist_entry(i, struct yaffs_SearchContext,others);
+                         if(sc->nextReturn == obj)
+                                 yaffs_SearchAdvance(sc);
+                 }
+ 	}
+ 
+ }
+ 
+ 
+ /*-----------------------------------------------------------------*/
+ 
+ static int yaffs_readlink(struct dentry *dentry, char __user *buffer,
+ 			int buflen)
+ {
+ 	unsigned char *alias;
+ 	int ret;
+ 
+ 	yaffs_Device *dev = yaffs_DentryToObject(dentry)->myDev;
+ 
+ 	yaffs_GrossLock(dev);
+ 
+ 	alias = yaffs_GetSymlinkAlias(yaffs_DentryToObject(dentry));
+ 
+ 	yaffs_GrossUnlock(dev);
+ 
+ 	if (!alias)
+ 		return -ENOMEM;
+ 
+ 	ret = vfs_readlink(dentry, buffer, buflen, alias);
+ 	kfree(alias);
+ 	return ret;
+ }
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13))
+ static void *yaffs_follow_link(struct dentry *dentry, struct nameidata *nd)
+ #else
+ static int yaffs_follow_link(struct dentry *dentry, struct nameidata *nd)
+ #endif
+ {
+ 	unsigned char *alias;
+ 	int ret;
+ 	yaffs_Device *dev = yaffs_DentryToObject(dentry)->myDev;
+ 
+ 	yaffs_GrossLock(dev);
+ 
+ 	alias = yaffs_GetSymlinkAlias(yaffs_DentryToObject(dentry));
+ 
+ 	yaffs_GrossUnlock(dev);
+ 
+ 	if (!alias) {
+ 		ret = -ENOMEM;
+ 		goto out;
+ 	}
+ 
+ 	ret = vfs_follow_link(nd, alias);
+ 	kfree(alias);
+ out:
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13))
+ 	return ERR_PTR(ret);
+ #else
+ 	return ret;
+ #endif
+ }
+ 
+ struct inode *yaffs_get_inode(struct super_block *sb, int mode, int dev,
+ 				yaffs_Object *obj);
+ 
+ /*
+  * Lookup is used to find objects in the fs
+  */
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+ 
+ static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,
+ 				struct nameidata *n)
+ #else
+ static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry)
+ #endif
+ {
+ 	yaffs_Object *obj;
+ 	struct inode *inode = NULL;	/* NCB 2.5/2.6 needs NULL here */
+ 
+ 	yaffs_Device *dev = yaffs_InodeToObject(dir)->myDev;
+ 
+ 	if(current != yaffs_DeviceToContext(dev)->readdirProcess)
+ 		yaffs_GrossLock(dev);
+ 
+ 	T(YAFFS_TRACE_OS,
+ 		(TSTR("yaffs_lookup for %d:%s\n"),
+ 		yaffs_InodeToObject(dir)->objectId, dentry->d_name.name));
+ 
+ 	obj = yaffs_FindObjectByName(yaffs_InodeToObject(dir),
+ 					dentry->d_name.name);
+ 
+ 	obj = yaffs_GetEquivalentObject(obj);	/* in case it was a hardlink */
+ 
+ 	/* Can't hold gross lock when calling yaffs_get_inode() */
+ 	if(current != yaffs_DeviceToContext(dev)->readdirProcess)
+ 		yaffs_GrossUnlock(dev);
+ 
+ 	if (obj) {
+ 		T(YAFFS_TRACE_OS,
+ 			(TSTR("yaffs_lookup found %d\n"), obj->objectId));
+ 
+ 		inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
+ 
+ 		if (inode) {
+ 			T(YAFFS_TRACE_OS,
+ 				(TSTR("yaffs_loookup dentry \n")));
+ /* #if 0 asserted by NCB for 2.5/6 compatability - falls through to
+  * d_add even if NULL inode */
+ #if 0
+ 			/*dget(dentry); // try to solve directory bug */
+ 			d_add(dentry, inode);
+ 
+ 			/* return dentry; */
+ 			return NULL;
+ #endif
+ 		}
+ 
+ 	} else {
+ 		T(YAFFS_TRACE_OS,(TSTR("yaffs_lookup not found\n")));
+ 
+ 	}
+ 
+ /* added NCB for 2.5/6 compatability - forces add even if inode is
+  * NULL which creates dentry hash */
+ 	d_add(dentry, inode);
+ 
+ 	return NULL;
+ }
+ 
+ 
+ #ifdef YAFFS_HAS_PUT_INODE
+ 
+ /* For now put inode is just for debugging
+  * Put inode is called when the inode **structure** is put.
+  */
+ static void yaffs_put_inode(struct inode *inode)
+ {
+ 	T(YAFFS_TRACE_OS,
+ 		(TSTR("yaffs_put_inode: ino %d, count %d\n"), (int)inode->i_ino,
+ 		atomic_read(&inode->i_count)));
+ 
+ }
+ #endif
+ 
+ /* clear is called to tell the fs to release any per-inode data it holds */
+ static void yaffs_clear_inode(struct inode *inode)
+ {
+ 	yaffs_Object *obj;
+ 	yaffs_Device *dev;
+ 
+ 	obj = yaffs_InodeToObject(inode);
+ 
+ 	T(YAFFS_TRACE_OS,
+ 		(TSTR("yaffs_clear_inode: ino %d, count %d %s\n"), (int)inode->i_ino,
+ 		atomic_read(&inode->i_count),
+ 		obj ? "object exists" : "null object"));
+ 
+ 	if (obj) {
+ 		dev = obj->myDev;
+ 		yaffs_GrossLock(dev);
+ 
+ 		/* Clear the association between the inode and
+ 		 * the yaffs_Object.
+ 		 */
+ 		obj->myInode = NULL;
+ 		yaffs_InodeToObjectLV(inode) = NULL;
+ 
+ 		/* If the object freeing was deferred, then the real
+ 		 * free happens now.
+ 		 * This should fix the inode inconsistency problem.
+ 		 */
+ 
+ 		yaffs_HandleDeferedFree(obj);
+ 
+ 		yaffs_GrossUnlock(dev);
+ 	}
+ 
+ }
+ 
+ /* delete is called when the link count is zero and the inode
+  * is put (ie. nobody wants to know about it anymore, time to
+  * delete the file).
+  * NB Must call clear_inode()
+  */
+ static void yaffs_delete_inode(struct inode *inode)
+ {
+ 	yaffs_Object *obj = yaffs_InodeToObject(inode);
+ 	yaffs_Device *dev;
+ 
+ 	T(YAFFS_TRACE_OS,
+ 		(TSTR("yaffs_delete_inode: ino %d, count %d %s\n"), (int)inode->i_ino,
+ 		atomic_read(&inode->i_count),
+ 		obj ? "object exists" : "null object"));
+ 
+ 	if (obj) {
+ 		dev = obj->myDev;
+ 		yaffs_GrossLock(dev);
+ 		yaffs_DeleteObject(obj);
+ 		yaffs_GrossUnlock(dev);
+ 	}
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13))
+ 	truncate_inode_pages(&inode->i_data, 0);
+ #endif
+ 	clear_inode(inode);
+ }
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+ static int yaffs_file_flush(struct file *file, fl_owner_t id)
+ #else
+ static int yaffs_file_flush(struct file *file)
+ #endif
+ {
+ 	yaffs_Object *obj = yaffs_DentryToObject(file->f_dentry);
+ 
+ 	yaffs_Device *dev = obj->myDev;
+ 
+ 	T(YAFFS_TRACE_OS,
+ 		(TSTR("yaffs_file_flush object %d (%s)\n"), obj->objectId,
+ 		obj->dirty ? "dirty" : "clean"));
+ 
+ 	yaffs_GrossLock(dev);
+ 
+ 	yaffs_FlushFile(obj, 1, 0);
+ 
+ 	yaffs_GrossUnlock(dev);
+ 
+ 	return 0;
+ }
+ 
+ static int yaffs_readpage_nolock(struct file *f, struct page *pg)
+ {
+ 	/* Lifted from jffs2 */
+ 
+ 	yaffs_Object *obj;
+ 	unsigned char *pg_buf;
+ 	int ret;
+ 
+ 	yaffs_Device *dev;
+ 
+ 	T(YAFFS_TRACE_OS,
+ 		(TSTR("yaffs_readpage_nolock at %08x, size %08x\n"),
+ 		(unsigned)(pg->index << PAGE_CACHE_SHIFT),
+ 		(unsigned)PAGE_CACHE_SIZE));
+ 
+ 	obj = yaffs_DentryToObject(f->f_dentry);
+ 
+ 	dev = obj->myDev;
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+ 	BUG_ON(!PageLocked(pg));
+ #else
+ 	if (!PageLocked(pg))
+ 		PAGE_BUG(pg);
+ #endif
+ 
+ 	pg_buf = kmap(pg);
+ 	/* FIXME: Can kmap fail? */
+ 
+ 	yaffs_GrossLock(dev);
+ 
+ 	ret = yaffs_ReadDataFromFile(obj, pg_buf,
+ 				pg->index << PAGE_CACHE_SHIFT,
+ 				PAGE_CACHE_SIZE);
+ 
+ 	yaffs_GrossUnlock(dev);
+ 
+ 	if (ret >= 0)
+ 		ret = 0;
+ 
+ 	if (ret) {
+ 		ClearPageUptodate(pg);
+ 		SetPageError(pg);
+ 	} else {
+ 		SetPageUptodate(pg);
+ 		ClearPageError(pg);
+ 	}
+ 
+ 	flush_dcache_page(pg);
+ 	kunmap(pg);
+ 
+ 	T(YAFFS_TRACE_OS, (TSTR("yaffs_readpage_nolock done\n")));
+ 	return ret;
+ }
+ 
+ static int yaffs_readpage_unlock(struct file *f, struct page *pg)
+ {
+ 	int ret = yaffs_readpage_nolock(f, pg);
+ 	UnlockPage(pg);
+ 	return ret;
+ }
+ 
+ static int yaffs_readpage(struct file *f, struct page *pg)
+ {
+ 	int ret;
+ 
+ 	T(YAFFS_TRACE_OS, (TSTR("yaffs_readpage\n")));
+ 	ret=yaffs_readpage_unlock(f, pg);
+ 	T(YAFFS_TRACE_OS, (TSTR("yaffs_readpage done\n")));
+ 	return ret;
+ }
+ 
+ /* writepage inspired by/stolen from smbfs */
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+ static int yaffs_writepage(struct page *page, struct writeback_control *wbc)
+ #else
+ static int yaffs_writepage(struct page *page)
+ #endif
+ {
+ 	struct address_space *mapping = page->mapping;
+ 	struct inode *inode;
+ 	unsigned long end_index;
+ 	char *buffer;
+ 	yaffs_Object *obj;
+ 	int nWritten = 0;
+ 	unsigned nBytes;
+ 	loff_t i_size;
+ 
+ 	if (!mapping)
+ 		BUG();
+ 	inode = mapping->host;
+ 	if (!inode)
+ 		BUG();
+ 	i_size = i_size_read(inode);
+ 
+ 	end_index = i_size >> PAGE_CACHE_SHIFT;
+ 
+ 	if(page->index < end_index)
+ 		nBytes = PAGE_CACHE_SIZE;
+ 	else {
+ 		nBytes = i_size & (PAGE_CACHE_SIZE -1);
+ 
+ 		if (page->index > end_index || !nBytes) {
+ 			T(YAFFS_TRACE_OS,
+ 				(TSTR("yaffs_writepage at %08x, inode size = %08x!!!\n"),
+ 				(unsigned)(page->index << PAGE_CACHE_SHIFT),
+ 				(unsigned)inode->i_size));
+ 			T(YAFFS_TRACE_OS,
+ 				(TSTR("                -> don't care!!\n")));
+ 
+ 			zero_user_segment(page,0,PAGE_CACHE_SIZE);
+ 			set_page_writeback(page);
+ 			unlock_page(page);
+ 			end_page_writeback(page);
+ 			return 0;
+ 		}
+ 	}
+ 
+ 	if(nBytes != PAGE_CACHE_SIZE)
+ 		zero_user_segment(page,nBytes,PAGE_CACHE_SIZE);
+ 
+ 	get_page(page);
+ 
+ 	buffer = kmap(page);
+ 
+ 	obj = yaffs_InodeToObject(inode);
+ 	yaffs_GrossLock(obj->myDev);
+ 
+ 	T(YAFFS_TRACE_OS,
+ 		(TSTR("yaffs_writepage at %08x, size %08x\n"),
+ 		(unsigned)(page->index << PAGE_CACHE_SHIFT), nBytes));
+ 	T(YAFFS_TRACE_OS,
+ 		(TSTR("writepag0: obj = %05x, ino = %05x\n"),
+ 		(int)obj->variant.fileVariant.fileSize, (int)inode->i_size));
+ 
+ 	nWritten = yaffs_WriteDataToFile(obj, buffer,
+ 			page->index << PAGE_CACHE_SHIFT, nBytes, 0);
+ 
+ 	T(YAFFS_TRACE_OS,
+ 		(TSTR("writepag1: obj = %05x, ino = %05x\n"),
+ 		(int)obj->variant.fileVariant.fileSize, (int)inode->i_size));
+ 
+ 	yaffs_GrossUnlock(obj->myDev);
+ 
+ 	kunmap(page);
+ 	set_page_writeback(page);
+ 	unlock_page(page);
+ 	end_page_writeback(page);
+ 	put_page(page);
+ 
+ 	return (nWritten == nBytes) ? 0 : -ENOSPC;
+ }
+ 
+ 
+ #if (YAFFS_USE_WRITE_BEGIN_END > 0)
+ static int yaffs_write_begin(struct file *filp, struct address_space *mapping,
+ 				loff_t pos, unsigned len, unsigned flags,
+ 				struct page **pagep, void **fsdata)
+ {
+ 	struct page *pg = NULL;
+ 	pgoff_t index = pos >> PAGE_CACHE_SHIFT;
+ 
+ 	int ret = 0;
+ 	int space_held = 0;
+ 
+ 	/* Get a page */
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+ 	pg = grab_cache_page_write_begin(mapping, index, flags);
+ #else
+ 	pg = __grab_cache_page(mapping, index);
+ #endif
+ 
+ 	*pagep = pg;
+ 	if (!pg) {
+ 		ret =  -ENOMEM;
+ 		goto out;
+ 	}
+ 	T(YAFFS_TRACE_OS,
+ 		(TSTR("start yaffs_write_begin index %d(%x) uptodate %d\n"),
+ 		(int)index,(int)index,Page_Uptodate(pg) ? 1 : 0));
+ 
+ 	/* Get fs space */
+ 	space_held = yaffs_hold_space(filp);
+ 
+ 	if (!space_held) {
+ 		ret = -ENOSPC;
+ 		goto out;
+ 	}
+ 
+ 	/* Update page if required */
+ 
+ 	if (!Page_Uptodate(pg))
+ 		ret = yaffs_readpage_nolock(filp, pg);
+ 
+ 	if (ret)
+ 		goto out;
+ 
+ 	/* Happy path return */
+ 	T(YAFFS_TRACE_OS, (TSTR("end yaffs_write_begin - ok\n")));
+ 
+ 	return 0;
+ 
+ out:
+ 	T(YAFFS_TRACE_OS,
+ 		(TSTR("end yaffs_write_begin fail returning %d\n"), ret));
+ 	if (space_held)
+ 		yaffs_release_space(filp);
+ 	if (pg) {
+ 		unlock_page(pg);
+ 		page_cache_release(pg);
+ 	}
+ 	return ret;
+ }
+ 
+ #else
+ 
+ static int yaffs_prepare_write(struct file *f, struct page *pg,
+ 				unsigned offset, unsigned to)
+ {
+ 	T(YAFFS_TRACE_OS, (TSTR("yaffs_prepair_write\n")));
+ 
+ 	if (!Page_Uptodate(pg))
+ 		return yaffs_readpage_nolock(f, pg);
+ 	return 0;
+ }
+ #endif
+ 
+ #if (YAFFS_USE_WRITE_BEGIN_END > 0)
+ static int yaffs_write_end(struct file *filp, struct address_space *mapping,
+ 				loff_t pos, unsigned len, unsigned copied,
+ 				struct page *pg, void *fsdadata)
+ {
+ 	int ret = 0;
+ 	void *addr, *kva;
+ 	uint32_t offset_into_page = pos & (PAGE_CACHE_SIZE - 1);
+ 
+ 	kva = kmap(pg);
+ 	addr = kva + offset_into_page;
+ 
+ 	T(YAFFS_TRACE_OS,
+ 		("yaffs_write_end addr %p pos %x nBytes %d\n",
+ 		addr,(unsigned)pos, copied));
+ 
+ 	ret = yaffs_file_write(filp, addr, copied, &pos);
+ 
+ 	if (ret != copied) {
+ 		T(YAFFS_TRACE_OS,
+ 			(TSTR("yaffs_write_end not same size ret %d  copied %d\n"),
+ 			ret, copied));
+ 		SetPageError(pg);
+ 	} else {
+ 		/* Nothing */
+ 	}
+ 
+ 	kunmap(pg);
+ 
+ 	yaffs_release_space(filp);
+ 	unlock_page(pg);
+ 	page_cache_release(pg);
+ 	return ret;
+ }
+ #else
+ 
+ static int yaffs_commit_write(struct file *f, struct page *pg, unsigned offset,
+ 				unsigned to)
+ {
+ 	void *addr, *kva;
+ 
+ 	loff_t pos = (((loff_t) pg->index) << PAGE_CACHE_SHIFT) + offset;
+ 	int nBytes = to - offset;
+ 	int nWritten;
+ 
+ 	unsigned spos = pos;
+ 	unsigned saddr;
+ 
+ 	kva = kmap(pg);
+ 	addr = kva + offset;
+ 
+ 	saddr = (unsigned) addr;
+ 
+ 	T(YAFFS_TRACE_OS,
+ 		(TSTR("yaffs_commit_write addr %x pos %x nBytes %d\n"),
+ 		saddr, spos, nBytes));
+ 
+ 	nWritten = yaffs_file_write(f, addr, nBytes, &pos);
+ 
+ 	if (nWritten != nBytes) {
+ 		T(YAFFS_TRACE_OS,
+ 			(TSTR("yaffs_commit_write not same size nWritten %d  nBytes %d\n"),
+ 			nWritten, nBytes));
+ 		SetPageError(pg);
+ 	} else {
+ 		/* Nothing */
+ 	}
+ 
+ 	kunmap(pg);
+ 
+ 	T(YAFFS_TRACE_OS,
+ 		(TSTR("yaffs_commit_write returning %d\n"),
+ 		nWritten == nBytes ? 0 : nWritten));
+ 
+ 	return nWritten == nBytes ? 0 : nWritten;
+ }
+ #endif
+ 
+ 
+ static void yaffs_FillInodeFromObject(struct inode *inode, yaffs_Object *obj)
+ {
+ 	if (inode && obj) {
+ 
+ 
+ 		/* Check mode against the variant type and attempt to repair if broken. */
+ 		__u32 mode = obj->yst_mode;
+ 		switch (obj->variantType) {
+ 		case YAFFS_OBJECT_TYPE_FILE:
+ 			if (!S_ISREG(mode)) {
+ 				obj->yst_mode &= ~S_IFMT;
+ 				obj->yst_mode |= S_IFREG;
+ 			}
+ 
+ 			break;
+ 		case YAFFS_OBJECT_TYPE_SYMLINK:
+ 			if (!S_ISLNK(mode)) {
+ 				obj->yst_mode &= ~S_IFMT;
+ 				obj->yst_mode |= S_IFLNK;
+ 			}
+ 
+ 			break;
+ 		case YAFFS_OBJECT_TYPE_DIRECTORY:
+ 			if (!S_ISDIR(mode)) {
+ 				obj->yst_mode &= ~S_IFMT;
+ 				obj->yst_mode |= S_IFDIR;
+ 			}
+ 
+ 			break;
+ 		case YAFFS_OBJECT_TYPE_UNKNOWN:
+ 		case YAFFS_OBJECT_TYPE_HARDLINK:
+ 		case YAFFS_OBJECT_TYPE_SPECIAL:
+ 		default:
+ 			/* TODO? */
+ 			break;
+ 		}
+ 
+ 		inode->i_flags |= S_NOATIME;
+ 
+ 		inode->i_ino = obj->objectId;
+ 		inode->i_mode = obj->yst_mode;
+ 		inode->i_uid = obj->yst_uid;
+ 		inode->i_gid = obj->yst_gid;
+ #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+ 		inode->i_blksize = inode->i_sb->s_blocksize;
+ #endif
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+ 
+ 		inode->i_rdev = old_decode_dev(obj->yst_rdev);
+ 		inode->i_atime.tv_sec = (time_t) (obj->yst_atime);
+ 		inode->i_atime.tv_nsec = 0;
+ 		inode->i_mtime.tv_sec = (time_t) obj->yst_mtime;
+ 		inode->i_mtime.tv_nsec = 0;
+ 		inode->i_ctime.tv_sec = (time_t) obj->yst_ctime;
+ 		inode->i_ctime.tv_nsec = 0;
+ #else
+ 		inode->i_rdev = obj->yst_rdev;
+ 		inode->i_atime = obj->yst_atime;
+ 		inode->i_mtime = obj->yst_mtime;
+ 		inode->i_ctime = obj->yst_ctime;
+ #endif
+ 		inode->i_size = yaffs_GetObjectFileLength(obj);
+ 		inode->i_blocks = (inode->i_size + 511) >> 9;
+ 
+ 		inode->i_nlink = yaffs_GetObjectLinkCount(obj);
+ 
+ 		T(YAFFS_TRACE_OS,
+ 			(TSTR("yaffs_FillInode mode %x uid %d gid %d size %d count %d\n"),
+ 			inode->i_mode, inode->i_uid, inode->i_gid,
+ 			(int)inode->i_size, atomic_read(&inode->i_count)));
+ 
+ 		switch (obj->yst_mode & S_IFMT) {
+ 		default:	/* fifo, device or socket */
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+ 			init_special_inode(inode, obj->yst_mode,
+ 					old_decode_dev(obj->yst_rdev));
+ #else
+ 			init_special_inode(inode, obj->yst_mode,
+ 					(dev_t) (obj->yst_rdev));
+ #endif
+ 			break;
+ 		case S_IFREG:	/* file */
+ 			inode->i_op = &yaffs_file_inode_operations;
+ 			inode->i_fop = &yaffs_file_operations;
+ 			inode->i_mapping->a_ops =
+ 				&yaffs_file_address_operations;
+ 			break;
+ 		case S_IFDIR:	/* directory */
+ 			inode->i_op = &yaffs_dir_inode_operations;
+ 			inode->i_fop = &yaffs_dir_operations;
+ 			break;
+ 		case S_IFLNK:	/* symlink */
+ 			inode->i_op = &yaffs_symlink_inode_operations;
+ 			break;
+ 		}
+ 
+ 		yaffs_InodeToObjectLV(inode) = obj;
+ 
+ 		obj->myInode = inode;
+ 
+ 	} else {
+ 		T(YAFFS_TRACE_OS,
+ 			(TSTR("yaffs_FileInode invalid parameters\n")));
+ 	}
+ 
+ }
+ 
+ struct inode *yaffs_get_inode(struct super_block *sb, int mode, int dev,
+ 				yaffs_Object *obj)
+ {
+ 	struct inode *inode;
+ 
+ 	if (!sb) {
+ 		T(YAFFS_TRACE_OS,
+ 			(TSTR("yaffs_get_inode for NULL super_block!!\n")));
+ 		return NULL;
+ 
+ 	}
+ 
+ 	if (!obj) {
+ 		T(YAFFS_TRACE_OS,
+ 			(TSTR("yaffs_get_inode for NULL object!!\n")));
+ 		return NULL;
+ 
+ 	}
+ 
+ 	T(YAFFS_TRACE_OS,
+ 		(TSTR("yaffs_get_inode for object %d\n"), obj->objectId));
+ 
+ 	inode = Y_IGET(sb, obj->objectId);
+ 	if (IS_ERR(inode))
+ 		return NULL;
+ 
+ 	/* NB Side effect: iget calls back to yaffs_read_inode(). */
+ 	/* iget also increments the inode's i_count */
+ 	/* NB You can't be holding grossLock or deadlock will happen! */
+ 
+ 	return inode;
+ }
+ 
+ static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,
+ 				loff_t *pos)
+ {
+ 	yaffs_Object *obj;
+ 	int nWritten, ipos;
+ 	struct inode *inode;
+ 	yaffs_Device *dev;
+ 
+ 	obj = yaffs_DentryToObject(f->f_dentry);
+ 
+ 	dev = obj->myDev;
+ 
+ 	yaffs_GrossLock(dev);
+ 
+ 	inode = f->f_dentry->d_inode;
+ 
+ 	if (!S_ISBLK(inode->i_mode) && f->f_flags & O_APPEND)
+ 		ipos = inode->i_size;
+ 	else
+ 		ipos = *pos;
+ 
+ 	if (!obj)
+ 		T(YAFFS_TRACE_OS,
+ 			(TSTR("yaffs_file_write: hey obj is null!\n")));
+ 	else
+ 		T(YAFFS_TRACE_OS,
+ 			(TSTR("yaffs_file_write about to write writing %u(%x) bytes"
+ 			"to object %d at %d(%x)\n"),
+ 			(unsigned) n, (unsigned) n, obj->objectId, ipos,ipos));
+ 
+ 	nWritten = yaffs_WriteDataToFile(obj, buf, ipos, n, 0);
+ 
+ 	T(YAFFS_TRACE_OS,
+ 		(TSTR("yaffs_file_write: %d(%x) bytes written\n"),
+ 		(unsigned )n,(unsigned)n));
+ 
+ 	if (nWritten > 0) {
+ 		ipos += nWritten;
+ 		*pos = ipos;
+ 		if (ipos > inode->i_size) {
+ 			inode->i_size = ipos;
+ 			inode->i_blocks = (ipos + 511) >> 9;
+ 
+ 			T(YAFFS_TRACE_OS,
+ 				(TSTR("yaffs_file_write size updated to %d bytes, "
+ 				"%d blocks\n"),
+ 				ipos, (int)(inode->i_blocks)));
+ 		}
+ 
+ 	}
+ 	yaffs_GrossUnlock(dev);
+ 	return (nWritten == 0) && (n > 0) ? -ENOSPC : nWritten;
+ }
+ 
+ /* Space holding and freeing is done to ensure we have space available for write_begin/end */
+ /* For now we just assume few parallel writes and check against a small number. */
+ /* Todo: need to do this with a counter to handle parallel reads better */
+ 
+ static ssize_t yaffs_hold_space(struct file *f)
+ {
+ 	yaffs_Object *obj;
+ 	yaffs_Device *dev;
+ 
+ 	int nFreeChunks;
+ 
+ 
+ 	obj = yaffs_DentryToObject(f->f_dentry);
+ 
+ 	dev = obj->myDev;
+ 
+ 	yaffs_GrossLock(dev);
+ 
+ 	nFreeChunks = yaffs_GetNumberOfFreeChunks(dev);
+ 
+ 	yaffs_GrossUnlock(dev);
+ 
+ 	return (nFreeChunks > 20) ? 1 : 0;
+ }
+ 
+ static void yaffs_release_space(struct file *f)
+ {
+ 	yaffs_Object *obj;
+ 	yaffs_Device *dev;
+ 
+ 
+ 	obj = yaffs_DentryToObject(f->f_dentry);
+ 
+ 	dev = obj->myDev;
+ 
+ 	yaffs_GrossLock(dev);
+ 
+ 
+ 	yaffs_GrossUnlock(dev);
+ }
+ 
+ 
+ static loff_t yaffs_dir_llseek(struct file *file, loff_t offset, int origin)
+ {
+ 	long long retval;
+ 
+ 	lock_kernel();
+ 
+ 	switch (origin){
+ 	case 2:
+ 		offset += i_size_read(file->f_path.dentry->d_inode);
+ 		break;
+ 	case 1:
+ 		offset += file->f_pos;
+ 	}
+ 	retval = -EINVAL;
+ 
+ 	if (offset >= 0){
+ 		if (offset != file->f_pos)
+ 			file->f_pos = offset;
+ 
+ 		retval = offset;
+ 	}
+ 	unlock_kernel();
+ 	return retval;
+ }
+ 
+ 
+ static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir)
+ {
+ 	yaffs_Object *obj;
+ 	yaffs_Device *dev;
+         struct yaffs_SearchContext *sc;
+ 	struct inode *inode = f->f_dentry->d_inode;
+ 	unsigned long offset, curoffs;
+ 	yaffs_Object *l;
+         int retVal = 0;
+ 
+ 	char name[YAFFS_MAX_NAME_LENGTH + 1];
+ 
+ 	obj = yaffs_DentryToObject(f->f_dentry);
+ 	dev = obj->myDev;
+ 
+ 	yaffs_GrossLock(dev);
+ 
+ 	yaffs_DeviceToContext(dev)->readdirProcess = current;
+ 
+ 	offset = f->f_pos;
+ 
+         sc = yaffs_NewSearch(obj);
+         if(!sc){
+                 retVal = -ENOMEM;
+                 goto unlock_out;
+         }
+ 
+ 	T(YAFFS_TRACE_OS, (TSTR("yaffs_readdir: starting at %d\n"), (int)offset));
+ 
+ 	if (offset == 0) {
+ 		T(YAFFS_TRACE_OS,
+ 			(TSTR("yaffs_readdir: entry . ino %d \n"),
+ 			(int)inode->i_ino));
+ 		yaffs_GrossUnlock(dev);
+ 		if (filldir(dirent, ".", 1, offset, inode->i_ino, DT_DIR) < 0)
+ 			goto out;
+ 		yaffs_GrossLock(dev);
+ 		offset++;
+ 		f->f_pos++;
+ 	}
+ 	if (offset == 1) {
+ 		T(YAFFS_TRACE_OS,
+ 			(TSTR("yaffs_readdir: entry .. ino %d \n"),
+ 			(int)f->f_dentry->d_parent->d_inode->i_ino));
+ 		yaffs_GrossUnlock(dev);
+ 		if (filldir(dirent, "..", 2, offset,
+ 			f->f_dentry->d_parent->d_inode->i_ino, DT_DIR) < 0)
+ 			goto out;
+ 		yaffs_GrossLock(dev);
+ 		offset++;
+ 		f->f_pos++;
+ 	}
+ 
+ 	curoffs = 1;
+ 
+ 	/* If the directory has changed since the open or last call to
+ 	   readdir, rewind to after the 2 canned entries. */
+ 	if (f->f_version != inode->i_version) {
+ 		offset = 2;
+ 		f->f_pos = offset;
+ 		f->f_version = inode->i_version;
+ 	}
+ 
+ 	while(sc->nextReturn){
+ 		curoffs++;
+                 l = sc->nextReturn;
+ 		if (curoffs >= offset) {
+                         int this_inode = yaffs_GetObjectInode(l);
+                         int this_type = yaffs_GetObjectType(l);
+ 
+ 			yaffs_GetObjectName(l, name,
+ 					    YAFFS_MAX_NAME_LENGTH + 1);
+ 			T(YAFFS_TRACE_OS,
+ 			  (TSTR("yaffs_readdir: %s inode %d\n"),
+ 			  name, yaffs_GetObjectInode(l)));
+ 
+                         yaffs_GrossUnlock(dev);
+ 
+ 			if (filldir(dirent,
+ 					name,
+ 					strlen(name),
+ 					offset,
+ 					this_inode,
+ 					this_type) < 0)
+ 				goto out;
+ 
+                         yaffs_GrossLock(dev);
+ 
+ 			offset++;
+ 			f->f_pos++;
+ 		}
+                 yaffs_SearchAdvance(sc);
+ 	}
+ 
+ unlock_out:
+ 	yaffs_DeviceToContext(dev)->readdirProcess = NULL;
+ 
+ 	yaffs_GrossUnlock(dev);
+ out:
+         yaffs_EndSearch(sc);
+ 
+ 	return retVal;
+ }
+ 
+ 
+ 
+ /*
+  * File creation. Allocate an inode, and we're done..
+  */
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
+ #define YCRED(x) x
+ #else
+ #define YCRED(x) (x->cred)
+ #endif
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+ static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+ 			dev_t rdev)
+ #else
+ static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+ 			int rdev)
+ #endif
+ {
+ 	struct inode *inode;
+ 
+ 	yaffs_Object *obj = NULL;
+ 	yaffs_Device *dev;
+ 
+ 	yaffs_Object *parent = yaffs_InodeToObject(dir);
+ 
+ 	int error = -ENOSPC;
+ 	uid_t uid = YCRED(current)->fsuid;
+ 	gid_t gid = (dir->i_mode & S_ISGID) ? dir->i_gid : YCRED(current)->fsgid;
+ 
+ 	if ((dir->i_mode & S_ISGID) && S_ISDIR(mode))
+ 		mode |= S_ISGID;
+ 
+ 	if (parent) {
+ 		T(YAFFS_TRACE_OS,
+ 			(TSTR("yaffs_mknod: parent object %d type %d\n"),
+ 			parent->objectId, parent->variantType));
+ 	} else {
+ 		T(YAFFS_TRACE_OS,
+ 			(TSTR("yaffs_mknod: could not get parent object\n")));
+ 		return -EPERM;
+ 	}
+ 
+ 	T(YAFFS_TRACE_OS, (TSTR("yaffs_mknod: making oject for %s, "
+ 			"mode %x dev %x\n"),
+ 			dentry->d_name.name, mode, rdev));
+ 
+ 	dev = parent->myDev;
+ 
+ 	yaffs_GrossLock(dev);
+ 
+ 	switch (mode & S_IFMT) {
+ 	default:
+ 		/* Special (socket, fifo, device...) */
+ 		T(YAFFS_TRACE_OS, (TSTR("yaffs_mknod: making special\n")));
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+ 		obj = yaffs_MknodSpecial(parent, dentry->d_name.name, mode, uid,
+ 				gid, old_encode_dev(rdev));
+ #else
+ 		obj = yaffs_MknodSpecial(parent, dentry->d_name.name, mode, uid,
+ 				gid, rdev);
+ #endif
+ 		break;
+ 	case S_IFREG:		/* file          */
+ 		T(YAFFS_TRACE_OS, (TSTR("yaffs_mknod: making file\n")));
+ 		obj = yaffs_MknodFile(parent, dentry->d_name.name, mode, uid,
+ 				gid);
+ 		break;
+ 	case S_IFDIR:		/* directory */
+ 		T(YAFFS_TRACE_OS,
+ 			(TSTR("yaffs_mknod: making directory\n")));
+ 		obj = yaffs_MknodDirectory(parent, dentry->d_name.name, mode,
+ 					uid, gid);
+ 		break;
+ 	case S_IFLNK:		/* symlink */
+ 		T(YAFFS_TRACE_OS, (TSTR("yaffs_mknod: making symlink\n")));
+ 		obj = NULL;	/* Do we ever get here? */
+ 		break;
+ 	}
+ 
+ 	/* Can not call yaffs_get_inode() with gross lock held */
+ 	yaffs_GrossUnlock(dev);
+ 
+ 	if (obj) {
+ 		inode = yaffs_get_inode(dir->i_sb, mode, rdev, obj);
+ 		d_instantiate(dentry, inode);
+ 		update_dir_time(dir);
+ 		T(YAFFS_TRACE_OS,
+ 			(TSTR("yaffs_mknod created object %d count = %d\n"),
+ 			obj->objectId, atomic_read(&inode->i_count)));
+ 		error = 0;
+ 		yaffs_FillInodeFromObject(dir,parent);
+ 	} else {
+ 		T(YAFFS_TRACE_OS,
+ 			(TSTR("yaffs_mknod failed making object\n")));
+ 		error = -ENOMEM;
+ 	}
+ 
+ 	return error;
+ }
+ 
+ static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+ {
+ 	int retVal;
+ 	T(YAFFS_TRACE_OS, (TSTR("yaffs_mkdir\n")));
+ 	retVal = yaffs_mknod(dir, dentry, mode | S_IFDIR, 0);
+ 	return retVal;
+ }
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+ static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode,
+ 			struct nameidata *n)
+ #else
+ static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode)
+ #endif
+ {
+ 	T(YAFFS_TRACE_OS,(TSTR("yaffs_create\n")));
+ 	return yaffs_mknod(dir, dentry, mode | S_IFREG, 0);
+ }
+ 
+ static int yaffs_unlink(struct inode *dir, struct dentry *dentry)
+ {
+ 	int retVal;
+ 
+ 	yaffs_Device *dev;
+ 	yaffs_Object *obj;
+ 
+ 	T(YAFFS_TRACE_OS,
+ 		(TSTR("yaffs_unlink %d:%s\n"),
+ 		(int)(dir->i_ino),
+ 		dentry->d_name.name));
+ 	obj = yaffs_InodeToObject(dir);
+ 	dev = obj->myDev;
+ 
+ 	yaffs_GrossLock(dev);
+ 
+ 	retVal = yaffs_Unlink(obj, dentry->d_name.name);
+ 
+ 	if (retVal == YAFFS_OK) {
+ 		dentry->d_inode->i_nlink--;
+ 		dir->i_version++;
+ 		yaffs_GrossUnlock(dev);
+ 		mark_inode_dirty(dentry->d_inode);
+ 		update_dir_time(dir);
+ 		return 0;
+ 	}
+ 	yaffs_GrossUnlock(dev);
+ 	return -ENOTEMPTY;
+ }
+ 
+ /*
+  * Create a link...
+  */
+ static int yaffs_link(struct dentry *old_dentry, struct inode *dir,
+ 			struct dentry *dentry)
+ {
+ 	struct inode *inode = old_dentry->d_inode;
+ 	yaffs_Object *obj = NULL;
+ 	yaffs_Object *link = NULL;
+ 	yaffs_Device *dev;
+ 
+ 	T(YAFFS_TRACE_OS, (TSTR("yaffs_link\n")));
+ 
+ 	obj = yaffs_InodeToObject(inode);
+ 	dev = obj->myDev;
+ 
+ 	yaffs_GrossLock(dev);
+ 
+ 	if (!S_ISDIR(inode->i_mode))		/* Don't link directories */
+ 		link = yaffs_Link(yaffs_InodeToObject(dir), dentry->d_name.name,
+ 			obj);
+ 
+ 	if (link) {
+ 		old_dentry->d_inode->i_nlink = yaffs_GetObjectLinkCount(obj);
+ 		d_instantiate(dentry, old_dentry->d_inode);
+ 		atomic_inc(&old_dentry->d_inode->i_count);
+ 		T(YAFFS_TRACE_OS,
+ 			(TSTR("yaffs_link link count %d i_count %d\n"),
+ 			old_dentry->d_inode->i_nlink,
+ 			atomic_read(&old_dentry->d_inode->i_count)));
+ 	}
+ 
+ 	yaffs_GrossUnlock(dev);
+ 
+ 	if (link){
+ 		update_dir_time(dir);
+ 		return 0;
+ 	}
+ 
+ 	return -EPERM;
+ }
+ 
+ static int yaffs_symlink(struct inode *dir, struct dentry *dentry,
+ 				const char *symname)
+ {
+ 	yaffs_Object *obj;
+ 	yaffs_Device *dev;
+ 	uid_t uid = YCRED(current)->fsuid;
+ 	gid_t gid = (dir->i_mode & S_ISGID) ? dir->i_gid : YCRED(current)->fsgid;
+ 
+ 	T(YAFFS_TRACE_OS, (TSTR("yaffs_symlink\n")));
+ 
+ 	dev = yaffs_InodeToObject(dir)->myDev;
+ 	yaffs_GrossLock(dev);
+ 	obj = yaffs_MknodSymLink(yaffs_InodeToObject(dir), dentry->d_name.name,
+ 				S_IFLNK | S_IRWXUGO, uid, gid, symname);
+ 	yaffs_GrossUnlock(dev);
+ 
+ 	if (obj) {
+ 		struct inode *inode;
+ 
+ 		inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
+ 		d_instantiate(dentry, inode);
+ 		update_dir_time(dir);
+ 		T(YAFFS_TRACE_OS, (TSTR("symlink created OK\n")));
+ 		return 0;
+ 	} else {
+ 		T(YAFFS_TRACE_OS, (TSTR("symlink not created\n")));
+ 	}
+ 
+ 	return -ENOMEM;
+ }
+ 
+ static int yaffs_sync_object(struct file *file, struct dentry *dentry,
+ 				int datasync)
+ {
+ 
+ 	yaffs_Object *obj;
+ 	yaffs_Device *dev;
+ 
+ 	obj = yaffs_DentryToObject(dentry);
+ 
+ 	dev = obj->myDev;
+ 
+ 	T(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC,
+ 		(TSTR("yaffs_sync_object\n")));
+ 	yaffs_GrossLock(dev);
+ 	yaffs_FlushFile(obj, 1, datasync);
+ 	yaffs_GrossUnlock(dev);
+ 	return 0;
+ }
+ 
+ /*
+  * The VFS layer already does all the dentry stuff for rename.
+  *
+  * NB: POSIX says you can rename an object over an old object of the same name
+  */
+ static int yaffs_rename(struct inode *old_dir, struct dentry *old_dentry,
+ 			struct inode *new_dir, struct dentry *new_dentry)
+ {
+ 	yaffs_Device *dev;
+ 	int retVal = YAFFS_FAIL;
+ 	yaffs_Object *target;
+ 
+ 	T(YAFFS_TRACE_OS, (TSTR("yaffs_rename\n")));
+ 	dev = yaffs_InodeToObject(old_dir)->myDev;
+ 
+ 	yaffs_GrossLock(dev);
+ 
+ 	/* Check if the target is an existing directory that is not empty. */
+ 	target = yaffs_FindObjectByName(yaffs_InodeToObject(new_dir),
+ 				new_dentry->d_name.name);
+ 
+ 
+ 
+ 	if (target && target->variantType == YAFFS_OBJECT_TYPE_DIRECTORY &&
+ 		!ylist_empty(&target->variant.directoryVariant.children)) {
+ 
+ 		T(YAFFS_TRACE_OS, (TSTR("target is non-empty dir\n")));
+ 
+ 		retVal = YAFFS_FAIL;
+ 	} else {
+ 		/* Now does unlinking internally using shadowing mechanism */
+ 		T(YAFFS_TRACE_OS, (TSTR("calling yaffs_RenameObject\n")));
+ 
+ 		retVal = yaffs_RenameObject(yaffs_InodeToObject(old_dir),
+ 				old_dentry->d_name.name,
+ 				yaffs_InodeToObject(new_dir),
+ 				new_dentry->d_name.name);
+ 	}
+ 	yaffs_GrossUnlock(dev);
+ 
+ 	if (retVal == YAFFS_OK) {
+ 		if (target) {
+ 			new_dentry->d_inode->i_nlink--;
+ 			mark_inode_dirty(new_dentry->d_inode);
+ 		}
+ 		
+ 		update_dir_time(old_dir);
+ 		if(old_dir != new_dir)
+ 			update_dir_time(new_dir);
+ 		return 0;
+ 	} else {
+ 		return -ENOTEMPTY;
+ 	}
+ }
+ 
+ static int yaffs_setattr(struct dentry *dentry, struct iattr *attr)
+ {
+ 	struct inode *inode = dentry->d_inode;
+ 	int error = 0;
+ 	yaffs_Device *dev;
+ 
+ 	T(YAFFS_TRACE_OS,
+ 		(TSTR("yaffs_setattr of object %d\n"),
+ 		yaffs_InodeToObject(inode)->objectId));
+ 
+ 	/* Fail if a requested resize >= 2GB */		
+ 	if (attr->ia_valid & ATTR_SIZE &&
+ 		(attr->ia_size >> 31))
+ 		error = -EINVAL;
+ 
+ 	if (error == 0)
+ 		error = inode_change_ok(inode, attr);
+ 	if (error == 0) {
+ 		int result;
+ 		if (!error){
+ 			error = inode_setattr(inode, attr);
+ 			T(YAFFS_TRACE_OS,(TSTR("inode_setattr called\n")));
+ 			if (attr->ia_valid & ATTR_SIZE)
+                         	truncate_inode_pages(&inode->i_data,attr->ia_size);
+ 		}
+ 		dev = yaffs_InodeToObject(inode)->myDev;
+ 		if (attr->ia_valid & ATTR_SIZE){
+ 			T(YAFFS_TRACE_OS,(TSTR("resize to %d(%x)\n"),
+ 				(int)(attr->ia_size),(int)(attr->ia_size)));
+ 		}
+ 		yaffs_GrossLock(dev);
+ 		result = yaffs_SetAttributes(yaffs_InodeToObject(inode), attr);
+ 		if(result == YAFFS_OK) {
+ 			error = 0;
+ 		} else {
+ 			error = -EPERM;
+ 		}
+ 		yaffs_GrossUnlock(dev);
+ 
+ 	}
+ 
+ 	T(YAFFS_TRACE_OS,
+ 		(TSTR("yaffs_setattr done returning %d\n"),error));
+ 
+ 	return error;
+ }
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+ static int yaffs_statfs(struct dentry *dentry, struct kstatfs *buf)
+ {
+ 	yaffs_Device *dev = yaffs_DentryToObject(dentry)->myDev;
+ 	struct super_block *sb = dentry->d_sb;
+ #elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+ static int yaffs_statfs(struct super_block *sb, struct kstatfs *buf)
+ {
+ 	yaffs_Device *dev = yaffs_SuperToDevice(sb);
+ #else
+ static int yaffs_statfs(struct super_block *sb, struct statfs *buf)
+ {
+ 	yaffs_Device *dev = yaffs_SuperToDevice(sb);
+ #endif
+ 
+ 	T(YAFFS_TRACE_OS, (TSTR("yaffs_statfs\n")));
+ 
+ 	yaffs_GrossLock(dev);
+ 
+ 	buf->f_type = YAFFS_MAGIC;
+ 	buf->f_bsize = sb->s_blocksize;
+ 	buf->f_namelen = 255;
+ 
+ 	if (dev->nDataBytesPerChunk & (dev->nDataBytesPerChunk - 1)) {
+ 		/* Do this if chunk size is not a power of 2 */
+ 
+ 		uint64_t bytesInDev;
+ 		uint64_t bytesFree;
+ 
+ 		bytesInDev = ((uint64_t)((dev->param.endBlock - dev->param.startBlock + 1))) *
+ 			((uint64_t)(dev->param.nChunksPerBlock * dev->nDataBytesPerChunk));
+ 
+ 		do_div(bytesInDev, sb->s_blocksize); /* bytesInDev becomes the number of blocks */
+ 		buf->f_blocks = bytesInDev;
+ 
+ 		bytesFree  = ((uint64_t)(yaffs_GetNumberOfFreeChunks(dev))) *
+ 			((uint64_t)(dev->nDataBytesPerChunk));
+ 
+ 		do_div(bytesFree, sb->s_blocksize);
+ 
+ 		buf->f_bfree = bytesFree;
+ 
+ 	} else if (sb->s_blocksize > dev->nDataBytesPerChunk) {
+ 
+ 		buf->f_blocks =
+ 			(dev->param.endBlock - dev->param.startBlock + 1) *
+ 			dev->param.nChunksPerBlock /
+ 			(sb->s_blocksize / dev->nDataBytesPerChunk);
+ 		buf->f_bfree =
+ 			yaffs_GetNumberOfFreeChunks(dev) /
+ 			(sb->s_blocksize / dev->nDataBytesPerChunk);
+ 	} else {
+ 		buf->f_blocks =
+ 			(dev->param.endBlock - dev->param.startBlock + 1) *
+ 			dev->param.nChunksPerBlock *
+ 			(dev->nDataBytesPerChunk / sb->s_blocksize);
+ 
+ 		buf->f_bfree =
+ 			yaffs_GetNumberOfFreeChunks(dev) *
+ 			(dev->nDataBytesPerChunk / sb->s_blocksize);
+ 	}
+ 
+ 	buf->f_files = 0;
+ 	buf->f_ffree = 0;
+ 	buf->f_bavail = buf->f_bfree;
+ 
+ 	yaffs_GrossUnlock(dev);
+ 	return 0;
+ }
+ 
+ 
+ 
+ static void yaffs_FlushInodes(struct super_block *sb)
+ {
+ 	struct inode *iptr;
+ 	yaffs_Object *obj;
+ 	
+ 	list_for_each_entry(iptr,&sb->s_inodes, i_sb_list){
+ 		obj = yaffs_InodeToObject(iptr);
+ 		if(obj){
+ 			T(YAFFS_TRACE_OS, (TSTR("flushing obj %d\n"),
+ 				obj->objectId));
+ 			yaffs_FlushFile(obj,1,0);
+ 		}
+ 	}
+ }
+ 
+ 
+ static void yaffs_FlushSuperBlock(struct super_block *sb, int do_checkpoint)
+ {
+ 	yaffs_Device *dev = yaffs_SuperToDevice(sb);	
+ 	if(!dev)
+ 		return;
+ 	
+ 	yaffs_FlushInodes(sb);
+ 	yaffs_UpdateDirtyDirectories(dev);
+ 	yaffs_FlushEntireDeviceCache(dev);
+ 	if(do_checkpoint)
+ 		yaffs_CheckpointSave(dev);
+ }
+ 
+ 
+ static unsigned yaffs_bg_gc_urgency(yaffs_Device *dev)
+ {
+ 	unsigned erasedChunks = dev->nErasedBlocks * dev->param.nChunksPerBlock;
+ 	struct yaffs_LinuxContext *context = yaffs_DeviceToContext(dev);
+ 	unsigned scatteredFree = 0; /* Free chunks not in an erased block */
+ 
+ 	if(erasedChunks < dev->nFreeChunks)
+ 		scatteredFree = (dev->nFreeChunks - erasedChunks);
+ 
+ 	if(!context->bgRunning)
+ 		return 0;
+ 	else if(scatteredFree < (dev->param.nChunksPerBlock * 2))
+ 		return 0;
+ 	else if(erasedChunks > dev->nFreeChunks/2)
+ 		return 0;
+ 	else if(erasedChunks > dev->nFreeChunks/4)
+ 		return 1;
+ 	else
+ 		return 2;
+ }
+ 
+ static int yaffs_do_sync_fs(struct super_block *sb,
+ 				int request_checkpoint)
+ {
+ 
+ 	yaffs_Device *dev = yaffs_SuperToDevice(sb);
+ 	unsigned int oneshot_checkpoint = (yaffs_auto_checkpoint & 4);
+ 	unsigned gc_urgent = yaffs_bg_gc_urgency(dev);
+ 	int do_checkpoint;
+ 
+ 	T(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC | YAFFS_TRACE_BACKGROUND,
+ 		(TSTR("yaffs_do_sync_fs: gc-urgency %d %s %s%s\n"),
+ 		gc_urgent,
+ 		sb->s_dirt ? "dirty" : "clean",
+ 		request_checkpoint ? "checkpoint requested" : "no checkpoint",
+ 		oneshot_checkpoint ? " one-shot" : "" ));
+ 
+ 	yaffs_GrossLock(dev);
+ 	do_checkpoint = ((request_checkpoint && !gc_urgent) ||
+ 			oneshot_checkpoint) &&
+ 			!dev->isCheckpointed;
+ 
+ 	if (sb->s_dirt || do_checkpoint) {
+ 		yaffs_FlushSuperBlock(sb, !dev->isCheckpointed && do_checkpoint);
+ 		sb->s_dirt = 0;
+ 		if(oneshot_checkpoint)
+ 			yaffs_auto_checkpoint &= ~4;
+ 	}
+ 	yaffs_GrossUnlock(dev);
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * yaffs background thread functions .
+  * yaffs_BackgroundThread() the thread function
+  * yaffs_BackgroundStart() launches the background thread.
+  * yaffs_BackgroundStop() cleans up the background thread.
+  *
+  * NB: 
+  * The thread should only run after the yaffs is initialised
+  * The thread should be stopped before yaffs is unmounted.
+  * The thread should not do any writing while the fs is in read only.
+  */
+ 
+ #ifdef YAFFS_COMPILE_BACKGROUND
+ 
+ void yaffs_background_waker(unsigned long data)
+ {
+ 	wake_up_process((struct task_struct *)data);
+ }
+ 
+ static int yaffs_BackgroundThread(void *data)
+ {
+ 	yaffs_Device *dev = (yaffs_Device *)data;
+ 	struct yaffs_LinuxContext *context = yaffs_DeviceToContext(dev);
+ 	unsigned long now = jiffies;
+ 	unsigned long next_dir_update = now;
+ 	unsigned long next_gc = now;
+ 	unsigned long expires;
+ 	unsigned int urgency;
+ 
+ 	int gcResult;
+ 	struct timer_list timer;
+ 
+ 	T(YAFFS_TRACE_BACKGROUND,
+ 		(TSTR("yaffs_background starting for dev %p\n"),
+ 		(void *)dev));
+ 
+ 	set_freezable();
+ 
+ 	while(context->bgRunning){
+ 		T(YAFFS_TRACE_BACKGROUND,
+ 			(TSTR("yaffs_background\n")));
+ 
+ 		if(kthread_should_stop())
+ 			break;
+ 
+ 		if(try_to_freeze())
+ 			continue;
+ 
+ 		yaffs_GrossLock(dev);
+ 
+ 		now = jiffies;
+ 
+ 		if(time_after(now, next_dir_update)){
+ 			yaffs_UpdateDirtyDirectories(dev);
+ 			next_dir_update = now + HZ;
+ 		}
+ 
+ 		if(time_after(now,next_gc)){
+ 			if(!dev->isCheckpointed){
+ 				urgency = yaffs_bg_gc_urgency(dev);
+ 				gcResult = yaffs_BackgroundGarbageCollect(dev, urgency);
+ 				if(urgency > 1)
+ 					next_gc = now + HZ/20+1;
+ 				else if(urgency > 0)
+ 					next_gc = now + HZ/10+1;
+ 				else
+ 					next_gc = now + HZ * 2;
+ 			} else /*
+ 				* gc not running so set to next_dir_update
+ 				* to cut down on wake ups
+ 				*/
+ 				next_gc = next_dir_update;
+ 		}
+ 		yaffs_GrossUnlock(dev);
+ #if 1
+ 		expires = next_dir_update;
+ 		if (time_before(next_gc,expires))
+ 			expires = next_gc;
+ 		if(time_before(expires,now))
+ 			expires = now + HZ;
+ 
+ 		init_timer(&timer);
+ 		timer.expires = expires+1;
+ 		timer.data = (unsigned long) current;
+ 		timer.function = yaffs_background_waker;
+ 
+                 set_current_state(TASK_INTERRUPTIBLE);
+ 		add_timer(&timer);
+ 		schedule();
+ 		del_timer_sync(&timer);
+ #else
+ 		msleep(10);
+ #endif
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int yaffs_BackgroundStart(yaffs_Device *dev)
+ {
+ 	int retval = 0;
+ 	struct yaffs_LinuxContext *context = yaffs_DeviceToContext(dev);
+ 
+ 	context->bgRunning = 1;
+ 
+ 	context->bgThread = kthread_run(yaffs_BackgroundThread,
+ 	                        (void *)dev,"yaffs-bg");
+ 
+ 	if(IS_ERR(context->bgThread)){
+ 		retval = PTR_ERR(context->bgThread);
+ 		context->bgThread = NULL;
+ 		context->bgRunning = 0;
+ 	}
+ 	return retval;
+ }
+ 
+ static void yaffs_BackgroundStop(yaffs_Device *dev)
+ {
+ 	struct yaffs_LinuxContext *ctxt = yaffs_DeviceToContext(dev);
+ 
+ 	ctxt->bgRunning = 0;
+ 
+ 	if( ctxt->bgThread){
+ 		kthread_stop(ctxt->bgThread);
+ 		ctxt->bgThread = NULL;
+ 	}
+ }
+ #else
+ static int yaffs_BackgroundThread(void *data)
+ {
+ 	return 0;
+ }
+ 
+ static int yaffs_BackgroundStart(yaffs_Device *dev)
+ {
+ 	return 0;
+ }
+ 
+ static void yaffs_BackgroundStop(yaffs_Device *dev)
+ {
+ }
+ #endif
+ 
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+ static void yaffs_write_super(struct super_block *sb)
+ #else
+ static int yaffs_write_super(struct super_block *sb)
+ #endif
+ {
+ 	unsigned request_checkpoint = (yaffs_auto_checkpoint >= 2);
+ 
+ 	T(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC | YAFFS_TRACE_BACKGROUND,
+ 		(TSTR("yaffs_write_super%s\n"),
+ 		request_checkpoint ? " checkpt" : ""));
+ 
+ 	yaffs_do_sync_fs(sb, request_checkpoint);
+ 
+ #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18))
+ 	return 0;
+ #endif
+ }
+ 
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+ static int yaffs_sync_fs(struct super_block *sb, int wait)
+ #else
+ static int yaffs_sync_fs(struct super_block *sb)
+ #endif
+ {
+ 	unsigned request_checkpoint = (yaffs_auto_checkpoint >= 1);
+ 
+ 	T(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC,
+ 		(TSTR("yaffs_sync_fs%s\n"),
+ 		request_checkpoint ? " checkpt" : ""));
+ 
+ 	yaffs_do_sync_fs(sb, request_checkpoint);
+ 
+ 	return 0;
+ }
+ 
+ #ifdef YAFFS_USE_OWN_IGET
+ 
+ static struct inode *yaffs_iget(struct super_block *sb, unsigned long ino)
+ {
+ 	struct inode *inode;
+ 	yaffs_Object *obj;
+ 	yaffs_Device *dev = yaffs_SuperToDevice(sb);
+ 
+ 	T(YAFFS_TRACE_OS,
+ 		(TSTR("yaffs_iget for %lu\n"), ino));
+ 
+ 	inode = iget_locked(sb, ino);
+ 	if (!inode)
+ 		return ERR_PTR(-ENOMEM);
+ 	if (!(inode->i_state & I_NEW))
+ 		return inode;
+ 
+ 	/* NB This is called as a side effect of other functions, but
+ 	 * we had to release the lock to prevent deadlocks, so
+ 	 * need to lock again.
+ 	 */
+ 
+ 	yaffs_GrossLock(dev);
+ 
+ 	obj = yaffs_FindObjectByNumber(dev, inode->i_ino);
+ 
+ 	yaffs_FillInodeFromObject(inode, obj);
+ 
+ 	yaffs_GrossUnlock(dev);
+ 
+ 	unlock_new_inode(inode);
+ 	return inode;
+ }
+ 
+ #else
+ 
+ static void yaffs_read_inode(struct inode *inode)
+ {
+ 	/* NB This is called as a side effect of other functions, but
+ 	 * we had to release the lock to prevent deadlocks, so
+ 	 * need to lock again.
+ 	 */
+ 
+ 	yaffs_Object *obj;
+ 	yaffs_Device *dev = yaffs_SuperToDevice(inode->i_sb);
+ 
+ 	T(YAFFS_TRACE_OS,
+ 		(TSTR("yaffs_read_inode for %d\n"), (int)inode->i_ino));
+ 
+ 	if(current != yaffs_DeviceToContext(dev)->readdirProcess)
+ 		yaffs_GrossLock(dev);
+ 
+ 	obj = yaffs_FindObjectByNumber(dev, inode->i_ino);
+ 
+ 	yaffs_FillInodeFromObject(inode, obj);
+ 
+ 	if(current != yaffs_DeviceToContext(dev)->readdirProcess)
+ 		yaffs_GrossUnlock(dev);
+ }
+ 
+ #endif
+ 
+ static YLIST_HEAD(yaffs_context_list);
+ struct semaphore yaffs_context_lock;
+ 
+ #if 0 /* not used */
+ static int yaffs_remount_fs(struct super_block *sb, int *flags, char *data)
+ {
+ 	yaffs_Device    *dev = yaffs_SuperToDevice(sb);
+ 
+ 	if (*flags & MS_RDONLY) {
+ 		struct mtd_info *mtd = yaffs_SuperToDevice(sb)->genericDevice;
+ 
+ 		T(YAFFS_TRACE_OS,
+ 			(TSTR("yaffs_remount_fs: %s: RO\n"), dev->name));
+ 
+ 		yaffs_GrossLock(dev);
+ 
+ 		yaffs_FlushSuperBlock(sb,1);
+ 
+ 		if (mtd->sync)
+ 			mtd->sync(mtd);
+ 
+ 		yaffs_GrossUnlock(dev);
+ 	} else {
+ 		T(YAFFS_TRACE_OS,
+ 			(TSTR("yaffs_remount_fs: %s: RW\n"), dev->name));
+ 	}
+ 
+ 	return 0;
+ }
+ #endif
+ 
+ static void yaffs_put_super(struct super_block *sb)
+ {
+ 	yaffs_Device *dev = yaffs_SuperToDevice(sb);
+ 
+ 	T(YAFFS_TRACE_OS, (TSTR("yaffs_put_super\n")));
+ 
+ 	T(YAFFS_TRACE_OS | YAFFS_TRACE_BACKGROUND,
+ 		(TSTR("Shutting down yaffs background thread\n")));
+ 	yaffs_BackgroundStop(dev);
+ 	T(YAFFS_TRACE_OS | YAFFS_TRACE_BACKGROUND,
+ 		(TSTR("yaffs background thread shut down\n")));
+ 
+ 	yaffs_GrossLock(dev);
+ 
+ 	yaffs_FlushSuperBlock(sb,1);
+ 
+ 	if (yaffs_DeviceToContext(dev)->putSuperFunc)
+ 		yaffs_DeviceToContext(dev)->putSuperFunc(sb);
+ 
+ 
+ 	yaffs_Deinitialise(dev);
+ 
+ 	yaffs_GrossUnlock(dev);
+ 
+ 	down(&yaffs_context_lock);
+ 	ylist_del_init(&(yaffs_DeviceToContext(dev)->contextList));
+ 	up(&yaffs_context_lock);
+ 
+ 	if (yaffs_DeviceToContext(dev)->spareBuffer) {
+ 		YFREE(yaffs_DeviceToContext(dev)->spareBuffer);
+ 		yaffs_DeviceToContext(dev)->spareBuffer = NULL;
+ 	}
+ 
+ 	kfree(dev);
+ }
+ 
+ 
+ static void yaffs_MTDPutSuper(struct super_block *sb)
+ {
+ 	struct mtd_info *mtd = yaffs_DeviceToContext(yaffs_SuperToDevice(sb))->mtd;
+ 
+ 	if (mtd->sync)
+ 		mtd->sync(mtd);
+ 
+ 	put_mtd_device(mtd);
+ }
+ 
+ 
+ static void yaffs_MarkSuperBlockDirty(yaffs_Device *dev)
+ {
+ 	struct super_block *sb = yaffs_DeviceToContext(dev)->superBlock;
+ 
+ 	T(YAFFS_TRACE_OS, (TSTR("yaffs_MarkSuperBlockDirty() sb = %p\n"), sb));
+ 	if (sb)
+ 		sb->s_dirt = 1;
+ }
+ 
+ typedef struct {
+ 	int inband_tags;
+ 	int skip_checkpoint_read;
+ 	int skip_checkpoint_write;
+ 	int no_cache;
+ 	int tags_ecc_on;
+ 	int tags_ecc_overridden;
+ 	int lazy_loading_enabled;
+ 	int lazy_loading_overridden;
+ 	int empty_lost_and_found;
+ 	int empty_lost_and_found_overridden;
+ } yaffs_options;
+ 
+ #define MAX_OPT_LEN 30
+ static int yaffs_parse_options(yaffs_options *options, const char *options_str)
+ {
+ 	char cur_opt[MAX_OPT_LEN + 1];
+ 	int p;
+ 	int error = 0;
+ 
+ 	/* Parse through the options which is a comma seperated list */
+ 
+ 	while (options_str && *options_str && !error) {
+ 		memset(cur_opt, 0, MAX_OPT_LEN + 1);
+ 		p = 0;
+ 
+ 		while(*options_str == ',')
+ 			options_str++;
+ 
+ 		while (*options_str && *options_str != ',') {
+ 			if (p < MAX_OPT_LEN) {
+ 				cur_opt[p] = *options_str;
+ 				p++;
+ 			}
+ 			options_str++;
+ 		}
+ 
+ 		if (!strcmp(cur_opt, "inband-tags"))
+ 			options->inband_tags = 1;
+ 		else if (!strcmp(cur_opt, "tags-ecc-off")){
+ 			options->tags_ecc_on = 0;
+ 			options->tags_ecc_overridden=1;
+ 		} else if (!strcmp(cur_opt, "tags-ecc-on")){
+ 			options->tags_ecc_on = 1;
+ 			options->tags_ecc_overridden = 1;
+ 		} else if (!strcmp(cur_opt, "lazy-loading-off")){
+ 			options->lazy_loading_enabled = 0;
+ 			options->lazy_loading_overridden=1;
+ 		} else if (!strcmp(cur_opt, "lazy-loading-on")){
+ 			options->lazy_loading_enabled = 1;
+ 			options->lazy_loading_overridden = 1;
+ 		} else if (!strcmp(cur_opt, "empty-lost-and-found-off")){
+ 			options->empty_lost_and_found = 0;
+ 			options->empty_lost_and_found_overridden=1;
+ 		} else if (!strcmp(cur_opt, "empty-lost-and-found-on")){
+ 			options->empty_lost_and_found = 1;
+ 			options->empty_lost_and_found_overridden=1;
+ 		} else if (!strcmp(cur_opt, "no-cache"))
+ 			options->no_cache = 1;
+ 		else if (!strcmp(cur_opt, "no-checkpoint-read"))
+ 			options->skip_checkpoint_read = 1;
+ 		else if (!strcmp(cur_opt, "no-checkpoint-write"))
+ 			options->skip_checkpoint_write = 1;
+ 		else if (!strcmp(cur_opt, "no-checkpoint")) {
+ 			options->skip_checkpoint_read = 1;
+ 			options->skip_checkpoint_write = 1;
+ 		} else {
+ 			printk(KERN_INFO "yaffs: Bad mount option \"%s\"\n",
+ 					cur_opt);
+ 			error = 1;
+ 		}
+ 	}
+ 
+ 	return error;
+ }
+ 
+ static struct super_block *yaffs_internal_read_super(int yaffsVersion,
+ 						struct super_block *sb,
+ 						void *data, int silent)
+ {
+ 	int nBlocks;
+ 	struct inode *inode = NULL;
+ 	struct dentry *root;
+ 	yaffs_Device *dev = 0;
+ 	char devname_buf[BDEVNAME_SIZE + 1];
+ 	struct mtd_info *mtd;
+ 	int err;
+ 	char *data_str = (char *)data;
+ 	struct yaffs_LinuxContext *context = NULL;
+ 	yaffs_DeviceParam *param;
+ 
+ 	yaffs_options options;
+ 
+ 	sb->s_magic = YAFFS_MAGIC;
+ 	sb->s_op = &yaffs_super_ops;
+ 	sb->s_flags |= MS_NOATIME;
+ 
+ #ifdef YAFFS_COMPILE_EXPORTFS
+ 	sb->s_export_op = &yaffs_export_ops;
+ #endif
+ 
+ 	if (!sb)
+ 		printk(KERN_INFO "yaffs: sb is NULL\n");
+ 	else if (!sb->s_dev)
+ 		printk(KERN_INFO "yaffs: sb->s_dev is NULL\n");
+ 	else if (!yaffs_devname(sb, devname_buf))
+ 		printk(KERN_INFO "yaffs: devname is NULL\n");
+ 	else
+ 		printk(KERN_INFO "yaffs: dev is %d name is \"%s\"\n",
+ 		       sb->s_dev,
+ 		       yaffs_devname(sb, devname_buf));
+ 
+ 	if (!data_str)
+ 		data_str = "";
+ 
+ 	printk(KERN_INFO "yaffs: passed flags \"%s\"\n", data_str);
+ 
+ 	memset(&options, 0, sizeof(options));
+ 
+ 	if (yaffs_parse_options(&options, data_str)) {
+ 		/* Option parsing failed */
+ 		return NULL;
+ 	}
+ 
+ 
+ 	sb->s_blocksize = PAGE_CACHE_SIZE;
+ 	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
+ 
+ 	T(YAFFS_TRACE_OS,
+ 		(TSTR("yaffs_read_super: Using yaffs%d\n"), yaffsVersion));
+ 	T(YAFFS_TRACE_OS,
+ 		(TSTR("yaffs_read_super: block size %d\n"),
+ 		(int)(sb->s_blocksize)));
+ 
+ 	T(YAFFS_TRACE_ALWAYS,
+ 		(TSTR("yaffs: Attempting MTD mount of %u.%u,\"%s\"\n"),
+ 	       MAJOR(sb->s_dev), MINOR(sb->s_dev),
+ 	       yaffs_devname(sb, devname_buf)));
+ 
+ 	/* Check it's an mtd device..... */
+ 	if (MAJOR(sb->s_dev) != MTD_BLOCK_MAJOR)
+ 		return NULL;	/* This isn't an mtd device */
+ 
+ 	/* Get the device */
+ 	mtd = get_mtd_device(NULL, MINOR(sb->s_dev));
+ 	if (!mtd) {
+ 		T(YAFFS_TRACE_ALWAYS,
+ 			(TSTR("yaffs: MTD device #%u doesn't appear to exist\n"),
+ 			MINOR(sb->s_dev)));
+ 		return NULL;
+ 	}
+ 	/* Check it's NAND */
+ 	if (mtd->type != MTD_NANDFLASH) {
+ 		T(YAFFS_TRACE_ALWAYS,
+ 			(TSTR("yaffs: MTD device is not NAND it's type %d\n"),
+ 			mtd->type));
+ 		return NULL;
+ 	}
+ 
+ 	T(YAFFS_TRACE_OS, (TSTR(" erase %p\n"), mtd->erase));
+ 	T(YAFFS_TRACE_OS, (TSTR(" read %p\n"), mtd->read));
+ 	T(YAFFS_TRACE_OS, (TSTR(" write %p\n"), mtd->write));
+ 	T(YAFFS_TRACE_OS, (TSTR(" readoob %p\n"), mtd->read_oob));
+ 	T(YAFFS_TRACE_OS, (TSTR(" writeoob %p\n"), mtd->write_oob));
+ 	T(YAFFS_TRACE_OS, (TSTR(" block_isbad %p\n"), mtd->block_isbad));
+ 	T(YAFFS_TRACE_OS, (TSTR(" block_markbad %p\n"), mtd->block_markbad));
+ 	T(YAFFS_TRACE_OS, (TSTR(" %s %d\n"), WRITE_SIZE_STR, WRITE_SIZE(mtd)));
+ 	T(YAFFS_TRACE_OS, (TSTR(" oobsize %d\n"), mtd->oobsize));
+ 	T(YAFFS_TRACE_OS, (TSTR(" erasesize %d\n"), mtd->erasesize));
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
+ 	T(YAFFS_TRACE_OS, (TSTR(" size %u\n"), mtd->size));
+ #else
+ 	T(YAFFS_TRACE_OS, (TSTR(" size %lld\n"), mtd->size));
+ #endif
+ 
+ #ifdef CONFIG_YAFFS_AUTO_YAFFS2
+ 
+ 	if (yaffsVersion == 1 && WRITE_SIZE(mtd) >= 2048) {
+ 		T(YAFFS_TRACE_ALWAYS,
+ 			(TSTR("yaffs: auto selecting yaffs2\n")));
+ 		yaffsVersion = 2;
+ 	}
+ 
+ 	/* Added NCB 26/5/2006 for completeness */
+ 	if (yaffsVersion == 2 && !options.inband_tags && WRITE_SIZE(mtd) == 512) {
+ 		T(YAFFS_TRACE_ALWAYS,
+ 			(TSTR("yaffs: auto selecting yaffs1\n")));
+ 		yaffsVersion = 1;
+ 	}
+ 
+ #endif
+ 
+ 	if (yaffsVersion == 2) {
+ 		/* Check for version 2 style functions */
+ 		if (!mtd->erase ||
+ 		    !mtd->block_isbad ||
+ 		    !mtd->block_markbad ||
+ 		    !mtd->read ||
+ 		    !mtd->write ||
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+ 		    !mtd->read_oob || !mtd->write_oob) {
+ #else
+ 		    !mtd->write_ecc ||
+ 		    !mtd->read_ecc || !mtd->read_oob || !mtd->write_oob) {
+ #endif
+ 			T(YAFFS_TRACE_ALWAYS,
+ 			  (TSTR("yaffs: MTD device does not support required "
+ 			   "functions\n")));
+ 			return NULL;
+ 		}
+ 
+ 		if ((WRITE_SIZE(mtd) < YAFFS_MIN_YAFFS2_CHUNK_SIZE ||
+ 		    mtd->oobsize < YAFFS_MIN_YAFFS2_SPARE_SIZE) &&
+ 		    !options.inband_tags) {
+ 			T(YAFFS_TRACE_ALWAYS,
+ 			  (TSTR("yaffs: MTD device does not have the "
+ 			   "right page sizes\n")));
+ 			return NULL;
+ 		}
+ 	} else {
+ 		/* Check for V1 style functions */
+ 		if (!mtd->erase ||
+ 		    !mtd->read ||
+ 		    !mtd->write ||
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+ 		    !mtd->read_oob || !mtd->write_oob) {
+ #else
+ 		    !mtd->write_ecc ||
+ 		    !mtd->read_ecc || !mtd->read_oob || !mtd->write_oob) {
+ #endif
+ 			T(YAFFS_TRACE_ALWAYS,
+ 			  (TSTR("yaffs: MTD device does not support required "
+ 			   "functions\n")));
+ 			return NULL;
+ 		}
+ 
+ 		if (WRITE_SIZE(mtd) < YAFFS_BYTES_PER_CHUNK ||
+ 		    mtd->oobsize != YAFFS_BYTES_PER_SPARE) {
+ 			T(YAFFS_TRACE_ALWAYS,
+ 			  (TSTR("yaffs: MTD device does not support have the "
+ 			   "right page sizes\n")));
+ 			return NULL;
+ 		}
+ 	}
+ 
+ 	/* OK, so if we got here, we have an MTD that's NAND and looks
+ 	 * like it has the right capabilities
+ 	 * Set the yaffs_Device up for mtd
+ 	 */
+ 
+ 	dev = kmalloc(sizeof(yaffs_Device), GFP_KERNEL);
+ 	context = kmalloc(sizeof(struct yaffs_LinuxContext),GFP_KERNEL);
+ 	
+ 	if(!dev || !context ){
+ 		if(dev)
+ 			kfree(dev);
+ 		if(context)
+ 			kfree(context);
+ 		dev = NULL;
+ 		context = NULL;
+ 	}
+ 
+ 	if (!dev) {
+ 		/* Deep shit could not allocate device structure */
+ 		T(YAFFS_TRACE_ALWAYS,
+ 		  (TSTR("yaffs_read_super: Failed trying to allocate "
+ 		   "yaffs_Device. \n")));
+ 		return NULL;
+ 	}
+ 	memset(dev, 0, sizeof(yaffs_Device));
+ 	param = &(dev->param);
+ 
+ 	memset(context,0,sizeof(struct yaffs_LinuxContext));
+ 	dev->context = context;
+ 	YINIT_LIST_HEAD(&(context->contextList));
+ 	context->dev = dev;
+ 	context->superBlock = sb;
+ 
+ 	
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+ 	sb->s_fs_info = dev;
+ #else
+ 	sb->u.generic_sbp = dev;
+ #endif
+ 	
+ 	yaffs_DeviceToContext(dev)->mtd = mtd;
+ 	param->name = mtd->name;
+ 
+ 	/* Set up the memory size parameters.... */
+ 
+ 	nBlocks = YCALCBLOCKS(mtd->size, (YAFFS_CHUNKS_PER_BLOCK * YAFFS_BYTES_PER_CHUNK));
+ 
+ 	param->startBlock = 0;
+ 	param->endBlock = nBlocks - 1;
+ 	param->nChunksPerBlock = YAFFS_CHUNKS_PER_BLOCK;
+ 	param->totalBytesPerChunk = YAFFS_BYTES_PER_CHUNK;
+ 	param->nReservedBlocks = 5;
+ 	param->nShortOpCaches = (options.no_cache) ? 0 : 10;
+ 	param->inbandTags = options.inband_tags;
+ 
+ #ifdef CONFIG_YAFFS_DISABLE_LAZY_LOAD
+ 	param->disableLazyLoad = 1;
+ #endif
+ 	if(options.lazy_loading_overridden)
+ 		param->disableLazyLoad = !options.lazy_loading_enabled;
+ 
+ #ifdef CONFIG_YAFFS_DISABLE_TAGS_ECC
+ 	param->noTagsECC = 1;
+ #endif
+ 
+ #ifdef CONFIG_YAFFS_DISABLE_BACKGROUND
+ #else
+ 	param->deferDirectoryUpdate = 1;
+ #endif
+ 
+ 	if(options.tags_ecc_overridden)
+ 		param->noTagsECC = !options.tags_ecc_on;
+ 
+ #ifdef CONFIG_YAFFS_EMPTY_LOST_AND_FOUND
+ 	param->emptyLostAndFound = 1;
+ #endif
+ 
+ #ifdef CONFIG_YAFFS_DISABLE_BLOCK_REFRESHING
+ 	param->refreshPeriod = 0;
+ #else
+ 	param->refreshPeriod = 500;
+ #endif
+ 
+ 	if(options.empty_lost_and_found_overridden)
+ 		param->emptyLostAndFound = options.empty_lost_and_found;
+ 
+ 	/* ... and the functions. */
+ 	if (yaffsVersion == 2) {
+ 		param->writeChunkWithTagsToNAND =
+ 		    nandmtd2_WriteChunkWithTagsToNAND;
+ 		param->readChunkWithTagsFromNAND =
+ 		    nandmtd2_ReadChunkWithTagsFromNAND;
+ 		param->markNANDBlockBad = nandmtd2_MarkNANDBlockBad;
+ 		param->queryNANDBlock = nandmtd2_QueryNANDBlock;
+ 		yaffs_DeviceToContext(dev)->spareBuffer = YMALLOC(mtd->oobsize);
+ 		param->isYaffs2 = 1;
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+ 		param->totalBytesPerChunk = mtd->writesize;
+ 		param->nChunksPerBlock = mtd->erasesize / mtd->writesize;
+ #else
+ 		param->totalBytesPerChunk = mtd->oobblock;
+ 		param->nChunksPerBlock = mtd->erasesize / mtd->oobblock;
+ #endif
+ 		nBlocks = YCALCBLOCKS(mtd->size, mtd->erasesize);
+ 
+ 		param->startBlock = 0;
+ 		param->endBlock = nBlocks - 1;
+ 	} else {
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+ 		/* use the MTD interface in yaffs_mtdif1.c */
+ 		param->writeChunkWithTagsToNAND =
+ 			nandmtd1_WriteChunkWithTagsToNAND;
+ 		param->readChunkWithTagsFromNAND =
+ 			nandmtd1_ReadChunkWithTagsFromNAND;
+ 		param->markNANDBlockBad = nandmtd1_MarkNANDBlockBad;
+ 		param->queryNANDBlock = nandmtd1_QueryNANDBlock;
+ #else
+ 		param->writeChunkToNAND = nandmtd_WriteChunkToNAND;
+ 		param->readChunkFromNAND = nandmtd_ReadChunkFromNAND;
+ #endif
+ 		param->isYaffs2 = 0;
+ 	}
+ 	/* ... and common functions */
+ 	param->eraseBlockInNAND = nandmtd_EraseBlockInNAND;
+ 	param->initialiseNAND = nandmtd_InitialiseNAND;
+ 
+ 	yaffs_DeviceToContext(dev)->putSuperFunc = yaffs_MTDPutSuper;
+ 
+ 	param->markSuperBlockDirty = yaffs_MarkSuperBlockDirty;
+ 	param->gcControl = yaffs_gc_control_callback;
+ 
+ 	yaffs_DeviceToContext(dev)->superBlock= sb;
+ 	
+ 
+ #ifndef CONFIG_YAFFS_DOES_ECC
+ 	param->useNANDECC = 1;
+ #endif
+ 
+ #ifdef CONFIG_YAFFS_DISABLE_WIDE_TNODES
+ 	param->wideTnodesDisabled = 1;
+ #endif
+ 
+ 	param->skipCheckpointRead = options.skip_checkpoint_read;
+ 	param->skipCheckpointWrite = options.skip_checkpoint_write;
+ 
+ 	/* we assume this is protected by lock_kernel() in mount/umount */
+ 	down(&yaffs_context_lock);
+ 	ylist_add_tail(&(yaffs_DeviceToContext(dev)->contextList), &yaffs_context_list);
+ 	up(&yaffs_context_lock);
+ 
+         /* Directory search handling...*/
+         YINIT_LIST_HEAD(&(yaffs_DeviceToContext(dev)->searchContexts));
+         param->removeObjectCallback = yaffs_RemoveObjectCallback;
+ 
+ 	init_MUTEX(&(yaffs_DeviceToContext(dev)->grossLock));
+ 
+ 	yaffs_GrossLock(dev);
+ 
+ 	err = yaffs_GutsInitialise(dev);
+ 
+ 	T(YAFFS_TRACE_OS,
+ 	  (TSTR("yaffs_read_super: guts initialised %s\n"),
+ 	   (err == YAFFS_OK) ? "OK" : "FAILED"));
+ 	   
+ 	if(err == YAFFS_OK)
+ 		yaffs_BackgroundStart(dev);
+ 		
+ 	if(!context->bgThread)
+ 		param->deferDirectoryUpdate = 0;
+ 
+ 
+ 	/* Release lock before yaffs_get_inode() */
+ 	yaffs_GrossUnlock(dev);
+ 
+ 	/* Create root inode */
+ 	if (err == YAFFS_OK)
+ 		inode = yaffs_get_inode(sb, S_IFDIR | 0755, 0,
+ 					yaffs_Root(dev));
+ 
+ 	if (!inode)
+ 		return NULL;
+ 
+ 	inode->i_op = &yaffs_dir_inode_operations;
+ 	inode->i_fop = &yaffs_dir_operations;
+ 
+ 	T(YAFFS_TRACE_OS, (TSTR("yaffs_read_super: got root inode\n")));
+ 
+ 	root = d_alloc_root(inode);
+ 
+ 	T(YAFFS_TRACE_OS, (TSTR("yaffs_read_super: d_alloc_root done\n")));
+ 
+ 	if (!root) {
+ 		iput(inode);
+ 		return NULL;
+ 	}
+ 	sb->s_root = root;
+ 	sb->s_dirt = !dev->isCheckpointed;
+ 	T(YAFFS_TRACE_ALWAYS,
+ 		(TSTR("yaffs_read_super: isCheckpointed %d\n"),
+ 		dev->isCheckpointed));
+ 
+ 	T(YAFFS_TRACE_OS, (TSTR("yaffs_read_super: done\n")));
+ 	return sb;
+ }
+ 
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+ static int yaffs_internal_read_super_mtd(struct super_block *sb, void *data,
+ 					 int silent)
+ {
+ 	return yaffs_internal_read_super(1, sb, data, silent) ? 0 : -EINVAL;
+ }
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+ static int yaffs_read_super(struct file_system_type *fs,
+ 			    int flags, const char *dev_name,
+ 			    void *data, struct vfsmount *mnt)
+ {
+ 
+ 	return get_sb_bdev(fs, flags, dev_name, data,
+ 			   yaffs_internal_read_super_mtd, mnt);
+ }
+ #else
+ static struct super_block *yaffs_read_super(struct file_system_type *fs,
+ 					    int flags, const char *dev_name,
+ 					    void *data)
+ {
+ 
+ 	return get_sb_bdev(fs, flags, dev_name, data,
+ 			   yaffs_internal_read_super_mtd);
+ }
+ #endif
+ 
+ static struct file_system_type yaffs_fs_type = {
+ 	.owner = THIS_MODULE,
+ 	.name = "yaffs",
+ 	.get_sb = yaffs_read_super,
+ 	.kill_sb = kill_block_super,
+ 	.fs_flags = FS_REQUIRES_DEV,
+ };
+ #else
+ static struct super_block *yaffs_read_super(struct super_block *sb, void *data,
+ 					    int silent)
+ {
+ 	return yaffs_internal_read_super(1, sb, data, silent);
+ }
+ 
+ static DECLARE_FSTYPE(yaffs_fs_type, "yaffs", yaffs_read_super,
+ 		      FS_REQUIRES_DEV);
+ #endif
+ 
+ 
+ #ifdef CONFIG_YAFFS_YAFFS2
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+ static int yaffs2_internal_read_super_mtd(struct super_block *sb, void *data,
+ 					  int silent)
+ {
+ 	return yaffs_internal_read_super(2, sb, data, silent) ? 0 : -EINVAL;
+ }
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+ static int yaffs2_read_super(struct file_system_type *fs,
+ 			int flags, const char *dev_name, void *data,
+ 			struct vfsmount *mnt)
+ {
+ 	return get_sb_bdev(fs, flags, dev_name, data,
+ 			yaffs2_internal_read_super_mtd, mnt);
+ }
+ #else
+ static struct super_block *yaffs2_read_super(struct file_system_type *fs,
+ 					     int flags, const char *dev_name,
+ 					     void *data)
+ {
+ 
+ 	return get_sb_bdev(fs, flags, dev_name, data,
+ 			   yaffs2_internal_read_super_mtd);
+ }
+ #endif
+ 
+ static struct file_system_type yaffs2_fs_type = {
+ 	.owner = THIS_MODULE,
+ 	.name = "yaffs2",
+ 	.get_sb = yaffs2_read_super,
+ 	.kill_sb = kill_block_super,
+ 	.fs_flags = FS_REQUIRES_DEV,
+ };
+ #else
+ static struct super_block *yaffs2_read_super(struct super_block *sb,
+ 					     void *data, int silent)
+ {
+ 	return yaffs_internal_read_super(2, sb, data, silent);
+ }
+ 
+ static DECLARE_FSTYPE(yaffs2_fs_type, "yaffs2", yaffs2_read_super,
+ 		      FS_REQUIRES_DEV);
+ #endif
+ 
+ #endif				/* CONFIG_YAFFS_YAFFS2 */
+ 
+ static struct proc_dir_entry *my_proc_entry;
+ static struct proc_dir_entry *debug_proc_entry;
+ 
+ static char *yaffs_dump_dev_part0(char *buf, yaffs_Device * dev)
+ {
+ 	buf += sprintf(buf, "startBlock......... %d\n", dev->param.startBlock);
+ 	buf += sprintf(buf, "endBlock........... %d\n", dev->param.endBlock);
+ 	buf += sprintf(buf, "totalBytesPerChunk. %d\n", dev->param.totalBytesPerChunk);
+ 	buf += sprintf(buf, "useNANDECC......... %d\n", dev->param.useNANDECC);
+ 	buf += sprintf(buf, "noTagsECC.......... %d\n", dev->param.noTagsECC);
+ 	buf += sprintf(buf, "isYaffs2........... %d\n", dev->param.isYaffs2);
+ 	buf += sprintf(buf, "inbandTags......... %d\n", dev->param.inbandTags);
+ 	buf += sprintf(buf, "emptyLostAndFound.. %d\n", dev->param.emptyLostAndFound);
+ 	buf += sprintf(buf, "disableLazyLoad.... %d\n", dev->param.disableLazyLoad);
+ 	buf += sprintf(buf, "refreshPeriod...... %d\n", dev->param.refreshPeriod);
+ 	buf += sprintf(buf, "nShortOpCaches..... %d\n", dev->param.nShortOpCaches);
+ 	buf += sprintf(buf, "nReservedBlocks.... %d\n", dev->param.nReservedBlocks);
+ 
+ 	buf += sprintf(buf, "\n");
+ 
+ 	return buf;
+ }
+ 
+ 
+ static char *yaffs_dump_dev_part1(char *buf, yaffs_Device * dev)
+ {
+ 	buf += sprintf(buf, "nDataBytesPerChunk. %d\n", dev->nDataBytesPerChunk);
+ 	buf += sprintf(buf, "chunkGroupBits..... %d\n", dev->chunkGroupBits);
+ 	buf += sprintf(buf, "chunkGroupSize..... %d\n", dev->chunkGroupSize);
+ 	buf += sprintf(buf, "nErasedBlocks...... %d\n", dev->nErasedBlocks);
+ 	buf += sprintf(buf, "blocksInCheckpoint. %d\n", dev->blocksInCheckpoint);
+ 	buf += sprintf(buf, "\n");
+ 	buf += sprintf(buf, "nTnodesCreated..... %d\n", dev->nTnodesCreated);
+ 	buf += sprintf(buf, "nFreeTnodes........ %d\n", dev->nFreeTnodes);
+ 	buf += sprintf(buf, "nObjectsCreated.... %d\n", dev->nObjectsCreated);
+ 	buf += sprintf(buf, "nFreeObjects....... %d\n", dev->nFreeObjects);
+ 	buf += sprintf(buf, "nFreeChunks........ %d\n", dev->nFreeChunks);
+ 	buf += sprintf(buf, "\n");
+ 	buf += sprintf(buf, "nPageWrites........ %u\n", dev->nPageWrites);
+ 	buf += sprintf(buf, "nPageReads......... %u\n", dev->nPageReads);
+ 	buf += sprintf(buf, "nBlockErasures..... %u\n", dev->nBlockErasures);
+ 	buf += sprintf(buf, "nGCCopies.......... %u\n", dev->nGCCopies);
+ 	buf += sprintf(buf, "allGCs............. %u\n", dev->allGCs);
+ 	buf += sprintf(buf, "passiveGCs......... %u\n", dev->passiveGCs);
+ 	buf += sprintf(buf, "oldestDirtyGCs..... %u\n", dev->oldestDirtyGCs);
+ 	buf += sprintf(buf, "backgroundGCs...... %u\n", dev->backgroundGCs);
+ 	buf += sprintf(buf, "nRetriedWrites..... %u\n", dev->nRetriedWrites);
+ 	buf += sprintf(buf, "nRetireBlocks...... %u\n", dev->nRetiredBlocks);
+ 	buf += sprintf(buf, "eccFixed........... %u\n", dev->eccFixed);
+ 	buf += sprintf(buf, "eccUnfixed......... %u\n", dev->eccUnfixed);
+ 	buf += sprintf(buf, "tagsEccFixed....... %u\n", dev->tagsEccFixed);
+ 	buf += sprintf(buf, "tagsEccUnfixed..... %u\n", dev->tagsEccUnfixed);
+ 	buf += sprintf(buf, "cacheHits.......... %u\n", dev->cacheHits);
+ 	buf += sprintf(buf, "nDeletedFiles...... %u\n", dev->nDeletedFiles);
+ 	buf += sprintf(buf, "nUnlinkedFiles..... %u\n", dev->nUnlinkedFiles);
+ 	buf += sprintf(buf, "refreshCount....... %u\n", dev->refreshCount);
+ 	buf +=
+ 	    sprintf(buf, "nBackgroudDeletions %u\n", dev->nBackgroundDeletions);
+ 
+ 	return buf;
+ }
+ 
+ static int yaffs_proc_read(char *page,
+ 			   char **start,
+ 			   off_t offset, int count, int *eof, void *data)
+ {
+ 	struct ylist_head *item;
+ 	char *buf = page;
+ 	int step = offset;
+ 	int n = 0;
+ 
+ 	/* Get proc_file_read() to step 'offset' by one on each sucessive call.
+ 	 * We use 'offset' (*ppos) to indicate where we are in devList.
+ 	 * This also assumes the user has posted a read buffer large
+ 	 * enough to hold the complete output; but that's life in /proc.
+ 	 */
+ 
+ 	*(int *)start = 1;
+ 
+ 	/* Print header first */
+ 	if (step == 0)
+ 		buf += sprintf(buf, "YAFFS built:" __DATE__ " " __TIME__"\n");
+ 	else if (step == 1)
+ 		buf += sprintf(buf,"\n");
+ 	else {
+ 		step-=2;
+ 		
+ 		down(&yaffs_context_lock);
+ 
+ 		/* Locate and print the Nth entry.  Order N-squared but N is small. */
+ 		ylist_for_each(item, &yaffs_context_list) {
+ 			struct yaffs_LinuxContext *dc = ylist_entry(item, struct yaffs_LinuxContext, contextList);
+ 			yaffs_Device *dev = dc->dev;
+ 
+ 			if (n < (step & ~1)) {
+ 				n+=2;
+ 				continue;
+ 			}
+ 			if((step & 1)==0){
+ 				buf += sprintf(buf, "\nDevice %d \"%s\"\n", n, dev->param.name);
+ 				buf = yaffs_dump_dev_part0(buf, dev);
+ 			} else
+ 				buf = yaffs_dump_dev_part1(buf, dev);
+ 			
+ 			break;
+ 		}
+ 		up(&yaffs_context_lock);
+ 	}
+ 
+ 	return buf - page < count ? buf - page : count;
+ }
+ 
+ static int yaffs_stats_proc_read(char *page,
+ 				char **start,
+ 				off_t offset, int count, int *eof, void *data)
+ {
+ 	struct ylist_head *item;
+ 	char *buf = page;
+ 	int n = 0;
+ 
+ 	down(&yaffs_context_lock);
+ 
+ 	/* Locate and print the Nth entry.  Order N-squared but N is small. */
+ 	ylist_for_each(item, &yaffs_context_list) {
+ 		struct yaffs_LinuxContext *dc = ylist_entry(item, struct yaffs_LinuxContext, contextList);
+ 		yaffs_Device *dev = dc->dev;
+ 
+ 		int erasedChunks;
+ 		int nObjects;
+ 		int nTnodes;
+ 
+ 		erasedChunks = dev->nErasedBlocks * dev->param.nChunksPerBlock;
+ 		nObjects = dev->nObjectsCreated -dev->nFreeObjects;
+ 		nTnodes = dev->nTnodesCreated - dev->nFreeTnodes;
+ 		
+ 		
+ 		buf += sprintf(buf,"%d, %d, %d, %u, %u, %d, %d\n",
+ 				n, dev->nFreeChunks, erasedChunks,
+ 				dev->backgroundGCs, dev->oldestDirtyGCs,
+ 				nObjects, nTnodes);
+ 	}
+ 	up(&yaffs_context_lock);
+ 
+ 
+ 	return buf - page < count ? buf - page : count;
+ }
+ 
+ /**
+  * Set the verbosity of the warnings and error messages.
+  *
+  * Note that the names can only be a..z or _ with the current code.
+  */
+ 
+ static struct {
+ 	char *mask_name;
+ 	unsigned mask_bitfield;
+ } mask_flags[] = {
+ 	{"allocate", YAFFS_TRACE_ALLOCATE},
+ 	{"always", YAFFS_TRACE_ALWAYS},
+ 	{"background", YAFFS_TRACE_BACKGROUND},
+ 	{"bad_blocks", YAFFS_TRACE_BAD_BLOCKS},
+ 	{"buffers", YAFFS_TRACE_BUFFERS},
+ 	{"bug", YAFFS_TRACE_BUG},
+ 	{"checkpt", YAFFS_TRACE_CHECKPOINT},
+ 	{"deletion", YAFFS_TRACE_DELETION},
+ 	{"erase", YAFFS_TRACE_ERASE},
+ 	{"error", YAFFS_TRACE_ERROR},
+ 	{"gc_detail", YAFFS_TRACE_GC_DETAIL},
+ 	{"gc", YAFFS_TRACE_GC},
+ 	{"lock", YAFFS_TRACE_LOCK},
+ 	{"mtd", YAFFS_TRACE_MTD},
+ 	{"nandaccess", YAFFS_TRACE_NANDACCESS},
+ 	{"os", YAFFS_TRACE_OS},
+ 	{"scan_debug", YAFFS_TRACE_SCAN_DEBUG},
+ 	{"scan", YAFFS_TRACE_SCAN},
+ 	{"tracing", YAFFS_TRACE_TRACING},
+ 	{"sync", YAFFS_TRACE_SYNC},
+ 	{"write", YAFFS_TRACE_WRITE},
+ 
+ 	{"verify", YAFFS_TRACE_VERIFY},
+ 	{"verify_nand", YAFFS_TRACE_VERIFY_NAND},
+ 	{"verify_full", YAFFS_TRACE_VERIFY_FULL},
+ 	{"verify_all", YAFFS_TRACE_VERIFY_ALL},
+ 
+ 	{"all", 0xffffffff},
+ 	{"none", 0},
+ 	{NULL, 0},
+ };
+ 
+ #define MAX_MASK_NAME_LENGTH 40
+ static int yaffs_proc_write_trace_options(struct file *file, const char *buf,
+ 					 unsigned long count, void *data)
+ {
+ 	unsigned rg = 0, mask_bitfield;
+ 	char *end;
+ 	char *mask_name;
+ 	const char *x;
+ 	char substring[MAX_MASK_NAME_LENGTH + 1];
+ 	int i;
+ 	int done = 0;
+ 	int add, len = 0;
+ 	int pos = 0;
+ 
+ 	rg = yaffs_traceMask;
+ 
+ 	while (!done && (pos < count)) {
+ 		done = 1;
+ 		while ((pos < count) && isspace(buf[pos]))
+ 			pos++;
+ 
+ 		switch (buf[pos]) {
+ 		case '+':
+ 		case '-':
+ 		case '=':
+ 			add = buf[pos];
+ 			pos++;
+ 			break;
+ 
+ 		default:
+ 			add = ' ';
+ 			break;
+ 		}
+ 		mask_name = NULL;
+ 
+ 		mask_bitfield = simple_strtoul(buf + pos, &end, 0);
+ 
+ 		if (end > buf + pos) {
+ 			mask_name = "numeral";
+ 			len = end - (buf + pos);
+ 			pos += len;
+ 			done = 0;
+ 		} else {
+ 			for (x = buf + pos, i = 0;
+ 			    (*x == '_' || (*x >= 'a' && *x <= 'z')) &&
+ 			    i < MAX_MASK_NAME_LENGTH; x++, i++, pos++)
+ 				substring[i] = *x;
+ 			substring[i] = '\0';
+ 
+ 			for (i = 0; mask_flags[i].mask_name != NULL; i++) {
+ 				if (strcmp(substring, mask_flags[i].mask_name) == 0) {
+ 					mask_name = mask_flags[i].mask_name;
+ 					mask_bitfield = mask_flags[i].mask_bitfield;
+ 					done = 0;
+ 					break;
+ 				}
+ 			}
+ 		}
+ 
+ 		if (mask_name != NULL) {
+ 			done = 0;
+ 			switch (add) {
+ 			case '-':
+ 				rg &= ~mask_bitfield;
+ 				break;
+ 			case '+':
+ 				rg |= mask_bitfield;
+ 				break;
+ 			case '=':
+ 				rg = mask_bitfield;
+ 				break;
+ 			default:
+ 				rg |= mask_bitfield;
+ 				break;
+ 			}
+ 		}
+ 	}
+ 
+ 	yaffs_traceMask = rg | YAFFS_TRACE_ALWAYS;
+ 
+ 	printk(KERN_DEBUG "new trace = 0x%08X\n", yaffs_traceMask);
+ 
+ 	if (rg & YAFFS_TRACE_ALWAYS) {
+ 		for (i = 0; mask_flags[i].mask_name != NULL; i++) {
+ 			char flag;
+ 			flag = ((rg & mask_flags[i].mask_bitfield) ==
+ 				mask_flags[i].mask_bitfield) ? '+' : '-';
+ 			printk(KERN_DEBUG "%c%s\n", flag, mask_flags[i].mask_name);
+ 		}
+ 	}
+ 
+ 	return count;
+ }
+ 
+ 
+ static int yaffs_proc_write(struct file *file, const char *buf,
+ 					 unsigned long count, void *data)
+ {
+         return yaffs_proc_write_trace_options(file, buf, count, data);
+ }
+ 
+ /* Stuff to handle installation of file systems */
+ struct file_system_to_install {
+ 	struct file_system_type *fst;
+ 	int installed;
+ };
+ 
+ static struct file_system_to_install fs_to_install[] = {
+ 	{&yaffs_fs_type, 0},
+ 	{&yaffs2_fs_type, 0},
+ 	{NULL, 0}
+ };
+ 
+ static int __init init_yaffs_fs(void)
+ {
+ 	int error = 0;
+ 	struct file_system_to_install *fsinst;
+ 
+ 	T(YAFFS_TRACE_ALWAYS,
+ 	  (TSTR("yaffs built " __DATE__ " " __TIME__ " Installing. \n")));
+ 
+ #ifdef CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED
+ 	T(YAFFS_TRACE_ALWAYS,
+ 	  (TSTR(" \n\n\n\nYAFFS-WARNING CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED selected.\n\n\n\n")));
+ #endif
+ 
+ 
+ 
+ 
+ 	init_MUTEX(&yaffs_context_lock);
+ 
+ 	/* Install the proc_fs entries */
+ 	my_proc_entry = create_proc_entry("yaffs",
+ 					       S_IRUGO | S_IFREG,
+ 					       YPROC_ROOT);
+ 
+ 	if (my_proc_entry) {
+ 		my_proc_entry->write_proc = yaffs_proc_write;
+ 		my_proc_entry->read_proc = yaffs_proc_read;
+ 		my_proc_entry->data = NULL;
+ 	} else
+ 		return -ENOMEM;
+ 
+ 	debug_proc_entry = create_proc_entry("yaffs_stats",
+ 					       S_IRUGO | S_IFREG,
+ 					       YPROC_ROOT);
+ 
+ 	if (debug_proc_entry) {
+ 		debug_proc_entry->write_proc = NULL;
+ 		debug_proc_entry->read_proc = yaffs_stats_proc_read;
+ 		debug_proc_entry->data = NULL;
+ 	} else
+ 		return -ENOMEM;
+ 
+ 	/* Now add the file system entries */
+ 
+ 	fsinst = fs_to_install;
+ 
+ 	while (fsinst->fst && !error) {
+ 		error = register_filesystem(fsinst->fst);
+ 		if (!error)
+ 			fsinst->installed = 1;
+ 		fsinst++;
+ 	}
+ 
+ 	/* Any errors? uninstall  */
+ 	if (error) {
+ 		fsinst = fs_to_install;
+ 
+ 		while (fsinst->fst) {
+ 			if (fsinst->installed) {
+ 				unregister_filesystem(fsinst->fst);
+ 				fsinst->installed = 0;
+ 			}
+ 			fsinst++;
+ 		}
+ 	}
+ 
+ 	return error;
+ }
+ 
+ static void __exit exit_yaffs_fs(void)
+ {
+ 
+ 	struct file_system_to_install *fsinst;
+ 
+ 	T(YAFFS_TRACE_ALWAYS,
+ 		(TSTR("yaffs built " __DATE__ " " __TIME__ " removing. \n")));
+ 
+ 	remove_proc_entry("yaffs", YPROC_ROOT);
+ 	remove_proc_entry("yaffs_stats", YPROC_ROOT);
+ 
+ 	fsinst = fs_to_install;
+ 
+ 	while (fsinst->fst) {
+ 		if (fsinst->installed) {
+ 			unregister_filesystem(fsinst->fst);
+ 			fsinst->installed = 0;
+ 		}
+ 		fsinst++;
+ 	}
+ }
+ 
+ module_init(init_yaffs_fs)
+ module_exit(exit_yaffs_fs)
+ 
+ MODULE_DESCRIPTION("YAFFS2 - a NAND specific flash file system");
+ MODULE_AUTHOR("Charles Manning, Aleph One Ltd., 2002-2010");
+ MODULE_LICENSE("GPL");
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/yaffs_getblockinfo.h liab-linux-2.6.29.4/fs/yaffs2/yaffs_getblockinfo.h
*** linux-2.6.29.4/fs/yaffs2/yaffs_getblockinfo.h	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/yaffs_getblockinfo.h	2012-01-20 14:48:21.865306031 +0100
***************
*** 0 ****
--- 1,35 ----
+ /*
+  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+  *
+  * Copyright (C) 2002-2010 Aleph One Ltd.
+  *   for Toby Churchill Ltd and Brightstar Engineering
+  *
+  * Created by Charles Manning <charles@aleph1.co.uk>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU Lesser General Public License version 2.1 as
+  * published by the Free Software Foundation.
+  *
+  * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+  */
+ 
+ #ifndef __YAFFS_GETBLOCKINFO_H__
+ #define __YAFFS_GETBLOCKINFO_H__
+ 
+ #include "yaffs_guts.h"
+ #include "yaffs_trace.h"
+ 
+ /* Function to manipulate block info */
+ static Y_INLINE yaffs_BlockInfo *yaffs_GetBlockInfo(yaffs_Device * dev, int blk)
+ {
+ 	if (blk < dev->internalStartBlock || blk > dev->internalEndBlock) {
+ 		T(YAFFS_TRACE_ERROR,
+ 		  (TSTR
+ 		   ("**>> yaffs: getBlockInfo block %d is not valid" TENDSTR),
+ 		   blk));
+ 		YBUG();
+ 	}
+ 	return &dev->blockInfo[blk - dev->internalStartBlock];
+ }
+ 
+ #endif
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/yaffs_guts.c liab-linux-2.6.29.4/fs/yaffs2/yaffs_guts.c
*** linux-2.6.29.4/fs/yaffs2/yaffs_guts.c	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/yaffs_guts.c	2012-01-20 14:48:21.865306031 +0100
***************
*** 0 ****
--- 1,8237 ----
+ /*
+  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+  *
+  * Copyright (C) 2002-2010 Aleph One Ltd.
+  *   for Toby Churchill Ltd and Brightstar Engineering
+  *
+  * Created by Charles Manning <charles@aleph1.co.uk>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2 as
+  * published by the Free Software Foundation.
+  */
+ #include "yportenv.h"
+ #include "yaffs_trace.h"
+ 
+ #include "yaffsinterface.h"
+ #include "yaffs_guts.h"
+ #include "yaffs_tagsvalidity.h"
+ #include "yaffs_getblockinfo.h"
+ 
+ #include "yaffs_tagscompat.h"
+ #ifndef CONFIG_YAFFS_USE_OWN_SORT
+ #include "yaffs_qsort.h"
+ #endif
+ #include "yaffs_nand.h"
+ 
+ #include "yaffs_checkptrw.h"
+ 
+ #include "yaffs_nand.h"
+ #include "yaffs_packedtags2.h"
+ 
+ 
+ /* Note YAFFS_GC_GOOD_ENOUGH must be <= YAFFS_GC_PASSIVE_THRESHOLD */
+ #define YAFFS_GC_GOOD_ENOUGH 2
+ #define YAFFS_GC_PASSIVE_THRESHOLD 4
+ 
+ #define YAFFS_SMALL_HOLE_THRESHOLD 3
+ 
+ /*
+  * Checkpoints are really no benefit on very small partitions.
+  *
+  * To save space on small partitions don't bother with checkpoints unless
+  * the partition is at least this big.
+  */
+ #define YAFFS_CHECKPOINT_MIN_BLOCKS 60
+ 
+ #include "yaffs_ecc.h"
+ 
+ 
+ /* Robustification (if it ever comes about...) */
+ static void yaffs_RetireBlock(yaffs_Device *dev, int blockInNAND);
+ static void yaffs_HandleWriteChunkError(yaffs_Device *dev, int chunkInNAND,
+ 		int erasedOk);
+ static void yaffs_HandleWriteChunkOk(yaffs_Device *dev, int chunkInNAND,
+ 				const __u8 *data,
+ 				const yaffs_ExtendedTags *tags);
+ static void yaffs_HandleUpdateChunk(yaffs_Device *dev, int chunkInNAND,
+ 				const yaffs_ExtendedTags *tags);
+ 
+ /* Other local prototypes */
+ static void yaffs_UpdateParent(yaffs_Object *obj);
+ static int yaffs_UnlinkObject(yaffs_Object *obj);
+ static int yaffs_ObjectHasCachedWriteData(yaffs_Object *obj);
+ 
+ static void yaffs_HardlinkFixup(yaffs_Device *dev, yaffs_Object *hardList);
+ 
+ static int yaffs_WriteNewChunkWithTagsToNAND(yaffs_Device *dev,
+ 					const __u8 *buffer,
+ 					yaffs_ExtendedTags *tags,
+ 					int useReserve);
+ static int yaffs_PutChunkIntoFile(yaffs_Object *in, int chunkInInode,
+ 				int chunkInNAND, int inScan);
+ 
+ static yaffs_Object *yaffs_CreateNewObject(yaffs_Device *dev, int number,
+ 					yaffs_ObjectType type);
+ static void yaffs_AddObjectToDirectory(yaffs_Object *directory,
+ 				yaffs_Object *obj);
+ static int yaffs_UpdateObjectHeader(yaffs_Object *in, const YCHAR *name,
+ 				int force, int isShrink, int shadows);
+ static void yaffs_RemoveObjectFromDirectory(yaffs_Object *obj);
+ static int yaffs_CheckStructures(void);
+ static int yaffs_DoGenericObjectDeletion(yaffs_Object *in);
+ 
+ static yaffs_BlockInfo *yaffs_GetBlockInfo(yaffs_Device *dev, int blockNo);
+ 
+ 
+ static int yaffs_CheckChunkErased(struct yaffs_DeviceStruct *dev,
+ 				int chunkInNAND);
+ 
+ static int yaffs_UnlinkWorker(yaffs_Object *obj);
+ 
+ static int yaffs_TagsMatch(const yaffs_ExtendedTags *tags, int objectId,
+ 			int chunkInObject);
+ 
+ static int yaffs_AllocateChunk(yaffs_Device *dev, int useReserve,
+ 				yaffs_BlockInfo **blockUsedPtr);
+ 
+ static void yaffs_VerifyFreeChunks(yaffs_Device *dev);
+ 
+ static void yaffs_CheckObjectDetailsLoaded(yaffs_Object *in);
+ 
+ static void yaffs_VerifyDirectory(yaffs_Object *directory);
+ #ifdef YAFFS_PARANOID
+ static int yaffs_CheckFileSanity(yaffs_Object *in);
+ #else
+ #define yaffs_CheckFileSanity(in)
+ #endif
+ 
+ static void yaffs_InvalidateWholeChunkCache(yaffs_Object *in);
+ static void yaffs_InvalidateChunkCache(yaffs_Object *object, int chunkId);
+ 
+ static void yaffs_InvalidateCheckpoint(yaffs_Device *dev);
+ 
+ static int yaffs_FindChunkInFile(yaffs_Object *in, int chunkInInode,
+ 				yaffs_ExtendedTags *tags);
+ 
+ static __u32 yaffs_GetChunkGroupBase(yaffs_Device *dev, yaffs_Tnode *tn,
+ 		unsigned pos);
+ static yaffs_Tnode *yaffs_FindLevel0Tnode(yaffs_Device *dev,
+ 					yaffs_FileStructure *fStruct,
+ 					__u32 chunkId);
+ 
+ static int yaffs_HandleHole(yaffs_Object *obj, loff_t newSize);
+ static void yaffs_SkipRestOfBlock(yaffs_Device *dev);
+ static int yaffs_VerifyChunkWritten(yaffs_Device *dev,
+ 					int chunkInNAND,
+ 					const __u8 *data,
+ 					yaffs_ExtendedTags *tags);
+ 
+ /* Function to calculate chunk and offset */
+ 
+ static void yaffs_AddrToChunk(yaffs_Device *dev, loff_t addr, int *chunkOut,
+ 		__u32 *offsetOut)
+ {
+ 	int chunk;
+ 	__u32 offset;
+ 
+ 	chunk  = (__u32)(addr >> dev->chunkShift);
+ 
+ 	if (dev->chunkDiv == 1) {
+ 		/* easy power of 2 case */
+ 		offset = (__u32)(addr & dev->chunkMask);
+ 	} else {
+ 		/* Non power-of-2 case */
+ 
+ 		loff_t chunkBase;
+ 
+ 		chunk /= dev->chunkDiv;
+ 
+ 		chunkBase = ((loff_t)chunk) * dev->nDataBytesPerChunk;
+ 		offset = (__u32)(addr - chunkBase);
+ 	}
+ 
+ 	*chunkOut = chunk;
+ 	*offsetOut = offset;
+ }
+ 
+ /* Function to return the number of shifts for a power of 2 greater than or
+  * equal to the given number
+  * Note we don't try to cater for all possible numbers and this does not have to
+  * be hellishly efficient.
+  */
+ 
+ static __u32 ShiftsGE(__u32 x)
+ {
+ 	int extraBits;
+ 	int nShifts;
+ 
+ 	nShifts = extraBits = 0;
+ 
+ 	while (x > 1) {
+ 		if (x & 1)
+ 			extraBits++;
+ 		x >>= 1;
+ 		nShifts++;
+ 	}
+ 
+ 	if (extraBits)
+ 		nShifts++;
+ 
+ 	return nShifts;
+ }
+ 
+ /* Function to return the number of shifts to get a 1 in bit 0
+  */
+ 
+ static __u32 Shifts(__u32 x)
+ {
+ 	__u32 nShifts;
+ 
+ 	nShifts =  0;
+ 
+ 	if (!x)
+ 		return 0;
+ 
+ 	while (!(x&1)) {
+ 		x >>= 1;
+ 		nShifts++;
+ 	}
+ 
+ 	return nShifts;
+ }
+ 
+ 
+ 
+ /*
+  * Temporary buffer manipulations.
+  */
+ 
+ static int yaffs_InitialiseTempBuffers(yaffs_Device *dev)
+ {
+ 	int i;
+ 	__u8 *buf = (__u8 *)1;
+ 
+ 	memset(dev->tempBuffer, 0, sizeof(dev->tempBuffer));
+ 
+ 	for (i = 0; buf && i < YAFFS_N_TEMP_BUFFERS; i++) {
+ 		dev->tempBuffer[i].line = 0;	/* not in use */
+ 		dev->tempBuffer[i].buffer = buf =
+ 		    YMALLOC_DMA(dev->param.totalBytesPerChunk);
+ 	}
+ 
+ 	return buf ? YAFFS_OK : YAFFS_FAIL;
+ }
+ 
+ __u8 *yaffs_GetTempBuffer(yaffs_Device *dev, int lineNo)
+ {
+ 	int i, j;
+ 
+ 	dev->tempInUse++;
+ 	if (dev->tempInUse > dev->maxTemp)
+ 		dev->maxTemp = dev->tempInUse;
+ 
+ 	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
+ 		if (dev->tempBuffer[i].line == 0) {
+ 			dev->tempBuffer[i].line = lineNo;
+ 			if ((i + 1) > dev->maxTemp) {
+ 				dev->maxTemp = i + 1;
+ 				for (j = 0; j <= i; j++)
+ 					dev->tempBuffer[j].maxLine =
+ 					    dev->tempBuffer[j].line;
+ 			}
+ 
+ 			return dev->tempBuffer[i].buffer;
+ 		}
+ 	}
+ 
+ 	T(YAFFS_TRACE_BUFFERS,
+ 	  (TSTR("Out of temp buffers at line %d, other held by lines:"),
+ 	   lineNo));
+ 	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++)
+ 		T(YAFFS_TRACE_BUFFERS, (TSTR(" %d "), dev->tempBuffer[i].line));
+ 
+ 	T(YAFFS_TRACE_BUFFERS, (TSTR(" " TENDSTR)));
+ 
+ 	/*
+ 	 * If we got here then we have to allocate an unmanaged one
+ 	 * This is not good.
+ 	 */
+ 
+ 	dev->unmanagedTempAllocations++;
+ 	return YMALLOC(dev->nDataBytesPerChunk);
+ 
+ }
+ 
+ void yaffs_ReleaseTempBuffer(yaffs_Device *dev, __u8 *buffer,
+ 				    int lineNo)
+ {
+ 	int i;
+ 
+ 	dev->tempInUse--;
+ 
+ 	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
+ 		if (dev->tempBuffer[i].buffer == buffer) {
+ 			dev->tempBuffer[i].line = 0;
+ 			return;
+ 		}
+ 	}
+ 
+ 	if (buffer) {
+ 		/* assume it is an unmanaged one. */
+ 		T(YAFFS_TRACE_BUFFERS,
+ 		  (TSTR("Releasing unmanaged temp buffer in line %d" TENDSTR),
+ 		   lineNo));
+ 		YFREE(buffer);
+ 		dev->unmanagedTempDeallocations++;
+ 	}
+ 
+ }
+ 
+ /*
+  * Determine if we have a managed buffer.
+  */
+ int yaffs_IsManagedTempBuffer(yaffs_Device *dev, const __u8 *buffer)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
+ 		if (dev->tempBuffer[i].buffer == buffer)
+ 			return 1;
+ 	}
+ 
+ 	for (i = 0; i < dev->param.nShortOpCaches; i++) {
+ 		if (dev->srCache[i].data == buffer)
+ 			return 1;
+ 	}
+ 
+ 	if (buffer == dev->checkpointBuffer)
+ 		return 1;
+ 
+ 	T(YAFFS_TRACE_ALWAYS,
+ 		(TSTR("yaffs: unmaged buffer detected.\n" TENDSTR)));
+ 	return 0;
+ }
+ 
+ 
+ 
+ /*
+  * Chunk bitmap manipulations
+  */
+ 
+ static Y_INLINE __u8 *yaffs_BlockBits(yaffs_Device *dev, int blk)
+ {
+ 	if (blk < dev->internalStartBlock || blk > dev->internalEndBlock) {
+ 		T(YAFFS_TRACE_ERROR,
+ 			(TSTR("**>> yaffs: BlockBits block %d is not valid" TENDSTR),
+ 			blk));
+ 		YBUG();
+ 	}
+ 	return dev->chunkBits +
+ 		(dev->chunkBitmapStride * (blk - dev->internalStartBlock));
+ }
+ 
+ static Y_INLINE void yaffs_VerifyChunkBitId(yaffs_Device *dev, int blk, int chunk)
+ {
+ 	if (blk < dev->internalStartBlock || blk > dev->internalEndBlock ||
+ 			chunk < 0 || chunk >= dev->param.nChunksPerBlock) {
+ 		T(YAFFS_TRACE_ERROR,
+ 		(TSTR("**>> yaffs: Chunk Id (%d:%d) invalid"TENDSTR),
+ 			blk, chunk));
+ 		YBUG();
+ 	}
+ }
+ 
+ static Y_INLINE void yaffs_ClearChunkBits(yaffs_Device *dev, int blk)
+ {
+ 	__u8 *blkBits = yaffs_BlockBits(dev, blk);
+ 
+ 	memset(blkBits, 0, dev->chunkBitmapStride);
+ }
+ 
+ static Y_INLINE void yaffs_ClearChunkBit(yaffs_Device *dev, int blk, int chunk)
+ {
+ 	__u8 *blkBits = yaffs_BlockBits(dev, blk);
+ 
+ 	yaffs_VerifyChunkBitId(dev, blk, chunk);
+ 
+ 	blkBits[chunk / 8] &= ~(1 << (chunk & 7));
+ }
+ 
+ static Y_INLINE void yaffs_SetChunkBit(yaffs_Device *dev, int blk, int chunk)
+ {
+ 	__u8 *blkBits = yaffs_BlockBits(dev, blk);
+ 
+ 	yaffs_VerifyChunkBitId(dev, blk, chunk);
+ 
+ 	blkBits[chunk / 8] |= (1 << (chunk & 7));
+ }
+ 
+ static Y_INLINE int yaffs_CheckChunkBit(yaffs_Device *dev, int blk, int chunk)
+ {
+ 	__u8 *blkBits = yaffs_BlockBits(dev, blk);
+ 	yaffs_VerifyChunkBitId(dev, blk, chunk);
+ 
+ 	return (blkBits[chunk / 8] & (1 << (chunk & 7))) ? 1 : 0;
+ }
+ 
+ static Y_INLINE int yaffs_StillSomeChunkBits(yaffs_Device *dev, int blk)
+ {
+ 	__u8 *blkBits = yaffs_BlockBits(dev, blk);
+ 	int i;
+ 	for (i = 0; i < dev->chunkBitmapStride; i++) {
+ 		if (*blkBits)
+ 			return 1;
+ 		blkBits++;
+ 	}
+ 	return 0;
+ }
+ 
+ static int yaffs_CountChunkBits(yaffs_Device *dev, int blk)
+ {
+ 	__u8 *blkBits = yaffs_BlockBits(dev, blk);
+ 	int i;
+ 	int n = 0;
+ 	for (i = 0; i < dev->chunkBitmapStride; i++) {
+ 		__u8 x = *blkBits;
+ 		while (x) {
+ 			if (x & 1)
+ 				n++;
+ 			x >>= 1;
+ 		}
+ 
+ 		blkBits++;
+ 	}
+ 	return n;
+ }
+ 
+ /*
+  * Verification code
+  */
+ 
+ static int yaffs_SkipVerification(yaffs_Device *dev)
+ {
+ 	dev=dev;
+ 	return !(yaffs_traceMask & (YAFFS_TRACE_VERIFY | YAFFS_TRACE_VERIFY_FULL));
+ }
+ 
+ static int yaffs_SkipFullVerification(yaffs_Device *dev)
+ {
+ 	dev=dev;
+ 	return !(yaffs_traceMask & (YAFFS_TRACE_VERIFY_FULL));
+ }
+ 
+ static int yaffs_SkipNANDVerification(yaffs_Device *dev)
+ {
+ 	dev=dev;
+ 	return !(yaffs_traceMask & (YAFFS_TRACE_VERIFY_NAND));
+ }
+ 
+ static const char *blockStateName[] = {
+ "Unknown",
+ "Needs scanning",
+ "Scanning",
+ "Empty",
+ "Allocating",
+ "Full",
+ "Dirty",
+ "Checkpoint",
+ "Collecting",
+ "Dead"
+ };
+ 
+ static void yaffs_VerifyBlock(yaffs_Device *dev, yaffs_BlockInfo *bi, int n)
+ {
+ 	int actuallyUsed;
+ 	int inUse;
+ 
+ 	if (yaffs_SkipVerification(dev))
+ 		return;
+ 
+ 	/* Report illegal runtime states */
+ 	if (bi->blockState >= YAFFS_NUMBER_OF_BLOCK_STATES)
+ 		T(YAFFS_TRACE_VERIFY, (TSTR("Block %d has undefined state %d"TENDSTR), n, bi->blockState));
+ 
+ 	switch (bi->blockState) {
+ 	case YAFFS_BLOCK_STATE_UNKNOWN:
+ 	case YAFFS_BLOCK_STATE_SCANNING:
+ 	case YAFFS_BLOCK_STATE_NEEDS_SCANNING:
+ 		T(YAFFS_TRACE_VERIFY, (TSTR("Block %d has bad run-state %s"TENDSTR),
+ 		n, blockStateName[bi->blockState]));
+ 	}
+ 
+ 	/* Check pages in use and soft deletions are legal */
+ 
+ 	actuallyUsed = bi->pagesInUse - bi->softDeletions;
+ 
+ 	if (bi->pagesInUse < 0 || bi->pagesInUse > dev->param.nChunksPerBlock ||
+ 	   bi->softDeletions < 0 || bi->softDeletions > dev->param.nChunksPerBlock ||
+ 	   actuallyUsed < 0 || actuallyUsed > dev->param.nChunksPerBlock)
+ 		T(YAFFS_TRACE_VERIFY, (TSTR("Block %d has illegal values pagesInUsed %d softDeletions %d"TENDSTR),
+ 		n, bi->pagesInUse, bi->softDeletions));
+ 
+ 
+ 	/* Check chunk bitmap legal */
+ 	inUse = yaffs_CountChunkBits(dev, n);
+ 	if (inUse != bi->pagesInUse)
+ 		T(YAFFS_TRACE_VERIFY, (TSTR("Block %d has inconsistent values pagesInUse %d counted chunk bits %d"TENDSTR),
+ 			n, bi->pagesInUse, inUse));
+ 
+ 	/* Check that the sequence number is valid.
+ 	 * Ten million is legal, but is very unlikely
+ 	 */
+ 	if (dev->param.isYaffs2 &&
+ 	   (bi->blockState == YAFFS_BLOCK_STATE_ALLOCATING || bi->blockState == YAFFS_BLOCK_STATE_FULL) &&
+ 	   (bi->sequenceNumber < YAFFS_LOWEST_SEQUENCE_NUMBER || bi->sequenceNumber > 10000000))
+ 		T(YAFFS_TRACE_VERIFY, (TSTR("Block %d has suspect sequence number of %d"TENDSTR),
+ 		n, bi->sequenceNumber));
+ }
+ 
+ static void yaffs_VerifyCollectedBlock(yaffs_Device *dev, yaffs_BlockInfo *bi,
+ 		int n)
+ {
+ 	yaffs_VerifyBlock(dev, bi, n);
+ 
+ 	/* After collection the block should be in the erased state */
+ 	/* This will need to change if we do partial gc */
+ 
+ 	if (bi->blockState != YAFFS_BLOCK_STATE_COLLECTING &&
+ 			bi->blockState != YAFFS_BLOCK_STATE_EMPTY) {
+ 		T(YAFFS_TRACE_ERROR, (TSTR("Block %d is in state %d after gc, should be erased"TENDSTR),
+ 			n, bi->blockState));
+ 	}
+ }
+ 
+ static void yaffs_VerifyBlocks(yaffs_Device *dev)
+ {
+ 	int i;
+ 	int nBlocksPerState[YAFFS_NUMBER_OF_BLOCK_STATES];
+ 	int nIllegalBlockStates = 0;
+ 
+ 	if (yaffs_SkipVerification(dev))
+ 		return;
+ 
+ 	memset(nBlocksPerState, 0, sizeof(nBlocksPerState));
+ 
+ 	for (i = dev->internalStartBlock; i <= dev->internalEndBlock; i++) {
+ 		yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, i);
+ 		yaffs_VerifyBlock(dev, bi, i);
+ 
+ 		if (bi->blockState < YAFFS_NUMBER_OF_BLOCK_STATES)
+ 			nBlocksPerState[bi->blockState]++;
+ 		else
+ 			nIllegalBlockStates++;
+ 	}
+ 
+ 	T(YAFFS_TRACE_VERIFY, (TSTR(""TENDSTR)));
+ 	T(YAFFS_TRACE_VERIFY, (TSTR("Block summary"TENDSTR)));
+ 
+ 	T(YAFFS_TRACE_VERIFY, (TSTR("%d blocks have illegal states"TENDSTR), nIllegalBlockStates));
+ 	if (nBlocksPerState[YAFFS_BLOCK_STATE_ALLOCATING] > 1)
+ 		T(YAFFS_TRACE_VERIFY, (TSTR("Too many allocating blocks"TENDSTR)));
+ 
+ 	for (i = 0; i < YAFFS_NUMBER_OF_BLOCK_STATES; i++)
+ 		T(YAFFS_TRACE_VERIFY,
+ 		  (TSTR("%s %d blocks"TENDSTR),
+ 		  blockStateName[i], nBlocksPerState[i]));
+ 
+ 	if (dev->blocksInCheckpoint != nBlocksPerState[YAFFS_BLOCK_STATE_CHECKPOINT])
+ 		T(YAFFS_TRACE_VERIFY,
+ 		 (TSTR("Checkpoint block count wrong dev %d count %d"TENDSTR),
+ 		 dev->blocksInCheckpoint, nBlocksPerState[YAFFS_BLOCK_STATE_CHECKPOINT]));
+ 
+ 	if (dev->nErasedBlocks != nBlocksPerState[YAFFS_BLOCK_STATE_EMPTY])
+ 		T(YAFFS_TRACE_VERIFY,
+ 		 (TSTR("Erased block count wrong dev %d count %d"TENDSTR),
+ 		 dev->nErasedBlocks, nBlocksPerState[YAFFS_BLOCK_STATE_EMPTY]));
+ 
+ 	if (nBlocksPerState[YAFFS_BLOCK_STATE_COLLECTING] > 1)
+ 		T(YAFFS_TRACE_VERIFY,
+ 		 (TSTR("Too many collecting blocks %d (max is 1)"TENDSTR),
+ 		 nBlocksPerState[YAFFS_BLOCK_STATE_COLLECTING]));
+ 
+ 	T(YAFFS_TRACE_VERIFY, (TSTR(""TENDSTR)));
+ 
+ }
+ 
+ /*
+  * Verify the object header. oh must be valid, but obj and tags may be NULL in which
+  * case those tests will not be performed.
+  */
+ static void yaffs_VerifyObjectHeader(yaffs_Object *obj, yaffs_ObjectHeader *oh, yaffs_ExtendedTags *tags, int parentCheck)
+ {
+ 	if (obj && yaffs_SkipVerification(obj->myDev))
+ 		return;
+ 
+ 	if (!(tags && obj && oh)) {
+ 		T(YAFFS_TRACE_VERIFY,
+ 				(TSTR("Verifying object header tags %p obj %p oh %p"TENDSTR),
+ 				tags, obj, oh));
+ 		return;
+ 	}
+ 
+ 	if (oh->type <= YAFFS_OBJECT_TYPE_UNKNOWN ||
+ 			oh->type > YAFFS_OBJECT_TYPE_MAX)
+ 		T(YAFFS_TRACE_VERIFY,
+ 			(TSTR("Obj %d header type is illegal value 0x%x"TENDSTR),
+ 			tags->objectId, oh->type));
+ 
+ 	if (tags->objectId != obj->objectId)
+ 		T(YAFFS_TRACE_VERIFY,
+ 			(TSTR("Obj %d header mismatch objectId %d"TENDSTR),
+ 			tags->objectId, obj->objectId));
+ 
+ 
+ 	/*
+ 	 * Check that the object's parent ids match if parentCheck requested.
+ 	 *
+ 	 * Tests do not apply to the root object.
+ 	 */
+ 
+ 	if (parentCheck && tags->objectId > 1 && !obj->parent)
+ 		T(YAFFS_TRACE_VERIFY,
+ 			(TSTR("Obj %d header mismatch parentId %d obj->parent is NULL"TENDSTR),
+ 			tags->objectId, oh->parentObjectId));
+ 
+ 	if (parentCheck && obj->parent &&
+ 			oh->parentObjectId != obj->parent->objectId &&
+ 			(oh->parentObjectId != YAFFS_OBJECTID_UNLINKED ||
+ 			obj->parent->objectId != YAFFS_OBJECTID_DELETED))
+ 		T(YAFFS_TRACE_VERIFY,
+ 			(TSTR("Obj %d header mismatch parentId %d parentObjectId %d"TENDSTR),
+ 			tags->objectId, oh->parentObjectId, obj->parent->objectId));
+ 
+ 	if (tags->objectId > 1 && oh->name[0] == 0) /* Null name */
+ 		T(YAFFS_TRACE_VERIFY,
+ 			(TSTR("Obj %d header name is NULL"TENDSTR),
+ 			obj->objectId));
+ 
+ 	if (tags->objectId > 1 && ((__u8)(oh->name[0])) == 0xff) /* Trashed name */
+ 		T(YAFFS_TRACE_VERIFY,
+ 			(TSTR("Obj %d header name is 0xFF"TENDSTR),
+ 			obj->objectId));
+ }
+ 
+ 
+ #if 0
+ /* Not being used, but don't want to throw away yet */
+ static int yaffs_VerifyTnodeWorker(yaffs_Object *obj, yaffs_Tnode *tn,
+ 					__u32 level, int chunkOffset)
+ {
+ 	int i;
+ 	yaffs_Device *dev = obj->myDev;
+ 	int ok = 1;
+ 
+ 	if (tn) {
+ 		if (level > 0) {
+ 
+ 			for (i = 0; i < YAFFS_NTNODES_INTERNAL && ok; i++) {
+ 				if (tn->internal[i]) {
+ 					ok = yaffs_VerifyTnodeWorker(obj,
+ 							tn->internal[i],
+ 							level - 1,
+ 							(chunkOffset<<YAFFS_TNODES_INTERNAL_BITS) + i);
+ 				}
+ 			}
+ 		} else if (level == 0) {
+ 			yaffs_ExtendedTags tags;
+ 			__u32 objectId = obj->objectId;
+ 
+ 			chunkOffset <<=  YAFFS_TNODES_LEVEL0_BITS;
+ 
+ 			for (i = 0; i < YAFFS_NTNODES_LEVEL0; i++) {
+ 				__u32 theChunk = yaffs_GetChunkGroupBase(dev, tn, i);
+ 
+ 				if (theChunk > 0) {
+ 					/* T(~0,(TSTR("verifying (%d:%d) %d"TENDSTR),tags.objectId,tags.chunkId,theChunk)); */
+ 					yaffs_ReadChunkWithTagsFromNAND(dev, theChunk, NULL, &tags);
+ 					if (tags.objectId != objectId || tags.chunkId != chunkOffset) {
+ 						T(~0, (TSTR("Object %d chunkId %d NAND mismatch chunk %d tags (%d:%d)"TENDSTR),
+ 							objectId, chunkOffset, theChunk,
+ 							tags.objectId, tags.chunkId));
+ 					}
+ 				}
+ 				chunkOffset++;
+ 			}
+ 		}
+ 	}
+ 
+ 	return ok;
+ 
+ }
+ 
+ #endif
+ 
+ static void yaffs_VerifyFile(yaffs_Object *obj)
+ {
+ 	int requiredTallness;
+ 	int actualTallness;
+ 	__u32 lastChunk;
+ 	__u32 x;
+ 	__u32 i;
+ 	yaffs_Device *dev;
+ 	yaffs_ExtendedTags tags;
+ 	yaffs_Tnode *tn;
+ 	__u32 objectId;
+ 
+ 	if (!obj)
+ 		return;
+ 
+ 	if (yaffs_SkipVerification(obj->myDev))
+ 		return;
+ 
+ 	dev = obj->myDev;
+ 	objectId = obj->objectId;
+ 
+ 	/* Check file size is consistent with tnode depth */
+ 	lastChunk =  obj->variant.fileVariant.fileSize / dev->nDataBytesPerChunk + 1;
+ 	x = lastChunk >> YAFFS_TNODES_LEVEL0_BITS;
+ 	requiredTallness = 0;
+ 	while (x > 0) {
+ 		x >>= YAFFS_TNODES_INTERNAL_BITS;
+ 		requiredTallness++;
+ 	}
+ 
+ 	actualTallness = obj->variant.fileVariant.topLevel;
+ 
+ 	/* Check that the chunks in the tnode tree are all correct.
+ 	 * We do this by scanning through the tnode tree and
+ 	 * checking the tags for every chunk match.
+ 	 */
+ 
+ 	if (yaffs_SkipNANDVerification(dev))
+ 		return;
+ 
+ 	for (i = 1; i <= lastChunk; i++) {
+ 		tn = yaffs_FindLevel0Tnode(dev, &obj->variant.fileVariant, i);
+ 
+ 		if (tn) {
+ 			__u32 theChunk = yaffs_GetChunkGroupBase(dev, tn, i);
+ 			if (theChunk > 0) {
+ 				/* T(~0,(TSTR("verifying (%d:%d) %d"TENDSTR),objectId,i,theChunk)); */
+ 				yaffs_ReadChunkWithTagsFromNAND(dev, theChunk, NULL, &tags);
+ 				if (tags.objectId != objectId || tags.chunkId != i) {
+ 					T(~0, (TSTR("Object %d chunkId %d NAND mismatch chunk %d tags (%d:%d)"TENDSTR),
+ 						objectId, i, theChunk,
+ 						tags.objectId, tags.chunkId));
+ 				}
+ 			}
+ 		}
+ 	}
+ }
+ 
+ 
+ static void yaffs_VerifyHardLink(yaffs_Object *obj)
+ {
+ 	if (obj && yaffs_SkipVerification(obj->myDev))
+ 		return;
+ 
+ 	/* Verify sane equivalent object */
+ }
+ 
+ static void yaffs_VerifySymlink(yaffs_Object *obj)
+ {
+ 	if (obj && yaffs_SkipVerification(obj->myDev))
+ 		return;
+ 
+ 	/* Verify symlink string */
+ }
+ 
+ static void yaffs_VerifySpecial(yaffs_Object *obj)
+ {
+ 	if (obj && yaffs_SkipVerification(obj->myDev))
+ 		return;
+ }
+ 
+ static void yaffs_VerifyObject(yaffs_Object *obj)
+ {
+ 	yaffs_Device *dev;
+ 
+ 	__u32 chunkMin;
+ 	__u32 chunkMax;
+ 
+ 	__u32 chunkIdOk;
+ 	__u32 chunkInRange;
+ 	__u32 chunkShouldNotBeDeleted;
+ 	__u32 chunkValid;
+ 
+ 	if (!obj)
+ 		return;
+ 
+ 	if (obj->beingCreated)
+ 		return;
+ 
+ 	dev = obj->myDev;
+ 
+ 	if (yaffs_SkipVerification(dev))
+ 		return;
+ 
+ 	/* Check sane object header chunk */
+ 
+ 	chunkMin = dev->internalStartBlock * dev->param.nChunksPerBlock;
+ 	chunkMax = (dev->internalEndBlock+1) * dev->param.nChunksPerBlock - 1;
+ 
+ 	chunkInRange = (((unsigned)(obj->hdrChunk)) >= chunkMin && ((unsigned)(obj->hdrChunk)) <= chunkMax);
+ 	chunkIdOk = chunkInRange || (obj->hdrChunk == 0);
+ 	chunkValid = chunkInRange &&
+ 			yaffs_CheckChunkBit(dev,
+ 					obj->hdrChunk / dev->param.nChunksPerBlock,
+ 					obj->hdrChunk % dev->param.nChunksPerBlock);
+ 	chunkShouldNotBeDeleted = chunkInRange && !chunkValid;
+ 
+ 	if (!obj->fake &&
+ 			(!chunkIdOk || chunkShouldNotBeDeleted)) {
+ 		T(YAFFS_TRACE_VERIFY,
+ 			(TSTR("Obj %d has chunkId %d %s %s"TENDSTR),
+ 			obj->objectId, obj->hdrChunk,
+ 			chunkIdOk ? "" : ",out of range",
+ 			chunkShouldNotBeDeleted ? ",marked as deleted" : ""));
+ 	}
+ 
+ 	if (chunkValid && !yaffs_SkipNANDVerification(dev)) {
+ 		yaffs_ExtendedTags tags;
+ 		yaffs_ObjectHeader *oh;
+ 		__u8 *buffer = yaffs_GetTempBuffer(dev, __LINE__);
+ 
+ 		oh = (yaffs_ObjectHeader *)buffer;
+ 
+ 		yaffs_ReadChunkWithTagsFromNAND(dev, obj->hdrChunk, buffer,
+ 				&tags);
+ 
+ 		yaffs_VerifyObjectHeader(obj, oh, &tags, 1);
+ 
+ 		yaffs_ReleaseTempBuffer(dev, buffer, __LINE__);
+ 	}
+ 
+ 	/* Verify it has a parent */
+ 	if (obj && !obj->fake &&
+ 			(!obj->parent || obj->parent->myDev != dev)) {
+ 		T(YAFFS_TRACE_VERIFY,
+ 			(TSTR("Obj %d has parent pointer %p which does not look like an object"TENDSTR),
+ 			obj->objectId, obj->parent));
+ 	}
+ 
+ 	/* Verify parent is a directory */
+ 	if (obj->parent && obj->parent->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
+ 		T(YAFFS_TRACE_VERIFY,
+ 			(TSTR("Obj %d's parent is not a directory (type %d)"TENDSTR),
+ 			obj->objectId, obj->parent->variantType));
+ 	}
+ 
+ 	switch (obj->variantType) {
+ 	case YAFFS_OBJECT_TYPE_FILE:
+ 		yaffs_VerifyFile(obj);
+ 		break;
+ 	case YAFFS_OBJECT_TYPE_SYMLINK:
+ 		yaffs_VerifySymlink(obj);
+ 		break;
+ 	case YAFFS_OBJECT_TYPE_DIRECTORY:
+ 		yaffs_VerifyDirectory(obj);
+ 		break;
+ 	case YAFFS_OBJECT_TYPE_HARDLINK:
+ 		yaffs_VerifyHardLink(obj);
+ 		break;
+ 	case YAFFS_OBJECT_TYPE_SPECIAL:
+ 		yaffs_VerifySpecial(obj);
+ 		break;
+ 	case YAFFS_OBJECT_TYPE_UNKNOWN:
+ 	default:
+ 		T(YAFFS_TRACE_VERIFY,
+ 		(TSTR("Obj %d has illegaltype %d"TENDSTR),
+ 		obj->objectId, obj->variantType));
+ 		break;
+ 	}
+ }
+ 
+ static void yaffs_VerifyObjects(yaffs_Device *dev)
+ {
+ 	yaffs_Object *obj;
+ 	int i;
+ 	struct ylist_head *lh;
+ 
+ 	if (yaffs_SkipVerification(dev))
+ 		return;
+ 
+ 	/* Iterate through the objects in each hash entry */
+ 
+ 	for (i = 0; i <  YAFFS_NOBJECT_BUCKETS; i++) {
+ 		ylist_for_each(lh, &dev->objectBucket[i].list) {
+ 			if (lh) {
+ 				obj = ylist_entry(lh, yaffs_Object, hashLink);
+ 				yaffs_VerifyObject(obj);
+ 			}
+ 		}
+ 	}
+ }
+ 
+ 
+ /*
+  *  Simple hash function. Needs to have a reasonable spread
+  */
+ 
+ static Y_INLINE int yaffs_HashFunction(int n)
+ {
+ 	n = abs(n);
+ 	return n % YAFFS_NOBJECT_BUCKETS;
+ }
+ 
+ /*
+  * Access functions to useful fake objects.
+  * Note that root might have a presence in NAND if permissions are set.
+  */
+ 
+ yaffs_Object *yaffs_Root(yaffs_Device *dev)
+ {
+ 	return dev->rootDir;
+ }
+ 
+ yaffs_Object *yaffs_LostNFound(yaffs_Device *dev)
+ {
+ 	return dev->lostNFoundDir;
+ }
+ 
+ 
+ /*
+  *  Erased NAND checking functions
+  */
+ 
+ int yaffs_CheckFF(__u8 *buffer, int nBytes)
+ {
+ 	/* Horrible, slow implementation */
+ 	while (nBytes--) {
+ 		if (*buffer != 0xFF)
+ 			return 0;
+ 		buffer++;
+ 	}
+ 	return 1;
+ }
+ 
+ static int yaffs_CheckChunkErased(struct yaffs_DeviceStruct *dev,
+ 				int chunkInNAND)
+ {
+ 	int retval = YAFFS_OK;
+ 	__u8 *data = yaffs_GetTempBuffer(dev, __LINE__);
+ 	yaffs_ExtendedTags tags;
+ 	int result;
+ 
+ 	result = yaffs_ReadChunkWithTagsFromNAND(dev, chunkInNAND, data, &tags);
+ 
+ 	if (tags.eccResult > YAFFS_ECC_RESULT_NO_ERROR)
+ 		retval = YAFFS_FAIL;
+ 
+ 	if (!yaffs_CheckFF(data, dev->nDataBytesPerChunk) || tags.chunkUsed) {
+ 		T(YAFFS_TRACE_NANDACCESS,
+ 		  (TSTR("Chunk %d not erased" TENDSTR), chunkInNAND));
+ 		retval = YAFFS_FAIL;
+ 	}
+ 
+ 	yaffs_ReleaseTempBuffer(dev, data, __LINE__);
+ 
+ 	return retval;
+ 
+ }
+ 
+ 
+ static int yaffs_VerifyChunkWritten(yaffs_Device *dev,
+ 					int chunkInNAND,
+ 					const __u8 *data,
+ 					yaffs_ExtendedTags *tags)
+ {
+ 	int retval = YAFFS_OK;
+ 	yaffs_ExtendedTags tempTags;
+ 	__u8 *buffer = yaffs_GetTempBuffer(dev,__LINE__);
+ 	int result;
+ 	
+ 	result = yaffs_ReadChunkWithTagsFromNAND(dev,chunkInNAND,buffer,&tempTags);
+ 	if(memcmp(buffer,data,dev->nDataBytesPerChunk) ||
+ 		tempTags.objectId != tags->objectId ||
+ 		tempTags.chunkId  != tags->chunkId ||
+ 		tempTags.byteCount != tags->byteCount)
+ 		retval = YAFFS_FAIL;
+ 
+ 	yaffs_ReleaseTempBuffer(dev, buffer, __LINE__);
+ 
+ 	return retval;
+ }
+ 
+ static int yaffs_WriteNewChunkWithTagsToNAND(struct yaffs_DeviceStruct *dev,
+ 					const __u8 *data,
+ 					yaffs_ExtendedTags *tags,
+ 					int useReserve)
+ {
+ 	int attempts = 0;
+ 	int writeOk = 0;
+ 	int chunk;
+ 
+ 	yaffs_InvalidateCheckpoint(dev);
+ 
+ 	do {
+ 		yaffs_BlockInfo *bi = 0;
+ 		int erasedOk = 0;
+ 
+ 		chunk = yaffs_AllocateChunk(dev, useReserve, &bi);
+ 		if (chunk < 0) {
+ 			/* no space */
+ 			break;
+ 		}
+ 
+ 		/* First check this chunk is erased, if it needs
+ 		 * checking.  The checking policy (unless forced
+ 		 * always on) is as follows:
+ 		 *
+ 		 * Check the first page we try to write in a block.
+ 		 * If the check passes then we don't need to check any
+ 		 * more.	If the check fails, we check again...
+ 		 * If the block has been erased, we don't need to check.
+ 		 *
+ 		 * However, if the block has been prioritised for gc,
+ 		 * then we think there might be something odd about
+ 		 * this block and stop using it.
+ 		 *
+ 		 * Rationale: We should only ever see chunks that have
+ 		 * not been erased if there was a partially written
+ 		 * chunk due to power loss.  This checking policy should
+ 		 * catch that case with very few checks and thus save a
+ 		 * lot of checks that are most likely not needed.
+ 		 *
+ 		 * Mods to the above
+ 		 * If an erase check fails or the write fails we skip the 
+ 		 * rest of the block.
+ 		 */
+ 
+ 		/* let's give it a try */
+ 		attempts++;
+ 
+ #ifdef CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED
+ 		bi->skipErasedCheck = 0;
+ #endif
+ 		if (!bi->skipErasedCheck) {
+ 			erasedOk = yaffs_CheckChunkErased(dev, chunk);
+ 			if (erasedOk != YAFFS_OK) {
+ 				T(YAFFS_TRACE_ERROR,
+ 				(TSTR("**>> yaffs chunk %d was not erased"
+ 				TENDSTR), chunk));
+ 
+ 				/* If not erased, delete this one,
+ 				 * skip rest of block and
+ 				 * try another chunk */
+ 				 yaffs_DeleteChunk(dev,chunk,1,__LINE__);
+ 				 yaffs_SkipRestOfBlock(dev);
+ 				continue;
+ 			}
+ 		}
+ 
+ 		writeOk = yaffs_WriteChunkWithTagsToNAND(dev, chunk,
+ 				data, tags);
+ 
+ 		if(!bi->skipErasedCheck)
+ 			writeOk = yaffs_VerifyChunkWritten(dev, chunk, data, tags);
+ 
+ 		if (writeOk != YAFFS_OK) {
+ 			/* Clean up aborted write, skip to next block and
+ 			 * try another chunk */
+ 			yaffs_HandleWriteChunkError(dev, chunk, erasedOk);
+ 			continue;
+ 		}
+ 
+ 		bi->skipErasedCheck = 1;
+ 
+ 		/* Copy the data into the robustification buffer */
+ 		yaffs_HandleWriteChunkOk(dev, chunk, data, tags);
+ 
+ 	} while (writeOk != YAFFS_OK &&
+ 		(yaffs_wr_attempts <= 0 || attempts <= yaffs_wr_attempts));
+ 
+ 	if (!writeOk)
+ 		chunk = -1;
+ 
+ 	if (attempts > 1) {
+ 		T(YAFFS_TRACE_ERROR,
+ 			(TSTR("**>> yaffs write required %d attempts" TENDSTR),
+ 			attempts));
+ 
+ 		dev->nRetriedWrites += (attempts - 1);
+ 	}
+ 
+ 	return chunk;
+ }
+ 
+ 
+ /*
+  * Oldest Dirty Sequence Number handling.
+  */
+  
+ /* yaffs_CalcOldestDirtySequence()
+  * yaffs_FindOldestDirtySequence()
+  * Calculate the oldest dirty sequence number if we don't know it.
+  */
+ static void yaffs_CalcOldestDirtySequence(yaffs_Device *dev)
+ {
+ 	int i;
+ 	unsigned seq;
+ 	unsigned blockNo = 0;
+ 	yaffs_BlockInfo *b;
+ 
+ 	if(!dev->param.isYaffs2)
+ 		return;
+ 
+ 	/* Find the oldest dirty sequence number. */
+ 	seq = dev->sequenceNumber + 1;
+ 	b = dev->blockInfo;
+ 	for (i = dev->internalStartBlock; i <= dev->internalEndBlock; i++) {
+ 		if (b->blockState == YAFFS_BLOCK_STATE_FULL &&
+ 			(b->pagesInUse - b->softDeletions) < dev->param.nChunksPerBlock &&
+ 			b->sequenceNumber < seq) {
+ 			seq = b->sequenceNumber;
+ 			blockNo = i;
+ 		}
+ 		b++;
+ 	}
+ 
+ 	if(blockNo){
+ 		dev->oldestDirtySequence = seq;
+ 		dev->oldestDirtyBlock = blockNo;
+ 	}
+ 
+ }
+ 
+ 
+ static void yaffs_FindOldestDirtySequence(yaffs_Device *dev)
+ {
+ 	if(dev->param.isYaffs2 && !dev->oldestDirtySequence)
+ 		yaffs_CalcOldestDirtySequence(dev);
+ }
+ 
+ /*
+  * yaffs_ClearOldestDirtySequence()
+  * Called when a block is erased or marked bad. (ie. when its sequenceNumber
+  * becomes invalid). If the value matches the oldest then we clear 
+  * dev->oldestDirtySequence to force its recomputation.
+  */
+ static void yaffs_ClearOldestDirtySequence(yaffs_Device *dev, yaffs_BlockInfo *bi)
+ {
+ 
+ 	if(!dev->param.isYaffs2)
+ 		return;
+ 
+ 	if(!bi || bi->sequenceNumber == dev->oldestDirtySequence){
+ 		dev->oldestDirtySequence = 0;
+ 		dev->oldestDirtyBlock = 0;
+ 	}
+ }
+ 
+ /*
+  * yaffs_UpdateOldestDirtySequence()
+  * Update the oldest dirty sequence number whenever we dirty a block.
+  * Only do this if the oldestDirtySequence is actually being tracked.
+  */
+ static void yaffs_UpdateOldestDirtySequence(yaffs_Device *dev, unsigned blockNo, yaffs_BlockInfo *bi)
+ {
+ 	if(dev->param.isYaffs2 && dev->oldestDirtySequence){
+ 		if(dev->oldestDirtySequence > bi->sequenceNumber){
+ 			dev->oldestDirtySequence = bi->sequenceNumber;
+ 			dev->oldestDirtyBlock = blockNo;
+ 		}
+ 	}
+ }
+  
+ /*
+  * Block retiring for handling a broken block.
+  */
+ 
+ static void yaffs_RetireBlock(yaffs_Device *dev, int blockInNAND)
+ {
+ 	yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, blockInNAND);
+ 
+ 	yaffs_InvalidateCheckpoint(dev);
+ 	
+ 	yaffs_ClearOldestDirtySequence(dev,bi);
+ 
+ 	if (yaffs_MarkBlockBad(dev, blockInNAND) != YAFFS_OK) {
+ 		if (yaffs_EraseBlockInNAND(dev, blockInNAND) != YAFFS_OK) {
+ 			T(YAFFS_TRACE_ALWAYS, (TSTR(
+ 				"yaffs: Failed to mark bad and erase block %d"
+ 				TENDSTR), blockInNAND));
+ 		} else {
+ 			yaffs_ExtendedTags tags;
+ 			int chunkId = blockInNAND * dev->param.nChunksPerBlock;
+ 
+ 			__u8 *buffer = yaffs_GetTempBuffer(dev, __LINE__);
+ 
+ 			memset(buffer, 0xff, dev->nDataBytesPerChunk);
+ 			yaffs_InitialiseTags(&tags);
+ 			tags.sequenceNumber = YAFFS_SEQUENCE_BAD_BLOCK;
+ 			if (dev->param.writeChunkWithTagsToNAND(dev, chunkId -
+ 				dev->chunkOffset, buffer, &tags) != YAFFS_OK)
+ 				T(YAFFS_TRACE_ALWAYS, (TSTR("yaffs: Failed to "
+ 					TCONT("write bad block marker to block %d")
+ 					TENDSTR), blockInNAND));
+ 
+ 			yaffs_ReleaseTempBuffer(dev, buffer, __LINE__);
+ 		}
+ 	}
+ 
+ 	bi->blockState = YAFFS_BLOCK_STATE_DEAD;
+ 	bi->gcPrioritise = 0;
+ 	bi->needsRetiring = 0;
+ 
+ 	dev->nRetiredBlocks++;
+ }
+ 
+ /*
+  * Functions for robustisizing TODO
+  *
+  */
+ 
+ static void yaffs_HandleWriteChunkOk(yaffs_Device *dev, int chunkInNAND,
+ 				const __u8 *data,
+ 				const yaffs_ExtendedTags *tags)
+ {
+ 	dev=dev;
+ 	chunkInNAND=chunkInNAND;
+ 	data=data;
+ 	tags=tags;
+ }
+ 
+ static void yaffs_HandleUpdateChunk(yaffs_Device *dev, int chunkInNAND,
+ 				const yaffs_ExtendedTags *tags)
+ {
+ 	dev=dev;
+ 	chunkInNAND=chunkInNAND;
+ 	tags=tags;
+ }
+ 
+ void yaffs_HandleChunkError(yaffs_Device *dev, yaffs_BlockInfo *bi)
+ {
+ 	if (!bi->gcPrioritise) {
+ 		bi->gcPrioritise = 1;
+ 		dev->hasPendingPrioritisedGCs = 1;
+ 		bi->chunkErrorStrikes++;
+ 
+ 		if (bi->chunkErrorStrikes > 3) {
+ 			bi->needsRetiring = 1; /* Too many stikes, so retire this */
+ 			T(YAFFS_TRACE_ALWAYS, (TSTR("yaffs: Block struck out" TENDSTR)));
+ 
+ 		}
+ 	}
+ }
+ 
+ static void yaffs_HandleWriteChunkError(yaffs_Device *dev, int chunkInNAND,
+ 		int erasedOk)
+ {
+ 	int blockInNAND = chunkInNAND / dev->param.nChunksPerBlock;
+ 	yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, blockInNAND);
+ 
+ 	yaffs_HandleChunkError(dev, bi);
+ 
+ 	if (erasedOk) {
+ 		/* Was an actual write failure, so mark the block for retirement  */
+ 		bi->needsRetiring = 1;
+ 		T(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
+ 		  (TSTR("**>> Block %d needs retiring" TENDSTR), blockInNAND));
+ 	}
+ 
+ 	/* Delete the chunk */
+ 	yaffs_DeleteChunk(dev, chunkInNAND, 1, __LINE__);
+ 	yaffs_SkipRestOfBlock(dev);
+ }
+ 
+ 
+ /*---------------- Name handling functions ------------*/
+ 
+ static __u16 yaffs_CalcNameSum(const YCHAR *name)
+ {
+ 	__u16 sum = 0;
+ 	__u16 i = 1;
+ 
+ 	const YUCHAR *bname = (const YUCHAR *) name;
+ 	if (bname) {
+ 		while ((*bname) && (i < (YAFFS_MAX_NAME_LENGTH/2))) {
+ 
+ #ifdef CONFIG_YAFFS_CASE_INSENSITIVE
+ 			sum += yaffs_toupper(*bname) * i;
+ #else
+ 			sum += (*bname) * i;
+ #endif
+ 			i++;
+ 			bname++;
+ 		}
+ 	}
+ 	return sum;
+ }
+ 
+ static void yaffs_SetObjectName(yaffs_Object *obj, const YCHAR *name)
+ {
+ #ifdef CONFIG_YAFFS_SHORT_NAMES_IN_RAM
+ 	memset(obj->shortName, 0, sizeof(YCHAR) * (YAFFS_SHORT_NAME_LENGTH+1));
+ 	if (name && yaffs_strnlen(name,YAFFS_SHORT_NAME_LENGTH+1) <= YAFFS_SHORT_NAME_LENGTH)
+ 		yaffs_strcpy(obj->shortName, name);
+ 	else
+ 		obj->shortName[0] = _Y('\0');
+ #endif
+ 	obj->sum = yaffs_CalcNameSum(name);
+ }
+ 
+ /*-------------------- TNODES -------------------
+ 
+  * List of spare tnodes
+  * The list is hooked together using the first pointer
+  * in the tnode.
+  */
+ 
+ /* yaffs_CreateTnodes creates a bunch more tnodes and
+  * adds them to the tnode free list.
+  * Don't use this function directly
+  */
+ static Y_INLINE int yaffs_CalcTnodeSize(yaffs_Device *dev)
+ {
+ 	int tnodeSize;
+ 	/* Calculate the tnode size in bytes for variable width tnode support.
+ 	 * Must be a multiple of 32-bits  */
+ 	tnodeSize = (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8;
+ 
+ 	if (tnodeSize < sizeof(yaffs_Tnode))
+ 		tnodeSize = sizeof(yaffs_Tnode);
+ 	return tnodeSize;
+ }
+ 
+ static int yaffs_CreateTnodes(yaffs_Device *dev, int nTnodes)
+ {
+ 	int i;
+ 	int tnodeSize = yaffs_CalcTnodeSize(dev);
+ 	yaffs_Tnode *newTnodes;
+ 	__u8 *mem;
+ 	yaffs_Tnode *curr;
+ 	yaffs_Tnode *next;
+ 	yaffs_TnodeList *tnl;
+ 
+ 	if (nTnodes < 1)
+ 		return YAFFS_OK;
+ 
+ 
+ 	/* make these things */
+ 
+ 	newTnodes = YMALLOC(nTnodes * tnodeSize);
+ 	mem = (__u8 *)newTnodes;
+ 
+ 	if (!newTnodes) {
+ 		T(YAFFS_TRACE_ERROR,
+ 			(TSTR("yaffs: Could not allocate Tnodes" TENDSTR)));
+ 		return YAFFS_FAIL;
+ 	}
+ 
+ 	/* Hook them into the free list */
+ #if 0
+ 	for (i = 0; i < nTnodes - 1; i++) {
+ 		newTnodes[i].internal[0] = &newTnodes[i + 1];
+ #ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG
+ 		newTnodes[i].internal[YAFFS_NTNODES_INTERNAL] = (void *)1;
+ #endif
+ 	}
+ 
+ 	newTnodes[nTnodes - 1].internal[0] = dev->freeTnodes;
+ #ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG
+ 	newTnodes[nTnodes - 1].internal[YAFFS_NTNODES_INTERNAL] = (void *)1;
+ #endif
+ 	dev->freeTnodes = newTnodes;
+ #else
+ 	/* New hookup for wide tnodes */
+ 	for (i = 0; i < nTnodes - 1; i++) {
+ 		curr = (yaffs_Tnode *) &mem[i * tnodeSize];
+ 		next = (yaffs_Tnode *) &mem[(i+1) * tnodeSize];
+ 		curr->internal[0] = next;
+ 	}
+ 
+ 	curr = (yaffs_Tnode *) &mem[(nTnodes - 1) * tnodeSize];
+ 	curr->internal[0] = dev->freeTnodes;
+ 	dev->freeTnodes = (yaffs_Tnode *)mem;
+ 
+ #endif
+ 
+ 
+ 	dev->nFreeTnodes += nTnodes;
+ 	dev->nTnodesCreated += nTnodes;
+ 
+ 	/* Now add this bunch of tnodes to a list for freeing up.
+ 	 * NB If we can't add this to the management list it isn't fatal
+ 	 * but it just means we can't free this bunch of tnodes later.
+ 	 */
+ 
+ 	tnl = YMALLOC(sizeof(yaffs_TnodeList));
+ 	if (!tnl) {
+ 		T(YAFFS_TRACE_ERROR,
+ 		  (TSTR
+ 		   ("yaffs: Could not add tnodes to management list" TENDSTR)));
+ 		   return YAFFS_FAIL;
+ 	} else {
+ 		tnl->tnodes = newTnodes;
+ 		tnl->next = dev->allocatedTnodeList;
+ 		dev->allocatedTnodeList = tnl;
+ 	}
+ 
+ 	T(YAFFS_TRACE_ALLOCATE, (TSTR("yaffs: Tnodes added" TENDSTR)));
+ 
+ 	return YAFFS_OK;
+ }
+ 
+ /* GetTnode gets us a clean tnode. Tries to make allocate more if we run out */
+ 
+ static yaffs_Tnode *yaffs_GetTnodeRaw(yaffs_Device *dev)
+ {
+ 	yaffs_Tnode *tn = NULL;
+ 
+ #ifdef CONFIG_YAFFS_VALGRIND_TEST
+ 	tn = YMALLOC(yaffs_CalcTnodeSize(dev));
+ 	if(tn)
+ 		dev->nTnodesCreated++;
+ #else
+ 	/* If there are none left make more */
+ 	if (!dev->freeTnodes)
+ 		yaffs_CreateTnodes(dev, YAFFS_ALLOCATION_NTNODES);
+ 
+ 	if (dev->freeTnodes) {
+ 		tn = dev->freeTnodes;
+ #ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG
+ 		if (tn->internal[YAFFS_NTNODES_INTERNAL] != (void *)1) {
+ 			/* Hoosterman, this thing looks like it isn't in the list */
+ 			T(YAFFS_TRACE_ALWAYS,
+ 			  (TSTR("yaffs: Tnode list bug 1" TENDSTR)));
+ 		}
+ #endif
+ 		dev->freeTnodes = dev->freeTnodes->internal[0];
+ 		dev->nFreeTnodes--;
+ 	}
+ #endif
+ 	dev->nCheckpointBlocksRequired = 0; /* force recalculation*/
+ 
+ 	return tn;
+ }
+ 
+ static yaffs_Tnode *yaffs_GetTnode(yaffs_Device *dev)
+ {
+ 	yaffs_Tnode *tn = yaffs_GetTnodeRaw(dev);
+ 	int tnodeSize = yaffs_CalcTnodeSize(dev);
+ 
+ 	if (tn)
+ 		memset(tn, 0, tnodeSize);
+ 
+ 	return tn;
+ }
+ 
+ /* FreeTnode frees up a tnode and puts it back on the free list */
+ static void yaffs_FreeTnode(yaffs_Device *dev, yaffs_Tnode *tn)
+ {
+ 	if (tn) {
+ #ifdef CONFIG_YAFFS_VALGRIND_TEST
+ 		YFREE(tn);
+ 		dev->nTnodesCreated--;
+ #else
+ #ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG
+ 		if (tn->internal[YAFFS_NTNODES_INTERNAL] != 0) {
+ 			/* Hoosterman, this thing looks like it is already in the list */
+ 			T(YAFFS_TRACE_ALWAYS,
+ 			  (TSTR("yaffs: Tnode list bug 2" TENDSTR)));
+ 		}
+ 		tn->internal[YAFFS_NTNODES_INTERNAL] = (void *)1;
+ #endif
+ 		tn->internal[0] = dev->freeTnodes;
+ 		dev->freeTnodes = tn;
+ 		dev->nFreeTnodes++;
+ #endif
+ 	}
+ 	dev->nCheckpointBlocksRequired = 0; /* force recalculation*/
+ }
+ 
+ static void yaffs_DeinitialiseTnodes(yaffs_Device *dev)
+ {
+ 	/* Free the list of allocated tnodes */
+ 	yaffs_TnodeList *tmp;
+ 
+ 	while (dev->allocatedTnodeList) {
+ 		tmp = dev->allocatedTnodeList->next;
+ 
+ 		YFREE(dev->allocatedTnodeList->tnodes);
+ 		YFREE(dev->allocatedTnodeList);
+ 		dev->allocatedTnodeList = tmp;
+ 
+ 	}
+ 
+ 	dev->freeTnodes = NULL;
+ 	dev->nFreeTnodes = 0;
+ 	dev->nTnodesCreated = 0;
+ }
+ 
+ static void yaffs_InitialiseTnodes(yaffs_Device *dev)
+ {
+ 	dev->allocatedTnodeList = NULL;
+ 	dev->freeTnodes = NULL;
+ 	dev->nFreeTnodes = 0;
+ 	dev->nTnodesCreated = 0;
+ }
+ 
+ 
+ void yaffs_LoadLevel0Tnode(yaffs_Device *dev, yaffs_Tnode *tn, unsigned pos,
+ 		unsigned val)
+ {
+ 	__u32 *map = (__u32 *)tn;
+ 	__u32 bitInMap;
+ 	__u32 bitInWord;
+ 	__u32 wordInMap;
+ 	__u32 mask;
+ 
+ 	pos &= YAFFS_TNODES_LEVEL0_MASK;
+ 	val >>= dev->chunkGroupBits;
+ 
+ 	bitInMap = pos * dev->tnodeWidth;
+ 	wordInMap = bitInMap / 32;
+ 	bitInWord = bitInMap & (32 - 1);
+ 
+ 	mask = dev->tnodeMask << bitInWord;
+ 
+ 	map[wordInMap] &= ~mask;
+ 	map[wordInMap] |= (mask & (val << bitInWord));
+ 
+ 	if (dev->tnodeWidth > (32 - bitInWord)) {
+ 		bitInWord = (32 - bitInWord);
+ 		wordInMap++;;
+ 		mask = dev->tnodeMask >> (/*dev->tnodeWidth -*/ bitInWord);
+ 		map[wordInMap] &= ~mask;
+ 		map[wordInMap] |= (mask & (val >> bitInWord));
+ 	}
+ }
+ 
+ static __u32 yaffs_GetChunkGroupBase(yaffs_Device *dev, yaffs_Tnode *tn,
+ 		unsigned pos)
+ {
+ 	__u32 *map = (__u32 *)tn;
+ 	__u32 bitInMap;
+ 	__u32 bitInWord;
+ 	__u32 wordInMap;
+ 	__u32 val;
+ 
+ 	pos &= YAFFS_TNODES_LEVEL0_MASK;
+ 
+ 	bitInMap = pos * dev->tnodeWidth;
+ 	wordInMap = bitInMap / 32;
+ 	bitInWord = bitInMap & (32 - 1);
+ 
+ 	val = map[wordInMap] >> bitInWord;
+ 
+ 	if	(dev->tnodeWidth > (32 - bitInWord)) {
+ 		bitInWord = (32 - bitInWord);
+ 		wordInMap++;;
+ 		val |= (map[wordInMap] << bitInWord);
+ 	}
+ 
+ 	val &= dev->tnodeMask;
+ 	val <<= dev->chunkGroupBits;
+ 
+ 	return val;
+ }
+ 
+ /* ------------------- End of individual tnode manipulation -----------------*/
+ 
+ /* ---------Functions to manipulate the look-up tree (made up of tnodes) ------
+  * The look up tree is represented by the top tnode and the number of topLevel
+  * in the tree. 0 means only the level 0 tnode is in the tree.
+  */
+ 
+ /* FindLevel0Tnode finds the level 0 tnode, if one exists. */
+ static yaffs_Tnode *yaffs_FindLevel0Tnode(yaffs_Device *dev,
+ 					yaffs_FileStructure *fStruct,
+ 					__u32 chunkId)
+ {
+ 	yaffs_Tnode *tn = fStruct->top;
+ 	__u32 i;
+ 	int requiredTallness;
+ 	int level = fStruct->topLevel;
+ 
+ 	dev=dev;
+ 
+ 	/* Check sane level and chunk Id */
+ 	if (level < 0 || level > YAFFS_TNODES_MAX_LEVEL)
+ 		return NULL;
+ 
+ 	if (chunkId > YAFFS_MAX_CHUNK_ID)
+ 		return NULL;
+ 
+ 	/* First check we're tall enough (ie enough topLevel) */
+ 
+ 	i = chunkId >> YAFFS_TNODES_LEVEL0_BITS;
+ 	requiredTallness = 0;
+ 	while (i) {
+ 		i >>= YAFFS_TNODES_INTERNAL_BITS;
+ 		requiredTallness++;
+ 	}
+ 
+ 	if (requiredTallness > fStruct->topLevel)
+ 		return NULL; /* Not tall enough, so we can't find it */
+ 
+ 	/* Traverse down to level 0 */
+ 	while (level > 0 && tn) {
+ 		tn = tn->internal[(chunkId >>
+ 			(YAFFS_TNODES_LEVEL0_BITS +
+ 				(level - 1) *
+ 				YAFFS_TNODES_INTERNAL_BITS)) &
+ 			YAFFS_TNODES_INTERNAL_MASK];
+ 		level--;
+ 	}
+ 
+ 	return tn;
+ }
+ 
+ /* AddOrFindLevel0Tnode finds the level 0 tnode if it exists, otherwise first expands the tree.
+  * This happens in two steps:
+  *  1. If the tree isn't tall enough, then make it taller.
+  *  2. Scan down the tree towards the level 0 tnode adding tnodes if required.
+  *
+  * Used when modifying the tree.
+  *
+  *  If the tn argument is NULL, then a fresh tnode will be added otherwise the specified tn will
+  *  be plugged into the ttree.
+  */
+ 
+ static yaffs_Tnode *yaffs_AddOrFindLevel0Tnode(yaffs_Device *dev,
+ 					yaffs_FileStructure *fStruct,
+ 					__u32 chunkId,
+ 					yaffs_Tnode *passedTn)
+ {
+ 	int requiredTallness;
+ 	int i;
+ 	int l;
+ 	yaffs_Tnode *tn;
+ 
+ 	__u32 x;
+ 
+ 
+ 	/* Check sane level and page Id */
+ 	if (fStruct->topLevel < 0 || fStruct->topLevel > YAFFS_TNODES_MAX_LEVEL)
+ 		return NULL;
+ 
+ 	if (chunkId > YAFFS_MAX_CHUNK_ID)
+ 		return NULL;
+ 
+ 	/* First check we're tall enough (ie enough topLevel) */
+ 
+ 	x = chunkId >> YAFFS_TNODES_LEVEL0_BITS;
+ 	requiredTallness = 0;
+ 	while (x) {
+ 		x >>= YAFFS_TNODES_INTERNAL_BITS;
+ 		requiredTallness++;
+ 	}
+ 
+ 
+ 	if (requiredTallness > fStruct->topLevel) {
+ 		/* Not tall enough, gotta make the tree taller */
+ 		for (i = fStruct->topLevel; i < requiredTallness; i++) {
+ 
+ 			tn = yaffs_GetTnode(dev);
+ 
+ 			if (tn) {
+ 				tn->internal[0] = fStruct->top;
+ 				fStruct->top = tn;
+ 				fStruct->topLevel++;
+ 			} else {
+ 				T(YAFFS_TRACE_ERROR,
+ 					(TSTR("yaffs: no more tnodes" TENDSTR)));
+ 				return NULL;
+ 			}
+ 		}
+ 	}
+ 
+ 	/* Traverse down to level 0, adding anything we need */
+ 
+ 	l = fStruct->topLevel;
+ 	tn = fStruct->top;
+ 
+ 	if (l > 0) {
+ 		while (l > 0 && tn) {
+ 			x = (chunkId >>
+ 			     (YAFFS_TNODES_LEVEL0_BITS +
+ 			      (l - 1) * YAFFS_TNODES_INTERNAL_BITS)) &
+ 			    YAFFS_TNODES_INTERNAL_MASK;
+ 
+ 
+ 			if ((l > 1) && !tn->internal[x]) {
+ 				/* Add missing non-level-zero tnode */
+ 				tn->internal[x] = yaffs_GetTnode(dev);
+ 				if(!tn->internal[x])
+ 					return NULL;
+ 			} else if (l == 1) {
+ 				/* Looking from level 1 at level 0 */
+ 				if (passedTn) {
+ 					/* If we already have one, then release it.*/
+ 					if (tn->internal[x])
+ 						yaffs_FreeTnode(dev, tn->internal[x]);
+ 					tn->internal[x] = passedTn;
+ 
+ 				} else if (!tn->internal[x]) {
+ 					/* Don't have one, none passed in */
+ 					tn->internal[x] = yaffs_GetTnode(dev);
+ 					if(!tn->internal[x])
+ 						return NULL;
+ 				}
+ 			}
+ 
+ 			tn = tn->internal[x];
+ 			l--;
+ 		}
+ 	} else {
+ 		/* top is level 0 */
+ 		if (passedTn) {
+ 			memcpy(tn, passedTn, (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8);
+ 			yaffs_FreeTnode(dev, passedTn);
+ 		}
+ 	}
+ 
+ 	return tn;
+ }
+ 
+ static int yaffs_FindChunkInGroup(yaffs_Device *dev, int theChunk,
+ 				yaffs_ExtendedTags *tags, int objectId,
+ 				int chunkInInode)
+ {
+ 	int j;
+ 
+ 	for (j = 0; theChunk && j < dev->chunkGroupSize; j++) {
+ 		if (yaffs_CheckChunkBit(dev, theChunk / dev->param.nChunksPerBlock,
+ 				theChunk % dev->param.nChunksPerBlock)) {
+ 			
+ 			if(dev->chunkGroupSize == 1)
+ 				return theChunk;
+ 			else {
+ 				yaffs_ReadChunkWithTagsFromNAND(dev, theChunk, NULL,
+ 								tags);
+ 				if (yaffs_TagsMatch(tags, objectId, chunkInInode)) {
+ 					/* found it; */
+ 					return theChunk;
+ 				}
+ 			}
+ 		}
+ 		theChunk++;
+ 	}
+ 	return -1;
+ }
+ 
+ #if 0
+ /* Experimental code not being used yet. Might speed up file deletion */
+ /* DeleteWorker scans backwards through the tnode tree and deletes all the
+  * chunks and tnodes in the file.
+  * Returns 1 if the tree was deleted.
+  * Returns 0 if it stopped early due to hitting the limit and the delete is incomplete.
+  */
+ 
+ static int yaffs_DeleteWorker(yaffs_Object *in, yaffs_Tnode *tn, __u32 level,
+ 			      int chunkOffset, int *limit)
+ {
+ 	int i;
+ 	int chunkInInode;
+ 	int theChunk;
+ 	yaffs_ExtendedTags tags;
+ 	int foundChunk;
+ 	yaffs_Device *dev = in->myDev;
+ 
+ 	int allDone = 1;
+ 
+ 	if (tn) {
+ 		if (level > 0) {
+ 			for (i = YAFFS_NTNODES_INTERNAL - 1; allDone && i >= 0;
+ 			     i--) {
+ 				if (tn->internal[i]) {
+ 					if (limit && (*limit) < 0) {
+ 						allDone = 0;
+ 					} else {
+ 						allDone =
+ 							yaffs_DeleteWorker(in,
+ 								tn->
+ 								internal
+ 								[i],
+ 								level -
+ 								1,
+ 								(chunkOffset
+ 									<<
+ 									YAFFS_TNODES_INTERNAL_BITS)
+ 								+ i,
+ 								limit);
+ 					}
+ 					if (allDone) {
+ 						yaffs_FreeTnode(dev,
+ 								tn->
+ 								internal[i]);
+ 						tn->internal[i] = NULL;
+ 					}
+ 				}
+ 			}
+ 			return (allDone) ? 1 : 0;
+ 		} else if (level == 0) {
+ 			int hitLimit = 0;
+ 
+ 			for (i = YAFFS_NTNODES_LEVEL0 - 1; i >= 0 && !hitLimit;
+ 					i--) {
+ 				theChunk = yaffs_GetChunkGroupBase(dev, tn, i);
+ 				if (theChunk) {
+ 
+ 					chunkInInode = (chunkOffset <<
+ 						YAFFS_TNODES_LEVEL0_BITS) + i;
+ 
+ 					foundChunk =
+ 						yaffs_FindChunkInGroup(dev,
+ 								theChunk,
+ 								&tags,
+ 								in->objectId,
+ 								chunkInInode);
+ 
+ 					if (foundChunk > 0) {
+ 						yaffs_DeleteChunk(dev,
+ 								  foundChunk, 1,
+ 								  __LINE__);
+ 						in->nDataChunks--;
+ 						if (limit) {
+ 							*limit = *limit - 1;
+ 							if (*limit <= 0)
+ 								hitLimit = 1;
+ 						}
+ 
+ 					}
+ 
+ 					yaffs_LoadLevel0Tnode(dev, tn, i, 0);
+ 				}
+ 
+ 			}
+ 			return (i < 0) ? 1 : 0;
+ 
+ 		}
+ 
+ 	}
+ 
+ 	return 1;
+ 
+ }
+ 
+ #endif
+ 
+ static void yaffs_SoftDeleteChunk(yaffs_Device *dev, int chunk)
+ {
+ 	yaffs_BlockInfo *theBlock;
+ 	unsigned blockNo;
+ 
+ 	T(YAFFS_TRACE_DELETION, (TSTR("soft delete chunk %d" TENDSTR), chunk));
+ 
+ 	blockNo =  chunk / dev->param.nChunksPerBlock;
+ 	theBlock = yaffs_GetBlockInfo(dev, blockNo);
+ 	if (theBlock) {
+ 		theBlock->softDeletions++;
+ 		dev->nFreeChunks++;
+ 		yaffs_UpdateOldestDirtySequence(dev, blockNo, theBlock);
+ 	}
+ }
+ 
+ /* SoftDeleteWorker scans backwards through the tnode tree and soft deletes all the chunks in the file.
+  * All soft deleting does is increment the block's softdelete count and pulls the chunk out
+  * of the tnode.
+  * Thus, essentially this is the same as DeleteWorker except that the chunks are soft deleted.
+  */
+ 
+ static int yaffs_SoftDeleteWorker(yaffs_Object *in, yaffs_Tnode *tn,
+ 				  __u32 level, int chunkOffset)
+ {
+ 	int i;
+ 	int theChunk;
+ 	int allDone = 1;
+ 	yaffs_Device *dev = in->myDev;
+ 
+ 	if (tn) {
+ 		if (level > 0) {
+ 
+ 			for (i = YAFFS_NTNODES_INTERNAL - 1; allDone && i >= 0;
+ 			     i--) {
+ 				if (tn->internal[i]) {
+ 					allDone =
+ 					    yaffs_SoftDeleteWorker(in,
+ 								   tn->
+ 								   internal[i],
+ 								   level - 1,
+ 								   (chunkOffset
+ 								    <<
+ 								    YAFFS_TNODES_INTERNAL_BITS)
+ 								   + i);
+ 					if (allDone) {
+ 						yaffs_FreeTnode(dev,
+ 								tn->
+ 								internal[i]);
+ 						tn->internal[i] = NULL;
+ 					} else {
+ 						/* Hoosterman... how could this happen? */
+ 					}
+ 				}
+ 			}
+ 			return (allDone) ? 1 : 0;
+ 		} else if (level == 0) {
+ 
+ 			for (i = YAFFS_NTNODES_LEVEL0 - 1; i >= 0; i--) {
+ 				theChunk = yaffs_GetChunkGroupBase(dev, tn, i);
+ 				if (theChunk) {
+ 					/* Note this does not find the real chunk, only the chunk group.
+ 					 * We make an assumption that a chunk group is not larger than
+ 					 * a block.
+ 					 */
+ 					yaffs_SoftDeleteChunk(dev, theChunk);
+ 					yaffs_LoadLevel0Tnode(dev, tn, i, 0);
+ 				}
+ 
+ 			}
+ 			return 1;
+ 
+ 		}
+ 
+ 	}
+ 
+ 	return 1;
+ 
+ }
+ 
+ static void yaffs_SoftDeleteFile(yaffs_Object *obj)
+ {
+ 	if (obj->deleted &&
+ 	    obj->variantType == YAFFS_OBJECT_TYPE_FILE && !obj->softDeleted) {
+ 		if (obj->nDataChunks <= 0) {
+ 			/* Empty file with no duplicate object headers, just delete it immediately */
+ 			yaffs_FreeTnode(obj->myDev,
+ 					obj->variant.fileVariant.top);
+ 			obj->variant.fileVariant.top = NULL;
+ 			T(YAFFS_TRACE_TRACING,
+ 			  (TSTR("yaffs: Deleting empty file %d" TENDSTR),
+ 			   obj->objectId));
+ 			yaffs_DoGenericObjectDeletion(obj);
+ 		} else {
+ 			yaffs_SoftDeleteWorker(obj,
+ 					       obj->variant.fileVariant.top,
+ 					       obj->variant.fileVariant.
+ 					       topLevel, 0);
+ 			obj->softDeleted = 1;
+ 		}
+ 	}
+ }
+ 
+ /* Pruning removes any part of the file structure tree that is beyond the
+  * bounds of the file (ie that does not point to chunks).
+  *
+  * A file should only get pruned when its size is reduced.
+  *
+  * Before pruning, the chunks must be pulled from the tree and the
+  * level 0 tnode entries must be zeroed out.
+  * Could also use this for file deletion, but that's probably better handled
+  * by a special case.
+  *
+  * This function is recursive. For levels > 0 the function is called again on
+  * any sub-tree. For level == 0 we just check if the sub-tree has data.
+  * If there is no data in a subtree then it is pruned.
+  */
+ 
+ static yaffs_Tnode *yaffs_PruneWorker(yaffs_Device *dev, yaffs_Tnode *tn,
+ 				__u32 level, int del0)
+ {
+ 	int i;
+ 	int hasData;
+ 
+ 	if (tn) {
+ 		hasData = 0;
+ 
+ 		if(level > 0){
+ 			for (i = 0; i < YAFFS_NTNODES_INTERNAL; i++) {
+ 				if (tn->internal[i]) {
+ 					tn->internal[i] =
+ 						yaffs_PruneWorker(dev, tn->internal[i],
+ 							level - 1,
+ 							(i == 0) ? del0 : 1);
+ 				}
+ 
+ 				if (tn->internal[i])
+ 					hasData++;
+ 			}
+ 		} else {
+ 			int tnodeSize_u32 = yaffs_CalcTnodeSize(dev)/sizeof(__u32);
+ 			__u32 *map = (__u32 *)tn;
+ 
+                         for(i = 0; !hasData && i < tnodeSize_u32; i++){
+                                 if(map[i])
+                                         hasData++;
+                         }
+                 }
+ 
+ 		if (hasData == 0 && del0) {
+ 			/* Free and return NULL */
+ 
+ 			yaffs_FreeTnode(dev, tn);
+ 			tn = NULL;
+ 		}
+ 
+ 	}
+ 
+ 	return tn;
+ 
+ }
+ 
+ static int yaffs_PruneFileStructure(yaffs_Device *dev,
+ 				yaffs_FileStructure *fStruct)
+ {
+ 	int i;
+ 	int hasData;
+ 	int done = 0;
+ 	yaffs_Tnode *tn;
+ 
+ 	if (fStruct->topLevel > 0) {
+ 		fStruct->top =
+ 		    yaffs_PruneWorker(dev, fStruct->top, fStruct->topLevel, 0);
+ 
+ 		/* Now we have a tree with all the non-zero branches NULL but the height
+ 		 * is the same as it was.
+ 		 * Let's see if we can trim internal tnodes to shorten the tree.
+ 		 * We can do this if only the 0th element in the tnode is in use
+ 		 * (ie all the non-zero are NULL)
+ 		 */
+ 
+ 		while (fStruct->topLevel && !done) {
+ 			tn = fStruct->top;
+ 
+ 			hasData = 0;
+ 			for (i = 1; i < YAFFS_NTNODES_INTERNAL; i++) {
+ 				if (tn->internal[i])
+ 					hasData++;
+ 			}
+ 
+ 			if (!hasData) {
+ 				fStruct->top = tn->internal[0];
+ 				fStruct->topLevel--;
+ 				yaffs_FreeTnode(dev, tn);
+ 			} else {
+ 				done = 1;
+ 			}
+ 		}
+ 	}
+ 
+ 	return YAFFS_OK;
+ }
+ 
+ /*-------------------- End of File Structure functions.-------------------*/
+ 
+ /* yaffs_CreateFreeObjects creates a bunch more objects and
+  * adds them to the object free list.
+  */
+ static int yaffs_CreateFreeObjects(yaffs_Device *dev, int nObjects)
+ {
+ 	int i;
+ 	yaffs_Object *newObjects;
+ 	yaffs_ObjectList *list;
+ 
+ 	if (nObjects < 1)
+ 		return YAFFS_OK;
+ 
+ 	/* make these things */
+ 	newObjects = YMALLOC(nObjects * sizeof(yaffs_Object));
+ 	list = YMALLOC(sizeof(yaffs_ObjectList));
+ 
+ 	if (!newObjects || !list) {
+ 		if (newObjects){
+ 			YFREE(newObjects);
+ 			newObjects = NULL;
+ 		}
+ 		if (list){
+ 			YFREE(list);
+ 			list = NULL;
+ 		}
+ 		T(YAFFS_TRACE_ALLOCATE,
+ 		  (TSTR("yaffs: Could not allocate more objects" TENDSTR)));
+ 		return YAFFS_FAIL;
+ 	}
+ 
+ 	/* Hook them into the free list */
+ 	for (i = 0; i < nObjects - 1; i++) {
+ 		newObjects[i].siblings.next =
+ 				(struct ylist_head *)(&newObjects[i + 1]);
+ 	}
+ 
+ 	newObjects[nObjects - 1].siblings.next = (void *)dev->freeObjects;
+ 	dev->freeObjects = newObjects;
+ 	dev->nFreeObjects += nObjects;
+ 	dev->nObjectsCreated += nObjects;
+ 
+ 	/* Now add this bunch of Objects to a list for freeing up. */
+ 
+ 	list->objects = newObjects;
+ 	list->next = dev->allocatedObjectList;
+ 	dev->allocatedObjectList = list;
+ 
+ 	return YAFFS_OK;
+ }
+ 
+ 
+ /* AllocateEmptyObject gets us a clean Object. Tries to make allocate more if we run out */
+ static yaffs_Object *yaffs_AllocateEmptyObject(yaffs_Device *dev)
+ {
+ 	yaffs_Object *tn = NULL;
+ 
+ #ifdef CONFIG_YAFFS_VALGRIND_TEST
+ 	tn = YMALLOC(sizeof(yaffs_Object));
+ 	if(tn)
+ 		dev->nObjectsCreated++;
+ #else
+ 	/* If there are none left make more */
+ 	if (!dev->freeObjects)
+ 		yaffs_CreateFreeObjects(dev, YAFFS_ALLOCATION_NOBJECTS);
+ 
+ 	if (dev->freeObjects) {
+ 		tn = dev->freeObjects;
+ 		dev->freeObjects =
+ 			(yaffs_Object *) (dev->freeObjects->siblings.next);
+ 		dev->nFreeObjects--;
+ 	}
+ #endif
+ 	if (tn) {
+ 		/* Now sweeten it up... */
+ 
+ 		memset(tn, 0, sizeof(yaffs_Object));
+ 		tn->beingCreated = 1;
+ 
+ 		tn->myDev = dev;
+ 		tn->hdrChunk = 0;
+ 		tn->variantType = YAFFS_OBJECT_TYPE_UNKNOWN;
+ 		YINIT_LIST_HEAD(&(tn->hardLinks));
+ 		YINIT_LIST_HEAD(&(tn->hashLink));
+ 		YINIT_LIST_HEAD(&tn->siblings);
+ 
+ 
+ 		/* Now make the directory sane */
+ 		if (dev->rootDir) {
+ 			tn->parent = dev->rootDir;
+ 			ylist_add(&(tn->siblings), &dev->rootDir->variant.directoryVariant.children);
+ 		}
+ 
+ 		/* Add it to the lost and found directory.
+ 		 * NB Can't put root or lostNFound in lostNFound so
+ 		 * check if lostNFound exists first
+ 		 */
+ 		if (dev->lostNFoundDir)
+ 			yaffs_AddObjectToDirectory(dev->lostNFoundDir, tn);
+ 
+ 		tn->beingCreated = 0;
+ 	}
+ 
+ 	dev->nCheckpointBlocksRequired = 0; /* force recalculation*/
+ 
+ 	return tn;
+ }
+ 
+ static yaffs_Object *yaffs_CreateFakeDirectory(yaffs_Device *dev, int number,
+ 					       __u32 mode)
+ {
+ 
+ 	yaffs_Object *obj =
+ 	    yaffs_CreateNewObject(dev, number, YAFFS_OBJECT_TYPE_DIRECTORY);
+ 	if (obj) {
+ 		obj->fake = 1;		/* it is fake so it might have no NAND presence... */
+ 		obj->renameAllowed = 0;	/* ... and we're not allowed to rename it... */
+ 		obj->unlinkAllowed = 0;	/* ... or unlink it */
+ 		obj->deleted = 0;
+ 		obj->unlinked = 0;
+ 		obj->yst_mode = mode;
+ 		obj->myDev = dev;
+ 		obj->hdrChunk = 0;	/* Not a valid chunk. */
+ 	}
+ 
+ 	return obj;
+ 
+ }
+ 
+ static void yaffs_UnhashObject(yaffs_Object *tn)
+ {
+ 	int bucket;
+ 	yaffs_Device *dev = tn->myDev;
+ 
+ 	/* If it is still linked into the bucket list, free from the list */
+ 	if (!ylist_empty(&tn->hashLink)) {
+ 		ylist_del_init(&tn->hashLink);
+ 		bucket = yaffs_HashFunction(tn->objectId);
+ 		dev->objectBucket[bucket].count--;
+ 	}
+ }
+ 
+ /*  FreeObject frees up a Object and puts it back on the free list */
+ static void yaffs_FreeObject(yaffs_Object *tn)
+ {
+ 	yaffs_Device *dev = tn->myDev;
+ 
+ 	T(YAFFS_TRACE_OS, (TSTR("FreeObject %p inode %p"TENDSTR), tn, tn->myInode));
+ 
+ 	if (!tn)
+ 		YBUG();
+ 	if (tn->parent)
+ 		YBUG();
+ 	if (!ylist_empty(&tn->siblings))
+ 		YBUG();
+ 
+ 
+ 	if (tn->myInode) {
+ 		/* We're still hooked up to a cached inode.
+ 		 * Don't delete now, but mark for later deletion
+ 		 */
+ 		tn->deferedFree = 1;
+ 		return;
+ 	}
+ 
+ 	yaffs_UnhashObject(tn);
+ 
+ #ifdef CONFIG_YAFFS_VALGRIND_TEST
+ 	YFREE(tn);
+ 	dev->nObjectsCreated--;
+ 	tn = NULL;
+ #else
+ 	/* Link into the free list. */
+ 	tn->siblings.next = (struct ylist_head *)(dev->freeObjects);
+ 	dev->freeObjects = tn;
+ 	dev->nFreeObjects++;
+ #endif
+ 	dev->nCheckpointBlocksRequired = 0; /* force recalculation*/
+ }
+ 
+ 
+ void yaffs_HandleDeferedFree(yaffs_Object *obj)
+ {
+ 	if (obj->deferedFree)
+ 		yaffs_FreeObject(obj);
+ }
+ 
+ 
+ static void yaffs_DeinitialiseObjects(yaffs_Device *dev)
+ {
+ 	/* Free the list of allocated Objects */
+ 
+ 	yaffs_ObjectList *tmp;
+ 
+ 	while (dev->allocatedObjectList) {
+ 		tmp = dev->allocatedObjectList->next;
+ 		YFREE(dev->allocatedObjectList->objects);
+ 		YFREE(dev->allocatedObjectList);
+ 
+ 		dev->allocatedObjectList = tmp;
+ 	}
+ 
+ 	dev->freeObjects = NULL;
+ 	dev->nFreeObjects = 0;
+ 	dev->nObjectsCreated = 0;
+ }
+ 
+ static void yaffs_InitialiseObjects(yaffs_Device *dev)
+ {
+ 	int i;
+ 
+ 	dev->allocatedObjectList = NULL;
+ 	dev->freeObjects = NULL;
+ 	dev->nFreeObjects = 0;
+ 
+ 	for (i = 0; i < YAFFS_NOBJECT_BUCKETS; i++) {
+ 		YINIT_LIST_HEAD(&dev->objectBucket[i].list);
+ 		dev->objectBucket[i].count = 0;
+ 	}
+ }
+ 
+ static int yaffs_FindNiceObjectBucket(yaffs_Device *dev)
+ {
+ 	int i;
+ 	int l = 999;
+ 	int lowest = 999999;
+ 
+ 
+ 	/* Search for the shortest list or one that
+ 	 * isn't too long.
+ 	 */
+ 
+ 	for (i = 0; i < 10 && lowest > 4; i++) {
+ 		dev->bucketFinder++;
+ 		dev->bucketFinder %= YAFFS_NOBJECT_BUCKETS;
+ 		if (dev->objectBucket[dev->bucketFinder].count < lowest) {
+ 			lowest = dev->objectBucket[dev->bucketFinder].count;
+ 			l = dev->bucketFinder;
+ 		}
+ 
+ 	}
+ 
+ 	return l;
+ }
+ 
+ static int yaffs_CreateNewObjectNumber(yaffs_Device *dev)
+ {
+ 	int bucket = yaffs_FindNiceObjectBucket(dev);
+ 
+ 	/* Now find an object value that has not already been taken
+ 	 * by scanning the list.
+ 	 */
+ 
+ 	int found = 0;
+ 	struct ylist_head *i;
+ 
+ 	__u32 n = (__u32) bucket;
+ 
+ 	/* yaffs_CheckObjectHashSanity();  */
+ 
+ 	while (!found) {
+ 		found = 1;
+ 		n += YAFFS_NOBJECT_BUCKETS;
+ 		if (1 || dev->objectBucket[bucket].count > 0) {
+ 			ylist_for_each(i, &dev->objectBucket[bucket].list) {
+ 				/* If there is already one in the list */
+ 				if (i && ylist_entry(i, yaffs_Object,
+ 						hashLink)->objectId == n) {
+ 					found = 0;
+ 				}
+ 			}
+ 		}
+ 	}
+ 
+ 	return n;
+ }
+ 
+ static void yaffs_HashObject(yaffs_Object *in)
+ {
+ 	int bucket = yaffs_HashFunction(in->objectId);
+ 	yaffs_Device *dev = in->myDev;
+ 
+ 	ylist_add(&in->hashLink, &dev->objectBucket[bucket].list);
+ 	dev->objectBucket[bucket].count++;
+ }
+ 
+ yaffs_Object *yaffs_FindObjectByNumber(yaffs_Device *dev, __u32 number)
+ {
+ 	int bucket = yaffs_HashFunction(number);
+ 	struct ylist_head *i;
+ 	yaffs_Object *in;
+ 
+ 	ylist_for_each(i, &dev->objectBucket[bucket].list) {
+ 		/* Look if it is in the list */
+ 		if (i) {
+ 			in = ylist_entry(i, yaffs_Object, hashLink);
+ 			if (in->objectId == number) {
+ 
+ 				/* Don't tell the VFS about this one if it is defered free */
+ 				if (in->deferedFree)
+ 					return NULL;
+ 
+ 				return in;
+ 			}
+ 		}
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ yaffs_Object *yaffs_CreateNewObject(yaffs_Device *dev, int number,
+ 				    yaffs_ObjectType type)
+ {
+ 	yaffs_Object *theObject=NULL;
+ 	yaffs_Tnode *tn = NULL;
+ 
+ 	if (number < 0)
+ 		number = yaffs_CreateNewObjectNumber(dev);
+ 
+ 	if (type == YAFFS_OBJECT_TYPE_FILE) {
+ 		tn = yaffs_GetTnode(dev);
+ 		if (!tn)
+ 			return NULL;
+ 	}
+ 
+ 	theObject = yaffs_AllocateEmptyObject(dev);
+ 	if (!theObject){
+ 		if(tn)
+ 			yaffs_FreeTnode(dev,tn);
+ 		return NULL;
+ 	}
+ 
+ 
+ 	if (theObject) {
+ 		theObject->fake = 0;
+ 		theObject->renameAllowed = 1;
+ 		theObject->unlinkAllowed = 1;
+ 		theObject->objectId = number;
+ 		yaffs_HashObject(theObject);
+ 		theObject->variantType = type;
+ #ifdef CONFIG_YAFFS_WINCE
+ 		yfsd_WinFileTimeNow(theObject->win_atime);
+ 		theObject->win_ctime[0] = theObject->win_mtime[0] =
+ 		    theObject->win_atime[0];
+ 		theObject->win_ctime[1] = theObject->win_mtime[1] =
+ 		    theObject->win_atime[1];
+ 
+ #else
+ 
+ 		theObject->yst_atime = theObject->yst_mtime =
+ 		    theObject->yst_ctime = Y_CURRENT_TIME;
+ #endif
+ 		switch (type) {
+ 		case YAFFS_OBJECT_TYPE_FILE:
+ 			theObject->variant.fileVariant.fileSize = 0;
+ 			theObject->variant.fileVariant.scannedFileSize = 0;
+ 			theObject->variant.fileVariant.shrinkSize = 0xFFFFFFFF;	/* max __u32 */
+ 			theObject->variant.fileVariant.topLevel = 0;
+ 			theObject->variant.fileVariant.top = tn;
+ 			break;
+ 		case YAFFS_OBJECT_TYPE_DIRECTORY:
+ 			YINIT_LIST_HEAD(&theObject->variant.directoryVariant.
+ 					children);
+ 			YINIT_LIST_HEAD(&theObject->variant.directoryVariant.
+ 					dirty);
+ 			break;
+ 		case YAFFS_OBJECT_TYPE_SYMLINK:
+ 		case YAFFS_OBJECT_TYPE_HARDLINK:
+ 		case YAFFS_OBJECT_TYPE_SPECIAL:
+ 			/* No action required */
+ 			break;
+ 		case YAFFS_OBJECT_TYPE_UNKNOWN:
+ 			/* todo this should not happen */
+ 			break;
+ 		}
+ 	}
+ 
+ 	return theObject;
+ }
+ 
+ static yaffs_Object *yaffs_FindOrCreateObjectByNumber(yaffs_Device *dev,
+ 						      int number,
+ 						      yaffs_ObjectType type)
+ {
+ 	yaffs_Object *theObject = NULL;
+ 
+ 	if (number > 0)
+ 		theObject = yaffs_FindObjectByNumber(dev, number);
+ 
+ 	if (!theObject)
+ 		theObject = yaffs_CreateNewObject(dev, number, type);
+ 
+ 	return theObject;
+ 
+ }
+ 
+ 
+ static YCHAR *yaffs_CloneString(const YCHAR *str)
+ {
+ 	YCHAR *newStr = NULL;
+ 	int len;
+ 
+ 	if (!str)
+ 		str = _Y("");
+ 
+ 	len = yaffs_strnlen(str,YAFFS_MAX_ALIAS_LENGTH);
+ 	newStr = YMALLOC((len + 1) * sizeof(YCHAR));
+ 	if (newStr){
+ 		yaffs_strncpy(newStr, str,len);
+ 		newStr[len] = 0;
+ 	}
+ 	return newStr;
+ 
+ }
+ 
+ /*
+  * Mknod (create) a new object.
+  * equivalentObject only has meaning for a hard link;
+  * aliasString only has meaning for a symlink.
+  * rdev only has meaning for devices (a subset of special objects)
+  */
+ 
+ static yaffs_Object *yaffs_MknodObject(yaffs_ObjectType type,
+ 				       yaffs_Object *parent,
+ 				       const YCHAR *name,
+ 				       __u32 mode,
+ 				       __u32 uid,
+ 				       __u32 gid,
+ 				       yaffs_Object *equivalentObject,
+ 				       const YCHAR *aliasString, __u32 rdev)
+ {
+ 	yaffs_Object *in;
+ 	YCHAR *str = NULL;
+ 
+ 	yaffs_Device *dev = parent->myDev;
+ 
+ 	/* Check if the entry exists. If it does then fail the call since we don't want a dup.*/
+ 	if (yaffs_FindObjectByName(parent, name))
+ 		return NULL;
+ 
+ 	if (type == YAFFS_OBJECT_TYPE_SYMLINK) {
+ 		str = yaffs_CloneString(aliasString);
+ 		if (!str)
+ 			return NULL;
+ 	}
+ 
+ 	in = yaffs_CreateNewObject(dev, -1, type);
+ 
+ 	if (!in){
+ 		if(str)
+ 			YFREE(str);
+ 		return NULL;
+ 	}
+ 
+ 
+ 
+ 
+ 
+ 	if (in) {
+ 		in->hdrChunk = 0;
+ 		in->valid = 1;
+ 		in->variantType = type;
+ 
+ 		in->yst_mode = mode;
+ 
+ #ifdef CONFIG_YAFFS_WINCE
+ 		yfsd_WinFileTimeNow(in->win_atime);
+ 		in->win_ctime[0] = in->win_mtime[0] = in->win_atime[0];
+ 		in->win_ctime[1] = in->win_mtime[1] = in->win_atime[1];
+ 
+ #else
+ 		in->yst_atime = in->yst_mtime = in->yst_ctime = Y_CURRENT_TIME;
+ 
+ 		in->yst_rdev = rdev;
+ 		in->yst_uid = uid;
+ 		in->yst_gid = gid;
+ #endif
+ 		in->nDataChunks = 0;
+ 
+ 		yaffs_SetObjectName(in, name);
+ 		in->dirty = 1;
+ 
+ 		yaffs_AddObjectToDirectory(parent, in);
+ 
+ 		in->myDev = parent->myDev;
+ 
+ 		switch (type) {
+ 		case YAFFS_OBJECT_TYPE_SYMLINK:
+ 			in->variant.symLinkVariant.alias = str;
+ 			break;
+ 		case YAFFS_OBJECT_TYPE_HARDLINK:
+ 			in->variant.hardLinkVariant.equivalentObject =
+ 				equivalentObject;
+ 			in->variant.hardLinkVariant.equivalentObjectId =
+ 				equivalentObject->objectId;
+ 			ylist_add(&in->hardLinks, &equivalentObject->hardLinks);
+ 			break;
+ 		case YAFFS_OBJECT_TYPE_FILE:
+ 		case YAFFS_OBJECT_TYPE_DIRECTORY:
+ 		case YAFFS_OBJECT_TYPE_SPECIAL:
+ 		case YAFFS_OBJECT_TYPE_UNKNOWN:
+ 			/* do nothing */
+ 			break;
+ 		}
+ 
+ 		if (yaffs_UpdateObjectHeader(in, name, 0, 0, 0) < 0) {
+ 			/* Could not create the object header, fail the creation */
+ 			yaffs_DeleteObject(in);
+ 			in = NULL;
+ 		}
+ 
+ 		yaffs_UpdateParent(parent);
+ 	}
+ 
+ 	return in;
+ }
+ 
+ yaffs_Object *yaffs_MknodFile(yaffs_Object *parent, const YCHAR *name,
+ 			__u32 mode, __u32 uid, __u32 gid)
+ {
+ 	return yaffs_MknodObject(YAFFS_OBJECT_TYPE_FILE, parent, name, mode,
+ 				uid, gid, NULL, NULL, 0);
+ }
+ 
+ yaffs_Object *yaffs_MknodDirectory(yaffs_Object *parent, const YCHAR *name,
+ 				__u32 mode, __u32 uid, __u32 gid)
+ {
+ 	return yaffs_MknodObject(YAFFS_OBJECT_TYPE_DIRECTORY, parent, name,
+ 				 mode, uid, gid, NULL, NULL, 0);
+ }
+ 
+ yaffs_Object *yaffs_MknodSpecial(yaffs_Object *parent, const YCHAR *name,
+ 				__u32 mode, __u32 uid, __u32 gid, __u32 rdev)
+ {
+ 	return yaffs_MknodObject(YAFFS_OBJECT_TYPE_SPECIAL, parent, name, mode,
+ 				 uid, gid, NULL, NULL, rdev);
+ }
+ 
+ yaffs_Object *yaffs_MknodSymLink(yaffs_Object *parent, const YCHAR *name,
+ 				__u32 mode, __u32 uid, __u32 gid,
+ 				const YCHAR *alias)
+ {
+ 	return yaffs_MknodObject(YAFFS_OBJECT_TYPE_SYMLINK, parent, name, mode,
+ 				uid, gid, NULL, alias, 0);
+ }
+ 
+ /* yaffs_Link returns the object id of the equivalent object.*/
+ yaffs_Object *yaffs_Link(yaffs_Object *parent, const YCHAR *name,
+ 			yaffs_Object *equivalentObject)
+ {
+ 	/* Get the real object in case we were fed a hard link as an equivalent object */
+ 	equivalentObject = yaffs_GetEquivalentObject(equivalentObject);
+ 
+ 	if (yaffs_MknodObject
+ 	    (YAFFS_OBJECT_TYPE_HARDLINK, parent, name, 0, 0, 0,
+ 	     equivalentObject, NULL, 0)) {
+ 		return equivalentObject;
+ 	} else {
+ 		return NULL;
+ 	}
+ 
+ }
+ 
+ static int yaffs_ChangeObjectName(yaffs_Object *obj, yaffs_Object *newDir,
+ 				const YCHAR *newName, int force, int shadows)
+ {
+ 	int unlinkOp;
+ 	int deleteOp;
+ 
+ 	yaffs_Object *existingTarget;
+ 
+ 	if (newDir == NULL)
+ 		newDir = obj->parent;	/* use the old directory */
+ 
+ 	if (newDir->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
+ 		T(YAFFS_TRACE_ALWAYS,
+ 		  (TSTR
+ 		   ("tragedy: yaffs_ChangeObjectName: newDir is not a directory"
+ 		    TENDSTR)));
+ 		YBUG();
+ 	}
+ 
+ 	/* TODO: Do we need this different handling for YAFFS2 and YAFFS1?? */
+ 	if (obj->myDev->param.isYaffs2)
+ 		unlinkOp = (newDir == obj->myDev->unlinkedDir);
+ 	else
+ 		unlinkOp = (newDir == obj->myDev->unlinkedDir
+ 			    && obj->variantType == YAFFS_OBJECT_TYPE_FILE);
+ 
+ 	deleteOp = (newDir == obj->myDev->deletedDir);
+ 
+ 	existingTarget = yaffs_FindObjectByName(newDir, newName);
+ 
+ 	/* If the object is a file going into the unlinked directory,
+ 	 *   then it is OK to just stuff it in since duplicate names are allowed.
+ 	 *   else only proceed if the new name does not exist and if we're putting
+ 	 *   it into a directory.
+ 	 */
+ 	if ((unlinkOp ||
+ 	     deleteOp ||
+ 	     force ||
+ 	     (shadows > 0) ||
+ 	     !existingTarget) &&
+ 	    newDir->variantType == YAFFS_OBJECT_TYPE_DIRECTORY) {
+ 		yaffs_SetObjectName(obj, newName);
+ 		obj->dirty = 1;
+ 
+ 		yaffs_AddObjectToDirectory(newDir, obj);
+ 
+ 		if (unlinkOp)
+ 			obj->unlinked = 1;
+ 
+ 		/* If it is a deletion then we mark it as a shrink for gc purposes. */
+ 		if (yaffs_UpdateObjectHeader(obj, newName, 0, deleteOp, shadows) >= 0)
+ 			return YAFFS_OK;
+ 	}
+ 
+ 	return YAFFS_FAIL;
+ }
+ 
+ int yaffs_RenameObject(yaffs_Object *oldDir, const YCHAR *oldName,
+ 		yaffs_Object *newDir, const YCHAR *newName)
+ {
+ 	yaffs_Object *obj = NULL;
+ 	yaffs_Object *existingTarget = NULL;
+ 	int force = 0;
+ 	int result;
+ 	yaffs_Device *dev;
+ 
+ 
+ 	if (!oldDir || oldDir->variantType != YAFFS_OBJECT_TYPE_DIRECTORY)
+ 		YBUG();
+ 	if (!newDir || newDir->variantType != YAFFS_OBJECT_TYPE_DIRECTORY)
+ 		YBUG();
+ 
+ 	dev = oldDir->myDev;
+ 
+ #ifdef CONFIG_YAFFS_CASE_INSENSITIVE
+ 	/* Special case for case insemsitive systems (eg. WinCE).
+ 	 * While look-up is case insensitive, the name isn't.
+ 	 * Therefore we might want to change x.txt to X.txt
+ 	*/
+ 	if (oldDir == newDir && yaffs_strcmp(oldName, newName) == 0)
+ 		force = 1;
+ #endif
+ 
+ 	if(yaffs_strnlen(newName,YAFFS_MAX_NAME_LENGTH+1) > YAFFS_MAX_NAME_LENGTH)
+ 		/* ENAMETOOLONG */
+ 		return YAFFS_FAIL;
+ 
+ 	obj = yaffs_FindObjectByName(oldDir, oldName);
+ 
+ 	if (obj && obj->renameAllowed) {
+ 
+ 		/* Now do the handling for an existing target, if there is one */
+ 
+ 		existingTarget = yaffs_FindObjectByName(newDir, newName);
+ 		if (existingTarget &&
+ 			existingTarget->variantType == YAFFS_OBJECT_TYPE_DIRECTORY &&
+ 			!ylist_empty(&existingTarget->variant.directoryVariant.children)) {
+ 			/* There is a target that is a non-empty directory, so we fail */
+ 			return YAFFS_FAIL;	/* EEXIST or ENOTEMPTY */
+ 		} else if (existingTarget && existingTarget != obj) {
+ 			/* Nuke the target first, using shadowing,
+ 			 * but only if it isn't the same object.
+ 			 *
+ 			 * Note we must disable gc otherwise it can mess up the shadowing.
+ 			 *
+ 			 */
+ 			dev->gcDisable=1;
+ 			yaffs_ChangeObjectName(obj, newDir, newName, force,
+ 						existingTarget->objectId);
+ 			existingTarget->isShadowed = 1;
+ 			yaffs_UnlinkObject(existingTarget);
+ 			dev->gcDisable=0;
+ 		}
+ 
+ 		result = yaffs_ChangeObjectName(obj, newDir, newName, 1, 0);
+ 
+ 		yaffs_UpdateParent(oldDir);
+ 		if(newDir != oldDir)
+ 			yaffs_UpdateParent(newDir);
+ 		
+ 		return result;
+ 	}
+ 	return YAFFS_FAIL;
+ }
+ 
+ /*------------------------- Block Management and Page Allocation ----------------*/
+ 
+ static int yaffs_InitialiseBlocks(yaffs_Device *dev)
+ {
+ 	int nBlocks = dev->internalEndBlock - dev->internalStartBlock + 1;
+ 
+ 	dev->blockInfo = NULL;
+ 	dev->chunkBits = NULL;
+ 
+ 	dev->allocationBlock = -1;	/* force it to get a new one */
+ 
+ 	/* If the first allocation strategy fails, thry the alternate one */
+ 	dev->blockInfo = YMALLOC(nBlocks * sizeof(yaffs_BlockInfo));
+ 	if (!dev->blockInfo) {
+ 		dev->blockInfo = YMALLOC_ALT(nBlocks * sizeof(yaffs_BlockInfo));
+ 		dev->blockInfoAlt = 1;
+ 	} else
+ 		dev->blockInfoAlt = 0;
+ 
+ 	if (dev->blockInfo) {
+ 		/* Set up dynamic blockinfo stuff. */
+ 		dev->chunkBitmapStride = (dev->param.nChunksPerBlock + 7) / 8; /* round up bytes */
+ 		dev->chunkBits = YMALLOC(dev->chunkBitmapStride * nBlocks);
+ 		if (!dev->chunkBits) {
+ 			dev->chunkBits = YMALLOC_ALT(dev->chunkBitmapStride * nBlocks);
+ 			dev->chunkBitsAlt = 1;
+ 		} else
+ 			dev->chunkBitsAlt = 0;
+ 	}
+ 
+ 	if (dev->blockInfo && dev->chunkBits) {
+ 		memset(dev->blockInfo, 0, nBlocks * sizeof(yaffs_BlockInfo));
+ 		memset(dev->chunkBits, 0, dev->chunkBitmapStride * nBlocks);
+ 		return YAFFS_OK;
+ 	}
+ 
+ 	return YAFFS_FAIL;
+ }
+ 
+ static void yaffs_DeinitialiseBlocks(yaffs_Device *dev)
+ {
+ 	if (dev->blockInfoAlt && dev->blockInfo)
+ 		YFREE_ALT(dev->blockInfo);
+ 	else if (dev->blockInfo)
+ 		YFREE(dev->blockInfo);
+ 
+ 	dev->blockInfoAlt = 0;
+ 
+ 	dev->blockInfo = NULL;
+ 
+ 	if (dev->chunkBitsAlt && dev->chunkBits)
+ 		YFREE_ALT(dev->chunkBits);
+ 	else if (dev->chunkBits)
+ 		YFREE(dev->chunkBits);
+ 	dev->chunkBitsAlt = 0;
+ 	dev->chunkBits = NULL;
+ }
+ 
+ static int yaffs_BlockNotDisqualifiedFromGC(yaffs_Device *dev,
+ 					yaffs_BlockInfo *bi)
+ {
+ 
+ 	if (!dev->param.isYaffs2)
+ 		return 1;	/* disqualification only applies to yaffs2. */
+ 
+ 	if (!bi->hasShrinkHeader)
+ 		return 1;	/* can gc */
+ 
+ 	yaffs_FindOldestDirtySequence(dev);
+ 
+ 	/* Can't do gc of this block if there are any blocks older than this one that have
+ 	 * discarded pages.
+ 	 */
+ 	return (bi->sequenceNumber <= dev->oldestDirtySequence);
+ }
+ 
+ /*
+  * yaffs_FindRefreshBlock()
+  * periodically finds the oldest full block by sequence number for refreshing.
+  * Only for yaffs2.
+  */
+ static __u32 yaffs_FindRefreshBlock(yaffs_Device *dev)
+ {
+ 	__u32 b ;
+ 
+ 	__u32 oldest = 0;
+ 	__u32 oldestSequence = 0;
+ 
+ 	yaffs_BlockInfo *bi;
+ 
+ 	/*
+ 	 * If refresh period < 10 then refreshing is disabled.
+ 	 */
+ 	if(dev->param.refreshPeriod < 10 ||
+ 		!dev->param.isYaffs2)
+ 	        return oldest;
+ 
+         /*
+          * Fix broken values.
+          */
+         if(dev->refreshSkip > dev->param.refreshPeriod)
+                 dev->refreshSkip = dev->param.refreshPeriod;
+ 
+ 	if(dev->refreshSkip > 0)
+ 	        return oldest;
+ 
+ 	/*
+ 	 * Refresh skip is now zero.
+ 	 * We'll do a refresh this time around....
+ 	 * Update the refresh skip and find the oldest block.
+ 	 */
+ 	dev->refreshSkip = dev->param.refreshPeriod;
+ 	dev->refreshCount++;
+ 	bi = dev->blockInfo;
+ 	for (b = dev->internalStartBlock; b <=dev->internalEndBlock; b++){
+ 
+ 		if (bi->blockState == YAFFS_BLOCK_STATE_FULL){
+ 
+ 			if(oldest < 1 ||
+                                 bi->sequenceNumber < oldestSequence){
+                                 oldest = b;
+                                 oldestSequence = bi->sequenceNumber;
+                         }
+ 		}
+ 		bi++;
+ 	}
+ 
+ 	if (oldest > 0) {
+ 		T(YAFFS_TRACE_GC,
+ 		  (TSTR("GC refresh count %d selected block %d with sequenceNumber %d" TENDSTR),
+ 		   dev->refreshCount, oldest, oldestSequence));
+ 	}
+ 
+ 	return oldest;
+ }
+ 
+ 
+ static void yaffs_BlockBecameDirty(yaffs_Device *dev, int blockNo)
+ {
+ 	yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, blockNo);
+ 
+ 	int erasedOk = 0;
+ 
+ 	/* If the block is still healthy erase it and mark as clean.
+ 	 * If the block has had a data failure, then retire it.
+ 	 */
+ 
+ 	T(YAFFS_TRACE_GC | YAFFS_TRACE_ERASE,
+ 		(TSTR("yaffs_BlockBecameDirty block %d state %d %s"TENDSTR),
+ 		blockNo, bi->blockState, (bi->needsRetiring) ? "needs retiring" : ""));
+ 
+ 	yaffs_ClearOldestDirtySequence(dev,bi);
+ 
+ 	bi->blockState = YAFFS_BLOCK_STATE_DIRTY;
+ 
+ 	/* If this is the block being garbage collected then stop gc'ing this block */
+ 	if(blockNo == dev->gcBlock)
+ 		dev->gcBlock = 0;
+ 
+ 	/* If this block is currently the best candidate for gc then drop as a candidate */
+ 	if(blockNo == dev->gcDirtiest){
+ 		dev->gcDirtiest = 0;
+ 		dev->gcPagesInUse = 0;
+ 	}
+ 
+ 	if (!bi->needsRetiring) {
+ 		yaffs_InvalidateCheckpoint(dev);
+ 		erasedOk = yaffs_EraseBlockInNAND(dev, blockNo);
+ 		if (!erasedOk) {
+ 			dev->nErasureFailures++;
+ 			T(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
+ 			  (TSTR("**>> Erasure failed %d" TENDSTR), blockNo));
+ 		}
+ 	}
+ 
+ 	if (erasedOk &&
+ 	    ((yaffs_traceMask & YAFFS_TRACE_ERASE) || !yaffs_SkipVerification(dev))) {
+ 		int i;
+ 		for (i = 0; i < dev->param.nChunksPerBlock; i++) {
+ 			if (!yaffs_CheckChunkErased
+ 			    (dev, blockNo * dev->param.nChunksPerBlock + i)) {
+ 				T(YAFFS_TRACE_ERROR,
+ 				  (TSTR
+ 				   (">>Block %d erasure supposedly OK, but chunk %d not erased"
+ 				    TENDSTR), blockNo, i));
+ 			}
+ 		}
+ 	}
+ 
+ 	if (erasedOk) {
+ 		/* Clean it up... */
+ 		bi->blockState = YAFFS_BLOCK_STATE_EMPTY;
+ 		bi->sequenceNumber = 0;
+ 		dev->nErasedBlocks++;
+ 		bi->pagesInUse = 0;
+ 		bi->softDeletions = 0;
+ 		bi->hasShrinkHeader = 0;
+ 		bi->skipErasedCheck = 1;  /* This is clean, so no need to check */
+ 		bi->gcPrioritise = 0;
+ 		yaffs_ClearChunkBits(dev, blockNo);
+ 
+ 		T(YAFFS_TRACE_ERASE,
+ 		  (TSTR("Erased block %d" TENDSTR), blockNo));
+ 	} else {
+ 		dev->nFreeChunks -= dev->param.nChunksPerBlock;	/* We lost a block of free space */
+ 
+ 		yaffs_RetireBlock(dev, blockNo);
+ 		T(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
+ 		  (TSTR("**>> Block %d retired" TENDSTR), blockNo));
+ 	}
+ }
+ 
+ static int yaffs_FindBlockForAllocation(yaffs_Device *dev)
+ {
+ 	int i;
+ 
+ 	yaffs_BlockInfo *bi;
+ 
+ 	if (dev->nErasedBlocks < 1) {
+ 		/* Hoosterman we've got a problem.
+ 		 * Can't get space to gc
+ 		 */
+ 		T(YAFFS_TRACE_ERROR,
+ 		  (TSTR("yaffs tragedy: no more erased blocks" TENDSTR)));
+ 
+ 		return -1;
+ 	}
+ 
+ 	/* Find an empty block. */
+ 
+ 	for (i = dev->internalStartBlock; i <= dev->internalEndBlock; i++) {
+ 		dev->allocationBlockFinder++;
+ 		if (dev->allocationBlockFinder < dev->internalStartBlock
+ 		    || dev->allocationBlockFinder > dev->internalEndBlock) {
+ 			dev->allocationBlockFinder = dev->internalStartBlock;
+ 		}
+ 
+ 		bi = yaffs_GetBlockInfo(dev, dev->allocationBlockFinder);
+ 
+ 		if (bi->blockState == YAFFS_BLOCK_STATE_EMPTY) {
+ 			bi->blockState = YAFFS_BLOCK_STATE_ALLOCATING;
+ 			dev->sequenceNumber++;
+ 			bi->sequenceNumber = dev->sequenceNumber;
+ 			dev->nErasedBlocks--;
+ 			T(YAFFS_TRACE_ALLOCATE,
+ 			  (TSTR("Allocated block %d, seq  %d, %d left" TENDSTR),
+ 			   dev->allocationBlockFinder, dev->sequenceNumber,
+ 			   dev->nErasedBlocks));
+ 			return dev->allocationBlockFinder;
+ 		}
+ 	}
+ 
+ 	T(YAFFS_TRACE_ALWAYS,
+ 	  (TSTR
+ 	   ("yaffs tragedy: no more erased blocks, but there should have been %d"
+ 	    TENDSTR), dev->nErasedBlocks));
+ 
+ 	return -1;
+ }
+ 
+ 
+ 
+ static int yaffs_CheckpointRequired(yaffs_Device *dev)
+ {
+ 	int nblocks = dev->internalEndBlock - dev->internalStartBlock + 1 ;
+ 	return dev->param.isYaffs2 &&
+ 		!dev->param.skipCheckpointWrite &&
+ 		(nblocks >= YAFFS_CHECKPOINT_MIN_BLOCKS);
+ }
+ static int yaffs_CalcCheckpointBlocksRequired(yaffs_Device *dev)
+ {
+ 	if (!dev->nCheckpointBlocksRequired &&
+ 		yaffs_CheckpointRequired(dev)){
+ 		/* Not a valid value so recalculate */
+ 		int nBytes = 0;
+ 		int nBlocks;
+ 		int devBlocks = (dev->param.endBlock - dev->param.startBlock + 1);
+ 		int tnodeSize = yaffs_CalcTnodeSize(dev);
+ 
+ 		nBytes += sizeof(yaffs_CheckpointValidity);
+ 		nBytes += sizeof(yaffs_CheckpointDevice);
+ 		nBytes += devBlocks * sizeof(yaffs_BlockInfo);
+ 		nBytes += devBlocks * dev->chunkBitmapStride;
+ 		nBytes += (sizeof(yaffs_CheckpointObject) + sizeof(__u32)) * (dev->nObjectsCreated - dev->nFreeObjects);
+ 		nBytes += (tnodeSize + sizeof(__u32)) * (dev->nTnodesCreated - dev->nFreeTnodes);
+ 		nBytes += sizeof(yaffs_CheckpointValidity);
+ 		nBytes += sizeof(__u32); /* checksum*/
+ 
+ 		/* Round up and add 2 blocks to allow for some bad blocks, so add 3 */
+ 
+ 		nBlocks = (nBytes/(dev->nDataBytesPerChunk * dev->param.nChunksPerBlock)) + 3;
+ 
+ 		dev->nCheckpointBlocksRequired = nBlocks;
+ 	}
+ 
+ 	return dev->nCheckpointBlocksRequired;
+ }
+ 
+ /*
+  * Check if there's space to allocate...
+  * Thinks.... do we need top make this ths same as yaffs_GetFreeChunks()?
+  */
+ static int yaffs_CheckSpaceForAllocation(yaffs_Device *dev, int nChunks)
+ {
+ 	int reservedChunks;
+ 	int reservedBlocks = dev->param.nReservedBlocks;
+ 	int checkpointBlocks;
+ 
+ 	if (dev->param.isYaffs2) {
+ 		checkpointBlocks =  yaffs_CalcCheckpointBlocksRequired(dev) -
+ 				    dev->blocksInCheckpoint;
+ 		if (checkpointBlocks < 0)
+ 			checkpointBlocks = 0;
+ 	} else {
+ 		checkpointBlocks = 0;
+ 	}
+ 
+ 	reservedChunks = ((reservedBlocks + checkpointBlocks) * dev->param.nChunksPerBlock);
+ 
+ 	return (dev->nFreeChunks > (reservedChunks + nChunks));
+ }
+ 
+ static int yaffs_AllocateChunk(yaffs_Device *dev, int useReserve,
+ 		yaffs_BlockInfo **blockUsedPtr)
+ {
+ 	int retVal;
+ 	yaffs_BlockInfo *bi;
+ 
+ 	if (dev->allocationBlock < 0) {
+ 		/* Get next block to allocate off */
+ 		dev->allocationBlock = yaffs_FindBlockForAllocation(dev);
+ 		dev->allocationPage = 0;
+ 	}
+ 
+ 	if (!useReserve && !yaffs_CheckSpaceForAllocation(dev, 1)) {
+ 		/* Not enough space to allocate unless we're allowed to use the reserve. */
+ 		return -1;
+ 	}
+ 
+ 	if (dev->nErasedBlocks < dev->param.nReservedBlocks
+ 			&& dev->allocationPage == 0) {
+ 		T(YAFFS_TRACE_ALLOCATE, (TSTR("Allocating reserve" TENDSTR)));
+ 	}
+ 
+ 	/* Next page please.... */
+ 	if (dev->allocationBlock >= 0) {
+ 		bi = yaffs_GetBlockInfo(dev, dev->allocationBlock);
+ 
+ 		retVal = (dev->allocationBlock * dev->param.nChunksPerBlock) +
+ 			dev->allocationPage;
+ 		bi->pagesInUse++;
+ 		yaffs_SetChunkBit(dev, dev->allocationBlock,
+ 				dev->allocationPage);
+ 
+ 		dev->allocationPage++;
+ 
+ 		dev->nFreeChunks--;
+ 
+ 		/* If the block is full set the state to full */
+ 		if (dev->allocationPage >= dev->param.nChunksPerBlock) {
+ 			bi->blockState = YAFFS_BLOCK_STATE_FULL;
+ 			dev->allocationBlock = -1;
+ 		}
+ 
+ 		if (blockUsedPtr)
+ 			*blockUsedPtr = bi;
+ 
+ 		return retVal;
+ 	}
+ 
+ 	T(YAFFS_TRACE_ERROR,
+ 			(TSTR("!!!!!!!!! Allocator out !!!!!!!!!!!!!!!!!" TENDSTR)));
+ 
+ 	return -1;
+ }
+ 
+ static int yaffs_GetErasedChunks(yaffs_Device *dev)
+ {
+ 	int n;
+ 
+ 	n = dev->nErasedBlocks * dev->param.nChunksPerBlock;
+ 
+ 	if (dev->allocationBlock > 0)
+ 		n += (dev->param.nChunksPerBlock - dev->allocationPage);
+ 
+ 	return n;
+ 
+ }
+ 
+ /*
+  * yaffs_SkipRestOfBlock() skips over the rest of the allocation block
+  * if we don't want to write to it.
+  */
+ static void yaffs_SkipRestOfBlock(yaffs_Device *dev)
+ {
+ 	if(dev->allocationBlock > 0){
+ 		yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, dev->allocationBlock);
+ 		if(bi->blockState == YAFFS_BLOCK_STATE_ALLOCATING){
+ 			bi->blockState = YAFFS_BLOCK_STATE_FULL;
+ 			dev->allocationBlock = -1;
+ 		}
+ 	}
+ }
+ 
+ 
+ static int yaffs_GarbageCollectBlock(yaffs_Device *dev, int block,
+ 		int wholeBlock)
+ {
+ 	int oldChunk;
+ 	int newChunk;
+ 	int markNAND;
+ 	int retVal = YAFFS_OK;
+ 	int cleanups = 0;
+ 	int i;
+ 	int isCheckpointBlock;
+ 	int matchingChunk;
+ 	int maxCopies;
+ 
+ 	int chunksBefore = yaffs_GetErasedChunks(dev);
+ 	int chunksAfter;
+ 
+ 	yaffs_ExtendedTags tags;
+ 
+ 	yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, block);
+ 
+ 	yaffs_Object *object;
+ 
+ 	isCheckpointBlock = (bi->blockState == YAFFS_BLOCK_STATE_CHECKPOINT);
+ 
+ 
+ 	T(YAFFS_TRACE_TRACING,
+ 			(TSTR("Collecting block %d, in use %d, shrink %d, wholeBlock %d" TENDSTR),
+ 			 block,
+ 			 bi->pagesInUse,
+ 			 bi->hasShrinkHeader,
+ 			 wholeBlock));
+ 
+ 	/*yaffs_VerifyFreeChunks(dev); */
+ 
+ 	if(bi->blockState == YAFFS_BLOCK_STATE_FULL)
+ 		bi->blockState = YAFFS_BLOCK_STATE_COLLECTING;
+ 	
+ 	bi->hasShrinkHeader = 0;	/* clear the flag so that the block can erase */
+ 
+ 	dev->gcDisable = 1;
+ 
+ 	if (isCheckpointBlock ||
+ 			!yaffs_StillSomeChunkBits(dev, block)) {
+ 		T(YAFFS_TRACE_TRACING,
+ 				(TSTR
+ 				 ("Collecting block %d that has no chunks in use" TENDSTR),
+ 				 block));
+ 		yaffs_BlockBecameDirty(dev, block);
+ 	} else {
+ 
+ 		__u8 *buffer = yaffs_GetTempBuffer(dev, __LINE__);
+ 
+ 		yaffs_VerifyBlock(dev, bi, block);
+ 
+ 		maxCopies = (wholeBlock) ? dev->param.nChunksPerBlock : 5;
+ 		oldChunk = block * dev->param.nChunksPerBlock + dev->gcChunk;
+ 
+ 		for (/* init already done */;
+ 		     retVal == YAFFS_OK &&
+ 		     dev->gcChunk < dev->param.nChunksPerBlock &&
+ 		     (bi->blockState == YAFFS_BLOCK_STATE_COLLECTING) &&
+ 		     maxCopies > 0;
+ 		     dev->gcChunk++, oldChunk++) {
+ 			if (yaffs_CheckChunkBit(dev, block, dev->gcChunk)) {
+ 
+ 				/* This page is in use and might need to be copied off */
+ 
+ 				maxCopies--;
+ 
+ 				markNAND = 1;
+ 
+ 				yaffs_InitialiseTags(&tags);
+ 
+ 				yaffs_ReadChunkWithTagsFromNAND(dev, oldChunk,
+ 								buffer, &tags);
+ 
+ 				object =
+ 				    yaffs_FindObjectByNumber(dev,
+ 							     tags.objectId);
+ 
+ 				T(YAFFS_TRACE_GC_DETAIL,
+ 				  (TSTR
+ 				   ("Collecting chunk in block %d, %d %d %d " TENDSTR),
+ 				   dev->gcChunk, tags.objectId, tags.chunkId,
+ 				   tags.byteCount));
+ 
+ 				if (object && !yaffs_SkipVerification(dev)) {
+ 					if (tags.chunkId == 0)
+ 						matchingChunk = object->hdrChunk;
+ 					else if (object->softDeleted)
+ 						matchingChunk = oldChunk; /* Defeat the test */
+ 					else
+ 						matchingChunk = yaffs_FindChunkInFile(object, tags.chunkId, NULL);
+ 
+ 					if (oldChunk != matchingChunk)
+ 						T(YAFFS_TRACE_ERROR,
+ 						  (TSTR("gc: page in gc mismatch: %d %d %d %d"TENDSTR),
+ 						  oldChunk, matchingChunk, tags.objectId, tags.chunkId));
+ 
+ 				}
+ 
+ 				if (!object) {
+ 					T(YAFFS_TRACE_ERROR,
+ 					  (TSTR
+ 					   ("page %d in gc has no object: %d %d %d "
+ 					    TENDSTR), oldChunk,
+ 					    tags.objectId, tags.chunkId, tags.byteCount));
+ 				}
+ 
+ 				if (object &&
+ 				    object->deleted &&
+ 				    object->softDeleted &&
+ 				    tags.chunkId != 0) {
+ 					/* Data chunk in a soft deleted file, throw it away
+ 					 * It's a soft deleted data chunk,
+ 					 * No need to copy this, just forget about it and
+ 					 * fix up the object.
+ 					 */
+ 					 
+ 					/* Free chunks already includes softdeleted chunks.
+ 					 * How ever this chunk is going to soon be really deleted
+ 					 * which will increment free chunks.
+ 					 * We have to decrement free chunks so this works out properly.
+ 					 */
+ 					dev->nFreeChunks--;
+ 
+ 					object->nDataChunks--;
+ 
+ 					if (object->nDataChunks <= 0) {
+ 						/* remeber to clean up the object */
+ 						dev->gcCleanupList[cleanups] =
+ 						    tags.objectId;
+ 						cleanups++;
+ 					}
+ 					markNAND = 0;
+ 				} else if (0) {
+ 					/* Todo object && object->deleted && object->nDataChunks == 0 */
+ 					/* Deleted object header with no data chunks.
+ 					 * Can be discarded and the file deleted.
+ 					 */
+ 					object->hdrChunk = 0;
+ 					yaffs_FreeTnode(object->myDev,
+ 							object->variant.
+ 							fileVariant.top);
+ 					object->variant.fileVariant.top = NULL;
+ 					yaffs_DoGenericObjectDeletion(object);
+ 
+ 				} else if (object) {
+ 					/* It's either a data chunk in a live file or
+ 					 * an ObjectHeader, so we're interested in it.
+ 					 * NB Need to keep the ObjectHeaders of deleted files
+ 					 * until the whole file has been deleted off
+ 					 */
+ 					tags.serialNumber++;
+ 
+ 					dev->nGCCopies++;
+ 
+ 					if (tags.chunkId == 0) {
+ 						/* It is an object Id,
+ 						 * We need to nuke the shrinkheader flags first
+ 						 * Also need to clean up shadowing.
+ 						 * We no longer want the shrinkHeader flag since its work is done
+ 						 * and if it is left in place it will mess up scanning.
+ 						 */
+ 
+ 						yaffs_ObjectHeader *oh;
+ 						oh = (yaffs_ObjectHeader *)buffer;
+ 
+ 						oh->isShrink = 0;
+ 						tags.extraIsShrinkHeader = 0;
+ 
+ 						oh->shadowsObject = 0;
+ 						oh->inbandShadowsObject = 0;
+ 						tags.extraShadows = 0;
+ 
+ 						/* Update file size */
+ 						if(object->variantType == YAFFS_OBJECT_TYPE_FILE){
+ 							oh->fileSize = object->variant.fileVariant.fileSize;
+ 							tags.extraFileLength = oh->fileSize;
+ 						}
+ 
+ 						yaffs_VerifyObjectHeader(object, oh, &tags, 1);
+ 						newChunk =
+ 						    yaffs_WriteNewChunkWithTagsToNAND(dev,(__u8 *) oh, &tags, 1);
+ 					} else
+ 						newChunk =
+ 						    yaffs_WriteNewChunkWithTagsToNAND(dev, buffer, &tags, 1);
+ 
+ 					if (newChunk < 0) {
+ 						retVal = YAFFS_FAIL;
+ 					} else {
+ 
+ 						/* Ok, now fix up the Tnodes etc. */
+ 
+ 						if (tags.chunkId == 0) {
+ 							/* It's a header */
+ 							object->hdrChunk =  newChunk;
+ 							object->serial =   tags.serialNumber;
+ 						} else {
+ 							/* It's a data chunk */
+ 							int ok;
+ 							ok = yaffs_PutChunkIntoFile
+ 							    (object,
+ 							     tags.chunkId,
+ 							     newChunk, 0);
+ 						}
+ 					}
+ 				}
+ 
+ 				if (retVal == YAFFS_OK)
+ 					yaffs_DeleteChunk(dev, oldChunk, markNAND, __LINE__);
+ 
+ 			}
+ 		}
+ 
+ 		yaffs_ReleaseTempBuffer(dev, buffer, __LINE__);
+ 
+ 
+ 		/* Do any required cleanups */
+ 		for (i = 0; i < cleanups; i++) {
+ 			/* Time to delete the file too */
+ 			object =
+ 			    yaffs_FindObjectByNumber(dev,
+ 						     dev->gcCleanupList[i]);
+ 			if (object) {
+ 				yaffs_FreeTnode(dev,
+ 						object->variant.fileVariant.
+ 						top);
+ 				object->variant.fileVariant.top = NULL;
+ 				T(YAFFS_TRACE_GC,
+ 				  (TSTR
+ 				   ("yaffs: About to finally delete object %d"
+ 				    TENDSTR), object->objectId));
+ 				yaffs_DoGenericObjectDeletion(object);
+ 				object->myDev->nDeletedFiles--;
+ 			}
+ 
+ 		}
+ 
+ 	}
+ 
+ 	yaffs_VerifyCollectedBlock(dev, bi, block);
+ 
+ 
+ 
+ 	if (bi->blockState == YAFFS_BLOCK_STATE_COLLECTING) {
+ 		/*
+ 		 * The gc did not complete. Set block state back to FULL
+ 		 * because checkpointing does not restore gc.
+ 		 */
+ 		bi->blockState = YAFFS_BLOCK_STATE_FULL;
+ 	} else {
+ 		/* The gc completed. */
+ 		chunksAfter = yaffs_GetErasedChunks(dev);
+ 		if (chunksBefore >= chunksAfter) {
+ 			T(YAFFS_TRACE_GC,
+ 			  (TSTR
+ 			   ("gc did not increase free chunks before %d after %d"
+ 			    TENDSTR), chunksBefore, chunksAfter));
+ 		}
+ 		dev->gcBlock = 0;
+ 		dev->gcChunk = 0;
+ 	}
+ 
+ 	dev->gcDisable = 0;
+ 
+ 	return retVal;
+ }
+ 
+ /*
+  * FindBlockForgarbageCollection is used to select the dirtiest block (or close enough)
+  * for garbage collection.
+  */
+ 
+ static unsigned yaffs_FindBlockForGarbageCollection(yaffs_Device *dev,
+ 					int aggressive,
+ 					int background)
+ {
+ 	int i;
+ 	int iterations;
+ 	unsigned selected = 0;
+ 	int prioritised = 0;
+ 	int prioritisedExists = 0;
+ 	yaffs_BlockInfo *bi;
+ 	int threshold;
+ 
+ 	/* First let's see if we need to grab a prioritised block */
+ 	if (dev->hasPendingPrioritisedGCs && !aggressive) {
+ 		dev->gcDirtiest = 0;
+ 		bi = dev->blockInfo;
+ 		for (i = dev->internalStartBlock;
+ 			i <= dev->internalEndBlock && !selected;
+ 			i++) {
+ 
+ 			if (bi->gcPrioritise) {
+ 				prioritisedExists = 1;
+ 				if (bi->blockState == YAFFS_BLOCK_STATE_FULL &&
+ 				   yaffs_BlockNotDisqualifiedFromGC(dev, bi)) {
+ 					selected = i;
+ 					prioritised = 1;
+ 				}
+ 			}
+ 			bi++;
+ 		}
+ 
+ 		/*
+ 		 * If there is a prioritised block and none was selected then
+ 		 * this happened because there is at least one old dirty block gumming
+ 		 * up the works. Let's gc the oldest dirty block.
+ 		 */
+ 
+ 		if(prioritisedExists &&
+ 			!selected &&
+ 			dev->oldestDirtyBlock > 0)
+ 			selected = dev->oldestDirtyBlock;
+ 
+ 		if (!prioritisedExists) /* None found, so we can clear this */
+ 			dev->hasPendingPrioritisedGCs = 0;
+ 	}
+ 
+ 	/* If we're doing aggressive GC then we are happy to take a less-dirty block, and
+ 	 * search harder.
+ 	 * else (we're doing a leasurely gc), then we only bother to do this if the
+ 	 * block has only a few pages in use.
+ 	 */
+ 
+ 	if (!selected){
+ 		int pagesUsed;
+ 		int nBlocks = dev->internalEndBlock - dev->internalStartBlock + 1;
+ 		if (aggressive){
+ 			threshold = dev->param.nChunksPerBlock;
+ 			iterations = nBlocks;
+ 		} else {
+ 			int maxThreshold = dev->param.nChunksPerBlock/2;
+ 			threshold = background ?
+ 				(dev->gcNotDone + 2) * 2 : 0;
+ 			if(threshold <YAFFS_GC_PASSIVE_THRESHOLD)
+ 				threshold = YAFFS_GC_PASSIVE_THRESHOLD;
+ 			if(threshold > maxThreshold)
+ 				threshold = maxThreshold;
+ 
+ 			iterations = nBlocks / 16 + 1;
+ 			if (iterations > 100)
+ 				iterations = 100;
+ 		}
+ 
+ 		for (i = 0;
+ 			i < iterations &&
+ 			(dev->gcDirtiest < 1 ||
+ 				dev->gcPagesInUse > YAFFS_GC_GOOD_ENOUGH);
+ 			i++) {
+ 			dev->gcBlockFinder++;
+ 			if (dev->gcBlockFinder < dev->internalStartBlock ||
+ 				dev->gcBlockFinder > dev->internalEndBlock)
+ 				dev->gcBlockFinder = dev->internalStartBlock;
+ 
+ 			bi = yaffs_GetBlockInfo(dev, dev->gcBlockFinder);
+ 
+ 			pagesUsed = bi->pagesInUse - bi->softDeletions;
+ 
+ 			if (bi->blockState == YAFFS_BLOCK_STATE_FULL &&
+ 				pagesUsed < dev->param.nChunksPerBlock &&
+ 				(dev->gcDirtiest < 1 || pagesUsed < dev->gcPagesInUse) &&
+ 				yaffs_BlockNotDisqualifiedFromGC(dev, bi)) {
+ 				dev->gcDirtiest = dev->gcBlockFinder;
+ 				dev->gcPagesInUse = pagesUsed;
+ 			}
+ 		}
+ 
+ 		if(dev->gcDirtiest > 0 && dev->gcPagesInUse <= threshold)
+ 			selected = dev->gcDirtiest;
+ 	}
+ 
+ 	/*
+ 	 * If nothing has been selected for a while, try selecting the oldest dirty
+ 	 * because that's gumming up the works.
+ 	 */
+ 
+ 	if(!selected && dev->param.isYaffs2 &&
+ 		dev->gcNotDone >= ( background ? 10 : 20)){
+ 		yaffs_FindOldestDirtySequence(dev);
+ 		if(dev->oldestDirtyBlock > 0) {
+ 			selected = dev->oldestDirtyBlock;
+ 			dev->gcDirtiest = selected;
+ 			dev->oldestDirtyGCs++;
+ 			bi = yaffs_GetBlockInfo(dev, selected);
+ 			dev->gcPagesInUse =  bi->pagesInUse - bi->softDeletions;
+ 		} else
+ 			dev->gcNotDone = 0;
+ 	}
+ 
+ 	if(selected){
+ 		T(YAFFS_TRACE_GC,
+ 		  (TSTR("GC Selected block %d with %d free, prioritised:%d" TENDSTR),
+ 		  selected,
+ 		  dev->param.nChunksPerBlock - dev->gcPagesInUse,
+ 		  prioritised));
+ 
+ 		if(background)
+ 			dev->backgroundGCs++;
+ 		dev->gcDirtiest = 0;
+ 		dev->gcPagesInUse = 0;
+ 		dev->gcNotDone = 0;
+ 		if(dev->refreshSkip > 0)
+ 			dev->refreshSkip--;
+ 	} else{
+ 		dev->gcNotDone++;
+ 		T(YAFFS_TRACE_GC,
+ 		  (TSTR("GC none: finder %d skip %d threshold %d dirtiest %d using %d oldest %d%s" TENDSTR),
+ 		  dev->gcBlockFinder, dev->gcNotDone,
+ 		  threshold,
+ 		  dev->gcDirtiest, dev->gcPagesInUse,
+ 		  dev->oldestDirtyBlock,
+ 		  background ? " bg" : ""));
+ 	}
+ 
+ 	return selected;
+ }
+ 
+ /* New garbage collector
+  * If we're very low on erased blocks then we do aggressive garbage collection
+  * otherwise we do "leasurely" garbage collection.
+  * Aggressive gc looks further (whole array) and will accept less dirty blocks.
+  * Passive gc only inspects smaller areas and will only accept more dirty blocks.
+  *
+  * The idea is to help clear out space in a more spread-out manner.
+  * Dunno if it really does anything useful.
+  */
+ static int yaffs_CheckGarbageCollection(yaffs_Device *dev, int background)
+ {
+ 	int aggressive = 0;
+ 	int gcOk = YAFFS_OK;
+ 	int maxTries = 0;
+ 
+ 	int minErased;
+ 	int erasedChunks;
+ 
+ 	int checkpointBlockAdjust;
+ 
+ 	if(dev->param.gcControl &&
+ 		(dev->param.gcControl(dev) & 1) == 0)
+ 		return YAFFS_OK;
+ 
+ 	if (dev->gcDisable) {
+ 		/* Bail out so we don't get recursive gc */
+ 		return YAFFS_OK;
+ 	}
+ 
+ 	/* This loop should pass the first time.
+ 	 * We'll only see looping here if the collection does not increase space.
+ 	 */
+ 
+ 	do {
+ 		maxTries++;
+ 
+ 		checkpointBlockAdjust = yaffs_CalcCheckpointBlocksRequired(dev) - dev->blocksInCheckpoint;
+ 		if (checkpointBlockAdjust < 0)
+ 			checkpointBlockAdjust = 0;
+ 
+ 		minErased  = dev->param.nReservedBlocks + checkpointBlockAdjust + 1;
+ 		erasedChunks = dev->nErasedBlocks * dev->param.nChunksPerBlock;
+ 
+ 		/* If we need a block soon then do aggressive gc.*/
+ 		if (dev->nErasedBlocks < minErased)
+ 			aggressive = 1;
+ 		else {
+ 			if(dev->gcSkip > 20)
+ 				dev->gcSkip = 20;
+ 			if(erasedChunks < dev->nFreeChunks/2 ||
+ 				dev->gcSkip < 1 ||
+ 				background)
+ 				aggressive = 0;
+ 			else {
+ 				dev->gcSkip--;
+ 				break;
+ 			}
+ 		}
+ 
+ 		dev->gcSkip = 5;
+ 
+                 /* If we don't already have a block being gc'd then see if we should start another */
+ 
+ 		if (dev->gcBlock < 1 && !aggressive) {
+ 			dev->gcBlock = yaffs_FindRefreshBlock(dev);
+ 			dev->gcChunk = 0;
+ 		}
+ 		if (dev->gcBlock < 1) {
+ 			dev->gcBlock = yaffs_FindBlockForGarbageCollection(dev, aggressive, background);
+ 			dev->gcChunk = 0;
+ 		}
+ 
+ 		if (dev->gcBlock > 0) {
+ 			dev->allGCs++;
+ 			if (!aggressive)
+ 				dev->passiveGCs++;
+ 
+ 			T(YAFFS_TRACE_GC,
+ 			  (TSTR
+ 			   ("yaffs: GC erasedBlocks %d aggressive %d" TENDSTR),
+ 			   dev->nErasedBlocks, aggressive));
+ 
+ 			gcOk = yaffs_GarbageCollectBlock(dev, dev->gcBlock, aggressive);
+ 		}
+ 
+ 		if (dev->nErasedBlocks < (dev->param.nReservedBlocks) && dev->gcBlock > 0) {
+ 			T(YAFFS_TRACE_GC,
+ 			  (TSTR
+ 			   ("yaffs: GC !!!no reclaim!!! erasedBlocks %d after try %d block %d"
+ 			    TENDSTR), dev->nErasedBlocks, maxTries, dev->gcBlock));
+ 		}
+ 	} while ((dev->nErasedBlocks < dev->param.nReservedBlocks) &&
+ 		 (dev->gcBlock > 0) &&
+ 		 (maxTries < 2));
+ 
+ 	return aggressive ? gcOk : YAFFS_OK;
+ }
+ 
+ /*
+  * yaffs_BackgroundGarbageCollect()
+  * Garbage collects. Intended to be called from a background thread.
+  * Returns non-zero if at least half the free chunks are erased.
+  */
+ int yaffs_BackgroundGarbageCollect(yaffs_Device *dev, unsigned urgency)
+ {
+ 	int erasedChunks = dev->nErasedBlocks * dev->param.nChunksPerBlock;
+ 
+ 	T(YAFFS_TRACE_BACKGROUND, (TSTR("Background gc %u" TENDSTR),urgency));
+ 
+ 	yaffs_CheckGarbageCollection(dev, 1);
+ 	return erasedChunks > dev->nFreeChunks/2;
+ }
+ 
+ /*-------------------------  TAGS --------------------------------*/
+ 
+ static int yaffs_TagsMatch(const yaffs_ExtendedTags *tags, int objectId,
+ 			   int chunkInObject)
+ {
+ 	return (tags->chunkId == chunkInObject &&
+ 		tags->objectId == objectId && !tags->chunkDeleted) ? 1 : 0;
+ 
+ }
+ 
+ 
+ /*-------------------- Data file manipulation -----------------*/
+ 
+ static int yaffs_FindChunkInFile(yaffs_Object *in, int chunkInInode,
+ 				 yaffs_ExtendedTags *tags)
+ {
+ 	/*Get the Tnode, then get the level 0 offset chunk offset */
+ 	yaffs_Tnode *tn;
+ 	int theChunk = -1;
+ 	yaffs_ExtendedTags localTags;
+ 	int retVal = -1;
+ 
+ 	yaffs_Device *dev = in->myDev;
+ 
+ 	if (!tags) {
+ 		/* Passed a NULL, so use our own tags space */
+ 		tags = &localTags;
+ 	}
+ 
+ 	tn = yaffs_FindLevel0Tnode(dev, &in->variant.fileVariant, chunkInInode);
+ 
+ 	if (tn) {
+ 		theChunk = yaffs_GetChunkGroupBase(dev, tn, chunkInInode);
+ 
+ 		retVal =
+ 		    yaffs_FindChunkInGroup(dev, theChunk, tags, in->objectId,
+ 					   chunkInInode);
+ 	}
+ 	return retVal;
+ }
+ 
+ static int yaffs_FindAndDeleteChunkInFile(yaffs_Object *in, int chunkInInode,
+ 					  yaffs_ExtendedTags *tags)
+ {
+ 	/* Get the Tnode, then get the level 0 offset chunk offset */
+ 	yaffs_Tnode *tn;
+ 	int theChunk = -1;
+ 	yaffs_ExtendedTags localTags;
+ 
+ 	yaffs_Device *dev = in->myDev;
+ 	int retVal = -1;
+ 
+ 	if (!tags) {
+ 		/* Passed a NULL, so use our own tags space */
+ 		tags = &localTags;
+ 	}
+ 
+ 	tn = yaffs_FindLevel0Tnode(dev, &in->variant.fileVariant, chunkInInode);
+ 
+ 	if (tn) {
+ 
+ 		theChunk = yaffs_GetChunkGroupBase(dev, tn, chunkInInode);
+ 
+ 		retVal =
+ 		    yaffs_FindChunkInGroup(dev, theChunk, tags, in->objectId,
+ 					   chunkInInode);
+ 
+ 		/* Delete the entry in the filestructure (if found) */
+ 		if (retVal != -1)
+ 			yaffs_LoadLevel0Tnode(dev, tn, chunkInInode, 0);
+ 	}
+ 
+ 	return retVal;
+ }
+ 
+ #ifdef YAFFS_PARANOID
+ 
+ static int yaffs_CheckFileSanity(yaffs_Object *in)
+ {
+ 	int chunk;
+ 	int nChunks;
+ 	int fSize;
+ 	int failed = 0;
+ 	int objId;
+ 	yaffs_Tnode *tn;
+ 	yaffs_Tags localTags;
+ 	yaffs_Tags *tags = &localTags;
+ 	int theChunk;
+ 	int chunkDeleted;
+ 
+ 	if (in->variantType != YAFFS_OBJECT_TYPE_FILE)
+ 		return YAFFS_FAIL;
+ 
+ 	objId = in->objectId;
+ 	fSize = in->variant.fileVariant.fileSize;
+ 	nChunks =
+ 	    (fSize + in->myDev->nDataBytesPerChunk - 1) / in->myDev->nDataBytesPerChunk;
+ 
+ 	for (chunk = 1; chunk <= nChunks; chunk++) {
+ 		tn = yaffs_FindLevel0Tnode(in->myDev, &in->variant.fileVariant,
+ 					   chunk);
+ 
+ 		if (tn) {
+ 
+ 			theChunk = yaffs_GetChunkGroupBase(dev, tn, chunk);
+ 
+ 			if (yaffs_CheckChunkBits
+ 			    (dev, theChunk / dev->param.nChunksPerBlock,
+ 			     theChunk % dev->param.nChunksPerBlock)) {
+ 
+ 				yaffs_ReadChunkTagsFromNAND(in->myDev, theChunk,
+ 							    tags,
+ 							    &chunkDeleted);
+ 				if (yaffs_TagsMatch
+ 				    (tags, in->objectId, chunk, chunkDeleted)) {
+ 					/* found it; */
+ 
+ 				}
+ 			} else {
+ 
+ 				failed = 1;
+ 			}
+ 
+ 		} else {
+ 			/* T(("No level 0 found for %d\n", chunk)); */
+ 		}
+ 	}
+ 
+ 	return failed ? YAFFS_FAIL : YAFFS_OK;
+ }
+ 
+ #endif
+ 
+ static int yaffs_PutChunkIntoFile(yaffs_Object *in, int chunkInInode,
+ 				  int chunkInNAND, int inScan)
+ {
+ 	/* NB inScan is zero unless scanning.
+ 	 * For forward scanning, inScan is > 0;
+ 	 * for backward scanning inScan is < 0
+ 	 *
+ 	 * chunkInNAND = 0 is a dummy insert to make sure the tnodes are there.
+ 	 */
+ 
+ 	yaffs_Tnode *tn;
+ 	yaffs_Device *dev = in->myDev;
+ 	int existingChunk;
+ 	yaffs_ExtendedTags existingTags;
+ 	yaffs_ExtendedTags newTags;
+ 	unsigned existingSerial, newSerial;
+ 
+ 	if (in->variantType != YAFFS_OBJECT_TYPE_FILE) {
+ 		/* Just ignore an attempt at putting a chunk into a non-file during scanning
+ 		 * If it is not during Scanning then something went wrong!
+ 		 */
+ 		if (!inScan) {
+ 			T(YAFFS_TRACE_ERROR,
+ 			  (TSTR
+ 			   ("yaffs tragedy:attempt to put data chunk into a non-file"
+ 			    TENDSTR)));
+ 			YBUG();
+ 		}
+ 
+ 		yaffs_DeleteChunk(dev, chunkInNAND, 1, __LINE__);
+ 		return YAFFS_OK;
+ 	}
+ 
+ 	tn = yaffs_AddOrFindLevel0Tnode(dev,
+ 					&in->variant.fileVariant,
+ 					chunkInInode,
+ 					NULL);
+ 	if (!tn)
+ 		return YAFFS_FAIL;
+ 	
+ 	if(!chunkInNAND)
+ 		/* Dummy insert, bail now */
+ 		return YAFFS_OK;
+ 
+ 	existingChunk = yaffs_GetChunkGroupBase(dev, tn, chunkInInode);
+ 
+ 	if (inScan != 0) {
+ 		/* If we're scanning then we need to test for duplicates
+ 		 * NB This does not need to be efficient since it should only ever
+ 		 * happen when the power fails during a write, then only one
+ 		 * chunk should ever be affected.
+ 		 *
+ 		 * Correction for YAFFS2: This could happen quite a lot and we need to think about efficiency! TODO
+ 		 * Update: For backward scanning we don't need to re-read tags so this is quite cheap.
+ 		 */
+ 
+ 		if (existingChunk > 0) {
+ 			/* NB Right now existing chunk will not be real chunkId if the device >= 32MB
+ 			 *    thus we have to do a FindChunkInFile to get the real chunk id.
+ 			 *
+ 			 * We have a duplicate now we need to decide which one to use:
+ 			 *
+ 			 * Backwards scanning YAFFS2: The old one is what we use, dump the new one.
+ 			 * Forward scanning YAFFS2: The new one is what we use, dump the old one.
+ 			 * YAFFS1: Get both sets of tags and compare serial numbers.
+ 			 */
+ 
+ 			if (inScan > 0) {
+ 				/* Only do this for forward scanning */
+ 				yaffs_ReadChunkWithTagsFromNAND(dev,
+ 								chunkInNAND,
+ 								NULL, &newTags);
+ 
+ 				/* Do a proper find */
+ 				existingChunk =
+ 				    yaffs_FindChunkInFile(in, chunkInInode,
+ 							  &existingTags);
+ 			}
+ 
+ 			if (existingChunk <= 0) {
+ 				/*Hoosterman - how did this happen? */
+ 
+ 				T(YAFFS_TRACE_ERROR,
+ 				  (TSTR
+ 				   ("yaffs tragedy: existing chunk < 0 in scan"
+ 				    TENDSTR)));
+ 
+ 			}
+ 
+ 			/* NB The deleted flags should be false, otherwise the chunks will
+ 			 * not be loaded during a scan
+ 			 */
+ 
+ 			if (inScan > 0) {
+ 				newSerial = newTags.serialNumber;
+ 				existingSerial = existingTags.serialNumber;
+ 			}
+ 
+ 			if ((inScan > 0) &&
+ 			    (in->myDev->param.isYaffs2 ||
+ 			     existingChunk <= 0 ||
+ 			     ((existingSerial + 1) & 3) == newSerial)) {
+ 				/* Forward scanning.
+ 				 * Use new
+ 				 * Delete the old one and drop through to update the tnode
+ 				 */
+ 				yaffs_DeleteChunk(dev, existingChunk, 1,
+ 						  __LINE__);
+ 			} else {
+ 				/* Backward scanning or we want to use the existing one
+ 				 * Use existing.
+ 				 * Delete the new one and return early so that the tnode isn't changed
+ 				 */
+ 				yaffs_DeleteChunk(dev, chunkInNAND, 1,
+ 						  __LINE__);
+ 				return YAFFS_OK;
+ 			}
+ 		}
+ 
+ 	}
+ 
+ 	if (existingChunk == 0)
+ 		in->nDataChunks++;
+ 
+ 	yaffs_LoadLevel0Tnode(dev, tn, chunkInInode, chunkInNAND);
+ 
+ 	return YAFFS_OK;
+ }
+ 
+ static int yaffs_ReadChunkDataFromObject(yaffs_Object *in, int chunkInInode,
+ 					__u8 *buffer)
+ {
+ 	int chunkInNAND = yaffs_FindChunkInFile(in, chunkInInode, NULL);
+ 
+ 	if (chunkInNAND >= 0)
+ 		return yaffs_ReadChunkWithTagsFromNAND(in->myDev, chunkInNAND,
+ 						buffer, NULL);
+ 	else {
+ 		T(YAFFS_TRACE_NANDACCESS,
+ 		  (TSTR("Chunk %d not found zero instead" TENDSTR),
+ 		   chunkInNAND));
+ 		/* get sane (zero) data if you read a hole */
+ 		memset(buffer, 0, in->myDev->nDataBytesPerChunk);
+ 		return 0;
+ 	}
+ 
+ }
+ 
+ void yaffs_DeleteChunk(yaffs_Device *dev, int chunkId, int markNAND, int lyn)
+ {
+ 	int block;
+ 	int page;
+ 	yaffs_ExtendedTags tags;
+ 	yaffs_BlockInfo *bi;
+ 
+ 	if (chunkId <= 0)
+ 		return;
+ 
+ 	dev->nDeletions++;
+ 	block = chunkId / dev->param.nChunksPerBlock;
+ 	page = chunkId % dev->param.nChunksPerBlock;
+ 
+ 
+ 	if (!yaffs_CheckChunkBit(dev, block, page))
+ 		T(YAFFS_TRACE_VERIFY,
+ 			(TSTR("Deleting invalid chunk %d"TENDSTR),
+ 			 chunkId));
+ 
+ 	bi = yaffs_GetBlockInfo(dev, block);
+ 	
+ 	yaffs_UpdateOldestDirtySequence(dev, block, bi);
+ 
+ 	T(YAFFS_TRACE_DELETION,
+ 	  (TSTR("line %d delete of chunk %d" TENDSTR), lyn, chunkId));
+ 
+ 	if (markNAND &&
+ 	    bi->blockState != YAFFS_BLOCK_STATE_COLLECTING && !dev->param.isYaffs2) {
+ 
+ 		yaffs_InitialiseTags(&tags);
+ 
+ 		tags.chunkDeleted = 1;
+ 
+ 		yaffs_WriteChunkWithTagsToNAND(dev, chunkId, NULL, &tags);
+ 		yaffs_HandleUpdateChunk(dev, chunkId, &tags);
+ 	} else {
+ 		dev->nUnmarkedDeletions++;
+ 	}
+ 
+ 	/* Pull out of the management area.
+ 	 * If the whole block became dirty, this will kick off an erasure.
+ 	 */
+ 	if (bi->blockState == YAFFS_BLOCK_STATE_ALLOCATING ||
+ 	    bi->blockState == YAFFS_BLOCK_STATE_FULL ||
+ 	    bi->blockState == YAFFS_BLOCK_STATE_NEEDS_SCANNING ||
+ 	    bi->blockState == YAFFS_BLOCK_STATE_COLLECTING) {
+ 		dev->nFreeChunks++;
+ 
+ 		yaffs_ClearChunkBit(dev, block, page);
+ 
+ 		bi->pagesInUse--;
+ 
+ 		if (bi->pagesInUse == 0 &&
+ 		    !bi->hasShrinkHeader &&
+ 		    bi->blockState != YAFFS_BLOCK_STATE_ALLOCATING &&
+ 		    bi->blockState != YAFFS_BLOCK_STATE_NEEDS_SCANNING) {
+ 			yaffs_BlockBecameDirty(dev, block);
+ 		}
+ 
+ 	}
+ 
+ }
+ 
+ static int yaffs_WriteChunkDataToObject(yaffs_Object *in, int chunkInInode,
+ 					const __u8 *buffer, int nBytes,
+ 					int useReserve)
+ {
+ 	/* Find old chunk Need to do this to get serial number
+ 	 * Write new one and patch into tree.
+ 	 * Invalidate old tags.
+ 	 */
+ 
+ 	int prevChunkId;
+ 	yaffs_ExtendedTags prevTags;
+ 
+ 	int newChunkId;
+ 	yaffs_ExtendedTags newTags;
+ 
+ 	yaffs_Device *dev = in->myDev;
+ 
+ 	yaffs_CheckGarbageCollection(dev,0);
+ 
+ 	/* Get the previous chunk at this location in the file if it exists.
+ 	 * If it does not exist then put a zero into the tree. This creates
+ 	 * the tnode now, rather than later when it is harder to clean up.
+ 	 */
+ 	prevChunkId = yaffs_FindChunkInFile(in, chunkInInode, &prevTags);
+ 	if(prevChunkId < 1 &&
+ 		!yaffs_PutChunkIntoFile(in, chunkInInode, 0, 0))
+ 		return 0;
+ 
+ 	/* Set up new tags */
+ 	yaffs_InitialiseTags(&newTags);
+ 
+ 	newTags.chunkId = chunkInInode;
+ 	newTags.objectId = in->objectId;
+ 	newTags.serialNumber =
+ 	    (prevChunkId > 0) ? prevTags.serialNumber + 1 : 1;
+ 	newTags.byteCount = nBytes;
+ 
+ 	if (nBytes < 1 || nBytes > dev->param.totalBytesPerChunk) {
+ 		T(YAFFS_TRACE_ERROR,
+ 		(TSTR("Writing %d bytes to chunk!!!!!!!!!" TENDSTR), nBytes));
+ 		YBUG();
+ 	}
+ 	
+ 		
+ 	newChunkId =
+ 	    yaffs_WriteNewChunkWithTagsToNAND(dev, buffer, &newTags,
+ 					      useReserve);
+ 
+ 	if (newChunkId > 0) {
+ 		yaffs_PutChunkIntoFile(in, chunkInInode, newChunkId, 0);
+ 
+ 		if (prevChunkId > 0)
+ 			yaffs_DeleteChunk(dev, prevChunkId, 1, __LINE__);
+ 
+ 		yaffs_CheckFileSanity(in);
+ 	}
+ 	return newChunkId;
+ 
+ }
+ 
+ /* UpdateObjectHeader updates the header on NAND for an object.
+  * If name is not NULL, then that new name is used.
+  */
+ int yaffs_UpdateObjectHeader(yaffs_Object *in, const YCHAR *name, int force,
+ 			     int isShrink, int shadows)
+ {
+ 
+ 	yaffs_BlockInfo *bi;
+ 
+ 	yaffs_Device *dev = in->myDev;
+ 
+ 	int prevChunkId;
+ 	int retVal = 0;
+ 	int result = 0;
+ 
+ 	int newChunkId;
+ 	yaffs_ExtendedTags newTags;
+ 	yaffs_ExtendedTags oldTags;
+ 	YCHAR *alias = NULL;
+ 
+ 	__u8 *buffer = NULL;
+ 	YCHAR oldName[YAFFS_MAX_NAME_LENGTH + 1];
+ 
+ 	yaffs_ObjectHeader *oh = NULL;
+ 
+ 	yaffs_strcpy(oldName, _Y("silly old name"));
+ 
+ 
+ 	if (!in->fake ||
+ 		in == dev->rootDir || /* The rootDir should also be saved */
+ 		force) {
+ 
+ 		yaffs_CheckGarbageCollection(dev,0);
+ 		yaffs_CheckObjectDetailsLoaded(in);
+ 
+ 		buffer = yaffs_GetTempBuffer(in->myDev, __LINE__);
+ 		oh = (yaffs_ObjectHeader *) buffer;
+ 
+ 		prevChunkId = in->hdrChunk;
+ 
+ 		if (prevChunkId > 0) {
+ 			result = yaffs_ReadChunkWithTagsFromNAND(dev, prevChunkId,
+ 							buffer, &oldTags);
+ 
+ 			yaffs_VerifyObjectHeader(in, oh, &oldTags, 0);
+ 
+ 			memcpy(oldName, oh->name, sizeof(oh->name));
+ 		}
+ 
+ 		memset(buffer, 0xFF, dev->nDataBytesPerChunk);
+ 
+ 		oh->type = in->variantType;
+ 		oh->yst_mode = in->yst_mode;
+ 		oh->shadowsObject = oh->inbandShadowsObject = shadows;
+ 
+ #ifdef CONFIG_YAFFS_WINCE
+ 		oh->win_atime[0] = in->win_atime[0];
+ 		oh->win_ctime[0] = in->win_ctime[0];
+ 		oh->win_mtime[0] = in->win_mtime[0];
+ 		oh->win_atime[1] = in->win_atime[1];
+ 		oh->win_ctime[1] = in->win_ctime[1];
+ 		oh->win_mtime[1] = in->win_mtime[1];
+ #else
+ 		oh->yst_uid = in->yst_uid;
+ 		oh->yst_gid = in->yst_gid;
+ 		oh->yst_atime = in->yst_atime;
+ 		oh->yst_mtime = in->yst_mtime;
+ 		oh->yst_ctime = in->yst_ctime;
+ 		oh->yst_rdev = in->yst_rdev;
+ #endif
+ 		if (in->parent)
+ 			oh->parentObjectId = in->parent->objectId;
+ 		else
+ 			oh->parentObjectId = 0;
+ 
+ 		if (name && *name) {
+ 			memset(oh->name, 0, sizeof(oh->name));
+ 			yaffs_strncpy(oh->name, name, YAFFS_MAX_NAME_LENGTH);
+ 		} else if (prevChunkId > 0)
+ 			memcpy(oh->name, oldName, sizeof(oh->name));
+ 		else
+ 			memset(oh->name, 0, sizeof(oh->name));
+ 
+ 		oh->isShrink = isShrink;
+ 
+ 		switch (in->variantType) {
+ 		case YAFFS_OBJECT_TYPE_UNKNOWN:
+ 			/* Should not happen */
+ 			break;
+ 		case YAFFS_OBJECT_TYPE_FILE:
+ 			oh->fileSize =
+ 			    (oh->parentObjectId == YAFFS_OBJECTID_DELETED
+ 			     || oh->parentObjectId ==
+ 			     YAFFS_OBJECTID_UNLINKED) ? 0 : in->variant.
+ 			    fileVariant.fileSize;
+ 			break;
+ 		case YAFFS_OBJECT_TYPE_HARDLINK:
+ 			oh->equivalentObjectId =
+ 			    in->variant.hardLinkVariant.equivalentObjectId;
+ 			break;
+ 		case YAFFS_OBJECT_TYPE_SPECIAL:
+ 			/* Do nothing */
+ 			break;
+ 		case YAFFS_OBJECT_TYPE_DIRECTORY:
+ 			/* Do nothing */
+ 			break;
+ 		case YAFFS_OBJECT_TYPE_SYMLINK:
+ 			alias = in->variant.symLinkVariant.alias;
+ 			if(!alias)
+ 				alias = _Y("no alias");
+ 			yaffs_strncpy(oh->alias,
+ 					alias,
+ 				      YAFFS_MAX_ALIAS_LENGTH);
+ 			oh->alias[YAFFS_MAX_ALIAS_LENGTH] = 0;
+ 			break;
+ 		}
+ 
+ 		/* Tags */
+ 		yaffs_InitialiseTags(&newTags);
+ 		in->serial++;
+ 		newTags.chunkId = 0;
+ 		newTags.objectId = in->objectId;
+ 		newTags.serialNumber = in->serial;
+ 
+ 		/* Add extra info for file header */
+ 
+ 		newTags.extraHeaderInfoAvailable = 1;
+ 		newTags.extraParentObjectId = oh->parentObjectId;
+ 		newTags.extraFileLength = oh->fileSize;
+ 		newTags.extraIsShrinkHeader = oh->isShrink;
+ 		newTags.extraEquivalentObjectId = oh->equivalentObjectId;
+ 		newTags.extraShadows = (oh->shadowsObject > 0) ? 1 : 0;
+ 		newTags.extraObjectType = in->variantType;
+ 
+ 		yaffs_VerifyObjectHeader(in, oh, &newTags, 1);
+ 
+ 		/* Create new chunk in NAND */
+ 		newChunkId =
+ 		    yaffs_WriteNewChunkWithTagsToNAND(dev, buffer, &newTags,
+ 						      (prevChunkId > 0) ? 1 : 0);
+ 
+ 		if (newChunkId >= 0) {
+ 
+ 			in->hdrChunk = newChunkId;
+ 
+ 			if (prevChunkId > 0) {
+ 				yaffs_DeleteChunk(dev, prevChunkId, 1,
+ 						  __LINE__);
+ 			}
+ 
+ 			if (!yaffs_ObjectHasCachedWriteData(in))
+ 				in->dirty = 0;
+ 
+ 			/* If this was a shrink, then mark the block that the chunk lives on */
+ 			if (isShrink) {
+ 				bi = yaffs_GetBlockInfo(in->myDev,
+ 					newChunkId / in->myDev->param.nChunksPerBlock);
+ 				bi->hasShrinkHeader = 1;
+ 			}
+ 
+ 		}
+ 
+ 		retVal = newChunkId;
+ 
+ 	}
+ 
+ 	if (buffer)
+ 		yaffs_ReleaseTempBuffer(dev, buffer, __LINE__);
+ 
+ 	return retVal;
+ }
+ 
+ /*------------------------ Short Operations Cache ----------------------------------------
+  *   In many situations where there is no high level buffering (eg WinCE) a lot of
+  *   reads might be short sequential reads, and a lot of writes may be short
+  *   sequential writes. eg. scanning/writing a jpeg file.
+  *   In these cases, a short read/write cache can provide a huge perfomance benefit
+  *   with dumb-as-a-rock code.
+  *   In Linux, the page cache provides read buffering aand the short op cache provides write
+  *   buffering.
+  *
+  *   There are a limited number (~10) of cache chunks per device so that we don't
+  *   need a very intelligent search.
+  */
+ 
+ static int yaffs_ObjectHasCachedWriteData(yaffs_Object *obj)
+ {
+ 	yaffs_Device *dev = obj->myDev;
+ 	int i;
+ 	yaffs_ChunkCache *cache;
+ 	int nCaches = obj->myDev->param.nShortOpCaches;
+ 
+ 	for (i = 0; i < nCaches; i++) {
+ 		cache = &dev->srCache[i];
+ 		if (cache->object == obj &&
+ 		    cache->dirty)
+ 			return 1;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ 
+ static void yaffs_FlushFilesChunkCache(yaffs_Object *obj)
+ {
+ 	yaffs_Device *dev = obj->myDev;
+ 	int lowest = -99;	/* Stop compiler whining. */
+ 	int i;
+ 	yaffs_ChunkCache *cache;
+ 	int chunkWritten = 0;
+ 	int nCaches = obj->myDev->param.nShortOpCaches;
+ 
+ 	if (nCaches > 0) {
+ 		do {
+ 			cache = NULL;
+ 
+ 			/* Find the dirty cache for this object with the lowest chunk id. */
+ 			for (i = 0; i < nCaches; i++) {
+ 				if (dev->srCache[i].object == obj &&
+ 				    dev->srCache[i].dirty) {
+ 					if (!cache
+ 					    || dev->srCache[i].chunkId <
+ 					    lowest) {
+ 						cache = &dev->srCache[i];
+ 						lowest = cache->chunkId;
+ 					}
+ 				}
+ 			}
+ 
+ 			if (cache && !cache->locked) {
+ 				/* Write it out and free it up */
+ 
+ 				chunkWritten =
+ 				    yaffs_WriteChunkDataToObject(cache->object,
+ 								 cache->chunkId,
+ 								 cache->data,
+ 								 cache->nBytes,
+ 								 1);
+ 				cache->dirty = 0;
+ 				cache->object = NULL;
+ 			}
+ 
+ 		} while (cache && chunkWritten > 0);
+ 
+ 		if (cache) {
+ 			/* Hoosterman, disk full while writing cache out. */
+ 			T(YAFFS_TRACE_ERROR,
+ 			  (TSTR("yaffs tragedy: no space during cache write" TENDSTR)));
+ 
+ 		}
+ 	}
+ 
+ }
+ 
+ /*yaffs_FlushEntireDeviceCache(dev)
+  *
+  *
+  */
+ 
+ void yaffs_FlushEntireDeviceCache(yaffs_Device *dev)
+ {
+ 	yaffs_Object *obj;
+ 	int nCaches = dev->param.nShortOpCaches;
+ 	int i;
+ 
+ 	/* Find a dirty object in the cache and flush it...
+ 	 * until there are no further dirty objects.
+ 	 */
+ 	do {
+ 		obj = NULL;
+ 		for (i = 0; i < nCaches && !obj; i++) {
+ 			if (dev->srCache[i].object &&
+ 			    dev->srCache[i].dirty)
+ 				obj = dev->srCache[i].object;
+ 
+ 		}
+ 		if (obj)
+ 			yaffs_FlushFilesChunkCache(obj);
+ 
+ 	} while (obj);
+ 
+ }
+ 
+ 
+ /* Grab us a cache chunk for use.
+  * First look for an empty one.
+  * Then look for the least recently used non-dirty one.
+  * Then look for the least recently used dirty one...., flush and look again.
+  */
+ static yaffs_ChunkCache *yaffs_GrabChunkCacheWorker(yaffs_Device *dev)
+ {
+ 	int i;
+ 
+ 	if (dev->param.nShortOpCaches > 0) {
+ 		for (i = 0; i < dev->param.nShortOpCaches; i++) {
+ 			if (!dev->srCache[i].object)
+ 				return &dev->srCache[i];
+ 		}
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ static yaffs_ChunkCache *yaffs_GrabChunkCache(yaffs_Device *dev)
+ {
+ 	yaffs_ChunkCache *cache;
+ 	yaffs_Object *theObj;
+ 	int usage;
+ 	int i;
+ 	int pushout;
+ 
+ 	if (dev->param.nShortOpCaches > 0) {
+ 		/* Try find a non-dirty one... */
+ 
+ 		cache = yaffs_GrabChunkCacheWorker(dev);
+ 
+ 		if (!cache) {
+ 			/* They were all dirty, find the last recently used object and flush
+ 			 * its cache, then  find again.
+ 			 * NB what's here is not very accurate, we actually flush the object
+ 			 * the last recently used page.
+ 			 */
+ 
+ 			/* With locking we can't assume we can use entry zero */
+ 
+ 			theObj = NULL;
+ 			usage = -1;
+ 			cache = NULL;
+ 			pushout = -1;
+ 
+ 			for (i = 0; i < dev->param.nShortOpCaches; i++) {
+ 				if (dev->srCache[i].object &&
+ 				    !dev->srCache[i].locked &&
+ 				    (dev->srCache[i].lastUse < usage || !cache)) {
+ 					usage = dev->srCache[i].lastUse;
+ 					theObj = dev->srCache[i].object;
+ 					cache = &dev->srCache[i];
+ 					pushout = i;
+ 				}
+ 			}
+ 
+ 			if (!cache || cache->dirty) {
+ 				/* Flush and try again */
+ 				yaffs_FlushFilesChunkCache(theObj);
+ 				cache = yaffs_GrabChunkCacheWorker(dev);
+ 			}
+ 
+ 		}
+ 		return cache;
+ 	} else
+ 		return NULL;
+ 
+ }
+ 
+ /* Find a cached chunk */
+ static yaffs_ChunkCache *yaffs_FindChunkCache(const yaffs_Object *obj,
+ 					      int chunkId)
+ {
+ 	yaffs_Device *dev = obj->myDev;
+ 	int i;
+ 	if (dev->param.nShortOpCaches > 0) {
+ 		for (i = 0; i < dev->param.nShortOpCaches; i++) {
+ 			if (dev->srCache[i].object == obj &&
+ 			    dev->srCache[i].chunkId == chunkId) {
+ 				dev->cacheHits++;
+ 
+ 				return &dev->srCache[i];
+ 			}
+ 		}
+ 	}
+ 	return NULL;
+ }
+ 
+ /* Mark the chunk for the least recently used algorithym */
+ static void yaffs_UseChunkCache(yaffs_Device *dev, yaffs_ChunkCache *cache,
+ 				int isAWrite)
+ {
+ 
+ 	if (dev->param.nShortOpCaches > 0) {
+ 		if (dev->srLastUse < 0 || dev->srLastUse > 100000000) {
+ 			/* Reset the cache usages */
+ 			int i;
+ 			for (i = 1; i < dev->param.nShortOpCaches; i++)
+ 				dev->srCache[i].lastUse = 0;
+ 
+ 			dev->srLastUse = 0;
+ 		}
+ 
+ 		dev->srLastUse++;
+ 
+ 		cache->lastUse = dev->srLastUse;
+ 
+ 		if (isAWrite)
+ 			cache->dirty = 1;
+ 	}
+ }
+ 
+ /* Invalidate a single cache page.
+  * Do this when a whole page gets written,
+  * ie the short cache for this page is no longer valid.
+  */
+ static void yaffs_InvalidateChunkCache(yaffs_Object *object, int chunkId)
+ {
+ 	if (object->myDev->param.nShortOpCaches > 0) {
+ 		yaffs_ChunkCache *cache = yaffs_FindChunkCache(object, chunkId);
+ 
+ 		if (cache)
+ 			cache->object = NULL;
+ 	}
+ }
+ 
+ /* Invalidate all the cache pages associated with this object
+  * Do this whenever ther file is deleted or resized.
+  */
+ static void yaffs_InvalidateWholeChunkCache(yaffs_Object *in)
+ {
+ 	int i;
+ 	yaffs_Device *dev = in->myDev;
+ 
+ 	if (dev->param.nShortOpCaches > 0) {
+ 		/* Invalidate it. */
+ 		for (i = 0; i < dev->param.nShortOpCaches; i++) {
+ 			if (dev->srCache[i].object == in)
+ 				dev->srCache[i].object = NULL;
+ 		}
+ 	}
+ }
+ 
+ /*--------------------- Checkpointing --------------------*/
+ 
+ 
+ static int yaffs_WriteCheckpointValidityMarker(yaffs_Device *dev, int head)
+ {
+ 	yaffs_CheckpointValidity cp;
+ 
+ 	memset(&cp, 0, sizeof(cp));
+ 
+ 	cp.structType = sizeof(cp);
+ 	cp.magic = YAFFS_MAGIC;
+ 	cp.version = YAFFS_CHECKPOINT_VERSION;
+ 	cp.head = (head) ? 1 : 0;
+ 
+ 	return (yaffs_CheckpointWrite(dev, &cp, sizeof(cp)) == sizeof(cp)) ?
+ 		1 : 0;
+ }
+ 
+ static int yaffs_ReadCheckpointValidityMarker(yaffs_Device *dev, int head)
+ {
+ 	yaffs_CheckpointValidity cp;
+ 	int ok;
+ 
+ 	ok = (yaffs_CheckpointRead(dev, &cp, sizeof(cp)) == sizeof(cp));
+ 
+ 	if (ok)
+ 		ok = (cp.structType == sizeof(cp)) &&
+ 		     (cp.magic == YAFFS_MAGIC) &&
+ 		     (cp.version == YAFFS_CHECKPOINT_VERSION) &&
+ 		     (cp.head == ((head) ? 1 : 0));
+ 	return ok ? 1 : 0;
+ }
+ 
+ static void yaffs_DeviceToCheckpointDevice(yaffs_CheckpointDevice *cp,
+ 					   yaffs_Device *dev)
+ {
+ 	cp->nErasedBlocks = dev->nErasedBlocks;
+ 	cp->allocationBlock = dev->allocationBlock;
+ 	cp->allocationPage = dev->allocationPage;
+ 	cp->nFreeChunks = dev->nFreeChunks;
+ 
+ 	cp->nDeletedFiles = dev->nDeletedFiles;
+ 	cp->nUnlinkedFiles = dev->nUnlinkedFiles;
+ 	cp->nBackgroundDeletions = dev->nBackgroundDeletions;
+ 	cp->sequenceNumber = dev->sequenceNumber;
+ 
+ }
+ 
+ static void yaffs_CheckpointDeviceToDevice(yaffs_Device *dev,
+ 					   yaffs_CheckpointDevice *cp)
+ {
+ 	dev->nErasedBlocks = cp->nErasedBlocks;
+ 	dev->allocationBlock = cp->allocationBlock;
+ 	dev->allocationPage = cp->allocationPage;
+ 	dev->nFreeChunks = cp->nFreeChunks;
+ 
+ 	dev->nDeletedFiles = cp->nDeletedFiles;
+ 	dev->nUnlinkedFiles = cp->nUnlinkedFiles;
+ 	dev->nBackgroundDeletions = cp->nBackgroundDeletions;
+ 	dev->sequenceNumber = cp->sequenceNumber;
+ }
+ 
+ 
+ static int yaffs_WriteCheckpointDevice(yaffs_Device *dev)
+ {
+ 	yaffs_CheckpointDevice cp;
+ 	__u32 nBytes;
+ 	__u32 nBlocks = (dev->internalEndBlock - dev->internalStartBlock + 1);
+ 
+ 	int ok;
+ 
+ 	/* Write device runtime values*/
+ 	yaffs_DeviceToCheckpointDevice(&cp, dev);
+ 	cp.structType = sizeof(cp);
+ 
+ 	ok = (yaffs_CheckpointWrite(dev, &cp, sizeof(cp)) == sizeof(cp));
+ 
+ 	/* Write block info */
+ 	if (ok) {
+ 		nBytes = nBlocks * sizeof(yaffs_BlockInfo);
+ 		ok = (yaffs_CheckpointWrite(dev, dev->blockInfo, nBytes) == nBytes);
+ 	}
+ 
+ 	/* Write chunk bits */
+ 	if (ok) {
+ 		nBytes = nBlocks * dev->chunkBitmapStride;
+ 		ok = (yaffs_CheckpointWrite(dev, dev->chunkBits, nBytes) == nBytes);
+ 	}
+ 	return	 ok ? 1 : 0;
+ 
+ }
+ 
+ static int yaffs_ReadCheckpointDevice(yaffs_Device *dev)
+ {
+ 	yaffs_CheckpointDevice cp;
+ 	__u32 nBytes;
+ 	__u32 nBlocks = (dev->internalEndBlock - dev->internalStartBlock + 1);
+ 
+ 	int ok;
+ 
+ 	ok = (yaffs_CheckpointRead(dev, &cp, sizeof(cp)) == sizeof(cp));
+ 	if (!ok)
+ 		return 0;
+ 
+ 	if (cp.structType != sizeof(cp))
+ 		return 0;
+ 
+ 
+ 	yaffs_CheckpointDeviceToDevice(dev, &cp);
+ 
+ 	nBytes = nBlocks * sizeof(yaffs_BlockInfo);
+ 
+ 	ok = (yaffs_CheckpointRead(dev, dev->blockInfo, nBytes) == nBytes);
+ 
+ 	if (!ok)
+ 		return 0;
+ 	nBytes = nBlocks * dev->chunkBitmapStride;
+ 
+ 	ok = (yaffs_CheckpointRead(dev, dev->chunkBits, nBytes) == nBytes);
+ 
+ 	return ok ? 1 : 0;
+ }
+ 
+ static void yaffs_ObjectToCheckpointObject(yaffs_CheckpointObject *cp,
+ 					   yaffs_Object *obj)
+ {
+ 
+ 	cp->objectId = obj->objectId;
+ 	cp->parentId = (obj->parent) ? obj->parent->objectId : 0;
+ 	cp->hdrChunk = obj->hdrChunk;
+ 	cp->variantType = obj->variantType;
+ 	cp->deleted = obj->deleted;
+ 	cp->softDeleted = obj->softDeleted;
+ 	cp->unlinked = obj->unlinked;
+ 	cp->fake = obj->fake;
+ 	cp->renameAllowed = obj->renameAllowed;
+ 	cp->unlinkAllowed = obj->unlinkAllowed;
+ 	cp->serial = obj->serial;
+ 	cp->nDataChunks = obj->nDataChunks;
+ 
+ 	if (obj->variantType == YAFFS_OBJECT_TYPE_FILE)
+ 		cp->fileSizeOrEquivalentObjectId = obj->variant.fileVariant.fileSize;
+ 	else if (obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK)
+ 		cp->fileSizeOrEquivalentObjectId = obj->variant.hardLinkVariant.equivalentObjectId;
+ }
+ 
+ static int yaffs_CheckpointObjectToObject(yaffs_Object *obj, yaffs_CheckpointObject *cp)
+ {
+ 
+ 	yaffs_Object *parent;
+ 
+ 	if (obj->variantType != cp->variantType) {
+ 		T(YAFFS_TRACE_ERROR, (TSTR("Checkpoint read object %d type %d "
+ 			TCONT("chunk %d does not match existing object type %d")
+ 			TENDSTR), cp->objectId, cp->variantType, cp->hdrChunk,
+ 			obj->variantType));
+ 		return 0;
+ 	}
+ 
+ 	obj->objectId = cp->objectId;
+ 
+ 	if (cp->parentId)
+ 		parent = yaffs_FindOrCreateObjectByNumber(
+ 					obj->myDev,
+ 					cp->parentId,
+ 					YAFFS_OBJECT_TYPE_DIRECTORY);
+ 	else
+ 		parent = NULL;
+ 
+ 	if (parent) {
+ 		if (parent->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
+ 			T(YAFFS_TRACE_ALWAYS, (TSTR("Checkpoint read object %d parent %d type %d"
+ 				TCONT(" chunk %d Parent type, %d, not directory")
+ 				TENDSTR),
+ 				cp->objectId, cp->parentId, cp->variantType,
+ 				cp->hdrChunk, parent->variantType));
+ 			return 0;
+ 		}
+ 		yaffs_AddObjectToDirectory(parent, obj);
+ 	}
+ 
+ 	obj->hdrChunk = cp->hdrChunk;
+ 	obj->variantType = cp->variantType;
+ 	obj->deleted = cp->deleted;
+ 	obj->softDeleted = cp->softDeleted;
+ 	obj->unlinked = cp->unlinked;
+ 	obj->fake = cp->fake;
+ 	obj->renameAllowed = cp->renameAllowed;
+ 	obj->unlinkAllowed = cp->unlinkAllowed;
+ 	obj->serial = cp->serial;
+ 	obj->nDataChunks = cp->nDataChunks;
+ 
+ 	if (obj->variantType == YAFFS_OBJECT_TYPE_FILE)
+ 		obj->variant.fileVariant.fileSize = cp->fileSizeOrEquivalentObjectId;
+ 	else if (obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK)
+ 		obj->variant.hardLinkVariant.equivalentObjectId = cp->fileSizeOrEquivalentObjectId;
+ 
+ 	if (obj->hdrChunk > 0)
+ 		obj->lazyLoaded = 1;
+ 	return 1;
+ }
+ 
+ 
+ 
+ static int yaffs_CheckpointTnodeWorker(yaffs_Object *in, yaffs_Tnode *tn,
+ 					__u32 level, int chunkOffset)
+ {
+ 	int i;
+ 	yaffs_Device *dev = in->myDev;
+ 	int ok = 1;
+ 	int tnodeSize = yaffs_CalcTnodeSize(dev);
+ 
+ 	if (tn) {
+ 		if (level > 0) {
+ 
+ 			for (i = 0; i < YAFFS_NTNODES_INTERNAL && ok; i++) {
+ 				if (tn->internal[i]) {
+ 					ok = yaffs_CheckpointTnodeWorker(in,
+ 							tn->internal[i],
+ 							level - 1,
+ 							(chunkOffset<<YAFFS_TNODES_INTERNAL_BITS) + i);
+ 				}
+ 			}
+ 		} else if (level == 0) {
+ 			__u32 baseOffset = chunkOffset <<  YAFFS_TNODES_LEVEL0_BITS;
+ 			ok = (yaffs_CheckpointWrite(dev, &baseOffset, sizeof(baseOffset)) == sizeof(baseOffset));
+ 			if (ok)
+ 				ok = (yaffs_CheckpointWrite(dev, tn, tnodeSize) == tnodeSize);
+ 		}
+ 	}
+ 
+ 	return ok;
+ 
+ }
+ 
+ static int yaffs_WriteCheckpointTnodes(yaffs_Object *obj)
+ {
+ 	__u32 endMarker = ~0;
+ 	int ok = 1;
+ 
+ 	if (obj->variantType == YAFFS_OBJECT_TYPE_FILE) {
+ 		ok = yaffs_CheckpointTnodeWorker(obj,
+ 					    obj->variant.fileVariant.top,
+ 					    obj->variant.fileVariant.topLevel,
+ 					    0);
+ 		if (ok)
+ 			ok = (yaffs_CheckpointWrite(obj->myDev, &endMarker, sizeof(endMarker)) ==
+ 				sizeof(endMarker));
+ 	}
+ 
+ 	return ok ? 1 : 0;
+ }
+ 
+ static int yaffs_ReadCheckpointTnodes(yaffs_Object *obj)
+ {
+ 	__u32 baseChunk;
+ 	int ok = 1;
+ 	yaffs_Device *dev = obj->myDev;
+ 	yaffs_FileStructure *fileStructPtr = &obj->variant.fileVariant;
+ 	yaffs_Tnode *tn;
+ 	int nread = 0;
+ 	int tnodeSize = yaffs_CalcTnodeSize(dev);
+ 
+ 	ok = (yaffs_CheckpointRead(dev, &baseChunk, sizeof(baseChunk)) == sizeof(baseChunk));
+ 
+ 	while (ok && (~baseChunk)) {
+ 		nread++;
+ 		/* Read level 0 tnode */
+ 
+ 
+ 		tn = yaffs_GetTnodeRaw(dev);
+ 		if (tn)
+ 			ok = (yaffs_CheckpointRead(dev, tn, tnodeSize) == tnodeSize);
+ 		else
+ 			ok = 0;
+ 
+ 		if (tn && ok)
+ 			ok = yaffs_AddOrFindLevel0Tnode(dev,
+ 							fileStructPtr,
+ 							baseChunk,
+ 							tn) ? 1 : 0;
+ 
+ 		if (ok)
+ 			ok = (yaffs_CheckpointRead(dev, &baseChunk, sizeof(baseChunk)) == sizeof(baseChunk));
+ 
+ 	}
+ 
+ 	T(YAFFS_TRACE_CHECKPOINT, (
+ 		TSTR("Checkpoint read tnodes %d records, last %d. ok %d" TENDSTR),
+ 		nread, baseChunk, ok));
+ 
+ 	return ok ? 1 : 0;
+ }
+ 
+ 
+ static int yaffs_WriteCheckpointObjects(yaffs_Device *dev)
+ {
+ 	yaffs_Object *obj;
+ 	yaffs_CheckpointObject cp;
+ 	int i;
+ 	int ok = 1;
+ 	struct ylist_head *lh;
+ 
+ 
+ 	/* Iterate through the objects in each hash entry,
+ 	 * dumping them to the checkpointing stream.
+ 	 */
+ 
+ 	for (i = 0; ok &&  i <  YAFFS_NOBJECT_BUCKETS; i++) {
+ 		ylist_for_each(lh, &dev->objectBucket[i].list) {
+ 			if (lh) {
+ 				obj = ylist_entry(lh, yaffs_Object, hashLink);
+ 				if (!obj->deferedFree) {
+ 					yaffs_ObjectToCheckpointObject(&cp, obj);
+ 					cp.structType = sizeof(cp);
+ 
+ 					T(YAFFS_TRACE_CHECKPOINT, (
+ 						TSTR("Checkpoint write object %d parent %d type %d chunk %d obj addr %p" TENDSTR),
+ 						cp.objectId, cp.parentId, cp.variantType, cp.hdrChunk, obj));
+ 
+ 					ok = (yaffs_CheckpointWrite(dev, &cp, sizeof(cp)) == sizeof(cp));
+ 
+ 					if (ok && obj->variantType == YAFFS_OBJECT_TYPE_FILE)
+ 						ok = yaffs_WriteCheckpointTnodes(obj);
+ 				}
+ 			}
+ 		}
+ 	}
+ 
+ 	/* Dump end of list */
+ 	memset(&cp, 0xFF, sizeof(yaffs_CheckpointObject));
+ 	cp.structType = sizeof(cp);
+ 
+ 	if (ok)
+ 		ok = (yaffs_CheckpointWrite(dev, &cp, sizeof(cp)) == sizeof(cp));
+ 
+ 	return ok ? 1 : 0;
+ }
+ 
+ static int yaffs_ReadCheckpointObjects(yaffs_Device *dev)
+ {
+ 	yaffs_Object *obj;
+ 	yaffs_CheckpointObject cp;
+ 	int ok = 1;
+ 	int done = 0;
+ 	yaffs_Object *hardList = NULL;
+ 
+ 	while (ok && !done) {
+ 		ok = (yaffs_CheckpointRead(dev, &cp, sizeof(cp)) == sizeof(cp));
+ 		if (cp.structType != sizeof(cp)) {
+ 			T(YAFFS_TRACE_CHECKPOINT, (TSTR("struct size %d instead of %d ok %d"TENDSTR),
+ 				cp.structType, (int)sizeof(cp), ok));
+ 			ok = 0;
+ 		}
+ 
+ 		T(YAFFS_TRACE_CHECKPOINT, (TSTR("Checkpoint read object %d parent %d type %d chunk %d " TENDSTR),
+ 			cp.objectId, cp.parentId, cp.variantType, cp.hdrChunk));
+ 
+ 		if (ok && cp.objectId == ~0)
+ 			done = 1;
+ 		else if (ok) {
+ 			obj = yaffs_FindOrCreateObjectByNumber(dev, cp.objectId, cp.variantType);
+ 			if (obj) {
+ 				ok = yaffs_CheckpointObjectToObject(obj, &cp);
+ 				if (!ok)
+ 					break;
+ 				if (obj->variantType == YAFFS_OBJECT_TYPE_FILE) {
+ 					ok = yaffs_ReadCheckpointTnodes(obj);
+ 				} else if (obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK) {
+ 					obj->hardLinks.next =
+ 						(struct ylist_head *) hardList;
+ 					hardList = obj;
+ 				}
+ 			} else
+ 				ok = 0;
+ 		}
+ 	}
+ 
+ 	if (ok)
+ 		yaffs_HardlinkFixup(dev, hardList);
+ 
+ 	return ok ? 1 : 0;
+ }
+ 
+ static int yaffs_WriteCheckpointSum(yaffs_Device *dev)
+ {
+ 	__u32 checkpointSum;
+ 	int ok;
+ 
+ 	yaffs_GetCheckpointSum(dev, &checkpointSum);
+ 
+ 	ok = (yaffs_CheckpointWrite(dev, &checkpointSum, sizeof(checkpointSum)) == sizeof(checkpointSum));
+ 
+ 	if (!ok)
+ 		return 0;
+ 
+ 	return 1;
+ }
+ 
+ static int yaffs_ReadCheckpointSum(yaffs_Device *dev)
+ {
+ 	__u32 checkpointSum0;
+ 	__u32 checkpointSum1;
+ 	int ok;
+ 
+ 	yaffs_GetCheckpointSum(dev, &checkpointSum0);
+ 
+ 	ok = (yaffs_CheckpointRead(dev, &checkpointSum1, sizeof(checkpointSum1)) == sizeof(checkpointSum1));
+ 
+ 	if (!ok)
+ 		return 0;
+ 
+ 	if (checkpointSum0 != checkpointSum1)
+ 		return 0;
+ 
+ 	return 1;
+ }
+ 
+ 
+ static int yaffs_WriteCheckpointData(yaffs_Device *dev)
+ {
+ 	int ok = 1;
+ 
+ 	if (!yaffs_CheckpointRequired(dev)) {
+ 		T(YAFFS_TRACE_CHECKPOINT, (TSTR("skipping checkpoint write" TENDSTR)));
+ 		ok = 0;
+ 	}
+ 
+ 	if (ok)
+ 		ok = yaffs_CheckpointOpen(dev, 1);
+ 
+ 	if (ok) {
+ 		T(YAFFS_TRACE_CHECKPOINT, (TSTR("write checkpoint validity" TENDSTR)));
+ 		ok = yaffs_WriteCheckpointValidityMarker(dev, 1);
+ 	}
+ 	if (ok) {
+ 		T(YAFFS_TRACE_CHECKPOINT, (TSTR("write checkpoint device" TENDSTR)));
+ 		ok = yaffs_WriteCheckpointDevice(dev);
+ 	}
+ 	if (ok) {
+ 		T(YAFFS_TRACE_CHECKPOINT, (TSTR("write checkpoint objects" TENDSTR)));
+ 		ok = yaffs_WriteCheckpointObjects(dev);
+ 	}
+ 	if (ok) {
+ 		T(YAFFS_TRACE_CHECKPOINT, (TSTR("write checkpoint validity" TENDSTR)));
+ 		ok = yaffs_WriteCheckpointValidityMarker(dev, 0);
+ 	}
+ 
+ 	if (ok)
+ 		ok = yaffs_WriteCheckpointSum(dev);
+ 
+ 	if (!yaffs_CheckpointClose(dev))
+ 		ok = 0;
+ 
+ 	if (ok)
+ 		dev->isCheckpointed = 1;
+ 	else
+ 		dev->isCheckpointed = 0;
+ 
+ 	return dev->isCheckpointed;
+ }
+ 
+ static int yaffs_ReadCheckpointData(yaffs_Device *dev)
+ {
+ 	int ok = 1;
+ 
+ 	if (dev->param.skipCheckpointRead || !dev->param.isYaffs2) {
+ 		T(YAFFS_TRACE_CHECKPOINT, (TSTR("skipping checkpoint read" TENDSTR)));
+ 		ok = 0;
+ 	}
+ 
+ 	if (ok)
+ 		ok = yaffs_CheckpointOpen(dev, 0); /* open for read */
+ 
+ 	if (ok) {
+ 		T(YAFFS_TRACE_CHECKPOINT, (TSTR("read checkpoint validity" TENDSTR)));
+ 		ok = yaffs_ReadCheckpointValidityMarker(dev, 1);
+ 	}
+ 	if (ok) {
+ 		T(YAFFS_TRACE_CHECKPOINT, (TSTR("read checkpoint device" TENDSTR)));
+ 		ok = yaffs_ReadCheckpointDevice(dev);
+ 	}
+ 	if (ok) {
+ 		T(YAFFS_TRACE_CHECKPOINT, (TSTR("read checkpoint objects" TENDSTR)));
+ 		ok = yaffs_ReadCheckpointObjects(dev);
+ 	}
+ 	if (ok) {
+ 		T(YAFFS_TRACE_CHECKPOINT, (TSTR("read checkpoint validity" TENDSTR)));
+ 		ok = yaffs_ReadCheckpointValidityMarker(dev, 0);
+ 	}
+ 
+ 	if (ok) {
+ 		ok = yaffs_ReadCheckpointSum(dev);
+ 		T(YAFFS_TRACE_CHECKPOINT, (TSTR("read checkpoint checksum %d" TENDSTR), ok));
+ 	}
+ 
+ 	if (!yaffs_CheckpointClose(dev))
+ 		ok = 0;
+ 
+ 	if (ok)
+ 		dev->isCheckpointed = 1;
+ 	else
+ 		dev->isCheckpointed = 0;
+ 
+ 	return ok ? 1 : 0;
+ 
+ }
+ 
+ static void yaffs_InvalidateCheckpoint(yaffs_Device *dev)
+ {
+ 	if (dev->isCheckpointed ||
+ 			dev->blocksInCheckpoint > 0) {
+ 		dev->isCheckpointed = 0;
+ 		yaffs_CheckpointInvalidateStream(dev);
+ 	}
+ 	if (dev->param.markSuperBlockDirty)
+ 		dev->param.markSuperBlockDirty(dev);
+ }
+ 
+ 
+ int yaffs_CheckpointSave(yaffs_Device *dev)
+ {
+ 
+ 	T(YAFFS_TRACE_CHECKPOINT, (TSTR("save entry: isCheckpointed %d"TENDSTR), dev->isCheckpointed));
+ 
+ 	yaffs_VerifyObjects(dev);
+ 	yaffs_VerifyBlocks(dev);
+ 	yaffs_VerifyFreeChunks(dev);
+ 
+ 	if (!dev->isCheckpointed) {
+ 		yaffs_InvalidateCheckpoint(dev);
+ 		yaffs_WriteCheckpointData(dev);
+ 	}
+ 
+ 	T(YAFFS_TRACE_ALWAYS, (TSTR("save exit: isCheckpointed %d"TENDSTR), dev->isCheckpointed));
+ 
+ 	return dev->isCheckpointed;
+ }
+ 
+ int yaffs_CheckpointRestore(yaffs_Device *dev)
+ {
+ 	int retval;
+ 	T(YAFFS_TRACE_CHECKPOINT, (TSTR("restore entry: isCheckpointed %d"TENDSTR), dev->isCheckpointed));
+ 
+ 	retval = yaffs_ReadCheckpointData(dev);
+ 
+ 	if (dev->isCheckpointed) {
+ 		yaffs_VerifyObjects(dev);
+ 		yaffs_VerifyBlocks(dev);
+ 		yaffs_VerifyFreeChunks(dev);
+ 	}
+ 
+ 	T(YAFFS_TRACE_CHECKPOINT, (TSTR("restore exit: isCheckpointed %d"TENDSTR), dev->isCheckpointed));
+ 
+ 	return retval;
+ }
+ 
+ /*--------------------- File read/write ------------------------
+  * Read and write have very similar structures.
+  * In general the read/write has three parts to it
+  * An incomplete chunk to start with (if the read/write is not chunk-aligned)
+  * Some complete chunks
+  * An incomplete chunk to end off with
+  *
+  * Curve-balls: the first chunk might also be the last chunk.
+  */
+ 
+ int yaffs_ReadDataFromFile(yaffs_Object *in, __u8 *buffer, loff_t offset,
+ 			int nBytes)
+ {
+ 
+ 	int chunk;
+ 	__u32 start;
+ 	int nToCopy;
+ 	int n = nBytes;
+ 	int nDone = 0;
+ 	yaffs_ChunkCache *cache;
+ 
+ 	yaffs_Device *dev;
+ 
+ 	dev = in->myDev;
+ 
+ 	while (n > 0) {
+ 		/* chunk = offset / dev->nDataBytesPerChunk + 1; */
+ 		/* start = offset % dev->nDataBytesPerChunk; */
+ 		yaffs_AddrToChunk(dev, offset, &chunk, &start);
+ 		chunk++;
+ 
+ 		/* OK now check for the curveball where the start and end are in
+ 		 * the same chunk.
+ 		 */
+ 		if ((start + n) < dev->nDataBytesPerChunk)
+ 			nToCopy = n;
+ 		else
+ 			nToCopy = dev->nDataBytesPerChunk - start;
+ 
+ 		cache = yaffs_FindChunkCache(in, chunk);
+ 
+ 		/* If the chunk is already in the cache or it is less than a whole chunk
+ 		 * or we're using inband tags then use the cache (if there is caching)
+ 		 * else bypass the cache.
+ 		 */
+ 		if (cache || nToCopy != dev->nDataBytesPerChunk || dev->param.inbandTags) {
+ 			if (dev->param.nShortOpCaches > 0) {
+ 
+ 				/* If we can't find the data in the cache, then load it up. */
+ 
+ 				if (!cache) {
+ 					cache = yaffs_GrabChunkCache(in->myDev);
+ 					cache->object = in;
+ 					cache->chunkId = chunk;
+ 					cache->dirty = 0;
+ 					cache->locked = 0;
+ 					yaffs_ReadChunkDataFromObject(in, chunk,
+ 								      cache->
+ 								      data);
+ 					cache->nBytes = 0;
+ 				}
+ 
+ 				yaffs_UseChunkCache(dev, cache, 0);
+ 
+ 				cache->locked = 1;
+ 
+ 
+ 				memcpy(buffer, &cache->data[start], nToCopy);
+ 
+ 				cache->locked = 0;
+ 			} else {
+ 				/* Read into the local buffer then copy..*/
+ 
+ 				__u8 *localBuffer =
+ 				    yaffs_GetTempBuffer(dev, __LINE__);
+ 				yaffs_ReadChunkDataFromObject(in, chunk,
+ 							      localBuffer);
+ 
+ 				memcpy(buffer, &localBuffer[start], nToCopy);
+ 
+ 
+ 				yaffs_ReleaseTempBuffer(dev, localBuffer,
+ 							__LINE__);
+ 			}
+ 
+ 		} else {
+ 
+ 			/* A full chunk. Read directly into the supplied buffer. */
+ 			yaffs_ReadChunkDataFromObject(in, chunk, buffer);
+ 
+ 		}
+ 
+ 		n -= nToCopy;
+ 		offset += nToCopy;
+ 		buffer += nToCopy;
+ 		nDone += nToCopy;
+ 
+ 	}
+ 
+ 	return nDone;
+ }
+ 
+ int yaffs_DoWriteDataToFile(yaffs_Object *in, const __u8 *buffer, loff_t offset,
+ 			int nBytes, int writeThrough)
+ {
+ 
+ 	int chunk;
+ 	__u32 start;
+ 	int nToCopy;
+ 	int n = nBytes;
+ 	int nDone = 0;
+ 	int nToWriteBack;
+ 	int startOfWrite = offset;
+ 	int chunkWritten = 0;
+ 	__u32 nBytesRead;
+ 	__u32 chunkStart;
+ 
+ 	yaffs_Device *dev;
+ 
+ 	dev = in->myDev;
+ 
+ 	while (n > 0 && chunkWritten >= 0) {
+ 		yaffs_AddrToChunk(dev, offset, &chunk, &start);
+ 
+ 		if (chunk * dev->nDataBytesPerChunk + start != offset ||
+ 				start >= dev->nDataBytesPerChunk) {
+ 			T(YAFFS_TRACE_ERROR, (
+ 			   TSTR("AddrToChunk of offset %d gives chunk %d start %d"
+ 			   TENDSTR),
+ 			   (int)offset, chunk, start));
+ 		}
+ 		chunk++; /* File pos to chunk in file offset */
+ 
+ 		/* OK now check for the curveball where the start and end are in
+ 		 * the same chunk.
+ 		 */
+ 
+ 		if ((start + n) < dev->nDataBytesPerChunk) {
+ 			nToCopy = n;
+ 
+ 			/* Now folks, to calculate how many bytes to write back....
+ 			 * If we're overwriting and not writing to then end of file then
+ 			 * we need to write back as much as was there before.
+ 			 */
+ 
+ 			chunkStart = ((chunk - 1) * dev->nDataBytesPerChunk);
+ 
+ 			if (chunkStart > in->variant.fileVariant.fileSize)
+ 				nBytesRead = 0; /* Past end of file */
+ 			else
+ 				nBytesRead = in->variant.fileVariant.fileSize - chunkStart;
+ 
+ 			if (nBytesRead > dev->nDataBytesPerChunk)
+ 				nBytesRead = dev->nDataBytesPerChunk;
+ 
+ 			nToWriteBack =
+ 			    (nBytesRead >
+ 			     (start + n)) ? nBytesRead : (start + n);
+ 
+ 			if (nToWriteBack < 0 || nToWriteBack > dev->nDataBytesPerChunk)
+ 				YBUG();
+ 
+ 		} else {
+ 			nToCopy = dev->nDataBytesPerChunk - start;
+ 			nToWriteBack = dev->nDataBytesPerChunk;
+ 		}
+ 
+ 		if (nToCopy != dev->nDataBytesPerChunk || dev->param.inbandTags) {
+ 			/* An incomplete start or end chunk (or maybe both start and end chunk),
+ 			 * or we're using inband tags, so we want to use the cache buffers.
+ 			 */
+ 			if (dev->param.nShortOpCaches > 0) {
+ 				yaffs_ChunkCache *cache;
+ 				/* If we can't find the data in the cache, then load the cache */
+ 				cache = yaffs_FindChunkCache(in, chunk);
+ 
+ 				if (!cache
+ 				    && yaffs_CheckSpaceForAllocation(dev, 1)) {
+ 					cache = yaffs_GrabChunkCache(dev);
+ 					cache->object = in;
+ 					cache->chunkId = chunk;
+ 					cache->dirty = 0;
+ 					cache->locked = 0;
+ 					yaffs_ReadChunkDataFromObject(in, chunk,
+ 								      cache->data);
+ 				} else if (cache &&
+ 					!cache->dirty &&
+ 					!yaffs_CheckSpaceForAllocation(dev, 1)) {
+ 					/* Drop the cache if it was a read cache item and
+ 					 * no space check has been made for it.
+ 					 */
+ 					 cache = NULL;
+ 				}
+ 
+ 				if (cache) {
+ 					yaffs_UseChunkCache(dev, cache, 1);
+ 					cache->locked = 1;
+ 
+ 
+ 					memcpy(&cache->data[start], buffer,
+ 					       nToCopy);
+ 
+ 
+ 					cache->locked = 0;
+ 					cache->nBytes = nToWriteBack;
+ 
+ 					if (writeThrough) {
+ 						chunkWritten =
+ 						    yaffs_WriteChunkDataToObject
+ 						    (cache->object,
+ 						     cache->chunkId,
+ 						     cache->data, cache->nBytes,
+ 						     1);
+ 						cache->dirty = 0;
+ 					}
+ 
+ 				} else {
+ 					chunkWritten = -1;	/* fail the write */
+ 				}
+ 			} else {
+ 				/* An incomplete start or end chunk (or maybe both start and end chunk)
+ 				 * Read into the local buffer then copy, then copy over and write back.
+ 				 */
+ 
+ 				__u8 *localBuffer =
+ 				    yaffs_GetTempBuffer(dev, __LINE__);
+ 
+ 				yaffs_ReadChunkDataFromObject(in, chunk,
+ 							      localBuffer);
+ 
+ 
+ 
+ 				memcpy(&localBuffer[start], buffer, nToCopy);
+ 
+ 				chunkWritten =
+ 				    yaffs_WriteChunkDataToObject(in, chunk,
+ 								 localBuffer,
+ 								 nToWriteBack,
+ 								 0);
+ 
+ 				yaffs_ReleaseTempBuffer(dev, localBuffer,
+ 							__LINE__);
+ 
+ 			}
+ 
+ 		} else {
+ 			/* A full chunk. Write directly from the supplied buffer. */
+ 
+ 
+ 
+ 			chunkWritten =
+ 			    yaffs_WriteChunkDataToObject(in, chunk, buffer,
+ 							 dev->nDataBytesPerChunk,
+ 							 0);
+ 
+ 			/* Since we've overwritten the cached data, we better invalidate it. */
+ 			yaffs_InvalidateChunkCache(in, chunk);
+ 		}
+ 
+ 		if (chunkWritten >= 0) {
+ 			n -= nToCopy;
+ 			offset += nToCopy;
+ 			buffer += nToCopy;
+ 			nDone += nToCopy;
+ 		}
+ 
+ 	}
+ 
+ 	/* Update file object */
+ 
+ 	if ((startOfWrite + nDone) > in->variant.fileVariant.fileSize)
+ 		in->variant.fileVariant.fileSize = (startOfWrite + nDone);
+ 
+ 	in->dirty = 1;
+ 
+ 	return nDone;
+ }
+ 
+ int yaffs_WriteDataToFile(yaffs_Object *in, const __u8 *buffer, loff_t offset,
+ 			int nBytes, int writeThrough)
+ {
+ 	yaffs_HandleHole(in,offset);
+ 	return yaffs_DoWriteDataToFile(in,buffer,offset,nBytes,writeThrough);
+ }
+ 
+ 
+ 
+ /* ---------------------- File resizing stuff ------------------ */
+ 
+ static void yaffs_PruneResizedChunks(yaffs_Object *in, int newSize)
+ {
+ 
+ 	yaffs_Device *dev = in->myDev;
+ 	int oldFileSize = in->variant.fileVariant.fileSize;
+ 
+ 	int lastDel = 1 + (oldFileSize - 1) / dev->nDataBytesPerChunk;
+ 
+ 	int startDel = 1 + (newSize + dev->nDataBytesPerChunk - 1) /
+ 	    dev->nDataBytesPerChunk;
+ 	int i;
+ 	int chunkId;
+ 
+ 	/* Delete backwards so that we don't end up with holes if
+ 	 * power is lost part-way through the operation.
+ 	 */
+ 	for (i = lastDel; i >= startDel; i--) {
+ 		/* NB this could be optimised somewhat,
+ 		 * eg. could retrieve the tags and write them without
+ 		 * using yaffs_DeleteChunk
+ 		 */
+ 
+ 		chunkId = yaffs_FindAndDeleteChunkInFile(in, i, NULL);
+ 		if (chunkId > 0) {
+ 			if (chunkId <
+ 			    (dev->internalStartBlock * dev->param.nChunksPerBlock)
+ 			    || chunkId >=
+ 			    ((dev->internalEndBlock +
+ 			      1) * dev->param.nChunksPerBlock)) {
+ 				T(YAFFS_TRACE_ALWAYS,
+ 				  (TSTR("Found daft chunkId %d for %d" TENDSTR),
+ 				   chunkId, i));
+ 			} else {
+ 				in->nDataChunks--;
+ 				yaffs_DeleteChunk(dev, chunkId, 1, __LINE__);
+ 			}
+ 		}
+ 	}
+ 
+ }
+ 
+ 
+ static void yaffs_ResizeDown( yaffs_Object *obj, loff_t newSize)
+ {
+ 	int newFullChunks;
+ 	__u32 newSizeOfPartialChunk;
+ 	yaffs_Device *dev = obj->myDev;
+ 
+ 	yaffs_AddrToChunk(dev, newSize, &newFullChunks, &newSizeOfPartialChunk);
+ 
+ 	yaffs_PruneResizedChunks(obj, newSize);
+ 
+ 	if (newSizeOfPartialChunk != 0) {
+ 		int lastChunk = 1 + newFullChunks;
+ 		__u8 *localBuffer = yaffs_GetTempBuffer(dev, __LINE__);
+ 
+ 		/* Got to read and rewrite the last chunk with its new size and zero pad */
+ 		yaffs_ReadChunkDataFromObject(obj, lastChunk, localBuffer);
+ 		memset(localBuffer + newSizeOfPartialChunk, 0,
+ 			dev->nDataBytesPerChunk - newSizeOfPartialChunk);
+ 
+ 		yaffs_WriteChunkDataToObject(obj, lastChunk, localBuffer,
+ 					     newSizeOfPartialChunk, 1);
+ 
+ 		yaffs_ReleaseTempBuffer(dev, localBuffer, __LINE__);
+ 	}
+ 
+ 	obj->variant.fileVariant.fileSize = newSize;
+ 
+ 	yaffs_PruneFileStructure(dev, &obj->variant.fileVariant);
+ }
+ 
+ 
+ static int yaffs_HandleHole(yaffs_Object *obj, loff_t newSize)
+ {
+ 	/* if newsSize > oldFileSize.
+ 	 * We're going to be writing a hole.
+ 	 * If the hole is small then write zeros otherwise write a start of hole marker.
+ 	 */
+ 		
+ 
+ 	loff_t oldFileSize;
+ 	int increase;
+ 	int smallHole   ;
+ 	int result = YAFFS_OK;
+ 	yaffs_Device *dev = NULL;
+ 
+ 	__u8 *localBuffer = NULL;
+ 	
+ 	int smallIncreaseOk = 0;
+ 	
+ 	if(!obj)
+ 		return YAFFS_FAIL;
+ 
+ 	if(obj->variantType != YAFFS_OBJECT_TYPE_FILE)
+ 		return YAFFS_FAIL;
+ 	
+ 	dev = obj->myDev;
+ 	
+ 	/* Bail out if not yaffs2 mode */
+ 	if(!dev->param.isYaffs2)
+ 		return YAFFS_OK;
+ 
+ 	oldFileSize = obj->variant.fileVariant.fileSize;
+ 
+ 	if (newSize <= oldFileSize)
+ 		return YAFFS_OK;
+ 
+ 	increase = newSize - oldFileSize;
+ 
+ 	if(increase < YAFFS_SMALL_HOLE_THRESHOLD * dev->nDataBytesPerChunk &&
+ 		yaffs_CheckSpaceForAllocation(dev, YAFFS_SMALL_HOLE_THRESHOLD + 1))
+ 		smallHole = 1;
+ 	else
+ 		smallHole = 0;
+ 
+ 	if(smallHole)
+ 		localBuffer= yaffs_GetTempBuffer(dev, __LINE__);
+ 	
+ 	if(localBuffer){
+ 		/* fill hole with zero bytes */
+ 		int pos = oldFileSize;
+ 		int thisWrite;
+ 		int written;
+ 		memset(localBuffer,0,dev->nDataBytesPerChunk);
+ 		smallIncreaseOk = 1;
+ 
+ 		while(increase > 0 && smallIncreaseOk){
+ 			thisWrite = increase;
+ 			if(thisWrite > dev->nDataBytesPerChunk)
+ 				thisWrite = dev->nDataBytesPerChunk;
+ 			written = yaffs_DoWriteDataToFile(obj,localBuffer,pos,thisWrite,0);
+ 			if(written == thisWrite){
+ 				pos += thisWrite;
+ 				increase -= thisWrite;
+ 			} else
+ 				smallIncreaseOk = 0;
+ 		}
+ 
+ 		yaffs_ReleaseTempBuffer(dev,localBuffer,__LINE__);
+ 
+ 		/* If we were out of space then reverse any chunks we've added */		
+ 		if(!smallIncreaseOk)
+ 			yaffs_ResizeDown(obj, oldFileSize);
+ 	}
+ 	
+ 	if (!smallIncreaseOk &&
+ 		obj->parent &&
+ 		obj->parent->objectId != YAFFS_OBJECTID_UNLINKED &&
+ 		obj->parent->objectId != YAFFS_OBJECTID_DELETED){
+ 		/* Write a hole start header with the old file size */
+ 		yaffs_UpdateObjectHeader(obj, NULL, 0,1,0);
+ 	}
+ 
+ 	return result;
+ 
+ }
+ 
+ int yaffs_ResizeFile(yaffs_Object *in, loff_t newSize)
+ {
+ 	yaffs_Device *dev = in->myDev;
+ 	int oldFileSize = in->variant.fileVariant.fileSize;
+ 
+ 	yaffs_FlushFilesChunkCache(in);
+ 	yaffs_InvalidateWholeChunkCache(in);
+ 
+ 	yaffs_CheckGarbageCollection(dev,0);
+ 
+ 	if (in->variantType != YAFFS_OBJECT_TYPE_FILE)
+ 		return YAFFS_FAIL;
+ 
+ 	if (newSize == oldFileSize)
+ 		return YAFFS_OK;
+ 		
+ 	if(newSize > oldFileSize){
+ 		yaffs_HandleHole(in,newSize);
+ 		in->variant.fileVariant.fileSize = newSize;
+ 	} else {
+ 		/* newSize < oldFileSize */ 
+ 		yaffs_ResizeDown(in, newSize);
+ 	} 
+ 
+ 	/* Write a new object header to reflect the resize.
+ 	 * show we've shrunk the file, if need be
+ 	 * Do this only if the file is not in the deleted directories
+ 	 * and is not shadowed.
+ 	 */
+ 	if (in->parent &&
+ 	    !in->isShadowed &&
+ 	    in->parent->objectId != YAFFS_OBJECTID_UNLINKED &&
+ 	    in->parent->objectId != YAFFS_OBJECTID_DELETED)
+ 		yaffs_UpdateObjectHeader(in, NULL, 0,0,0);
+ 
+ 
+ 	return YAFFS_OK;
+ }
+ 
+ loff_t yaffs_GetFileSize(yaffs_Object *obj)
+ {
+ 	YCHAR *alias = NULL;
+ 	obj = yaffs_GetEquivalentObject(obj);
+ 
+ 	switch (obj->variantType) {
+ 	case YAFFS_OBJECT_TYPE_FILE:
+ 		return obj->variant.fileVariant.fileSize;
+ 	case YAFFS_OBJECT_TYPE_SYMLINK:
+ 		alias = obj->variant.symLinkVariant.alias;
+ 		if(!alias)
+ 			return 0;
+ 		return yaffs_strnlen(alias,YAFFS_MAX_ALIAS_LENGTH);
+ 	default:
+ 		return 0;
+ 	}
+ }
+ 
+ 
+ 
+ int yaffs_FlushFile(yaffs_Object *in, int updateTime, int dataSync)
+ {
+ 	int retVal;
+ 	if (in->dirty) {
+ 		yaffs_FlushFilesChunkCache(in);
+ 		if(dataSync) /* Only sync data */
+ 			retVal=YAFFS_OK;
+ 		else {
+ 			if (updateTime) {
+ #ifdef CONFIG_YAFFS_WINCE
+ 				yfsd_WinFileTimeNow(in->win_mtime);
+ #else
+ 
+ 				in->yst_mtime = Y_CURRENT_TIME;
+ 
+ #endif
+ 			}
+ 
+ 			retVal = (yaffs_UpdateObjectHeader(in, NULL, 0, 0, 0) >=
+ 				0) ? YAFFS_OK : YAFFS_FAIL;
+ 		}
+ 	} else {
+ 		retVal = YAFFS_OK;
+ 	}
+ 
+ 	return retVal;
+ 
+ }
+ 
+ static int yaffs_DoGenericObjectDeletion(yaffs_Object *in)
+ {
+ 
+ 	/* First off, invalidate the file's data in the cache, without flushing. */
+ 	yaffs_InvalidateWholeChunkCache(in);
+ 
+ 	if (in->myDev->param.isYaffs2 && (in->parent != in->myDev->deletedDir)) {
+ 		/* Move to the unlinked directory so we have a record that it was deleted. */
+ 		yaffs_ChangeObjectName(in, in->myDev->deletedDir, _Y("deleted"), 0, 0);
+ 
+ 	}
+ 
+ 	yaffs_RemoveObjectFromDirectory(in);
+ 	yaffs_DeleteChunk(in->myDev, in->hdrChunk, 1, __LINE__);
+ 	in->hdrChunk = 0;
+ 
+ 	yaffs_FreeObject(in);
+ 	return YAFFS_OK;
+ 
+ }
+ 
+ /* yaffs_DeleteFile deletes the whole file data
+  * and the inode associated with the file.
+  * It does not delete the links associated with the file.
+  */
+ static int yaffs_UnlinkFileIfNeeded(yaffs_Object *in)
+ {
+ 
+ 	int retVal;
+ 	int immediateDeletion = 0;
+ 	yaffs_Device *dev = in->myDev;
+ 
+ 	if (!in->myInode)
+ 		immediateDeletion = 1;
+ 
+ 	if (immediateDeletion) {
+ 		retVal =
+ 		    yaffs_ChangeObjectName(in, in->myDev->deletedDir,
+ 					   _Y("deleted"), 0, 0);
+ 		T(YAFFS_TRACE_TRACING,
+ 		  (TSTR("yaffs: immediate deletion of file %d" TENDSTR),
+ 		   in->objectId));
+ 		in->deleted = 1;
+ 		in->myDev->nDeletedFiles++;
+ 		if (dev->param.disableSoftDelete || dev->param.isYaffs2)
+ 			yaffs_ResizeFile(in, 0);
+ 		yaffs_SoftDeleteFile(in);
+ 	} else {
+ 		retVal =
+ 		    yaffs_ChangeObjectName(in, in->myDev->unlinkedDir,
+ 					   _Y("unlinked"), 0, 0);
+ 	}
+ 
+ 
+ 	return retVal;
+ }
+ 
+ int yaffs_DeleteFile(yaffs_Object *in)
+ {
+ 	int retVal = YAFFS_OK;
+ 	int deleted; /* Need to cache value on stack if in is freed */
+ 	yaffs_Device *dev = in->myDev;
+ 
+ 	if (dev->param.disableSoftDelete || dev->param.isYaffs2)
+ 		yaffs_ResizeFile(in, 0);
+ 
+ 	if (in->nDataChunks > 0) {
+ 		/* Use soft deletion if there is data in the file.
+ 		 * That won't be the case if it has been resized to zero.
+ 		 */
+ 		if (!in->unlinked)
+ 			retVal = yaffs_UnlinkFileIfNeeded(in);
+ 
+ 		deleted = in->deleted;
+ 
+ 		if (retVal == YAFFS_OK && in->unlinked && !in->deleted) {
+ 			in->deleted = 1;
+ 			deleted = 1;
+ 			in->myDev->nDeletedFiles++;
+ 			yaffs_SoftDeleteFile(in);
+ 		}
+ 		return deleted ? YAFFS_OK : YAFFS_FAIL;
+ 	} else {
+ 		/* The file has no data chunks so we toss it immediately */
+ 		yaffs_FreeTnode(in->myDev, in->variant.fileVariant.top);
+ 		in->variant.fileVariant.top = NULL;
+ 		yaffs_DoGenericObjectDeletion(in);
+ 
+ 		return YAFFS_OK;
+ 	}
+ }
+ 
+ static int yaffs_IsNonEmptyDirectory(yaffs_Object *obj)
+ {
+ 	return (obj->variantType == YAFFS_OBJECT_TYPE_DIRECTORY) &&
+ 		!(ylist_empty(&obj->variant.directoryVariant.children));
+ }
+ 
+ static int yaffs_DeleteDirectory(yaffs_Object *obj)
+ {
+ 	/* First check that the directory is empty. */
+ 	if (yaffs_IsNonEmptyDirectory(obj))
+ 		return YAFFS_FAIL;
+ 
+ 	return yaffs_DoGenericObjectDeletion(obj);
+ }
+ 
+ static int yaffs_DeleteSymLink(yaffs_Object *in)
+ {
+ 	if(in->variant.symLinkVariant.alias)
+ 		YFREE(in->variant.symLinkVariant.alias);
+ 	in->variant.symLinkVariant.alias=NULL;
+ 
+ 	return yaffs_DoGenericObjectDeletion(in);
+ }
+ 
+ static int yaffs_DeleteHardLink(yaffs_Object *in)
+ {
+ 	/* remove this hardlink from the list assocaited with the equivalent
+ 	 * object
+ 	 */
+ 	ylist_del_init(&in->hardLinks);
+ 	return yaffs_DoGenericObjectDeletion(in);
+ }
+ 
+ int yaffs_DeleteObject(yaffs_Object *obj)
+ {
+ int retVal = -1;
+ 	switch (obj->variantType) {
+ 	case YAFFS_OBJECT_TYPE_FILE:
+ 		retVal = yaffs_DeleteFile(obj);
+ 		break;
+ 	case YAFFS_OBJECT_TYPE_DIRECTORY:
+ 		if(!ylist_empty(&obj->variant.directoryVariant.dirty)){
+ 			T(YAFFS_TRACE_BACKGROUND, (TSTR("Remove object %d from dirty directories" TENDSTR),obj->objectId));
+ 			ylist_del_init(&obj->variant.directoryVariant.dirty);
+ 		}
+ 		return yaffs_DeleteDirectory(obj);
+ 		break;
+ 	case YAFFS_OBJECT_TYPE_SYMLINK:
+ 		retVal = yaffs_DeleteSymLink(obj);
+ 		break;
+ 	case YAFFS_OBJECT_TYPE_HARDLINK:
+ 		retVal = yaffs_DeleteHardLink(obj);
+ 		break;
+ 	case YAFFS_OBJECT_TYPE_SPECIAL:
+ 		retVal = yaffs_DoGenericObjectDeletion(obj);
+ 		break;
+ 	case YAFFS_OBJECT_TYPE_UNKNOWN:
+ 		retVal = 0;
+ 		break;		/* should not happen. */
+ 	}
+ 
+ 	return retVal;
+ }
+ 
+ static int yaffs_UnlinkWorker(yaffs_Object *obj)
+ {
+ 
+ 	int immediateDeletion = 0;
+ 
+ 	if (!obj->myInode)
+ 		immediateDeletion = 1;
+ 
+ 	if(obj)
+ 		yaffs_UpdateParent(obj->parent);
+ 
+ 	if (obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK) {
+ 		return yaffs_DeleteHardLink(obj);
+ 	} else if (!ylist_empty(&obj->hardLinks)) {
+ 		/* Curve ball: We're unlinking an object that has a hardlink.
+ 		 *
+ 		 * This problem arises because we are not strictly following
+ 		 * The Linux link/inode model.
+ 		 *
+ 		 * We can't really delete the object.
+ 		 * Instead, we do the following:
+ 		 * - Select a hardlink.
+ 		 * - Unhook it from the hard links
+ 		 * - Move it from its parent directory (so that the rename can work)
+ 		 * - Rename the object to the hardlink's name.
+ 		 * - Delete the hardlink
+ 		 */
+ 
+ 		yaffs_Object *hl;
+ 		yaffs_Object *parent;
+ 		int retVal;
+ 		YCHAR name[YAFFS_MAX_NAME_LENGTH + 1];
+ 
+ 		hl = ylist_entry(obj->hardLinks.next, yaffs_Object, hardLinks);
+ 
+ 		yaffs_GetObjectName(hl, name, YAFFS_MAX_NAME_LENGTH + 1);
+ 		parent = hl->parent;
+ 
+ 		ylist_del_init(&hl->hardLinks);
+ 
+  		yaffs_AddObjectToDirectory(obj->myDev->unlinkedDir, hl);
+ 
+ 		retVal = yaffs_ChangeObjectName(obj,parent, name, 0, 0);
+ 
+ 		if (retVal == YAFFS_OK)
+ 			retVal = yaffs_DoGenericObjectDeletion(hl);
+ 
+ 		return retVal;
+ 
+ 	} else if (immediateDeletion) {
+ 		switch (obj->variantType) {
+ 		case YAFFS_OBJECT_TYPE_FILE:
+ 			return yaffs_DeleteFile(obj);
+ 			break;
+ 		case YAFFS_OBJECT_TYPE_DIRECTORY:
+ 			ylist_del_init(&obj->variant.directoryVariant.dirty);
+ 			return yaffs_DeleteDirectory(obj);
+ 			break;
+ 		case YAFFS_OBJECT_TYPE_SYMLINK:
+ 			return yaffs_DeleteSymLink(obj);
+ 			break;
+ 		case YAFFS_OBJECT_TYPE_SPECIAL:
+ 			return yaffs_DoGenericObjectDeletion(obj);
+ 			break;
+ 		case YAFFS_OBJECT_TYPE_HARDLINK:
+ 		case YAFFS_OBJECT_TYPE_UNKNOWN:
+ 		default:
+ 			return YAFFS_FAIL;
+ 		}
+ 	} else if(yaffs_IsNonEmptyDirectory(obj))
+ 		return YAFFS_FAIL;
+ 	else
+ 		return yaffs_ChangeObjectName(obj, obj->myDev->unlinkedDir,
+ 					   _Y("unlinked"), 0, 0);
+ }
+ 
+ 
+ static int yaffs_UnlinkObject(yaffs_Object *obj)
+ {
+ 
+ 	if (obj && obj->unlinkAllowed)
+ 		return yaffs_UnlinkWorker(obj);
+ 
+ 	return YAFFS_FAIL;
+ 
+ }
+ int yaffs_Unlink(yaffs_Object *dir, const YCHAR *name)
+ {
+ 	yaffs_Object *obj;
+ 
+ 	obj = yaffs_FindObjectByName(dir, name);
+ 	return yaffs_UnlinkObject(obj);
+ }
+ 
+ /*----------------------- Initialisation Scanning ---------------------- */
+ 
+ static void yaffs_HandleShadowedObject(yaffs_Device *dev, int objId,
+ 				int backwardScanning)
+ {
+ 	yaffs_Object *obj;
+ 
+ 	if (!backwardScanning) {
+ 		/* Handle YAFFS1 forward scanning case
+ 		 * For YAFFS1 we always do the deletion
+ 		 */
+ 
+ 	} else {
+ 		/* Handle YAFFS2 case (backward scanning)
+ 		 * If the shadowed object exists then ignore.
+ 		 */
+ 		obj = yaffs_FindObjectByNumber(dev, objId);
+ 		if(obj)
+ 			return;
+ 	}
+ 
+ 	/* Let's create it (if it does not exist) assuming it is a file so that it can do shrinking etc.
+ 	 * We put it in unlinked dir to be cleaned up after the scanning
+ 	 */
+ 	obj =
+ 	    yaffs_FindOrCreateObjectByNumber(dev, objId,
+ 					     YAFFS_OBJECT_TYPE_FILE);
+ 	if (!obj)
+ 		return;
+ 	obj->isShadowed = 1;
+ 	yaffs_AddObjectToDirectory(dev->unlinkedDir, obj);
+ 	obj->variant.fileVariant.shrinkSize = 0;
+ 	obj->valid = 1;		/* So that we don't read any other info for this file */
+ 
+ }
+ 
+ typedef struct {
+ 	int seq;
+ 	int block;
+ } yaffs_BlockIndex;
+ 
+ 
+ static void yaffs_HardlinkFixup(yaffs_Device *dev, yaffs_Object *hardList)
+ {
+ 	yaffs_Object *hl;
+ 	yaffs_Object *in;
+ 
+ 	while (hardList) {
+ 		hl = hardList;
+ 		hardList = (yaffs_Object *) (hardList->hardLinks.next);
+ 
+ 		in = yaffs_FindObjectByNumber(dev,
+ 					      hl->variant.hardLinkVariant.
+ 					      equivalentObjectId);
+ 
+ 		if (in) {
+ 			/* Add the hardlink pointers */
+ 			hl->variant.hardLinkVariant.equivalentObject = in;
+ 			ylist_add(&hl->hardLinks, &in->hardLinks);
+ 		} else {
+ 			/* Todo Need to report/handle this better.
+ 			 * Got a problem... hardlink to a non-existant object
+ 			 */
+ 			hl->variant.hardLinkVariant.equivalentObject = NULL;
+ 			YINIT_LIST_HEAD(&hl->hardLinks);
+ 
+ 		}
+ 	}
+ }
+ 
+ 
+ 
+ 
+ 
+ static int ybicmp(const void *a, const void *b)
+ {
+ 	register int aseq = ((yaffs_BlockIndex *)a)->seq;
+ 	register int bseq = ((yaffs_BlockIndex *)b)->seq;
+ 	register int ablock = ((yaffs_BlockIndex *)a)->block;
+ 	register int bblock = ((yaffs_BlockIndex *)b)->block;
+ 	if (aseq == bseq)
+ 		return ablock - bblock;
+ 	else
+ 		return aseq - bseq;
+ }
+ 
+ 
+ struct yaffs_ShadowFixerStruct {
+ 	int objectId;
+ 	int shadowedId;
+ 	struct yaffs_ShadowFixerStruct *next;
+ };
+ 
+ 
+ static void yaffs_StripDeletedObjects(yaffs_Device *dev)
+ {
+ 	/*
+ 	*  Sort out state of unlinked and deleted objects after scanning.
+ 	*/
+ 	struct ylist_head *i;
+ 	struct ylist_head *n;
+ 	yaffs_Object *l;
+ 
+ 	/* Soft delete all the unlinked files */
+ 	ylist_for_each_safe(i, n,
+ 		&dev->unlinkedDir->variant.directoryVariant.children) {
+ 		if (i) {
+ 			l = ylist_entry(i, yaffs_Object, siblings);
+ 			yaffs_DeleteObject(l);
+ 		}
+ 	}
+ 
+ 	ylist_for_each_safe(i, n,
+ 		&dev->deletedDir->variant.directoryVariant.children) {
+ 		if (i) {
+ 			l = ylist_entry(i, yaffs_Object, siblings);
+ 			yaffs_DeleteObject(l);
+ 		}
+ 	}
+ 
+ }
+ 
+ /*
+  * This code iterates through all the objects making sure that they are rooted.
+  * Any unrooted objects are re-rooted in lost+found.
+  * An object needs to be in one of:
+  * - Directly under deleted, unlinked
+  * - Directly or indirectly under root.
+  *
+  * Note:
+  *  This code assumes that we don't ever change the current relationships between
+  *  directories:
+  *   rootDir->parent == unlinkedDir->parent == deletedDir->parent == NULL
+  *   lostNfound->parent == rootDir
+  *
+  * This fixes the problem where directories might have inadvertently been deleted
+  * leaving the object "hanging" without being rooted in the directory tree.
+  */
+  
+ static int yaffs_HasNULLParent(yaffs_Device *dev, yaffs_Object *obj)
+ {
+ 	return (obj == dev->deletedDir ||
+ 		obj == dev->unlinkedDir||
+ 		obj == dev->rootDir);
+ }
+ 
+ static void yaffs_FixHangingObjects(yaffs_Device *dev)
+ {
+ 	yaffs_Object *obj;
+ 	yaffs_Object *parent;
+ 	int i;
+ 	struct ylist_head *lh;
+ 	struct ylist_head *n;
+ 	int depthLimit;
+ 	int hanging;
+ 
+ 
+ 	/* Iterate through the objects in each hash entry,
+ 	 * looking at each object.
+ 	 * Make sure it is rooted.
+ 	 */
+ 
+ 	for (i = 0; i <  YAFFS_NOBJECT_BUCKETS; i++) {
+ 		ylist_for_each_safe(lh, n, &dev->objectBucket[i].list) {
+ 			if (lh) {
+ 				obj = ylist_entry(lh, yaffs_Object, hashLink);
+ 				parent= obj->parent;
+ 				
+ 				if(yaffs_HasNULLParent(dev,obj)){
+ 					/* These directories are not hanging */
+ 					hanging = 0;
+ 				}
+ 				else if(!parent || parent->variantType != YAFFS_OBJECT_TYPE_DIRECTORY)
+ 					hanging = 1;
+ 				else if(yaffs_HasNULLParent(dev,parent))
+ 					hanging = 0;
+ 				else {
+ 					/*
+ 					 * Need to follow the parent chain to see if it is hanging.
+ 					 */
+ 					hanging = 0;
+ 					depthLimit=100;
+ 
+ 					while(parent != dev->rootDir &&
+ 						parent->parent &&
+ 						parent->parent->variantType == YAFFS_OBJECT_TYPE_DIRECTORY &&
+ 						depthLimit > 0){
+ 						parent = parent->parent;
+ 						depthLimit--;
+ 					}
+ 					if(parent != dev->rootDir)
+ 						hanging = 1;
+ 				}
+ 				if(hanging){
+ 					T(YAFFS_TRACE_SCAN,
+ 					  (TSTR("Hanging object %d moved to lost and found" TENDSTR),
+ 					  	obj->objectId));
+ 					yaffs_AddObjectToDirectory(dev->lostNFoundDir,obj);
+ 				}
+ 			}
+ 		}
+ 	}
+ }
+ 
+ 
+ /*
+  * Delete directory contents for cleaning up lost and found.
+  */
+ static void yaffs_DeleteDirectoryContents(yaffs_Object *dir)
+ {
+ 	yaffs_Object *obj;
+ 	struct ylist_head *lh;
+ 	struct ylist_head *n;
+ 
+ 	if(dir->variantType != YAFFS_OBJECT_TYPE_DIRECTORY)
+ 		YBUG();
+ 	
+ 	ylist_for_each_safe(lh, n, &dir->variant.directoryVariant.children) {
+ 		if (lh) {
+ 			obj = ylist_entry(lh, yaffs_Object, siblings);
+ 			if(obj->variantType == YAFFS_OBJECT_TYPE_DIRECTORY)
+ 				yaffs_DeleteDirectoryContents(obj);
+ 
+ 			T(YAFFS_TRACE_SCAN,
+ 				(TSTR("Deleting lost_found object %d" TENDSTR),
+ 				obj->objectId));
+ 
+ 			/* Need to use UnlinkObject since Delete would not handle
+ 			 * hardlinked objects correctly.
+ 			 */
+ 			yaffs_UnlinkObject(obj); 
+ 		}
+ 	}
+ 			
+ }
+ 
+ static void yaffs_EmptyLostAndFound(yaffs_Device *dev)
+ {
+ 	yaffs_DeleteDirectoryContents(dev->lostNFoundDir);
+ }
+ 
+ static int yaffs_Scan(yaffs_Device *dev)
+ {
+ 	yaffs_ExtendedTags tags;
+ 	int blk;
+ 	int blockIterator;
+ 	int startIterator;
+ 	int endIterator;
+ 	int result;
+ 
+ 	int chunk;
+ 	int c;
+ 	int deleted;
+ 	yaffs_BlockState state;
+ 	yaffs_Object *hardList = NULL;
+ 	yaffs_BlockInfo *bi;
+ 	__u32 sequenceNumber;
+ 	yaffs_ObjectHeader *oh;
+ 	yaffs_Object *in;
+ 	yaffs_Object *parent;
+ 
+ 	int alloc_failed = 0;
+ 
+ 	struct yaffs_ShadowFixerStruct *shadowFixerList = NULL;
+ 
+ 
+ 	__u8 *chunkData;
+ 
+ 
+ 
+ 	T(YAFFS_TRACE_SCAN,
+ 	  (TSTR("yaffs_Scan starts  intstartblk %d intendblk %d..." TENDSTR),
+ 	   dev->internalStartBlock, dev->internalEndBlock));
+ 
+ 	chunkData = yaffs_GetTempBuffer(dev, __LINE__);
+ 
+ 	dev->sequenceNumber = YAFFS_LOWEST_SEQUENCE_NUMBER;
+ 
+ 	/* Scan all the blocks to determine their state */
+ 	bi = dev->blockInfo;
+ 	for (blk = dev->internalStartBlock; blk <= dev->internalEndBlock; blk++) {
+ 		yaffs_ClearChunkBits(dev, blk);
+ 		bi->pagesInUse = 0;
+ 		bi->softDeletions = 0;
+ 
+ 		yaffs_QueryInitialBlockState(dev, blk, &state, &sequenceNumber);
+ 
+ 		bi->blockState = state;
+ 		bi->sequenceNumber = sequenceNumber;
+ 
+ 		if (bi->sequenceNumber == YAFFS_SEQUENCE_BAD_BLOCK)
+ 			bi->blockState = state = YAFFS_BLOCK_STATE_DEAD;
+ 
+ 		T(YAFFS_TRACE_SCAN_DEBUG,
+ 		  (TSTR("Block scanning block %d state %d seq %d" TENDSTR), blk,
+ 		   state, sequenceNumber));
+ 
+ 		if (state == YAFFS_BLOCK_STATE_DEAD) {
+ 			T(YAFFS_TRACE_BAD_BLOCKS,
+ 			  (TSTR("block %d is bad" TENDSTR), blk));
+ 		} else if (state == YAFFS_BLOCK_STATE_EMPTY) {
+ 			T(YAFFS_TRACE_SCAN_DEBUG,
+ 			  (TSTR("Block empty " TENDSTR)));
+ 			dev->nErasedBlocks++;
+ 			dev->nFreeChunks += dev->param.nChunksPerBlock;
+ 		}
+ 		bi++;
+ 	}
+ 
+ 	startIterator = dev->internalStartBlock;
+ 	endIterator = dev->internalEndBlock;
+ 
+ 	/* For each block.... */
+ 	for (blockIterator = startIterator; !alloc_failed && blockIterator <= endIterator;
+ 	     blockIterator++) {
+ 
+ 		YYIELD();
+ 
+ 		YYIELD();
+ 
+ 		blk = blockIterator;
+ 
+ 		bi = yaffs_GetBlockInfo(dev, blk);
+ 		state = bi->blockState;
+ 
+ 		deleted = 0;
+ 
+ 		/* For each chunk in each block that needs scanning....*/
+ 		for (c = 0; !alloc_failed && c < dev->param.nChunksPerBlock &&
+ 		     state == YAFFS_BLOCK_STATE_NEEDS_SCANNING; c++) {
+ 			/* Read the tags and decide what to do */
+ 			chunk = blk * dev->param.nChunksPerBlock + c;
+ 
+ 			result = yaffs_ReadChunkWithTagsFromNAND(dev, chunk, NULL,
+ 							&tags);
+ 
+ 			/* Let's have a good look at this chunk... */
+ 
+ 			if (tags.eccResult == YAFFS_ECC_RESULT_UNFIXED || tags.chunkDeleted) {
+ 				/* YAFFS1 only...
+ 				 * A deleted chunk
+ 				 */
+ 				deleted++;
+ 				dev->nFreeChunks++;
+ 				/*T((" %d %d deleted\n",blk,c)); */
+ 			} else if (!tags.chunkUsed) {
+ 				/* An unassigned chunk in the block
+ 				 * This means that either the block is empty or
+ 				 * this is the one being allocated from
+ 				 */
+ 
+ 				if (c == 0) {
+ 					/* We're looking at the first chunk in the block so the block is unused */
+ 					state = YAFFS_BLOCK_STATE_EMPTY;
+ 					dev->nErasedBlocks++;
+ 				} else {
+ 					/* this is the block being allocated from */
+ 					T(YAFFS_TRACE_SCAN,
+ 					  (TSTR
+ 					   (" Allocating from %d %d" TENDSTR),
+ 					   blk, c));
+ 					state = YAFFS_BLOCK_STATE_ALLOCATING;
+ 					dev->allocationBlock = blk;
+ 					dev->allocationPage = c;
+ 					dev->allocationBlockFinder = blk;
+ 					/* Set block finder here to encourage the allocator to go forth from here. */
+ 
+ 				}
+ 
+ 				dev->nFreeChunks += (dev->param.nChunksPerBlock - c);
+ 			} else if (tags.chunkId > 0) {
+ 				/* chunkId > 0 so it is a data chunk... */
+ 				unsigned int endpos;
+ 
+ 				yaffs_SetChunkBit(dev, blk, c);
+ 				bi->pagesInUse++;
+ 
+ 				in = yaffs_FindOrCreateObjectByNumber(dev,
+ 								      tags.
+ 								      objectId,
+ 								      YAFFS_OBJECT_TYPE_FILE);
+ 				/* PutChunkIntoFile checks for a clash (two data chunks with
+ 				 * the same chunkId).
+ 				 */
+ 
+ 				if (!in)
+ 					alloc_failed = 1;
+ 
+ 				if (in) {
+ 					if (!yaffs_PutChunkIntoFile(in, tags.chunkId, chunk, 1))
+ 						alloc_failed = 1;
+ 				}
+ 
+ 				endpos =
+ 				    (tags.chunkId - 1) * dev->nDataBytesPerChunk +
+ 				    tags.byteCount;
+ 				if (in &&
+ 				    in->variantType == YAFFS_OBJECT_TYPE_FILE
+ 				    && in->variant.fileVariant.scannedFileSize <
+ 				    endpos) {
+ 					in->variant.fileVariant.
+ 					    scannedFileSize = endpos;
+ 					if (!dev->param.useHeaderFileSize) {
+ 						in->variant.fileVariant.
+ 						    fileSize =
+ 						    in->variant.fileVariant.
+ 						    scannedFileSize;
+ 					}
+ 
+ 				}
+ 				/* T((" %d %d data %d %d\n",blk,c,tags.objectId,tags.chunkId));   */
+ 			} else {
+ 				/* chunkId == 0, so it is an ObjectHeader.
+ 				 * Thus, we read in the object header and make the object
+ 				 */
+ 				yaffs_SetChunkBit(dev, blk, c);
+ 				bi->pagesInUse++;
+ 
+ 				result = yaffs_ReadChunkWithTagsFromNAND(dev, chunk,
+ 								chunkData,
+ 								NULL);
+ 
+ 				oh = (yaffs_ObjectHeader *) chunkData;
+ 
+ 				in = yaffs_FindObjectByNumber(dev,
+ 							      tags.objectId);
+ 				if (in && in->variantType != oh->type) {
+ 					/* This should not happen, but somehow
+ 					 * Wev'e ended up with an objectId that has been reused but not yet
+ 					 * deleted, and worse still it has changed type. Delete the old object.
+ 					 */
+ 
+ 					yaffs_DeleteObject(in);
+ 
+ 					in = 0;
+ 				}
+ 
+ 				in = yaffs_FindOrCreateObjectByNumber(dev,
+ 								      tags.
+ 								      objectId,
+ 								      oh->type);
+ 
+ 				if (!in)
+ 					alloc_failed = 1;
+ 
+ 				if (in && oh->shadowsObject > 0) {
+ 
+ 					struct yaffs_ShadowFixerStruct *fixer;
+ 					fixer = YMALLOC(sizeof(struct yaffs_ShadowFixerStruct));
+ 					if (fixer) {
+ 						fixer->next = shadowFixerList;
+ 						shadowFixerList = fixer;
+ 						fixer->objectId = tags.objectId;
+ 						fixer->shadowedId = oh->shadowsObject;
+ 					}
+ 
+ 				}
+ 
+ 				if (in && in->valid) {
+ 					/* We have already filled this one. We have a duplicate and need to resolve it. */
+ 
+ 					unsigned existingSerial = in->serial;
+ 					unsigned newSerial = tags.serialNumber;
+ 
+ 					if (((existingSerial + 1) & 3) == newSerial) {
+ 						/* Use new one - destroy the exisiting one */
+ 						yaffs_DeleteChunk(dev,
+ 								  in->hdrChunk,
+ 								  1, __LINE__);
+ 						in->valid = 0;
+ 					} else {
+ 						/* Use existing - destroy this one. */
+ 						yaffs_DeleteChunk(dev, chunk, 1,
+ 								  __LINE__);
+ 					}
+ 				}
+ 
+ 				if (in && !in->valid &&
+ 				    (tags.objectId == YAFFS_OBJECTID_ROOT ||
+ 				     tags.objectId == YAFFS_OBJECTID_LOSTNFOUND)) {
+ 					/* We only load some info, don't fiddle with directory structure */
+ 					in->valid = 1;
+ 					in->variantType = oh->type;
+ 
+ 					in->yst_mode = oh->yst_mode;
+ #ifdef CONFIG_YAFFS_WINCE
+ 					in->win_atime[0] = oh->win_atime[0];
+ 					in->win_ctime[0] = oh->win_ctime[0];
+ 					in->win_mtime[0] = oh->win_mtime[0];
+ 					in->win_atime[1] = oh->win_atime[1];
+ 					in->win_ctime[1] = oh->win_ctime[1];
+ 					in->win_mtime[1] = oh->win_mtime[1];
+ #else
+ 					in->yst_uid = oh->yst_uid;
+ 					in->yst_gid = oh->yst_gid;
+ 					in->yst_atime = oh->yst_atime;
+ 					in->yst_mtime = oh->yst_mtime;
+ 					in->yst_ctime = oh->yst_ctime;
+ 					in->yst_rdev = oh->yst_rdev;
+ #endif
+ 					in->hdrChunk = chunk;
+ 					in->serial = tags.serialNumber;
+ 
+ 				} else if (in && !in->valid) {
+ 					/* we need to load this info */
+ 
+ 					in->valid = 1;
+ 					in->variantType = oh->type;
+ 
+ 					in->yst_mode = oh->yst_mode;
+ #ifdef CONFIG_YAFFS_WINCE
+ 					in->win_atime[0] = oh->win_atime[0];
+ 					in->win_ctime[0] = oh->win_ctime[0];
+ 					in->win_mtime[0] = oh->win_mtime[0];
+ 					in->win_atime[1] = oh->win_atime[1];
+ 					in->win_ctime[1] = oh->win_ctime[1];
+ 					in->win_mtime[1] = oh->win_mtime[1];
+ #else
+ 					in->yst_uid = oh->yst_uid;
+ 					in->yst_gid = oh->yst_gid;
+ 					in->yst_atime = oh->yst_atime;
+ 					in->yst_mtime = oh->yst_mtime;
+ 					in->yst_ctime = oh->yst_ctime;
+ 					in->yst_rdev = oh->yst_rdev;
+ #endif
+ 					in->hdrChunk = chunk;
+ 					in->serial = tags.serialNumber;
+ 
+ 					yaffs_SetObjectName(in, oh->name);
+ 					in->dirty = 0;
+ 
+ 					/* directory stuff...
+ 					 * hook up to parent
+ 					 */
+ 
+ 					parent =
+ 					    yaffs_FindOrCreateObjectByNumber
+ 					    (dev, oh->parentObjectId,
+ 					     YAFFS_OBJECT_TYPE_DIRECTORY);
+ 					if (!parent)
+ 						alloc_failed = 1;
+ 					if (parent && parent->variantType ==
+ 					    YAFFS_OBJECT_TYPE_UNKNOWN) {
+ 						/* Set up as a directory */
+ 						parent->variantType =
+ 							YAFFS_OBJECT_TYPE_DIRECTORY;
+ 						YINIT_LIST_HEAD(&parent->variant.
+ 								directoryVariant.
+ 								children);
+ 					} else if (!parent || parent->variantType !=
+ 						   YAFFS_OBJECT_TYPE_DIRECTORY) {
+ 						/* Hoosterman, another problem....
+ 						 * We're trying to use a non-directory as a directory
+ 						 */
+ 
+ 						T(YAFFS_TRACE_ERROR,
+ 						  (TSTR
+ 						   ("yaffs tragedy: attempting to use non-directory as a directory in scan. Put in lost+found."
+ 						    TENDSTR)));
+ 						parent = dev->lostNFoundDir;
+ 					}
+ 
+ 					yaffs_AddObjectToDirectory(parent, in);
+ 
+ 					if (0 && (parent == dev->deletedDir ||
+ 						  parent == dev->unlinkedDir)) {
+ 						in->deleted = 1;	/* If it is unlinked at start up then it wants deleting */
+ 						dev->nDeletedFiles++;
+ 					}
+ 					/* Note re hardlinks.
+ 					 * Since we might scan a hardlink before its equivalent object is scanned
+ 					 * we put them all in a list.
+ 					 * After scanning is complete, we should have all the objects, so we run through this
+ 					 * list and fix up all the chains.
+ 					 */
+ 
+ 					switch (in->variantType) {
+ 					case YAFFS_OBJECT_TYPE_UNKNOWN:
+ 						/* Todo got a problem */
+ 						break;
+ 					case YAFFS_OBJECT_TYPE_FILE:
+ 						if (dev->param.useHeaderFileSize)
+ 
+ 							in->variant.fileVariant.
+ 							    fileSize =
+ 							    oh->fileSize;
+ 
+ 						break;
+ 					case YAFFS_OBJECT_TYPE_HARDLINK:
+ 						in->variant.hardLinkVariant.
+ 							equivalentObjectId =
+ 							oh->equivalentObjectId;
+ 						in->hardLinks.next =
+ 							(struct ylist_head *)
+ 							hardList;
+ 						hardList = in;
+ 						break;
+ 					case YAFFS_OBJECT_TYPE_DIRECTORY:
+ 						/* Do nothing */
+ 						break;
+ 					case YAFFS_OBJECT_TYPE_SPECIAL:
+ 						/* Do nothing */
+ 						break;
+ 					case YAFFS_OBJECT_TYPE_SYMLINK:
+ 						in->variant.symLinkVariant.alias =
+ 						    yaffs_CloneString(oh->alias);
+ 						if (!in->variant.symLinkVariant.alias)
+ 							alloc_failed = 1;
+ 						break;
+ 					}
+ 
+ 				}
+ 			}
+ 		}
+ 
+ 		if (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING) {
+ 			/* If we got this far while scanning, then the block is fully allocated.*/
+ 			state = YAFFS_BLOCK_STATE_FULL;
+ 		}
+ 
+ 		if (state == YAFFS_BLOCK_STATE_ALLOCATING) {
+ 			/* If the block was partially allocated then treat it as fully allocated.*/
+ 			state = YAFFS_BLOCK_STATE_FULL;
+ 			dev->allocationBlock = -1;
+ 		}
+ 
+ 		bi->blockState = state;
+ 
+ 		/* Now let's see if it was dirty */
+ 		if (bi->pagesInUse == 0 &&
+ 		    !bi->hasShrinkHeader &&
+ 		    bi->blockState == YAFFS_BLOCK_STATE_FULL) {
+ 			yaffs_BlockBecameDirty(dev, blk);
+ 		}
+ 
+ 	}
+ 
+ 
+ 	/* Ok, we've done all the scanning.
+ 	 * Fix up the hard link chains.
+ 	 * We should now have scanned all the objects, now it's time to add these
+ 	 * hardlinks.
+ 	 */
+ 
+ 	yaffs_HardlinkFixup(dev, hardList);
+ 
+ 	/* Fix up any shadowed objects */
+ 	{
+ 		struct yaffs_ShadowFixerStruct *fixer;
+ 		yaffs_Object *obj;
+ 
+ 		while (shadowFixerList) {
+ 			fixer = shadowFixerList;
+ 			shadowFixerList = fixer->next;
+ 			/* Complete the rename transaction by deleting the shadowed object
+ 			 * then setting the object header to unshadowed.
+ 			 */
+ 			obj = yaffs_FindObjectByNumber(dev, fixer->shadowedId);
+ 			if (obj)
+ 				yaffs_DeleteObject(obj);
+ 
+ 			obj = yaffs_FindObjectByNumber(dev, fixer->objectId);
+ 
+ 			if (obj)
+ 				yaffs_UpdateObjectHeader(obj, NULL, 1, 0, 0);
+ 
+ 			YFREE(fixer);
+ 		}
+ 	}
+ 
+ 	yaffs_ReleaseTempBuffer(dev, chunkData, __LINE__);
+ 
+ 	if (alloc_failed)
+ 		return YAFFS_FAIL;
+ 
+ 	T(YAFFS_TRACE_SCAN, (TSTR("yaffs_Scan ends" TENDSTR)));
+ 
+ 
+ 	return YAFFS_OK;
+ }
+ 
+ static void yaffs_CheckObjectDetailsLoaded(yaffs_Object *in)
+ {
+ 	__u8 *chunkData;
+ 	yaffs_ObjectHeader *oh;
+ 	yaffs_Device *dev;
+ 	yaffs_ExtendedTags tags;
+ 	int result;
+ 	int alloc_failed = 0;
+ 
+ 	if (!in)
+ 		return;
+ 
+ 	dev = in->myDev;
+ 
+ #if 0
+ 	T(YAFFS_TRACE_SCAN, (TSTR("details for object %d %s loaded" TENDSTR),
+ 		in->objectId,
+ 		in->lazyLoaded ? "not yet" : "already"));
+ #endif
+ 
+ 	if (in->lazyLoaded && in->hdrChunk > 0) {
+ 		in->lazyLoaded = 0;
+ 		chunkData = yaffs_GetTempBuffer(dev, __LINE__);
+ 
+ 		result = yaffs_ReadChunkWithTagsFromNAND(dev, in->hdrChunk, chunkData, &tags);
+ 		oh = (yaffs_ObjectHeader *) chunkData;
+ 
+ 		in->yst_mode = oh->yst_mode;
+ #ifdef CONFIG_YAFFS_WINCE
+ 		in->win_atime[0] = oh->win_atime[0];
+ 		in->win_ctime[0] = oh->win_ctime[0];
+ 		in->win_mtime[0] = oh->win_mtime[0];
+ 		in->win_atime[1] = oh->win_atime[1];
+ 		in->win_ctime[1] = oh->win_ctime[1];
+ 		in->win_mtime[1] = oh->win_mtime[1];
+ #else
+ 		in->yst_uid = oh->yst_uid;
+ 		in->yst_gid = oh->yst_gid;
+ 		in->yst_atime = oh->yst_atime;
+ 		in->yst_mtime = oh->yst_mtime;
+ 		in->yst_ctime = oh->yst_ctime;
+ 		in->yst_rdev = oh->yst_rdev;
+ 
+ #endif
+ 		yaffs_SetObjectName(in, oh->name);
+ 
+ 		if (in->variantType == YAFFS_OBJECT_TYPE_SYMLINK) {
+ 			in->variant.symLinkVariant.alias =
+ 						    yaffs_CloneString(oh->alias);
+ 			if (!in->variant.symLinkVariant.alias)
+ 				alloc_failed = 1; /* Not returned to caller */
+ 		}
+ 
+ 		yaffs_ReleaseTempBuffer(dev, chunkData, __LINE__);
+ 	}
+ }
+ 
+ static int yaffs_ScanBackwards(yaffs_Device *dev)
+ {
+ 	yaffs_ExtendedTags tags;
+ 	int blk;
+ 	int blockIterator;
+ 	int startIterator;
+ 	int endIterator;
+ 	int nBlocksToScan = 0;
+ 
+ 	int chunk;
+ 	int result;
+ 	int c;
+ 	int deleted;
+ 	yaffs_BlockState state;
+ 	yaffs_Object *hardList = NULL;
+ 	yaffs_BlockInfo *bi;
+ 	__u32 sequenceNumber;
+ 	yaffs_ObjectHeader *oh;
+ 	yaffs_Object *in;
+ 	yaffs_Object *parent;
+ 	int nBlocks = dev->internalEndBlock - dev->internalStartBlock + 1;
+ 	int itsUnlinked;
+ 	__u8 *chunkData;
+ 
+ 	int fileSize;
+ 	int isShrink;
+ 	int foundChunksInBlock;
+ 	int equivalentObjectId;
+ 	int alloc_failed = 0;
+ 
+ 
+ 	yaffs_BlockIndex *blockIndex = NULL;
+ 	int altBlockIndex = 0;
+ 
+ 	if (!dev->param.isYaffs2) {
+ 		T(YAFFS_TRACE_SCAN,
+ 		  (TSTR("yaffs_ScanBackwards is only for YAFFS2!" TENDSTR)));
+ 		return YAFFS_FAIL;
+ 	}
+ 
+ 	T(YAFFS_TRACE_SCAN,
+ 	  (TSTR
+ 	   ("yaffs_ScanBackwards starts  intstartblk %d intendblk %d..."
+ 	    TENDSTR), dev->internalStartBlock, dev->internalEndBlock));
+ 
+ 
+ 	dev->sequenceNumber = YAFFS_LOWEST_SEQUENCE_NUMBER;
+ 
+ 	blockIndex = YMALLOC(nBlocks * sizeof(yaffs_BlockIndex));
+ 
+ 	if (!blockIndex) {
+ 		blockIndex = YMALLOC_ALT(nBlocks * sizeof(yaffs_BlockIndex));
+ 		altBlockIndex = 1;
+ 	}
+ 
+ 	if (!blockIndex) {
+ 		T(YAFFS_TRACE_SCAN,
+ 		  (TSTR("yaffs_Scan() could not allocate block index!" TENDSTR)));
+ 		return YAFFS_FAIL;
+ 	}
+ 
+ 	dev->blocksInCheckpoint = 0;
+ 
+ 	chunkData = yaffs_GetTempBuffer(dev, __LINE__);
+ 
+ 	/* Scan all the blocks to determine their state */
+ 	bi = dev->blockInfo;
+ 	for (blk = dev->internalStartBlock; blk <= dev->internalEndBlock; blk++) {
+ 		yaffs_ClearChunkBits(dev, blk);
+ 		bi->pagesInUse = 0;
+ 		bi->softDeletions = 0;
+ 
+ 		yaffs_QueryInitialBlockState(dev, blk, &state, &sequenceNumber);
+ 
+ 		bi->blockState = state;
+ 		bi->sequenceNumber = sequenceNumber;
+ 
+ 		if (bi->sequenceNumber == YAFFS_SEQUENCE_CHECKPOINT_DATA)
+ 			bi->blockState = state = YAFFS_BLOCK_STATE_CHECKPOINT;
+ 		if (bi->sequenceNumber == YAFFS_SEQUENCE_BAD_BLOCK)
+ 			bi->blockState = state = YAFFS_BLOCK_STATE_DEAD;
+ 
+ 		T(YAFFS_TRACE_SCAN_DEBUG,
+ 		  (TSTR("Block scanning block %d state %d seq %d" TENDSTR), blk,
+ 		   state, sequenceNumber));
+ 
+ 
+ 		if (state == YAFFS_BLOCK_STATE_CHECKPOINT) {
+ 			dev->blocksInCheckpoint++;
+ 
+ 		} else if (state == YAFFS_BLOCK_STATE_DEAD) {
+ 			T(YAFFS_TRACE_BAD_BLOCKS,
+ 			  (TSTR("block %d is bad" TENDSTR), blk));
+ 		} else if (state == YAFFS_BLOCK_STATE_EMPTY) {
+ 			T(YAFFS_TRACE_SCAN_DEBUG,
+ 			  (TSTR("Block empty " TENDSTR)));
+ 			dev->nErasedBlocks++;
+ 			dev->nFreeChunks += dev->param.nChunksPerBlock;
+ 		} else if (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING) {
+ 
+ 			/* Determine the highest sequence number */
+ 			if (sequenceNumber >= YAFFS_LOWEST_SEQUENCE_NUMBER &&
+ 			    sequenceNumber < YAFFS_HIGHEST_SEQUENCE_NUMBER) {
+ 
+ 				blockIndex[nBlocksToScan].seq = sequenceNumber;
+ 				blockIndex[nBlocksToScan].block = blk;
+ 
+ 				nBlocksToScan++;
+ 
+ 				if (sequenceNumber >= dev->sequenceNumber)
+ 					dev->sequenceNumber = sequenceNumber;
+ 			} else {
+ 				/* TODO: Nasty sequence number! */
+ 				T(YAFFS_TRACE_SCAN,
+ 				  (TSTR
+ 				   ("Block scanning block %d has bad sequence number %d"
+ 				    TENDSTR), blk, sequenceNumber));
+ 
+ 			}
+ 		}
+ 		bi++;
+ 	}
+ 
+ 	T(YAFFS_TRACE_SCAN,
+ 	(TSTR("%d blocks to be sorted..." TENDSTR), nBlocksToScan));
+ 
+ 
+ 
+ 	YYIELD();
+ 
+ 	/* Sort the blocks */
+ #ifndef CONFIG_YAFFS_USE_OWN_SORT
+ 	{
+ 		/* Use qsort now. */
+ 		yaffs_qsort(blockIndex, nBlocksToScan, sizeof(yaffs_BlockIndex), ybicmp);
+ 	}
+ #else
+ 	{
+ 		/* Dungy old bubble sort... */
+ 
+ 		yaffs_BlockIndex temp;
+ 		int i;
+ 		int j;
+ 
+ 		for (i = 0; i < nBlocksToScan; i++)
+ 			for (j = i + 1; j < nBlocksToScan; j++)
+ 				if (blockIndex[i].seq > blockIndex[j].seq) {
+ 					temp = blockIndex[j];
+ 					blockIndex[j] = blockIndex[i];
+ 					blockIndex[i] = temp;
+ 				}
+ 	}
+ #endif
+ 
+ 	YYIELD();
+ 
+ 	T(YAFFS_TRACE_SCAN, (TSTR("...done" TENDSTR)));
+ 
+ 	/* Now scan the blocks looking at the data. */
+ 	startIterator = 0;
+ 	endIterator = nBlocksToScan - 1;
+ 	T(YAFFS_TRACE_SCAN_DEBUG,
+ 	  (TSTR("%d blocks to be scanned" TENDSTR), nBlocksToScan));
+ 
+ 	/* For each block.... backwards */
+ 	for (blockIterator = endIterator; !alloc_failed && blockIterator >= startIterator;
+ 			blockIterator--) {
+ 		/* Cooperative multitasking! This loop can run for so
+ 		   long that watchdog timers expire. */
+ 		YYIELD();
+ 
+ 		/* get the block to scan in the correct order */
+ 		blk = blockIndex[blockIterator].block;
+ 
+ 		bi = yaffs_GetBlockInfo(dev, blk);
+ 
+ 
+ 		state = bi->blockState;
+ 
+ 		deleted = 0;
+ 
+ 		/* For each chunk in each block that needs scanning.... */
+ 		foundChunksInBlock = 0;
+ 		for (c = dev->param.nChunksPerBlock - 1;
+ 		     !alloc_failed && c >= 0 &&
+ 		     (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING ||
+ 		      state == YAFFS_BLOCK_STATE_ALLOCATING); c--) {
+ 			/* Scan backwards...
+ 			 * Read the tags and decide what to do
+ 			 */
+ 
+ 			chunk = blk * dev->param.nChunksPerBlock + c;
+ 
+ 			result = yaffs_ReadChunkWithTagsFromNAND(dev, chunk, NULL,
+ 							&tags);
+ 
+ 			/* Let's have a good look at this chunk... */
+ 
+ 			if (!tags.chunkUsed) {
+ 				/* An unassigned chunk in the block.
+ 				 * If there are used chunks after this one, then
+ 				 * it is a chunk that was skipped due to failing the erased
+ 				 * check. Just skip it so that it can be deleted.
+ 				 * But, more typically, We get here when this is an unallocated
+ 				 * chunk and his means that either the block is empty or
+ 				 * this is the one being allocated from
+ 				 */
+ 
+ 				if (foundChunksInBlock) {
+ 					/* This is a chunk that was skipped due to failing the erased check */
+ 				} else if (c == 0) {
+ 					/* We're looking at the first chunk in the block so the block is unused */
+ 					state = YAFFS_BLOCK_STATE_EMPTY;
+ 					dev->nErasedBlocks++;
+ 				} else {
+ 					if (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING ||
+ 					    state == YAFFS_BLOCK_STATE_ALLOCATING) {
+ 						if (dev->sequenceNumber == bi->sequenceNumber) {
+ 							/* this is the block being allocated from */
+ 
+ 							T(YAFFS_TRACE_SCAN,
+ 							  (TSTR
+ 							   (" Allocating from %d %d"
+ 							    TENDSTR), blk, c));
+ 
+ 							state = YAFFS_BLOCK_STATE_ALLOCATING;
+ 							dev->allocationBlock = blk;
+ 							dev->allocationPage = c;
+ 							dev->allocationBlockFinder = blk;
+ 						} else {
+ 							/* This is a partially written block that is not
+ 							 * the current allocation block.
+ 							 */
+ 
+ 							 T(YAFFS_TRACE_SCAN,
+ 							 (TSTR("Partially written block %d detected" TENDSTR),
+ 							 blk));
+ 						}
+ 					}
+ 				}
+ 
+ 				dev->nFreeChunks++;
+ 
+ 			} else if (tags.eccResult == YAFFS_ECC_RESULT_UNFIXED) {
+ 				T(YAFFS_TRACE_SCAN,
+ 				  (TSTR(" Unfixed ECC in chunk(%d:%d), chunk ignored"TENDSTR),
+ 				  blk, c));
+ 
+ 				  dev->nFreeChunks++;
+ 
+ 			} else if (tags.chunkId > 0) {
+ 				/* chunkId > 0 so it is a data chunk... */
+ 				unsigned int endpos;
+ 				__u32 chunkBase =
+ 				    (tags.chunkId - 1) * dev->nDataBytesPerChunk;
+ 
+ 				foundChunksInBlock = 1;
+ 
+ 
+ 				yaffs_SetChunkBit(dev, blk, c);
+ 				bi->pagesInUse++;
+ 
+ 				in = yaffs_FindOrCreateObjectByNumber(dev,
+ 								      tags.
+ 								      objectId,
+ 								      YAFFS_OBJECT_TYPE_FILE);
+ 				if (!in) {
+ 					/* Out of memory */
+ 					alloc_failed = 1;
+ 				}
+ 
+ 				if (in &&
+ 				    in->variantType == YAFFS_OBJECT_TYPE_FILE
+ 				    && chunkBase < in->variant.fileVariant.shrinkSize) {
+ 					/* This has not been invalidated by a resize */
+ 					if (!yaffs_PutChunkIntoFile(in, tags.chunkId, chunk, -1)) {
+ 						alloc_failed = 1;
+ 					}
+ 
+ 					/* File size is calculated by looking at the data chunks if we have not
+ 					 * seen an object header yet. Stop this practice once we find an object header.
+ 					 */
+ 					endpos = chunkBase + tags.byteCount;
+ 
+ 					if (!in->valid &&	/* have not got an object header yet */
+ 					    in->variant.fileVariant.scannedFileSize < endpos) {
+ 						in->variant.fileVariant.scannedFileSize = endpos;
+ 						in->variant.fileVariant.fileSize = endpos;
+ 					}
+ 
+ 				} else if (in) {
+ 					/* This chunk has been invalidated by a resize, or a past file deletion
+ 					 * so delete the chunk*/
+ 					yaffs_DeleteChunk(dev, chunk, 1, __LINE__);
+ 
+ 				}
+ 			} else {
+ 				/* chunkId == 0, so it is an ObjectHeader.
+ 				 * Thus, we read in the object header and make the object
+ 				 */
+ 				foundChunksInBlock = 1;
+ 
+ 				yaffs_SetChunkBit(dev, blk, c);
+ 				bi->pagesInUse++;
+ 
+ 				oh = NULL;
+ 				in = NULL;
+ 
+ 				if (tags.extraHeaderInfoAvailable) {
+ 					in = yaffs_FindOrCreateObjectByNumber(dev,
+ 						tags.objectId,
+ 						tags.extraObjectType);
+ 					if (!in)
+ 						alloc_failed = 1;
+ 				}
+ 
+ 				if (!in ||
+ 				    (!in->valid && dev->param.disableLazyLoad) ||
+ 				    tags.extraShadows ||
+ 				    (!in->valid &&
+ 				    (tags.objectId == YAFFS_OBJECTID_ROOT ||
+ 				     tags.objectId == YAFFS_OBJECTID_LOSTNFOUND))) {
+ 
+ 					/* If we don't have  valid info then we need to read the chunk
+ 					 * TODO In future we can probably defer reading the chunk and
+ 					 * living with invalid data until needed.
+ 					 */
+ 
+ 					result = yaffs_ReadChunkWithTagsFromNAND(dev,
+ 									chunk,
+ 									chunkData,
+ 									NULL);
+ 
+ 					oh = (yaffs_ObjectHeader *) chunkData;
+ 
+ 					if (dev->param.inbandTags) {
+ 						/* Fix up the header if they got corrupted by inband tags */
+ 						oh->shadowsObject = oh->inbandShadowsObject;
+ 						oh->isShrink = oh->inbandIsShrink;
+ 					}
+ 
+ 					if (!in) {
+ 						in = yaffs_FindOrCreateObjectByNumber(dev, tags.objectId, oh->type);
+ 						if (!in)
+ 							alloc_failed = 1;
+ 					}
+ 
+ 				}
+ 
+ 				if (!in) {
+ 					/* TODO Hoosterman we have a problem! */
+ 					T(YAFFS_TRACE_ERROR,
+ 					  (TSTR
+ 					   ("yaffs tragedy: Could not make object for object  %d at chunk %d during scan"
+ 					    TENDSTR), tags.objectId, chunk));
+ 					continue;
+ 				}
+ 
+ 				if (in->valid) {
+ 					/* We have already filled this one.
+ 					 * We have a duplicate that will be discarded, but
+ 					 * we first have to suck out resize info if it is a file.
+ 					 */
+ 
+ 					if ((in->variantType == YAFFS_OBJECT_TYPE_FILE) &&
+ 					     ((oh &&
+ 					       oh->type == YAFFS_OBJECT_TYPE_FILE) ||
+ 					      (tags.extraHeaderInfoAvailable  &&
+ 					       tags.extraObjectType == YAFFS_OBJECT_TYPE_FILE))) {
+ 						__u32 thisSize =
+ 						    (oh) ? oh->fileSize : tags.
+ 						    extraFileLength;
+ 						__u32 parentObjectId =
+ 						    (oh) ? oh->
+ 						    parentObjectId : tags.
+ 						    extraParentObjectId;
+ 
+ 
+ 						isShrink =
+ 						    (oh) ? oh->isShrink : tags.
+ 						    extraIsShrinkHeader;
+ 
+ 						/* If it is deleted (unlinked at start also means deleted)
+ 						 * we treat the file size as being zeroed at this point.
+ 						 */
+ 						if (parentObjectId ==
+ 						    YAFFS_OBJECTID_DELETED
+ 						    || parentObjectId ==
+ 						    YAFFS_OBJECTID_UNLINKED) {
+ 							thisSize = 0;
+ 							isShrink = 1;
+ 						}
+ 
+ 						if (isShrink && in->variant.fileVariant.shrinkSize > thisSize)
+ 							in->variant.fileVariant.shrinkSize = thisSize;
+ 
+ 						if (isShrink)
+ 							bi->hasShrinkHeader = 1;
+ 
+ 					}
+ 					/* Use existing - destroy this one. */
+ 					yaffs_DeleteChunk(dev, chunk, 1, __LINE__);
+ 
+ 				}
+ 
+ 				if (!in->valid && in->variantType !=
+ 				    (oh ? oh->type : tags.extraObjectType))
+ 					T(YAFFS_TRACE_ERROR, (
+ 						TSTR("yaffs tragedy: Bad object type, "
+ 					    TCONT("%d != %d, for object %d at chunk ")
+ 					    TCONT("%d during scan")
+ 						TENDSTR), oh ?
+ 					    oh->type : tags.extraObjectType,
+ 					    in->variantType, tags.objectId,
+ 					    chunk));
+ 
+ 				if (!in->valid &&
+ 				    (tags.objectId == YAFFS_OBJECTID_ROOT ||
+ 				     tags.objectId ==
+ 				     YAFFS_OBJECTID_LOSTNFOUND)) {
+ 					/* We only load some info, don't fiddle with directory structure */
+ 					in->valid = 1;
+ 
+ 					if (oh) {
+ 						in->variantType = oh->type;
+ 
+ 						in->yst_mode = oh->yst_mode;
+ #ifdef CONFIG_YAFFS_WINCE
+ 						in->win_atime[0] = oh->win_atime[0];
+ 						in->win_ctime[0] = oh->win_ctime[0];
+ 						in->win_mtime[0] = oh->win_mtime[0];
+ 						in->win_atime[1] = oh->win_atime[1];
+ 						in->win_ctime[1] = oh->win_ctime[1];
+ 						in->win_mtime[1] = oh->win_mtime[1];
+ #else
+ 						in->yst_uid = oh->yst_uid;
+ 						in->yst_gid = oh->yst_gid;
+ 						in->yst_atime = oh->yst_atime;
+ 						in->yst_mtime = oh->yst_mtime;
+ 						in->yst_ctime = oh->yst_ctime;
+ 						in->yst_rdev = oh->yst_rdev;
+ 
+ #endif
+ 					} else {
+ 						in->variantType = tags.extraObjectType;
+ 						in->lazyLoaded = 1;
+ 					}
+ 
+ 					in->hdrChunk = chunk;
+ 
+ 				} else if (!in->valid) {
+ 					/* we need to load this info */
+ 
+ 					in->valid = 1;
+ 					in->hdrChunk = chunk;
+ 
+ 					if (oh) {
+ 						in->variantType = oh->type;
+ 
+ 						in->yst_mode = oh->yst_mode;
+ #ifdef CONFIG_YAFFS_WINCE
+ 						in->win_atime[0] = oh->win_atime[0];
+ 						in->win_ctime[0] = oh->win_ctime[0];
+ 						in->win_mtime[0] = oh->win_mtime[0];
+ 						in->win_atime[1] = oh->win_atime[1];
+ 						in->win_ctime[1] = oh->win_ctime[1];
+ 						in->win_mtime[1] = oh->win_mtime[1];
+ #else
+ 						in->yst_uid = oh->yst_uid;
+ 						in->yst_gid = oh->yst_gid;
+ 						in->yst_atime = oh->yst_atime;
+ 						in->yst_mtime = oh->yst_mtime;
+ 						in->yst_ctime = oh->yst_ctime;
+ 						in->yst_rdev = oh->yst_rdev;
+ #endif
+ 
+ 						if (oh->shadowsObject > 0)
+ 							yaffs_HandleShadowedObject(dev,
+ 									   oh->
+ 									   shadowsObject,
+ 									   1);
+ 							
+ 
+ 
+ 						yaffs_SetObjectName(in, oh->name);
+ 						parent =
+ 						    yaffs_FindOrCreateObjectByNumber
+ 							(dev, oh->parentObjectId,
+ 							 YAFFS_OBJECT_TYPE_DIRECTORY);
+ 
+ 						 fileSize = oh->fileSize;
+ 						 isShrink = oh->isShrink;
+ 						 equivalentObjectId = oh->equivalentObjectId;
+ 
+ 					} else {
+ 						in->variantType = tags.extraObjectType;
+ 						parent =
+ 						    yaffs_FindOrCreateObjectByNumber
+ 							(dev, tags.extraParentObjectId,
+ 							 YAFFS_OBJECT_TYPE_DIRECTORY);
+ 						 fileSize = tags.extraFileLength;
+ 						 isShrink = tags.extraIsShrinkHeader;
+ 						 equivalentObjectId = tags.extraEquivalentObjectId;
+ 						in->lazyLoaded = 1;
+ 
+ 					}
+ 					in->dirty = 0;
+ 
+ 					if (!parent)
+ 						alloc_failed = 1;
+ 
+ 					/* directory stuff...
+ 					 * hook up to parent
+ 					 */
+ 
+ 					if (parent && parent->variantType ==
+ 					    YAFFS_OBJECT_TYPE_UNKNOWN) {
+ 						/* Set up as a directory */
+ 						parent->variantType =
+ 							YAFFS_OBJECT_TYPE_DIRECTORY;
+ 						YINIT_LIST_HEAD(&parent->variant.
+ 							directoryVariant.
+ 							children);
+ 					} else if (!parent || parent->variantType !=
+ 						   YAFFS_OBJECT_TYPE_DIRECTORY) {
+ 						/* Hoosterman, another problem....
+ 						 * We're trying to use a non-directory as a directory
+ 						 */
+ 
+ 						T(YAFFS_TRACE_ERROR,
+ 						  (TSTR
+ 						   ("yaffs tragedy: attempting to use non-directory as a directory in scan. Put in lost+found."
+ 						    TENDSTR)));
+ 						parent = dev->lostNFoundDir;
+ 					}
+ 
+ 					yaffs_AddObjectToDirectory(parent, in);
+ 
+ 					itsUnlinked = (parent == dev->deletedDir) ||
+ 						      (parent == dev->unlinkedDir);
+ 
+ 					if (isShrink) {
+ 						/* Mark the block as having a shrinkHeader */
+ 						bi->hasShrinkHeader = 1;
+ 					}
+ 
+ 					/* Note re hardlinks.
+ 					 * Since we might scan a hardlink before its equivalent object is scanned
+ 					 * we put them all in a list.
+ 					 * After scanning is complete, we should have all the objects, so we run
+ 					 * through this list and fix up all the chains.
+ 					 */
+ 
+ 					switch (in->variantType) {
+ 					case YAFFS_OBJECT_TYPE_UNKNOWN:
+ 						/* Todo got a problem */
+ 						break;
+ 					case YAFFS_OBJECT_TYPE_FILE:
+ 
+ 						if (in->variant.fileVariant.
+ 						    scannedFileSize < fileSize) {
+ 							/* This covers the case where the file size is greater
+ 							 * than where the data is
+ 							 * This will happen if the file is resized to be larger
+ 							 * than its current data extents.
+ 							 */
+ 							in->variant.fileVariant.fileSize = fileSize;
+ 							in->variant.fileVariant.scannedFileSize = fileSize;
+ 						}
+ 
+ 						if (in->variant.fileVariant.shrinkSize > fileSize)
+ 							in->variant.fileVariant.shrinkSize = fileSize;
+ 				
+ 
+ 						break;
+ 					case YAFFS_OBJECT_TYPE_HARDLINK:
+ 						if (!itsUnlinked) {
+ 							in->variant.hardLinkVariant.equivalentObjectId =
+ 								equivalentObjectId;
+ 							in->hardLinks.next =
+ 								(struct ylist_head *) hardList;
+ 							hardList = in;
+ 						}
+ 						break;
+ 					case YAFFS_OBJECT_TYPE_DIRECTORY:
+ 						/* Do nothing */
+ 						break;
+ 					case YAFFS_OBJECT_TYPE_SPECIAL:
+ 						/* Do nothing */
+ 						break;
+ 					case YAFFS_OBJECT_TYPE_SYMLINK:
+ 						if (oh) {
+ 							in->variant.symLinkVariant.alias =
+ 								yaffs_CloneString(oh->alias);
+ 							if (!in->variant.symLinkVariant.alias)
+ 								alloc_failed = 1;
+ 						}
+ 						break;
+ 					}
+ 
+ 				}
+ 
+ 			}
+ 
+ 		} /* End of scanning for each chunk */
+ 
+ 		if (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING) {
+ 			/* If we got this far while scanning, then the block is fully allocated. */
+ 			state = YAFFS_BLOCK_STATE_FULL;
+ 		}
+ 
+ 
+ 		bi->blockState = state;
+ 
+ 		/* Now let's see if it was dirty */
+ 		if (bi->pagesInUse == 0 &&
+ 		    !bi->hasShrinkHeader &&
+ 		    bi->blockState == YAFFS_BLOCK_STATE_FULL) {
+ 			yaffs_BlockBecameDirty(dev, blk);
+ 		}
+ 
+ 	}
+ 	
+ 	yaffs_SkipRestOfBlock(dev);
+ 
+ 	if (altBlockIndex)
+ 		YFREE_ALT(blockIndex);
+ 	else
+ 		YFREE(blockIndex);
+ 
+ 	/* Ok, we've done all the scanning.
+ 	 * Fix up the hard link chains.
+ 	 * We should now have scanned all the objects, now it's time to add these
+ 	 * hardlinks.
+ 	 */
+ 	yaffs_HardlinkFixup(dev, hardList);
+ 
+ 
+ 	yaffs_ReleaseTempBuffer(dev, chunkData, __LINE__);
+ 
+ 	if (alloc_failed)
+ 		return YAFFS_FAIL;
+ 
+ 	T(YAFFS_TRACE_SCAN, (TSTR("yaffs_ScanBackwards ends" TENDSTR)));
+ 
+ 	return YAFFS_OK;
+ }
+ 
+ /*------------------------------  Directory Functions ----------------------------- */
+ 
+ static void yaffs_VerifyObjectInDirectory(yaffs_Object *obj)
+ {
+ 	struct ylist_head *lh;
+ 	yaffs_Object *listObj;
+ 
+ 	int count = 0;
+ 
+ 	if (!obj) {
+ 		T(YAFFS_TRACE_ALWAYS, (TSTR("No object to verify" TENDSTR)));
+ 		YBUG();
+ 		return;
+ 	}
+ 
+ 	if (yaffs_SkipVerification(obj->myDev))
+ 		return;
+ 
+ 	if (!obj->parent) {
+ 		T(YAFFS_TRACE_ALWAYS, (TSTR("Object does not have parent" TENDSTR)));
+ 		YBUG();
+ 		return;
+ 	}
+ 
+ 	if (obj->parent->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
+ 		T(YAFFS_TRACE_ALWAYS, (TSTR("Parent is not directory" TENDSTR)));
+ 		YBUG();
+ 	}
+ 
+ 	/* Iterate through the objects in each hash entry */
+ 
+ 	ylist_for_each(lh, &obj->parent->variant.directoryVariant.children) {
+ 		if (lh) {
+ 			listObj = ylist_entry(lh, yaffs_Object, siblings);
+ 			yaffs_VerifyObject(listObj);
+ 			if (obj == listObj)
+ 				count++;
+ 		}
+ 	 }
+ 
+ 	if (count != 1) {
+ 		T(YAFFS_TRACE_ALWAYS, (TSTR("Object in directory %d times" TENDSTR), count));
+ 		YBUG();
+ 	}
+ }
+ 
+ static void yaffs_VerifyDirectory(yaffs_Object *directory)
+ {
+ 	struct ylist_head *lh;
+ 	yaffs_Object *listObj;
+ 
+ 	if (!directory) {
+ 		YBUG();
+ 		return;
+ 	}
+ 
+ 	if (yaffs_SkipFullVerification(directory->myDev))
+ 		return;
+ 
+ 	if (directory->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
+ 		T(YAFFS_TRACE_ALWAYS, (TSTR("Directory has wrong type: %d" TENDSTR), directory->variantType));
+ 		YBUG();
+ 	}
+ 
+ 	/* Iterate through the objects in each hash entry */
+ 
+ 	ylist_for_each(lh, &directory->variant.directoryVariant.children) {
+ 		if (lh) {
+ 			listObj = ylist_entry(lh, yaffs_Object, siblings);
+ 			if (listObj->parent != directory) {
+ 				T(YAFFS_TRACE_ALWAYS, (TSTR("Object in directory list has wrong parent %p" TENDSTR), listObj->parent));
+ 				YBUG();
+ 			}
+ 			yaffs_VerifyObjectInDirectory(listObj);
+ 		}
+ 	}
+ }
+ 
+ /*
+  *yaffs_UpdateParent() handles fixing a directories mtime and ctime when a new
+  * link (ie. name) is created or deleted in the directory.
+  *
+  * ie.
+  *   create dir/a : update dir's mtime/ctime
+  *   rm dir/a:   update dir's mtime/ctime
+  *   modify dir/a: don't update dir's mtimme/ctime
+  *
+  * This can be handled immediately or defered. Defering helps reduce the number
+  * of updates when many files in a directory are changed within a brief period.
+  *
+  * If the directory updating is defered then yaffs_UpdateDirtyDirecories must be
+  * called periodically.
+  */
+  
+ static void yaffs_UpdateParent(yaffs_Object *obj)
+ {
+ 	yaffs_Device *dev;
+ 	if(!obj)
+ 		return;
+ 
+ 	dev = obj->myDev;
+ 	obj->dirty = 1;
+ 	obj->yst_mtime = obj->yst_ctime = Y_CURRENT_TIME;
+ 	if(dev->param.deferDirectoryUpdate){
+ 		struct ylist_head *link = &obj->variant.directoryVariant.dirty; 
+ 	
+ 		if(ylist_empty(link)){
+ 			ylist_add(link,&dev->dirtyDirectories);
+ 			T(YAFFS_TRACE_BACKGROUND, (TSTR("Added object %d to dirty directories" TENDSTR),obj->objectId));
+ 		}
+ 
+ 	} else
+ 		yaffs_UpdateObjectHeader(obj,NULL,0,0,0);
+ }
+ 
+ void yaffs_UpdateDirtyDirectories(yaffs_Device *dev)
+ {
+ 	struct ylist_head *link;
+ 	yaffs_Object *obj;
+ 	yaffs_DirectoryStructure *dS;
+ 	yaffs_ObjectVariant *oV;
+ 
+ 	T(YAFFS_TRACE_BACKGROUND, (TSTR("Update dirty directories" TENDSTR)));
+ 
+ 	while(!ylist_empty(&dev->dirtyDirectories)){
+ 		link = dev->dirtyDirectories.next;
+ 		ylist_del_init(link);
+ 		
+ 		dS=ylist_entry(link,yaffs_DirectoryStructure,dirty);
+ 		oV = ylist_entry(dS,yaffs_ObjectVariant,directoryVariant);
+ 		obj = ylist_entry(oV,yaffs_Object,variant);
+ 
+ 		T(YAFFS_TRACE_BACKGROUND, (TSTR("Update directory %d" TENDSTR), obj->objectId));
+ 
+ 		if(obj->dirty)
+ 			yaffs_UpdateObjectHeader(obj,NULL,0,0,0);
+ 	}
+ }
+ 
+ static void yaffs_RemoveObjectFromDirectory(yaffs_Object *obj)
+ {
+ 	yaffs_Device *dev = obj->myDev;
+ 	yaffs_Object *parent;
+ 
+ 	yaffs_VerifyObjectInDirectory(obj);
+ 	parent = obj->parent;
+ 
+ 	yaffs_VerifyDirectory(parent);
+ 
+ 	if (dev && dev->param.removeObjectCallback)
+ 		dev->param.removeObjectCallback(obj);
+ 
+ 
+ 	ylist_del_init(&obj->siblings);
+ 	obj->parent = NULL;
+ 	
+ 	yaffs_VerifyDirectory(parent);
+ }
+ 
+ static void yaffs_AddObjectToDirectory(yaffs_Object *directory,
+ 					yaffs_Object *obj)
+ {
+ 	if (!directory) {
+ 		T(YAFFS_TRACE_ALWAYS,
+ 		  (TSTR
+ 		   ("tragedy: Trying to add an object to a null pointer directory"
+ 		    TENDSTR)));
+ 		YBUG();
+ 		return;
+ 	}
+ 	if (directory->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
+ 		T(YAFFS_TRACE_ALWAYS,
+ 		  (TSTR
+ 		   ("tragedy: Trying to add an object to a non-directory"
+ 		    TENDSTR)));
+ 		YBUG();
+ 	}
+ 
+ 	if (obj->siblings.prev == NULL) {
+ 		/* Not initialised */
+ 		YBUG();
+ 	}
+ 
+ 
+ 	yaffs_VerifyDirectory(directory);
+ 
+ 	yaffs_RemoveObjectFromDirectory(obj);
+ 
+ 
+ 	/* Now add it */
+ 	ylist_add(&obj->siblings, &directory->variant.directoryVariant.children);
+ 	obj->parent = directory;
+ 
+ 	if (directory == obj->myDev->unlinkedDir
+ 			|| directory == obj->myDev->deletedDir) {
+ 		obj->unlinked = 1;
+ 		obj->myDev->nUnlinkedFiles++;
+ 		obj->renameAllowed = 0;
+ 	}
+ 
+ 	yaffs_VerifyDirectory(directory);
+ 	yaffs_VerifyObjectInDirectory(obj);
+ }
+ 
+ yaffs_Object *yaffs_FindObjectByName(yaffs_Object *directory,
+ 				     const YCHAR *name)
+ {
+ 	int sum;
+ 
+ 	struct ylist_head *i;
+ 	YCHAR buffer[YAFFS_MAX_NAME_LENGTH + 1];
+ 
+ 	yaffs_Object *l;
+ 
+ 	if (!name)
+ 		return NULL;
+ 
+ 	if (!directory) {
+ 		T(YAFFS_TRACE_ALWAYS,
+ 		  (TSTR
+ 		   ("tragedy: yaffs_FindObjectByName: null pointer directory"
+ 		    TENDSTR)));
+ 		YBUG();
+ 		return NULL;
+ 	}
+ 	if (directory->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
+ 		T(YAFFS_TRACE_ALWAYS,
+ 		  (TSTR
+ 		   ("tragedy: yaffs_FindObjectByName: non-directory" TENDSTR)));
+ 		YBUG();
+ 	}
+ 
+ 	sum = yaffs_CalcNameSum(name);
+ 
+ 	ylist_for_each(i, &directory->variant.directoryVariant.children) {
+ 		if (i) {
+ 			l = ylist_entry(i, yaffs_Object, siblings);
+ 
+ 			if (l->parent != directory)
+ 				YBUG();
+ 
+ 			yaffs_CheckObjectDetailsLoaded(l);
+ 
+ 			/* Special case for lost-n-found */
+ 			if (l->objectId == YAFFS_OBJECTID_LOSTNFOUND) {
+ 				if (yaffs_strcmp(name, YAFFS_LOSTNFOUND_NAME) == 0)
+ 					return l;
+ 			} else if (yaffs_SumCompare(l->sum, sum) || l->hdrChunk <= 0) {
+ 				/* LostnFound chunk called Objxxx
+ 				 * Do a real check
+ 				 */
+ 				yaffs_GetObjectName(l, buffer,
+ 						    YAFFS_MAX_NAME_LENGTH + 1);
+ 				if (yaffs_strncmp(name, buffer, YAFFS_MAX_NAME_LENGTH) == 0)
+ 					return l;
+ 			}
+ 		}
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ 
+ #if 0
+ int yaffs_ApplyToDirectoryChildren(yaffs_Object *theDir,
+ 					int (*fn) (yaffs_Object *))
+ {
+ 	struct ylist_head *i;
+ 	yaffs_Object *l;
+ 
+ 	if (!theDir) {
+ 		T(YAFFS_TRACE_ALWAYS,
+ 		  (TSTR
+ 		   ("tragedy: yaffs_FindObjectByName: null pointer directory"
+ 		    TENDSTR)));
+ 		YBUG();
+ 		return YAFFS_FAIL;
+ 	}
+ 	if (theDir->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
+ 		T(YAFFS_TRACE_ALWAYS,
+ 		  (TSTR
+ 		   ("tragedy: yaffs_FindObjectByName: non-directory" TENDSTR)));
+ 		YBUG();
+ 		return YAFFS_FAIL;
+ 	}
+ 
+ 	ylist_for_each(i, &theDir->variant.directoryVariant.children) {
+ 		if (i) {
+ 			l = ylist_entry(i, yaffs_Object, siblings);
+ 			if (l && !fn(l))
+ 				return YAFFS_FAIL;
+ 		}
+ 	}
+ 
+ 	return YAFFS_OK;
+ 
+ }
+ #endif
+ 
+ /* GetEquivalentObject dereferences any hard links to get to the
+  * actual object.
+  */
+ 
+ yaffs_Object *yaffs_GetEquivalentObject(yaffs_Object *obj)
+ {
+ 	if (obj && obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK) {
+ 		/* We want the object id of the equivalent object, not this one */
+ 		obj = obj->variant.hardLinkVariant.equivalentObject;
+ 		yaffs_CheckObjectDetailsLoaded(obj);
+ 	}
+ 	return obj;
+ }
+ 
+ int yaffs_GetObjectName(yaffs_Object *obj, YCHAR *name, int buffSize)
+ {
+ 	memset(name, 0, buffSize * sizeof(YCHAR));
+ 
+ 	yaffs_CheckObjectDetailsLoaded(obj);
+ 
+ 	if (obj->objectId == YAFFS_OBJECTID_LOSTNFOUND) {
+ 		yaffs_strncpy(name, YAFFS_LOSTNFOUND_NAME, buffSize - 1);
+ 	} else if (obj->hdrChunk <= 0) {
+ 		YCHAR locName[20];
+ 		YCHAR numString[20];
+ 		YCHAR *x = &numString[19];
+ 		unsigned v = obj->objectId;
+ 		numString[19] = 0;
+ 		while (v > 0) {
+ 			x--;
+ 			*x = '0' + (v % 10);
+ 			v /= 10;
+ 		}
+ 		/* make up a name */
+ 		yaffs_strcpy(locName, YAFFS_LOSTNFOUND_PREFIX);
+ 		yaffs_strcat(locName, x);
+ 		yaffs_strncpy(name, locName, buffSize - 1);
+ 
+ 	}
+ #ifdef CONFIG_YAFFS_SHORT_NAMES_IN_RAM
+ 	else if (obj->shortName[0])
+ 		yaffs_strncpy(name, obj->shortName,YAFFS_SHORT_NAME_LENGTH+1);
+ #endif
+ 	else {
+ 		int result;
+ 		__u8 *buffer = yaffs_GetTempBuffer(obj->myDev, __LINE__);
+ 
+ 		yaffs_ObjectHeader *oh = (yaffs_ObjectHeader *) buffer;
+ 
+ 		memset(buffer, 0, obj->myDev->nDataBytesPerChunk);
+ 
+ 		if (obj->hdrChunk > 0) {
+ 			result = yaffs_ReadChunkWithTagsFromNAND(obj->myDev,
+ 							obj->hdrChunk, buffer,
+ 							NULL);
+ 		}
+ 		yaffs_strncpy(name, oh->name, buffSize - 1);
+ 		name[buffSize-1]=0;
+ 
+ 		yaffs_ReleaseTempBuffer(obj->myDev, buffer, __LINE__);
+ 	}
+ 
+ 	return yaffs_strnlen(name,buffSize-1);
+ }
+ 
+ int yaffs_GetObjectFileLength(yaffs_Object *obj)
+ {
+ 	/* Dereference any hard linking */
+ 	obj = yaffs_GetEquivalentObject(obj);
+ 
+ 	if (obj->variantType == YAFFS_OBJECT_TYPE_FILE)
+ 		return obj->variant.fileVariant.fileSize;
+ 	if (obj->variantType == YAFFS_OBJECT_TYPE_SYMLINK){
+ 		if(!obj->variant.symLinkVariant.alias)
+ 			return 0;
+ 		return yaffs_strnlen(obj->variant.symLinkVariant.alias,YAFFS_MAX_ALIAS_LENGTH);
+ 	} else {
+ 		/* Only a directory should drop through to here */
+ 		return obj->myDev->nDataBytesPerChunk;
+ 	}
+ }
+ 
+ int yaffs_GetObjectLinkCount(yaffs_Object *obj)
+ {
+ 	int count = 0;
+ 	struct ylist_head *i;
+ 
+ 	if (!obj->unlinked)
+ 		count++;		/* the object itself */
+ 
+ 	ylist_for_each(i, &obj->hardLinks)
+ 		count++;		/* add the hard links; */
+ 
+ 	return count;
+ }
+ 
+ int yaffs_GetObjectInode(yaffs_Object *obj)
+ {
+ 	obj = yaffs_GetEquivalentObject(obj);
+ 
+ 	return obj->objectId;
+ }
+ 
+ unsigned yaffs_GetObjectType(yaffs_Object *obj)
+ {
+ 	obj = yaffs_GetEquivalentObject(obj);
+ 
+ 	switch (obj->variantType) {
+ 	case YAFFS_OBJECT_TYPE_FILE:
+ 		return DT_REG;
+ 		break;
+ 	case YAFFS_OBJECT_TYPE_DIRECTORY:
+ 		return DT_DIR;
+ 		break;
+ 	case YAFFS_OBJECT_TYPE_SYMLINK:
+ 		return DT_LNK;
+ 		break;
+ 	case YAFFS_OBJECT_TYPE_HARDLINK:
+ 		return DT_REG;
+ 		break;
+ 	case YAFFS_OBJECT_TYPE_SPECIAL:
+ 		if (S_ISFIFO(obj->yst_mode))
+ 			return DT_FIFO;
+ 		if (S_ISCHR(obj->yst_mode))
+ 			return DT_CHR;
+ 		if (S_ISBLK(obj->yst_mode))
+ 			return DT_BLK;
+ 		if (S_ISSOCK(obj->yst_mode))
+ 			return DT_SOCK;
+ 	default:
+ 		return DT_REG;
+ 		break;
+ 	}
+ }
+ 
+ YCHAR *yaffs_GetSymlinkAlias(yaffs_Object *obj)
+ {
+ 	obj = yaffs_GetEquivalentObject(obj);
+ 	if (obj->variantType == YAFFS_OBJECT_TYPE_SYMLINK)
+ 		return yaffs_CloneString(obj->variant.symLinkVariant.alias);
+ 	else
+ 		return yaffs_CloneString(_Y(""));
+ }
+ 
+ #ifndef CONFIG_YAFFS_WINCE
+ 
+ int yaffs_SetAttributes(yaffs_Object *obj, struct iattr *attr)
+ {
+ 	unsigned int valid = attr->ia_valid;
+ 
+ 	if (valid & ATTR_MODE)
+ 		obj->yst_mode = attr->ia_mode;
+ 	if (valid & ATTR_UID)
+ 		obj->yst_uid = attr->ia_uid;
+ 	if (valid & ATTR_GID)
+ 		obj->yst_gid = attr->ia_gid;
+ 
+ 	if (valid & ATTR_ATIME)
+ 		obj->yst_atime = Y_TIME_CONVERT(attr->ia_atime);
+ 	if (valid & ATTR_CTIME)
+ 		obj->yst_ctime = Y_TIME_CONVERT(attr->ia_ctime);
+ 	if (valid & ATTR_MTIME)
+ 		obj->yst_mtime = Y_TIME_CONVERT(attr->ia_mtime);
+ 
+ 	if (valid & ATTR_SIZE)
+ 		yaffs_ResizeFile(obj, attr->ia_size);
+ 
+ 	yaffs_UpdateObjectHeader(obj, NULL, 1, 0, 0);
+ 
+ 	return YAFFS_OK;
+ 
+ }
+ int yaffs_GetAttributes(yaffs_Object *obj, struct iattr *attr)
+ {
+ 	unsigned int valid = 0;
+ 
+ 	attr->ia_mode = obj->yst_mode;
+ 	valid |= ATTR_MODE;
+ 	attr->ia_uid = obj->yst_uid;
+ 	valid |= ATTR_UID;
+ 	attr->ia_gid = obj->yst_gid;
+ 	valid |= ATTR_GID;
+ 
+ 	Y_TIME_CONVERT(attr->ia_atime) = obj->yst_atime;
+ 	valid |= ATTR_ATIME;
+ 	Y_TIME_CONVERT(attr->ia_ctime) = obj->yst_ctime;
+ 	valid |= ATTR_CTIME;
+ 	Y_TIME_CONVERT(attr->ia_mtime) = obj->yst_mtime;
+ 	valid |= ATTR_MTIME;
+ 
+ 	attr->ia_size = yaffs_GetFileSize(obj);
+ 	valid |= ATTR_SIZE;
+ 
+ 	attr->ia_valid = valid;
+ 
+ 	return YAFFS_OK;
+ }
+ 
+ #endif
+ 
+ #if 0
+ int yaffs_DumpObject(yaffs_Object *obj)
+ {
+ 	YCHAR name[257];
+ 
+ 	yaffs_GetObjectName(obj, name, YAFFS_MAX_NAME_LENGTH + 1);
+ 
+ 	T(YAFFS_TRACE_ALWAYS,
+ 	  (TSTR
+ 	   ("Object %d, inode %d \"%s\"\n dirty %d valid %d serial %d sum %d"
+ 	    " chunk %d type %d size %d\n"
+ 	    TENDSTR), obj->objectId, yaffs_GetObjectInode(obj), name,
+ 	   obj->dirty, obj->valid, obj->serial, obj->sum, obj->hdrChunk,
+ 	   yaffs_GetObjectType(obj), yaffs_GetObjectFileLength(obj)));
+ 
+ 	return YAFFS_OK;
+ }
+ #endif
+ 
+ /*---------------------------- Initialisation code -------------------------------------- */
+ 
+ static int yaffs_CheckDevFunctions(const yaffs_Device *dev)
+ {
+ 
+ 	/* Common functions, gotta have */
+ 	if (!dev->param.eraseBlockInNAND || !dev->param.initialiseNAND)
+ 		return 0;
+ 
+ #ifdef CONFIG_YAFFS_YAFFS2
+ 
+ 	/* Can use the "with tags" style interface for yaffs1 or yaffs2 */
+ 	if (dev->param.writeChunkWithTagsToNAND &&
+ 	    dev->param.readChunkWithTagsFromNAND &&
+ 	    !dev->param.writeChunkToNAND &&
+ 	    !dev->param.readChunkFromNAND &&
+ 	    dev->param.markNANDBlockBad &&
+ 	    dev->param.queryNANDBlock)
+ 		return 1;
+ #endif
+ 
+ 	/* Can use the "spare" style interface for yaffs1 */
+ 	if (!dev->param.isYaffs2 &&
+ 	    !dev->param.writeChunkWithTagsToNAND &&
+ 	    !dev->param.readChunkWithTagsFromNAND &&
+ 	    dev->param.writeChunkToNAND &&
+ 	    dev->param.readChunkFromNAND &&
+ 	    !dev->param.markNANDBlockBad &&
+ 	    !dev->param.queryNANDBlock)
+ 		return 1;
+ 
+ 	return 0;	/* bad */
+ }
+ 
+ 
+ static int yaffs_CreateInitialDirectories(yaffs_Device *dev)
+ {
+ 	/* Initialise the unlinked, deleted, root and lost and found directories */
+ 
+ 	dev->lostNFoundDir = dev->rootDir =  NULL;
+ 	dev->unlinkedDir = dev->deletedDir = NULL;
+ 
+ 	dev->unlinkedDir =
+ 	    yaffs_CreateFakeDirectory(dev, YAFFS_OBJECTID_UNLINKED, S_IFDIR);
+ 
+ 	dev->deletedDir =
+ 	    yaffs_CreateFakeDirectory(dev, YAFFS_OBJECTID_DELETED, S_IFDIR);
+ 
+ 	dev->rootDir =
+ 	    yaffs_CreateFakeDirectory(dev, YAFFS_OBJECTID_ROOT,
+ 				      YAFFS_ROOT_MODE | S_IFDIR);
+ 	dev->lostNFoundDir =
+ 	    yaffs_CreateFakeDirectory(dev, YAFFS_OBJECTID_LOSTNFOUND,
+ 				      YAFFS_LOSTNFOUND_MODE | S_IFDIR);
+ 
+ 	if (dev->lostNFoundDir && dev->rootDir && dev->unlinkedDir && dev->deletedDir) {
+ 		yaffs_AddObjectToDirectory(dev->rootDir, dev->lostNFoundDir);
+ 		return YAFFS_OK;
+ 	}
+ 
+ 	return YAFFS_FAIL;
+ }
+ 
+ int yaffs_GutsInitialise(yaffs_Device *dev)
+ {
+ 	int init_failed = 0;
+ 	unsigned x;
+ 	int bits;
+ 
+ 	T(YAFFS_TRACE_TRACING, (TSTR("yaffs: yaffs_GutsInitialise()" TENDSTR)));
+ 
+ 	/* Check stuff that must be set */
+ 
+ 	if (!dev) {
+ 		T(YAFFS_TRACE_ALWAYS, (TSTR("yaffs: Need a device" TENDSTR)));
+ 		return YAFFS_FAIL;
+ 	}
+ 
+ 	dev->internalStartBlock = dev->param.startBlock;
+ 	dev->internalEndBlock = dev->param.endBlock;
+ 	dev->blockOffset = 0;
+ 	dev->chunkOffset = 0;
+ 	dev->nFreeChunks = 0;
+ 
+ 	dev->gcBlock = 0;
+ 
+ 	if (dev->param.startBlock == 0) {
+ 		dev->internalStartBlock = dev->param.startBlock + 1;
+ 		dev->internalEndBlock = dev->param.endBlock + 1;
+ 		dev->blockOffset = 1;
+ 		dev->chunkOffset = dev->param.nChunksPerBlock;
+ 	}
+ 
+ 	/* Check geometry parameters. */
+ 
+ 	if ((!dev->param.inbandTags && dev->param.isYaffs2 && dev->param.totalBytesPerChunk < 1024) ||
+ 	    (!dev->param.isYaffs2 && dev->param.totalBytesPerChunk < 512) ||
+ 	    (dev->param.inbandTags && !dev->param.isYaffs2) ||
+ 	     dev->param.nChunksPerBlock < 2 ||
+ 	     dev->param.nReservedBlocks < 2 ||
+ 	     dev->internalStartBlock <= 0 ||
+ 	     dev->internalEndBlock <= 0 ||
+ 	     dev->internalEndBlock <= (dev->internalStartBlock + dev->param.nReservedBlocks + 2)) {	/* otherwise it is too small */
+ 		T(YAFFS_TRACE_ALWAYS,
+ 		  (TSTR
+ 		   ("yaffs: NAND geometry problems: chunk size %d, type is yaffs%s, inbandTags %d "
+ 		    TENDSTR), dev->param.totalBytesPerChunk, dev->param.isYaffs2 ? "2" : "", dev->param.inbandTags));
+ 		return YAFFS_FAIL;
+ 	}
+ 
+ 	if (yaffs_InitialiseNAND(dev) != YAFFS_OK) {
+ 		T(YAFFS_TRACE_ALWAYS,
+ 		  (TSTR("yaffs: InitialiseNAND failed" TENDSTR)));
+ 		return YAFFS_FAIL;
+ 	}
+ 
+ 	/* Sort out space for inband tags, if required */
+ 	if (dev->param.inbandTags)
+ 		dev->nDataBytesPerChunk = dev->param.totalBytesPerChunk - sizeof(yaffs_PackedTags2TagsPart);
+ 	else
+ 		dev->nDataBytesPerChunk = dev->param.totalBytesPerChunk;
+ 
+ 	/* Got the right mix of functions? */
+ 	if (!yaffs_CheckDevFunctions(dev)) {
+ 		/* Function missing */
+ 		T(YAFFS_TRACE_ALWAYS,
+ 		  (TSTR
+ 		   ("yaffs: device function(s) missing or wrong\n" TENDSTR)));
+ 
+ 		return YAFFS_FAIL;
+ 	}
+ 
+ 	/* This is really a compilation check. */
+ 	if (!yaffs_CheckStructures()) {
+ 		T(YAFFS_TRACE_ALWAYS,
+ 		  (TSTR("yaffs_CheckStructures failed\n" TENDSTR)));
+ 		return YAFFS_FAIL;
+ 	}
+ 
+ 	if (dev->isMounted) {
+ 		T(YAFFS_TRACE_ALWAYS,
+ 		  (TSTR("yaffs: device already mounted\n" TENDSTR)));
+ 		return YAFFS_FAIL;
+ 	}
+ 
+ 	/* Finished with most checks. One or two more checks happen later on too. */
+ 
+ 	dev->isMounted = 1;
+ 
+ 	/* OK now calculate a few things for the device */
+ 
+ 	/*
+ 	 *  Calculate all the chunk size manipulation numbers:
+ 	 */
+ 	x = dev->nDataBytesPerChunk;
+ 	/* We always use dev->chunkShift and dev->chunkDiv */
+ 	dev->chunkShift = Shifts(x);
+ 	x >>= dev->chunkShift;
+ 	dev->chunkDiv = x;
+ 	/* We only use chunk mask if chunkDiv is 1 */
+ 	dev->chunkMask = (1<<dev->chunkShift) - 1;
+ 
+ 	/*
+ 	 * Calculate chunkGroupBits.
+ 	 * We need to find the next power of 2 > than internalEndBlock
+ 	 */
+ 
+ 	x = dev->param.nChunksPerBlock * (dev->internalEndBlock + 1);
+ 
+ 	bits = ShiftsGE(x);
+ 
+ 	/* Set up tnode width if wide tnodes are enabled. */
+ 	if (!dev->param.wideTnodesDisabled) {
+ 		/* bits must be even so that we end up with 32-bit words */
+ 		if (bits & 1)
+ 			bits++;
+ 		if (bits < 16)
+ 			dev->tnodeWidth = 16;
+ 		else
+ 			dev->tnodeWidth = bits;
+ 	} else
+ 		dev->tnodeWidth = 16;
+ 
+ 	dev->tnodeMask = (1<<dev->tnodeWidth)-1;
+ 
+ 	/* Level0 Tnodes are 16 bits or wider (if wide tnodes are enabled),
+ 	 * so if the bitwidth of the
+ 	 * chunk range we're using is greater than 16 we need
+ 	 * to figure out chunk shift and chunkGroupSize
+ 	 */
+ 
+ 	if (bits <= dev->tnodeWidth)
+ 		dev->chunkGroupBits = 0;
+ 	else
+ 		dev->chunkGroupBits = bits - dev->tnodeWidth;
+ 
+ 
+ 	dev->chunkGroupSize = 1 << dev->chunkGroupBits;
+ 
+ 	if (dev->param.nChunksPerBlock < dev->chunkGroupSize) {
+ 		/* We have a problem because the soft delete won't work if
+ 		 * the chunk group size > chunks per block.
+ 		 * This can be remedied by using larger "virtual blocks".
+ 		 */
+ 		T(YAFFS_TRACE_ALWAYS,
+ 		  (TSTR("yaffs: chunk group too large\n" TENDSTR)));
+ 
+ 		return YAFFS_FAIL;
+ 	}
+ 
+ 	/* OK, we've finished verifying the device, lets continue with initialisation */
+ 
+ 	/* More device initialisation */
+ 	dev->allGCs = 0;
+ 	dev->passiveGCs = 0;
+ 	dev->oldestDirtyGCs = 0;
+ 	dev->backgroundGCs = 0;
+ 	dev->gcBlockFinder = 0;
+ 	dev->bufferedBlock = -1;
+ 	dev->doingBufferedBlockRewrite = 0;
+ 	dev->nDeletedFiles = 0;
+ 	dev->nBackgroundDeletions = 0;
+ 	dev->nUnlinkedFiles = 0;
+ 	dev->eccFixed = 0;
+ 	dev->eccUnfixed = 0;
+ 	dev->tagsEccFixed = 0;
+ 	dev->tagsEccUnfixed = 0;
+ 	dev->nErasureFailures = 0;
+ 	dev->nErasedBlocks = 0;
+ 	dev->gcDisable= 0;
+ 	dev->hasPendingPrioritisedGCs = 1; /* Assume the worst for now, will get fixed on first GC */
+ 	YINIT_LIST_HEAD(&dev->dirtyDirectories);
+ 	dev->oldestDirtySequence = 0;
+ 	dev->oldestDirtyBlock = 0;
+ 
+ 	/* Initialise temporary buffers and caches. */
+ 	if (!yaffs_InitialiseTempBuffers(dev))
+ 		init_failed = 1;
+ 
+ 	dev->srCache = NULL;
+ 	dev->gcCleanupList = NULL;
+ 
+ 
+ 	if (!init_failed &&
+ 	    dev->param.nShortOpCaches > 0) {
+ 		int i;
+ 		void *buf;
+ 		int srCacheBytes = dev->param.nShortOpCaches * sizeof(yaffs_ChunkCache);
+ 
+ 		if (dev->param.nShortOpCaches > YAFFS_MAX_SHORT_OP_CACHES)
+ 			dev->param.nShortOpCaches = YAFFS_MAX_SHORT_OP_CACHES;
+ 
+ 		dev->srCache =  YMALLOC(srCacheBytes);
+ 
+ 		buf = (__u8 *) dev->srCache;
+ 
+ 		if (dev->srCache)
+ 			memset(dev->srCache, 0, srCacheBytes);
+ 
+ 		for (i = 0; i < dev->param.nShortOpCaches && buf; i++) {
+ 			dev->srCache[i].object = NULL;
+ 			dev->srCache[i].lastUse = 0;
+ 			dev->srCache[i].dirty = 0;
+ 			dev->srCache[i].data = buf = YMALLOC_DMA(dev->param.totalBytesPerChunk);
+ 		}
+ 		if (!buf)
+ 			init_failed = 1;
+ 
+ 		dev->srLastUse = 0;
+ 	}
+ 
+ 	dev->cacheHits = 0;
+ 
+ 	if (!init_failed) {
+ 		dev->gcCleanupList = YMALLOC(dev->param.nChunksPerBlock * sizeof(__u32));
+ 		if (!dev->gcCleanupList)
+ 			init_failed = 1;
+ 	}
+ 
+ 	if (dev->param.isYaffs2)
+ 		dev->param.useHeaderFileSize = 1;
+ 
+ 	if (!init_failed && !yaffs_InitialiseBlocks(dev))
+ 		init_failed = 1;
+ 
+ 	yaffs_InitialiseTnodes(dev);
+ 	yaffs_InitialiseObjects(dev);
+ 
+ 	if (!init_failed && !yaffs_CreateInitialDirectories(dev))
+ 		init_failed = 1;
+ 
+ 
+ 	if (!init_failed) {
+ 		/* Now scan the flash. */
+ 		if (dev->param.isYaffs2) {
+ 			if (yaffs_CheckpointRestore(dev)) {
+ 				yaffs_CheckObjectDetailsLoaded(dev->rootDir);
+ 				T(YAFFS_TRACE_ALWAYS,
+ 				  (TSTR("yaffs: restored from checkpoint" TENDSTR)));
+ 			} else {
+ 
+ 				/* Clean up the mess caused by an aborted checkpoint load
+ 				 * and scan backwards.
+ 				 */
+ 				yaffs_DeinitialiseBlocks(dev);
+ 				yaffs_DeinitialiseTnodes(dev);
+ 				yaffs_DeinitialiseObjects(dev);
+ 
+ 
+ 				dev->nErasedBlocks = 0;
+ 				dev->nFreeChunks = 0;
+ 				dev->allocationBlock = -1;
+ 				dev->allocationPage = -1;
+ 				dev->nDeletedFiles = 0;
+ 				dev->nUnlinkedFiles = 0;
+ 				dev->nBackgroundDeletions = 0;
+ 
+ 				if (!init_failed && !yaffs_InitialiseBlocks(dev))
+ 					init_failed = 1;
+ 
+ 				yaffs_InitialiseTnodes(dev);
+ 				yaffs_InitialiseObjects(dev);
+ 
+ 				if (!init_failed && !yaffs_CreateInitialDirectories(dev))
+ 					init_failed = 1;
+ 
+ 				if (!init_failed && !yaffs_ScanBackwards(dev))
+ 					init_failed = 1;
+ 			}
+ 		} else if (!yaffs_Scan(dev))
+ 				init_failed = 1;
+ 
+ 		yaffs_StripDeletedObjects(dev);
+ 		yaffs_FixHangingObjects(dev);
+ 		if(dev->param.emptyLostAndFound)
+ 			yaffs_EmptyLostAndFound(dev);
+ 	}
+ 
+ 	if (init_failed) {
+ 		/* Clean up the mess */
+ 		T(YAFFS_TRACE_TRACING,
+ 		  (TSTR("yaffs: yaffs_GutsInitialise() aborted.\n" TENDSTR)));
+ 
+ 		yaffs_Deinitialise(dev);
+ 		return YAFFS_FAIL;
+ 	}
+ 
+ 	/* Zero out stats */
+ 	dev->nPageReads = 0;
+ 	dev->nPageWrites = 0;
+ 	dev->nBlockErasures = 0;
+ 	dev->nGCCopies = 0;
+ 	dev->nRetriedWrites = 0;
+ 
+ 	dev->nRetiredBlocks = 0;
+ 
+ 	yaffs_VerifyFreeChunks(dev);
+ 	yaffs_VerifyBlocks(dev);
+ 
+ 	/* Clean up any aborted checkpoint data */
+ 	if(!dev->isCheckpointed && dev->blocksInCheckpoint > 0)
+ 		yaffs_InvalidateCheckpoint(dev);
+ 
+ 	T(YAFFS_TRACE_TRACING,
+ 	  (TSTR("yaffs: yaffs_GutsInitialise() done.\n" TENDSTR)));
+ 	return YAFFS_OK;
+ 
+ }
+ 
+ void yaffs_Deinitialise(yaffs_Device *dev)
+ {
+ 	if (dev->isMounted) {
+ 		int i;
+ 
+ 		yaffs_DeinitialiseBlocks(dev);
+ 		yaffs_DeinitialiseTnodes(dev);
+ 		yaffs_DeinitialiseObjects(dev);
+ 		if (dev->param.nShortOpCaches > 0 &&
+ 		    dev->srCache) {
+ 
+ 			for (i = 0; i < dev->param.nShortOpCaches; i++) {
+ 				if (dev->srCache[i].data)
+ 					YFREE(dev->srCache[i].data);
+ 				dev->srCache[i].data = NULL;
+ 			}
+ 
+ 			YFREE(dev->srCache);
+ 			dev->srCache = NULL;
+ 		}
+ 
+ 		YFREE(dev->gcCleanupList);
+ 
+ 		for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++)
+ 			YFREE(dev->tempBuffer[i].buffer);
+ 
+ 		dev->isMounted = 0;
+ 
+ 		if (dev->param.deinitialiseNAND)
+ 			dev->param.deinitialiseNAND(dev);
+ 	}
+ }
+ 
+ static int yaffs_CountFreeChunks(yaffs_Device *dev)
+ {
+ 	int nFree=0;
+ 	int b;
+ 
+ 	yaffs_BlockInfo *blk;
+ 
+ 	blk = dev->blockInfo;
+ 	for (b = dev->internalStartBlock; b <= dev->internalEndBlock; b++) {
+ 		switch (blk->blockState) {
+ 		case YAFFS_BLOCK_STATE_EMPTY:
+ 		case YAFFS_BLOCK_STATE_ALLOCATING:
+ 		case YAFFS_BLOCK_STATE_COLLECTING:
+ 		case YAFFS_BLOCK_STATE_FULL:
+ 			nFree +=
+ 			    (dev->param.nChunksPerBlock - blk->pagesInUse +
+ 			     blk->softDeletions);
+ 			break;
+ 		default:
+ 			break;
+ 		}
+ 		blk++;
+ 	}
+ 
+ 	return nFree;
+ }
+ 
+ int yaffs_GetNumberOfFreeChunks(yaffs_Device *dev)
+ {
+ 	/* This is what we report to the outside world */
+ 
+ 	int nFree;
+ 	int nDirtyCacheChunks;
+ 	int blocksForCheckpoint;
+ 	int i;
+ 
+ #if 1
+ 	nFree = dev->nFreeChunks;
+ #else
+ 	nFree = yaffs_CountFreeChunks(dev);
+ #endif
+ 
+ 	nFree += dev->nDeletedFiles;
+ 
+ 	/* Now count the number of dirty chunks in the cache and subtract those */
+ 
+ 	for (nDirtyCacheChunks = 0, i = 0; i < dev->param.nShortOpCaches; i++) {
+ 		if (dev->srCache[i].dirty)
+ 			nDirtyCacheChunks++;
+ 	}
+ 
+ 	nFree -= nDirtyCacheChunks;
+ 
+ 	nFree -= ((dev->param.nReservedBlocks + 1) * dev->param.nChunksPerBlock);
+ 
+ 	/* Now we figure out how much to reserve for the checkpoint and report that... */
+ 	blocksForCheckpoint = yaffs_CalcCheckpointBlocksRequired(dev) - dev->blocksInCheckpoint;
+ 	if (blocksForCheckpoint < 0)
+ 		blocksForCheckpoint = 0;
+ 
+ 	nFree -= (blocksForCheckpoint * dev->param.nChunksPerBlock);
+ 
+ 	if (nFree < 0)
+ 		nFree = 0;
+ 
+ 	return nFree;
+ 
+ }
+ 
+ static int yaffs_freeVerificationFailures;
+ 
+ static void yaffs_VerifyFreeChunks(yaffs_Device *dev)
+ {
+ 	int counted;
+ 	int difference;
+ 
+ 	if (yaffs_SkipVerification(dev))
+ 		return;
+ 
+ 	counted = yaffs_CountFreeChunks(dev);
+ 
+ 	difference = dev->nFreeChunks - counted;
+ 
+ 	if (difference) {
+ 		T(YAFFS_TRACE_ALWAYS,
+ 		  (TSTR("Freechunks verification failure %d %d %d" TENDSTR),
+ 		   dev->nFreeChunks, counted, difference));
+ 		yaffs_freeVerificationFailures++;
+ 	}
+ }
+ 
+ /*---------------------------------------- YAFFS test code ----------------------*/
+ 
+ #define yaffs_CheckStruct(structure, syze, name) \
+ 	do { \
+ 		if (sizeof(structure) != syze) { \
+ 			T(YAFFS_TRACE_ALWAYS, (TSTR("%s should be %d but is %d\n" TENDSTR),\
+ 				name, syze, (int) sizeof(structure))); \
+ 			return YAFFS_FAIL; \
+ 		} \
+ 	} while (0)
+ 
+ static int yaffs_CheckStructures(void)
+ {
+ /*      yaffs_CheckStruct(yaffs_Tags,8,"yaffs_Tags"); */
+ /*      yaffs_CheckStruct(yaffs_TagsUnion,8,"yaffs_TagsUnion"); */
+ /*      yaffs_CheckStruct(yaffs_Spare,16,"yaffs_Spare"); */
+ #ifndef CONFIG_YAFFS_TNODE_LIST_DEBUG
+ /*	yaffs_CheckStruct(yaffs_Tnode, 2 * YAFFS_NTNODES_LEVEL0, "yaffs_Tnode"); */
+ #endif
+ #ifndef CONFIG_YAFFS_WINCE
+ 	yaffs_CheckStruct(yaffs_ObjectHeader, 512, "yaffs_ObjectHeader");
+ #endif
+ 	return YAFFS_OK;
+ }
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/yaffs_guts.h liab-linux-2.6.29.4/fs/yaffs2/yaffs_guts.h
*** linux-2.6.29.4/fs/yaffs2/yaffs_guts.h	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/yaffs_guts.h	2012-01-20 14:48:21.869306031 +0100
***************
*** 0 ****
--- 1,919 ----
+ /*
+  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+  *
+  * Copyright (C) 2002-2010 Aleph One Ltd.
+  *   for Toby Churchill Ltd and Brightstar Engineering
+  *
+  * Created by Charles Manning <charles@aleph1.co.uk>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU Lesser General Public License version 2.1 as
+  * published by the Free Software Foundation.
+  *
+  * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+  */
+ 
+ #ifndef __YAFFS_GUTS_H__
+ #define __YAFFS_GUTS_H__
+ 
+ #include "devextras.h"
+ #include "yportenv.h"
+ 
+ #define YAFFS_OK	1
+ #define YAFFS_FAIL  0
+ 
+ /* Give us a  Y=0x59,
+  * Give us an A=0x41,
+  * Give us an FF=0xFF
+  * Give us an S=0x53
+  * And what have we got...
+  */
+ #define YAFFS_MAGIC			0x5941FF53
+ 
+ #define YAFFS_NTNODES_LEVEL0	  	16
+ #define YAFFS_TNODES_LEVEL0_BITS	4
+ #define YAFFS_TNODES_LEVEL0_MASK	0xf
+ 
+ #define YAFFS_NTNODES_INTERNAL 		(YAFFS_NTNODES_LEVEL0 / 2)
+ #define YAFFS_TNODES_INTERNAL_BITS 	(YAFFS_TNODES_LEVEL0_BITS - 1)
+ #define YAFFS_TNODES_INTERNAL_MASK	0x7
+ #define YAFFS_TNODES_MAX_LEVEL		6
+ 
+ #ifndef CONFIG_YAFFS_NO_YAFFS1
+ #define YAFFS_BYTES_PER_SPARE		16
+ #define YAFFS_BYTES_PER_CHUNK		512
+ #define YAFFS_CHUNK_SIZE_SHIFT		9
+ #define YAFFS_CHUNKS_PER_BLOCK		32
+ #define YAFFS_BYTES_PER_BLOCK		(YAFFS_CHUNKS_PER_BLOCK*YAFFS_BYTES_PER_CHUNK)
+ #endif
+ 
+ #define YAFFS_MIN_YAFFS2_CHUNK_SIZE 	1024
+ #define YAFFS_MIN_YAFFS2_SPARE_SIZE	32
+ 
+ #define YAFFS_MAX_CHUNK_ID		0x000FFFFF
+ 
+ #define YAFFS_UNUSED_OBJECT_ID		0x0003FFFF
+ 
+ #define YAFFS_ALLOCATION_NOBJECTS	100
+ #define YAFFS_ALLOCATION_NTNODES	100
+ #define YAFFS_ALLOCATION_NLINKS		100
+ 
+ #define YAFFS_NOBJECT_BUCKETS		256
+ 
+ 
+ #define YAFFS_OBJECT_SPACE		0x40000
+ 
+ #define YAFFS_CHECKPOINT_VERSION 	4
+ 
+ #ifdef CONFIG_YAFFS_UNICODE
+ #define YAFFS_MAX_NAME_LENGTH		127
+ #define YAFFS_MAX_ALIAS_LENGTH		79
+ #else
+ #define YAFFS_MAX_NAME_LENGTH		255
+ #define YAFFS_MAX_ALIAS_LENGTH		159
+ #endif
+ 
+ #define YAFFS_SHORT_NAME_LENGTH		15
+ 
+ /* Some special object ids for pseudo objects */
+ #define YAFFS_OBJECTID_ROOT		1
+ #define YAFFS_OBJECTID_LOSTNFOUND	2
+ #define YAFFS_OBJECTID_UNLINKED		3
+ #define YAFFS_OBJECTID_DELETED		4
+ 
+ /* Pseudo object ids for checkpointing */
+ #define YAFFS_OBJECTID_SB_HEADER	0x10
+ #define YAFFS_OBJECTID_CHECKPOINT_DATA	0x20
+ #define YAFFS_SEQUENCE_CHECKPOINT_DATA  0x21
+ 
+ 
+ #define YAFFS_MAX_SHORT_OP_CACHES	20
+ 
+ #define YAFFS_N_TEMP_BUFFERS		6
+ 
+ /* We limit the number attempts at sucessfully saving a chunk of data.
+  * Small-page devices have 32 pages per block; large-page devices have 64.
+  * Default to something in the order of 5 to 10 blocks worth of chunks.
+  */
+ #define YAFFS_WR_ATTEMPTS		(5*64)
+ 
+ /* Sequence numbers are used in YAFFS2 to determine block allocation order.
+  * The range is limited slightly to help distinguish bad numbers from good.
+  * This also allows us to perhaps in the future use special numbers for
+  * special purposes.
+  * EFFFFF00 allows the allocation of 8 blocks per second (~1Mbytes) for 15 years,
+  * and is a larger number than the lifetime of a 2GB device.
+  */
+ #define YAFFS_LOWEST_SEQUENCE_NUMBER	0x00001000
+ #define YAFFS_HIGHEST_SEQUENCE_NUMBER	0xEFFFFF00
+ 
+ /* Special sequence number for bad block that failed to be marked bad */
+ #define YAFFS_SEQUENCE_BAD_BLOCK	0xFFFF0000
+ 
+ /* ChunkCache is used for short read/write operations.*/
+ typedef struct {
+ 	struct yaffs_ObjectStruct *object;
+ 	int chunkId;
+ 	int lastUse;
+ 	int dirty;
+ 	int nBytes;		/* Only valid if the cache is dirty */
+ 	int locked;		/* Can't push out or flush while locked. */
+ 	__u8 *data;
+ } yaffs_ChunkCache;
+ 
+ 
+ 
+ /* Tags structures in RAM
+  * NB This uses bitfield. Bitfields should not straddle a u32 boundary otherwise
+  * the structure size will get blown out.
+  */
+ 
+ #ifndef CONFIG_YAFFS_NO_YAFFS1
+ typedef struct {
+ 	unsigned chunkId:20;
+ 	unsigned serialNumber:2;
+ 	unsigned byteCountLSB:10;
+ 	unsigned objectId:18;
+ 	unsigned ecc:12;
+ 	unsigned byteCountMSB:2;
+ } yaffs_Tags;
+ 
+ typedef union {
+ 	yaffs_Tags asTags;
+ 	__u8 asBytes[8];
+ } yaffs_TagsUnion;
+ 
+ #endif
+ 
+ /* Stuff used for extended tags in YAFFS2 */
+ 
+ typedef enum {
+ 	YAFFS_ECC_RESULT_UNKNOWN,
+ 	YAFFS_ECC_RESULT_NO_ERROR,
+ 	YAFFS_ECC_RESULT_FIXED,
+ 	YAFFS_ECC_RESULT_UNFIXED
+ } yaffs_ECCResult;
+ 
+ typedef enum {
+ 	YAFFS_OBJECT_TYPE_UNKNOWN,
+ 	YAFFS_OBJECT_TYPE_FILE,
+ 	YAFFS_OBJECT_TYPE_SYMLINK,
+ 	YAFFS_OBJECT_TYPE_DIRECTORY,
+ 	YAFFS_OBJECT_TYPE_HARDLINK,
+ 	YAFFS_OBJECT_TYPE_SPECIAL
+ } yaffs_ObjectType;
+ 
+ #define YAFFS_OBJECT_TYPE_MAX YAFFS_OBJECT_TYPE_SPECIAL
+ 
+ typedef struct {
+ 
+ 	unsigned validMarker0;
+ 	unsigned chunkUsed;	/*  Status of the chunk: used or unused */
+ 	unsigned objectId;	/* If 0 then this is not part of an object (unused) */
+ 	unsigned chunkId;	/* If 0 then this is a header, else a data chunk */
+ 	unsigned byteCount;	/* Only valid for data chunks */
+ 
+ 	/* The following stuff only has meaning when we read */
+ 	yaffs_ECCResult eccResult;
+ 	unsigned blockBad;
+ 
+ 	/* YAFFS 1 stuff */
+ 	unsigned chunkDeleted;	/* The chunk is marked deleted */
+ 	unsigned serialNumber;	/* Yaffs1 2-bit serial number */
+ 
+ 	/* YAFFS2 stuff */
+ 	unsigned sequenceNumber;	/* The sequence number of this block */
+ 
+ 	/* Extra info if this is an object header (YAFFS2 only) */
+ 
+ 	unsigned extraHeaderInfoAvailable;	/* There is extra info available if this is not zero */
+ 	unsigned extraParentObjectId;	/* The parent object */
+ 	unsigned extraIsShrinkHeader;	/* Is it a shrink header? */
+ 	unsigned extraShadows;		/* Does this shadow another object? */
+ 
+ 	yaffs_ObjectType extraObjectType;	/* What object type? */
+ 
+ 	unsigned extraFileLength;		/* Length if it is a file */
+ 	unsigned extraEquivalentObjectId;	/* Equivalent object Id if it is a hard link */
+ 
+ 	unsigned validMarker1;
+ 
+ } yaffs_ExtendedTags;
+ 
+ /* Spare structure for YAFFS1 */
+ typedef struct {
+ 	__u8 tagByte0;
+ 	__u8 tagByte1;
+ 	__u8 tagByte2;
+ 	__u8 tagByte3;
+ 	__u8 pageStatus;	/* set to 0 to delete the chunk */
+ 	__u8 blockStatus;
+ 	__u8 tagByte4;
+ 	__u8 tagByte5;
+ 	__u8 ecc1[3];
+ 	__u8 tagByte6;
+ 	__u8 tagByte7;
+ 	__u8 ecc2[3];
+ } yaffs_Spare;
+ 
+ /*Special structure for passing through to mtd */
+ struct yaffs_NANDSpare {
+ 	yaffs_Spare spare;
+ 	int eccres1;
+ 	int eccres2;
+ };
+ 
+ /* Block data in RAM */
+ 
+ typedef enum {
+ 	YAFFS_BLOCK_STATE_UNKNOWN = 0,
+ 
+ 	YAFFS_BLOCK_STATE_SCANNING,
+         /* Being scanned */
+ 
+ 	YAFFS_BLOCK_STATE_NEEDS_SCANNING,
+ 	/* The block might have something on it (ie it is allocating or full, perhaps empty)
+ 	 * but it needs to be scanned to determine its true state.
+ 	 * This state is only valid during yaffs_Scan.
+ 	 * NB We tolerate empty because the pre-scanner might be incapable of deciding
+ 	 * However, if this state is returned on a YAFFS2 device, then we expect a sequence number
+ 	 */
+ 
+ 	YAFFS_BLOCK_STATE_EMPTY,
+ 	/* This block is empty */
+ 
+ 	YAFFS_BLOCK_STATE_ALLOCATING,
+ 	/* This block is partially allocated.
+ 	 * At least one page holds valid data.
+ 	 * This is the one currently being used for page
+ 	 * allocation. Should never be more than one of these.
+          * If a block is only partially allocated at mount it is treated as full.
+ 	 */
+ 
+ 	YAFFS_BLOCK_STATE_FULL,
+ 	/* All the pages in this block have been allocated.
+          * If a block was only partially allocated when mounted we treat
+          * it as fully allocated.
+ 	 */
+ 
+ 	YAFFS_BLOCK_STATE_DIRTY,
+ 	/* The block was full and now all chunks have been deleted.
+ 	 * Erase me, reuse me.
+ 	 */
+ 
+ 	YAFFS_BLOCK_STATE_CHECKPOINT,
+ 	/* This block is assigned to holding checkpoint data. */
+ 
+ 	YAFFS_BLOCK_STATE_COLLECTING,
+ 	/* This block is being garbage collected */
+ 
+ 	YAFFS_BLOCK_STATE_DEAD
+ 	/* This block has failed and is not in use */
+ } yaffs_BlockState;
+ 
+ #define	YAFFS_NUMBER_OF_BLOCK_STATES (YAFFS_BLOCK_STATE_DEAD + 1)
+ 
+ 
+ typedef struct {
+ 
+ 	int softDeletions:10;	/* number of soft deleted pages */
+ 	int pagesInUse:10;	/* number of pages in use */
+ 	unsigned blockState:4;	/* One of the above block states. NB use unsigned because enum is sometimes an int */
+ 	__u32 needsRetiring:1;	/* Data has failed on this block, need to get valid data off */
+ 				/* and retire the block. */
+ 	__u32 skipErasedCheck:1; /* If this is set we can skip the erased check on this block */
+ 	__u32 gcPrioritise:1; 	/* An ECC check or blank check has failed on this block.
+ 				   It should be prioritised for GC */
+ 	__u32 chunkErrorStrikes:3; /* How many times we've had ecc etc failures on this block and tried to reuse it */
+ 
+ #ifdef CONFIG_YAFFS_YAFFS2
+ 	__u32 hasShrinkHeader:1; /* This block has at least one shrink object header */
+ 	__u32 sequenceNumber;	 /* block sequence number for yaffs2 */
+ #endif
+ 
+ } yaffs_BlockInfo;
+ 
+ /* -------------------------- Object structure -------------------------------*/
+ /* This is the object structure as stored on NAND */
+ 
+ typedef struct {
+ 	yaffs_ObjectType type;
+ 
+ 	/* Apply to everything  */
+ 	int parentObjectId;
+ 	__u16 sum__NoLongerUsed;        /* checksum of name. No longer used */
+ 	YCHAR name[YAFFS_MAX_NAME_LENGTH + 1];
+ 
+ 	/* The following apply to directories, files, symlinks - not hard links */
+ 	__u32 yst_mode;         /* protection */
+ 
+ #ifdef CONFIG_YAFFS_WINCE
+ 	__u32 notForWinCE[5];
+ #else
+ 	__u32 yst_uid;
+ 	__u32 yst_gid;
+ 	__u32 yst_atime;
+ 	__u32 yst_mtime;
+ 	__u32 yst_ctime;
+ #endif
+ 
+ 	/* File size  applies to files only */
+ 	int fileSize;
+ 
+ 	/* Equivalent object id applies to hard links only. */
+ 	int equivalentObjectId;
+ 
+ 	/* Alias is for symlinks only. */
+ 	YCHAR alias[YAFFS_MAX_ALIAS_LENGTH + 1];
+ 
+ 	__u32 yst_rdev;		/* device stuff for block and char devices (major/min) */
+ 
+ #ifdef CONFIG_YAFFS_WINCE
+ 	__u32 win_ctime[2];
+ 	__u32 win_atime[2];
+ 	__u32 win_mtime[2];
+ #else
+ 	__u32 roomToGrow[6];
+ 
+ #endif
+ 	__u32 inbandShadowsObject;
+ 	__u32 inbandIsShrink;
+ 
+ 	__u32 reservedSpace[2];
+ 	int shadowsObject;	/* This object header shadows the specified object if > 0 */
+ 
+ 	/* isShrink applies to object headers written when we shrink the file (ie resize) */
+ 	__u32 isShrink;
+ 
+ } yaffs_ObjectHeader;
+ 
+ /*--------------------------- Tnode -------------------------- */
+ 
+ union yaffs_Tnode_union {
+ #ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG
+ 	union yaffs_Tnode_union *internal[YAFFS_NTNODES_INTERNAL + 1];
+ #else
+ 	union yaffs_Tnode_union *internal[YAFFS_NTNODES_INTERNAL];
+ #endif
+ /*	__u16 level0[YAFFS_NTNODES_LEVEL0]; */
+ 
+ };
+ 
+ typedef union yaffs_Tnode_union yaffs_Tnode;
+ 
+ struct yaffs_TnodeList_struct {
+ 	struct yaffs_TnodeList_struct *next;
+ 	yaffs_Tnode *tnodes;
+ };
+ 
+ typedef struct yaffs_TnodeList_struct yaffs_TnodeList;
+ 
+ /*------------------------  Object -----------------------------*/
+ /* An object can be one of:
+  * - a directory (no data, has children links
+  * - a regular file (data.... not prunes :->).
+  * - a symlink [symbolic link] (the alias).
+  * - a hard link
+  */
+ 
+ typedef struct {
+ 	__u32 fileSize;
+ 	__u32 scannedFileSize;
+ 	__u32 shrinkSize;
+ 	int topLevel;
+ 	yaffs_Tnode *top;
+ } yaffs_FileStructure;
+ 
+ typedef struct {
+ 	struct ylist_head children;     /* list of child links */
+ 	struct ylist_head dirty;	/* Entry for list of dirty directories */
+ } yaffs_DirectoryStructure;
+ 
+ typedef struct {
+ 	YCHAR *alias;
+ } yaffs_SymLinkStructure;
+ 
+ typedef struct {
+ 	struct yaffs_ObjectStruct *equivalentObject;
+ 	__u32 equivalentObjectId;
+ } yaffs_HardLinkStructure;
+ 
+ typedef union {
+ 	yaffs_FileStructure fileVariant;
+ 	yaffs_DirectoryStructure directoryVariant;
+ 	yaffs_SymLinkStructure symLinkVariant;
+ 	yaffs_HardLinkStructure hardLinkVariant;
+ } yaffs_ObjectVariant;
+ 
+ 
+ 
+ struct yaffs_ObjectStruct {
+ 	__u8 deleted:1;		/* This should only apply to unlinked files. */
+ 	__u8 softDeleted:1;	/* it has also been soft deleted */
+ 	__u8 unlinked:1;	/* An unlinked file. The file should be in the unlinked directory.*/
+ 	__u8 fake:1;		/* A fake object has no presence on NAND. */
+ 	__u8 renameAllowed:1;	/* Some objects are not allowed to be renamed. */
+ 	__u8 unlinkAllowed:1;
+ 	__u8 dirty:1;		/* the object needs to be written to flash */
+ 	__u8 valid:1;		/* When the file system is being loaded up, this
+ 				 * object might be created before the data
+ 				 * is available (ie. file data records appear before the header).
+ 				 */
+ 	__u8 lazyLoaded:1;	/* This object has been lazy loaded and is missing some detail */
+ 
+ 	__u8 deferedFree:1;	/* For Linux kernel. Object is removed from NAND, but is
+ 				 * still in the inode cache. Free of object is defered.
+ 				 * until the inode is released.
+ 				 */
+ 	__u8 beingCreated:1;	/* This object is still being created so skip some checks. */
+ 	__u8 isShadowed:1;	/* This object is shadowed on the way to being renamed. */
+ 
+ 	__u8 serial;		/* serial number of chunk in NAND. Cached here */
+ 	__u16 sum;		/* sum of the name to speed searching */
+ 
+ 	struct yaffs_DeviceStruct *myDev;       /* The device I'm on */
+ 
+ 	struct ylist_head hashLink;     /* list of objects in this hash bucket */
+ 
+ 	struct ylist_head hardLinks;    /* all the equivalent hard linked objects */
+ 
+ 	/* directory structure stuff */
+ 	/* also used for linking up the free list */
+ 	struct yaffs_ObjectStruct *parent;
+ 	struct ylist_head siblings;
+ 
+ 	/* Where's my object header in NAND? */
+ 	int hdrChunk;
+ 
+ 	int nDataChunks;	/* Number of data chunks attached to the file. */
+ 
+ 	__u32 objectId;		/* the object id value */
+ 
+ 	__u32 yst_mode;
+ 
+ #ifdef CONFIG_YAFFS_SHORT_NAMES_IN_RAM
+ 	YCHAR shortName[YAFFS_SHORT_NAME_LENGTH + 1];
+ #endif
+ 
+ #ifdef CONFIG_YAFFS_WINCE
+ 	__u32 win_ctime[2];
+ 	__u32 win_mtime[2];
+ 	__u32 win_atime[2];
+ #else
+ 	__u32 yst_uid;
+ 	__u32 yst_gid;
+ 	__u32 yst_atime;
+ 	__u32 yst_mtime;
+ 	__u32 yst_ctime;
+ #endif
+ 
+ 	__u32 yst_rdev;
+ 
+ 	void *myInode;
+ 
+ 	yaffs_ObjectType variantType;
+ 
+ 	yaffs_ObjectVariant variant;
+ 
+ };
+ 
+ typedef struct yaffs_ObjectStruct yaffs_Object;
+ 
+ struct yaffs_ObjectList_struct {
+ 	yaffs_Object *objects;
+ 	struct yaffs_ObjectList_struct *next;
+ };
+ 
+ typedef struct yaffs_ObjectList_struct yaffs_ObjectList;
+ 
+ typedef struct {
+ 	struct ylist_head list;
+ 	int count;
+ } yaffs_ObjectBucket;
+ 
+ 
+ /* yaffs_CheckpointObject holds the definition of an object as dumped
+  * by checkpointing.
+  */
+ 
+ typedef struct {
+ 	int structType;
+ 	__u32 objectId;
+ 	__u32 parentId;
+ 	int hdrChunk;
+ 	yaffs_ObjectType variantType:3;
+ 	__u8 deleted:1;
+ 	__u8 softDeleted:1;
+ 	__u8 unlinked:1;
+ 	__u8 fake:1;
+ 	__u8 renameAllowed:1;
+ 	__u8 unlinkAllowed:1;
+ 	__u8 serial;
+ 
+ 	int nDataChunks;
+ 	__u32 fileSizeOrEquivalentObjectId;
+ } yaffs_CheckpointObject;
+ 
+ /*--------------------- Temporary buffers ----------------
+  *
+  * These are chunk-sized working buffers. Each device has a few
+  */
+ 
+ typedef struct {
+ 	__u8 *buffer;
+ 	int line;	/* track from whence this buffer was allocated */
+ 	int maxLine;
+ } yaffs_TempBuffer;
+ 
+ /*----------------- Device ---------------------------------*/
+ 
+ 
+ struct yaffs_DeviceParamStruct {
+ 	const char *name;
+ 
+ 	/*
+          * Entry parameters set up way early. Yaffs sets up the rest.
+          * The structure should be zeroed out before use so that unused
+          * and defualt values are zero.
+          */
+ 
+ 	int inbandTags;          /* Use unband tags */
+ 	__u32 totalBytesPerChunk; /* Should be >= 512, does not need to be a power of 2 */
+ 	int nChunksPerBlock;	/* does not need to be a power of 2 */
+ 	int spareBytesPerChunk;	/* spare area size */
+ 	int startBlock;		/* Start block we're allowed to use */
+ 	int endBlock;		/* End block we're allowed to use */
+ 	int nReservedBlocks;	/* We want this tuneable so that we can reduce */
+ 				/* reserved blocks on NOR and RAM. */
+ 
+ 
+ 	int nShortOpCaches;	/* If <= 0, then short op caching is disabled, else
+ 				 * the number of short op caches (don't use too many).
+                                  * 10 to 20 is a good bet.
+ 				 */
+ 	int useNANDECC;		/* Flag to decide whether or not to use NANDECC on data (yaffs1) */
+ 	int noTagsECC;		/* Flag to decide whether or not to do ECC on packed tags (yaffs2) */ 
+ 
+ 	int isYaffs2;           /* Use yaffs2 mode on this device */
+ 
+ 	int emptyLostAndFound;  /* Auto-empty lost+found directory on mount */
+ 
+ 	int refreshPeriod;	/* How often we should check to do a block refresh */
+ 
+ 	/* Checkpoint control. Can be set before or after initialisation */
+ 	__u8 skipCheckpointRead;
+ 	__u8 skipCheckpointWrite;
+ 
+ 	/* NAND access functions (Must be set before calling YAFFS)*/
+ 
+ 	int (*writeChunkToNAND) (struct yaffs_DeviceStruct *dev,
+ 					int chunkInNAND, const __u8 *data,
+ 					const yaffs_Spare *spare);
+ 	int (*readChunkFromNAND) (struct yaffs_DeviceStruct *dev,
+ 					int chunkInNAND, __u8 *data,
+ 					yaffs_Spare *spare);
+ 	int (*eraseBlockInNAND) (struct yaffs_DeviceStruct *dev,
+ 					int blockInNAND);
+ 	int (*initialiseNAND) (struct yaffs_DeviceStruct *dev);
+ 	int (*deinitialiseNAND) (struct yaffs_DeviceStruct *dev);
+ 
+ #ifdef CONFIG_YAFFS_YAFFS2
+ 	int (*writeChunkWithTagsToNAND) (struct yaffs_DeviceStruct *dev,
+ 					 int chunkInNAND, const __u8 *data,
+ 					 const yaffs_ExtendedTags *tags);
+ 	int (*readChunkWithTagsFromNAND) (struct yaffs_DeviceStruct *dev,
+ 					  int chunkInNAND, __u8 *data,
+ 					  yaffs_ExtendedTags *tags);
+ 	int (*markNANDBlockBad) (struct yaffs_DeviceStruct *dev, int blockNo);
+ 	int (*queryNANDBlock) (struct yaffs_DeviceStruct *dev, int blockNo,
+ 			       yaffs_BlockState *state, __u32 *sequenceNumber);
+ #endif
+ 
+ 	/* The removeObjectCallback function must be supplied by OS flavours that
+ 	 * need it.
+          * yaffs direct uses it to implement the faster readdir.
+          * Linux uses it to protect the directory during unlocking.
+ 	 */
+ 	void (*removeObjectCallback)(struct yaffs_ObjectStruct *obj);
+ 
+ 	/* Callback to mark the superblock dirty */
+ 	void (*markSuperBlockDirty)(struct yaffs_DeviceStruct *dev);
+ 	
+ 	/*  Callback to control garbage collection. */
+ 	unsigned (*gcControl)(struct yaffs_DeviceStruct *dev);
+ 
+         /* Debug control flags. Don't use unless you know what you're doing */
+ 	int useHeaderFileSize;	/* Flag to determine if we should use file sizes from the header */
+ 	int disableLazyLoad;	/* Disable lazy loading on this device */
+ 	int wideTnodesDisabled; /* Set to disable wide tnodes */
+ 	int disableSoftDelete;  /* yaffs 1 only: Set to disable the use of softdeletion. */
+ 	
+ 	int deferDirectoryUpdate; /* Set to defer directory updates */
+ 	
+ };
+ 
+ typedef struct yaffs_DeviceParamStruct yaffs_DeviceParam;
+ 
+ struct yaffs_DeviceStruct {
+ 	struct yaffs_DeviceParamStruct param;
+ 
+         /* Context storage. Holds extra OS specific data for this device */
+ 
+ 	void *context;
+ 
+ 	/* Runtime parameters. Set up by YAFFS. */
+ 	int nDataBytesPerChunk;	
+ 
+         /* Non-wide tnode stuff */
+ 	__u16 chunkGroupBits;	/* Number of bits that need to be resolved if
+                                  * the tnodes are not wide enough.
+                                  */
+ 	__u16 chunkGroupSize;	/* == 2^^chunkGroupBits */
+ 
+ 	/* Stuff to support wide tnodes */
+ 	__u32 tnodeWidth;
+ 	__u32 tnodeMask;
+ 
+ 	/* Stuff for figuring out file offset to chunk conversions */
+ 	__u32 chunkShift; /* Shift value */
+ 	__u32 chunkDiv;   /* Divisor after shifting: 1 for power-of-2 sizes */
+ 	__u32 chunkMask;  /* Mask to use for power-of-2 case */
+ 
+ 
+ 
+ 	int isMounted;
+ 	int readOnly;
+ 	int isCheckpointed;
+ 
+ 
+ 	/* Stuff to support block offsetting to support start block zero */
+ 	int internalStartBlock;
+ 	int internalEndBlock;
+ 	int blockOffset;
+ 	int chunkOffset;
+ 
+ 
+ 	/* Runtime checkpointing stuff */
+ 	int checkpointPageSequence;   /* running sequence number of checkpoint pages */
+ 	int checkpointByteCount;
+ 	int checkpointByteOffset;
+ 	__u8 *checkpointBuffer;
+ 	int checkpointOpenForWrite;
+ 	int blocksInCheckpoint;
+ 	int checkpointCurrentChunk;
+ 	int checkpointCurrentBlock;
+ 	int checkpointNextBlock;
+ 	int *checkpointBlockList;
+ 	int checkpointMaxBlocks;
+ 	__u32 checkpointSum;
+ 	__u32 checkpointXor;
+ 
+ 	int nCheckpointBlocksRequired; /* Number of blocks needed to store current checkpoint set */
+ 
+ 	/* Block Info */
+ 	yaffs_BlockInfo *blockInfo;
+ 	__u8 *chunkBits;	/* bitmap of chunks in use */
+ 	unsigned blockInfoAlt:1;	/* was allocated using alternative strategy */
+ 	unsigned chunkBitsAlt:1;	/* was allocated using alternative strategy */
+ 	int chunkBitmapStride;	/* Number of bytes of chunkBits per block.
+ 				 * Must be consistent with nChunksPerBlock.
+ 				 */
+ 
+ 	int nErasedBlocks;
+ 	int allocationBlock;	/* Current block being allocated off */
+ 	__u32 allocationPage;
+ 	int allocationBlockFinder;	/* Used to search for next allocation block */
+ 
+ 	int nTnodesCreated;
+ 	yaffs_Tnode *freeTnodes;
+ 	int nFreeTnodes;
+ 	yaffs_TnodeList *allocatedTnodeList;
+ 
+ 	int nObjectsCreated;
+ 	yaffs_Object *freeObjects;
+ 	int nFreeObjects;
+ 
+ 	int nHardLinks;
+ 
+ 	yaffs_ObjectList *allocatedObjectList;
+ 
+ 	yaffs_ObjectBucket objectBucket[YAFFS_NOBJECT_BUCKETS];
+ 	__u32 bucketFinder;
+ 
+ 	int nFreeChunks;
+ 
+ 	/* Garbage collection control */
+ 	__u32 *gcCleanupList;	/* objects to delete at the end of a GC. */
+ 
+ 	unsigned hasPendingPrioritisedGCs; /* We think this device might have pending prioritised gcs */
+ 	unsigned gcDisable;
+ 	unsigned gcBlockFinder;
+ 	unsigned gcDirtiest;
+ 	unsigned gcPagesInUse;
+ 	unsigned gcNotDone;
+ 	unsigned gcBlock;
+ 	unsigned gcChunk;
+ 	unsigned gcSkip;
+ 
+ 	/* Special directories */
+ 	yaffs_Object *rootDir;
+ 	yaffs_Object *lostNFoundDir;
+ 
+ 	/* Buffer areas for storing data to recover from write failures TODO
+ 	 *      __u8            bufferedData[YAFFS_CHUNKS_PER_BLOCK][YAFFS_BYTES_PER_CHUNK];
+ 	 *      yaffs_Spare bufferedSpare[YAFFS_CHUNKS_PER_BLOCK];
+ 	 */
+ 
+ 	int bufferedBlock;	/* Which block is buffered here? */
+ 	int doingBufferedBlockRewrite;
+ 
+ 	yaffs_ChunkCache *srCache;
+ 	int srLastUse;
+ 
+ 	/* Stuff for background deletion and unlinked files.*/
+ 	yaffs_Object *unlinkedDir;	/* Directory where unlinked and deleted files live. */
+ 	yaffs_Object *deletedDir;	/* Directory where deleted objects are sent to disappear. */
+ 	yaffs_Object *unlinkedDeletion;	/* Current file being background deleted.*/
+ 	int nDeletedFiles;		/* Count of files awaiting deletion;*/
+ 	int nUnlinkedFiles;		/* Count of unlinked files. */
+ 	int nBackgroundDeletions;	/* Count of background deletions. */
+ 
+ 	/* Temporary buffer management */
+ 	yaffs_TempBuffer tempBuffer[YAFFS_N_TEMP_BUFFERS];
+ 	int maxTemp;
+ 	int tempInUse;
+ 	int unmanagedTempAllocations;
+ 	int unmanagedTempDeallocations;
+ 
+ 	/* yaffs2 runtime stuff */
+ 	unsigned sequenceNumber;	/* Sequence number of currently allocating block */
+ 	unsigned oldestDirtySequence;
+ 	unsigned oldestDirtyBlock;
+ 
+ 	/* Block refreshing */
+ 	int refreshSkip;	/* A skip down counter. Refresh happens when this gets to zero. */
+ 
+ 	/* Dirty directory handling */
+ 	struct ylist_head dirtyDirectories; /* List of dirty directories */
+ 
+ 
+ 	/* Statistcs */
+ 	__u32 nPageWrites;
+ 	__u32 nPageReads;
+ 	__u32 nBlockErasures;
+ 	__u32 nErasureFailures;
+ 	__u32 nGCCopies;
+ 	__u32 allGCs;
+ 	__u32 passiveGCs;
+ 	__u32 oldestDirtyGCs;
+ 	__u32 backgroundGCs;
+ 	__u32 nRetriedWrites;
+ 	__u32 nRetiredBlocks;
+ 	__u32 eccFixed;
+ 	__u32 eccUnfixed;
+ 	__u32 tagsEccFixed;
+ 	__u32 tagsEccUnfixed;
+ 	__u32 nDeletions;
+ 	__u32 nUnmarkedDeletions;
+ 	__u32 refreshCount;
+ 	__u32 cacheHits;
+ 
+ };
+ 
+ typedef struct yaffs_DeviceStruct yaffs_Device;
+ 
+ /* The static layout of block usage etc is stored in the super block header */
+ typedef struct {
+ 	int StructType;
+ 	int version;
+ 	int checkpointStartBlock;
+ 	int checkpointEndBlock;
+ 	int startBlock;
+ 	int endBlock;
+ 	int rfu[100];
+ } yaffs_SuperBlockHeader;
+ 
+ /* The CheckpointDevice structure holds the device information that changes at runtime and
+  * must be preserved over unmount/mount cycles.
+  */
+ typedef struct {
+ 	int structType;
+ 	int nErasedBlocks;
+ 	int allocationBlock;	/* Current block being allocated off */
+ 	__u32 allocationPage;
+ 	int nFreeChunks;
+ 
+ 	int nDeletedFiles;		/* Count of files awaiting deletion;*/
+ 	int nUnlinkedFiles;		/* Count of unlinked files. */
+ 	int nBackgroundDeletions;	/* Count of background deletions. */
+ 
+ 	/* yaffs2 runtime stuff */
+ 	unsigned sequenceNumber;	/* Sequence number of currently allocating block */
+ 
+ } yaffs_CheckpointDevice;
+ 
+ 
+ typedef struct {
+ 	int structType;
+ 	__u32 magic;
+ 	__u32 version;
+ 	__u32 head;
+ } yaffs_CheckpointValidity;
+ 
+ 
+ /*----------------------- YAFFS Functions -----------------------*/
+ 
+ int yaffs_GutsInitialise(yaffs_Device *dev);
+ void yaffs_Deinitialise(yaffs_Device *dev);
+ 
+ int yaffs_GetNumberOfFreeChunks(yaffs_Device *dev);
+ 
+ int yaffs_RenameObject(yaffs_Object *oldDir, const YCHAR *oldName,
+ 		       yaffs_Object *newDir, const YCHAR *newName);
+ 
+ int yaffs_Unlink(yaffs_Object *dir, const YCHAR *name);
+ int yaffs_DeleteObject(yaffs_Object *obj);
+ 
+ int yaffs_GetObjectName(yaffs_Object *obj, YCHAR *name, int buffSize);
+ int yaffs_GetObjectFileLength(yaffs_Object *obj);
+ int yaffs_GetObjectInode(yaffs_Object *obj);
+ unsigned yaffs_GetObjectType(yaffs_Object *obj);
+ int yaffs_GetObjectLinkCount(yaffs_Object *obj);
+ 
+ int yaffs_SetAttributes(yaffs_Object *obj, struct iattr *attr);
+ int yaffs_GetAttributes(yaffs_Object *obj, struct iattr *attr);
+ 
+ /* File operations */
+ int yaffs_ReadDataFromFile(yaffs_Object *obj, __u8 *buffer, loff_t offset,
+ 				int nBytes);
+ int yaffs_WriteDataToFile(yaffs_Object *obj, const __u8 *buffer, loff_t offset,
+ 				int nBytes, int writeThrough);
+ int yaffs_ResizeFile(yaffs_Object *obj, loff_t newSize);
+ 
+ yaffs_Object *yaffs_MknodFile(yaffs_Object *parent, const YCHAR *name,
+ 				__u32 mode, __u32 uid, __u32 gid);
+ 
+ int yaffs_FlushFile(yaffs_Object *obj, int updateTime, int dataSync);
+ 
+ /* Flushing and checkpointing */
+ void yaffs_FlushEntireDeviceCache(yaffs_Device *dev);
+ 
+ int yaffs_CheckpointSave(yaffs_Device *dev);
+ int yaffs_CheckpointRestore(yaffs_Device *dev);
+ 
+ /* Directory operations */
+ yaffs_Object *yaffs_MknodDirectory(yaffs_Object *parent, const YCHAR *name,
+ 				__u32 mode, __u32 uid, __u32 gid);
+ yaffs_Object *yaffs_FindObjectByName(yaffs_Object *theDir, const YCHAR *name);
+ int yaffs_ApplyToDirectoryChildren(yaffs_Object *theDir,
+ 				   int (*fn) (yaffs_Object *));
+ 
+ yaffs_Object *yaffs_FindObjectByNumber(yaffs_Device *dev, __u32 number);
+ 
+ /* Link operations */
+ yaffs_Object *yaffs_Link(yaffs_Object *parent, const YCHAR *name,
+ 			 yaffs_Object *equivalentObject);
+ 
+ yaffs_Object *yaffs_GetEquivalentObject(yaffs_Object *obj);
+ 
+ /* Symlink operations */
+ yaffs_Object *yaffs_MknodSymLink(yaffs_Object *parent, const YCHAR *name,
+ 				 __u32 mode, __u32 uid, __u32 gid,
+ 				 const YCHAR *alias);
+ YCHAR *yaffs_GetSymlinkAlias(yaffs_Object *obj);
+ 
+ /* Special inodes (fifos, sockets and devices) */
+ yaffs_Object *yaffs_MknodSpecial(yaffs_Object *parent, const YCHAR *name,
+ 				 __u32 mode, __u32 uid, __u32 gid, __u32 rdev);
+ 
+ /* Special directories */
+ yaffs_Object *yaffs_Root(yaffs_Device *dev);
+ yaffs_Object *yaffs_LostNFound(yaffs_Device *dev);
+ 
+ #ifdef CONFIG_YAFFS_WINCE
+ /* CONFIG_YAFFS_WINCE special stuff */
+ void yfsd_WinFileTimeNow(__u32 target[2]);
+ #endif
+ 
+ void yaffs_HandleDeferedFree(yaffs_Object *obj);
+ 
+ void yaffs_UpdateDirtyDirectories(yaffs_Device *dev);
+ 
+ int yaffs_BackgroundGarbageCollect(yaffs_Device *dev, unsigned urgency);
+ 
+ /* Debug dump  */
+ int yaffs_DumpObject(yaffs_Object *obj);
+ 
+ void yaffs_GutsTest(yaffs_Device *dev);
+ 
+ /* A few useful functions */
+ void yaffs_InitialiseTags(yaffs_ExtendedTags *tags);
+ void yaffs_DeleteChunk(yaffs_Device *dev, int chunkId, int markNAND, int lyn);
+ int yaffs_CheckFF(__u8 *buffer, int nBytes);
+ void yaffs_HandleChunkError(yaffs_Device *dev, yaffs_BlockInfo *bi);
+ 
+ __u8 *yaffs_GetTempBuffer(yaffs_Device *dev, int lineNo);
+ void yaffs_ReleaseTempBuffer(yaffs_Device *dev, __u8 *buffer, int lineNo);
+ 
+ 
+ #endif
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/yaffsinterface.h liab-linux-2.6.29.4/fs/yaffs2/yaffsinterface.h
*** linux-2.6.29.4/fs/yaffs2/yaffsinterface.h	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/yaffsinterface.h	2012-01-20 14:48:21.865306031 +0100
***************
*** 0 ****
--- 1,21 ----
+ /*
+  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+  *
+  * Copyright (C) 2002-2010 Aleph One Ltd.
+  *   for Toby Churchill Ltd and Brightstar Engineering
+  *
+  * Created by Charles Manning <charles@aleph1.co.uk>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU Lesser General Public License version 2.1 as
+  * published by the Free Software Foundation.
+  *
+  * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+  */
+ 
+ #ifndef __YAFFSINTERFACE_H__
+ #define __YAFFSINTERFACE_H__
+ 
+ int yaffs_Initialise(unsigned nBlocks);
+ 
+ #endif
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/yaffs_linux.h liab-linux-2.6.29.4/fs/yaffs2/yaffs_linux.h
*** linux-2.6.29.4/fs/yaffs2/yaffs_linux.h	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/yaffs_linux.h	2012-01-20 14:48:21.869306031 +0100
***************
*** 0 ****
--- 1,42 ----
+ /*
+  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+  *
+  * Copyright (C) 2002-2010 Aleph One Ltd.
+  *   for Toby Churchill Ltd and Brightstar Engineering
+  *
+  * Created by Charles Manning <charles@aleph1.co.uk>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU Lesser General Public License version 2.1 as
+  * published by the Free Software Foundation.
+  *
+  * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+  */
+ 
+ #ifndef __YAFFS_LINUX_H__
+ #define __YAFFS_LINUX_H__
+ 
+ #include "devextras.h"
+ #include "yportenv.h"
+ 
+ struct yaffs_LinuxContext {
+ 	struct ylist_head	contextList; /* List of these we have mounted */
+ 	struct yaffs_DeviceStruct *dev;
+ 	struct super_block * superBlock;
+ 	struct task_struct *bgThread; /* Background thread for this device */
+ 	int bgRunning;
+         struct semaphore grossLock;     /* Gross locking semaphore */
+ 	__u8 *spareBuffer;      /* For mtdif2 use. Don't know the size of the buffer
+ 				 * at compile time so we have to allocate it.
+ 				 */
+ 	struct mtd_info *mtd;
+ 	struct ylist_head searchContexts;
+ 	void (*putSuperFunc)(struct super_block *sb);
+ 
+ 	struct task_struct *readdirProcess;
+ };
+ 
+ #define yaffs_DeviceToContext(dev) ((struct yaffs_LinuxContext *)((dev)->context))
+ 
+ #endif
+ 
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/yaffs_mtdif1.c liab-linux-2.6.29.4/fs/yaffs2/yaffs_mtdif1.c
*** linux-2.6.29.4/fs/yaffs2/yaffs_mtdif1.c	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/yaffs_mtdif1.c	2012-01-20 14:48:21.865306031 +0100
***************
*** 0 ****
--- 1,361 ----
+ /*
+  * YAFFS: Yet another FFS. A NAND-flash specific file system.
+  * yaffs_mtdif1.c  NAND mtd interface functions for small-page NAND.
+  *
+  * Copyright (C) 2002-2010 Aleph One Ltd.
+  *   for Toby Churchill Ltd and Brightstar Engineering
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2 as
+  * published by the Free Software Foundation.
+  */
+ 
+ /*
+  * This module provides the interface between yaffs_nand.c and the
+  * MTD API.  This version is used when the MTD interface supports the
+  * 'mtd_oob_ops' style calls to read_oob and write_oob, circa 2.6.17,
+  * and we have small-page NAND device.
+  *
+  * These functions are invoked via function pointers in yaffs_nand.c.
+  * This replaces functionality provided by functions in yaffs_mtdif.c
+  * and the yaffs_TagsCompatability functions in yaffs_tagscompat.c that are
+  * called in yaffs_mtdif.c when the function pointers are NULL.
+  * We assume the MTD layer is performing ECC (useNANDECC is true).
+  */
+ 
+ #include "yportenv.h"
+ #include "yaffs_trace.h"
+ #include "yaffs_guts.h"
+ #include "yaffs_packedtags1.h"
+ #include "yaffs_tagscompat.h"	/* for yaffs_CalcTagsECC */
+ #include "yaffs_linux.h"
+ 
+ #include "linux/kernel.h"
+ #include "linux/version.h"
+ #include "linux/types.h"
+ #include "linux/mtd/mtd.h"
+ 
+ /* Don't compile this module if we don't have MTD's mtd_oob_ops interface */
+ #if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
+ 
+ #ifndef CONFIG_YAFFS_9BYTE_TAGS
+ # define YTAG1_SIZE 8
+ #else
+ # define YTAG1_SIZE 9
+ #endif
+ 
+ #if 0
+ /* Use the following nand_ecclayout with MTD when using
+  * CONFIG_YAFFS_9BYTE_TAGS and the older on-NAND tags layout.
+  * If you have existing Yaffs images and the byte order differs from this,
+  * adjust 'oobfree' to match your existing Yaffs data.
+  *
+  * This nand_ecclayout scatters/gathers to/from the old-yaffs layout with the
+  * pageStatus byte (at NAND spare offset 4) scattered/gathered from/to
+  * the 9th byte.
+  *
+  * Old-style on-NAND format: T0,T1,T2,T3,P,B,T4,T5,E0,E1,E2,T6,T7,E3,E4,E5
+  * We have/need PackedTags1 plus pageStatus: T0,T1,T2,T3,T4,T5,T6,T7,P
+  * where Tn are the tag bytes, En are MTD's ECC bytes, P is the pageStatus
+  * byte and B is the small-page bad-block indicator byte.
+  */
+ static struct nand_ecclayout nand_oob_16 = {
+ 	.eccbytes = 6,
+ 	.eccpos = { 8, 9, 10, 13, 14, 15 },
+ 	.oobavail = 9,
+ 	.oobfree = { { 0, 4 }, { 6, 2 }, { 11, 2 }, { 4, 1 } }
+ };
+ #endif
+ 
+ /* Write a chunk (page) of data to NAND.
+  *
+  * Caller always provides ExtendedTags data which are converted to a more
+  * compact (packed) form for storage in NAND.  A mini-ECC runs over the
+  * contents of the tags meta-data; used to valid the tags when read.
+  *
+  *  - Pack ExtendedTags to PackedTags1 form
+  *  - Compute mini-ECC for PackedTags1
+  *  - Write data and packed tags to NAND.
+  *
+  * Note: Due to the use of the PackedTags1 meta-data which does not include
+  * a full sequence number (as found in the larger PackedTags2 form) it is
+  * necessary for Yaffs to re-write a chunk/page (just once) to mark it as
+  * discarded and dirty.  This is not ideal: newer NAND parts are supposed
+  * to be written just once.  When Yaffs performs this operation, this
+  * function is called with a NULL data pointer -- calling MTD write_oob
+  * without data is valid usage (2.6.17).
+  *
+  * Any underlying MTD error results in YAFFS_FAIL.
+  * Returns YAFFS_OK or YAFFS_FAIL.
+  */
+ int nandmtd1_WriteChunkWithTagsToNAND(yaffs_Device *dev,
+ 	int chunkInNAND, const __u8 *data, const yaffs_ExtendedTags *etags)
+ {
+ 	struct mtd_info *mtd = yaffs_DeviceToContext(dev)->mtd;
+ 	int chunkBytes = dev->nDataBytesPerChunk;
+ 	loff_t addr = ((loff_t)chunkInNAND) * chunkBytes;
+ 	struct mtd_oob_ops ops;
+ 	yaffs_PackedTags1 pt1;
+ 	int retval;
+ 
+ 	/* we assume that PackedTags1 and yaffs_Tags are compatible */
+ 	compile_time_assertion(sizeof(yaffs_PackedTags1) == 12);
+ 	compile_time_assertion(sizeof(yaffs_Tags) == 8);
+ 
+ 	yaffs_PackTags1(&pt1, etags);
+ 	yaffs_CalcTagsECC((yaffs_Tags *)&pt1);
+ 
+ 	/* When deleting a chunk, the upper layer provides only skeletal
+ 	 * etags, one with chunkDeleted set.  However, we need to update the
+ 	 * tags, not erase them completely.  So we use the NAND write property
+ 	 * that only zeroed-bits stick and set tag bytes to all-ones and
+ 	 * zero just the (not) deleted bit.
+ 	 */
+ #ifndef CONFIG_YAFFS_9BYTE_TAGS
+ 	if (etags->chunkDeleted) {
+ 		memset(&pt1, 0xff, 8);
+ 		/* clear delete status bit to indicate deleted */
+ 		pt1.deleted = 0;
+ 	}
+ #else
+ 	((__u8 *)&pt1)[8] = 0xff;
+ 	if (etags->chunkDeleted) {
+ 		memset(&pt1, 0xff, 8);
+ 		/* zero pageStatus byte to indicate deleted */
+ 		((__u8 *)&pt1)[8] = 0;
+ 	}
+ #endif
+ 
+ 	memset(&ops, 0, sizeof(ops));
+ 	ops.mode = MTD_OOB_AUTO;
+ 	ops.len = (data) ? chunkBytes : 0;
+ 	ops.ooblen = YTAG1_SIZE;
+ 	ops.datbuf = (__u8 *)data;
+ 	ops.oobbuf = (__u8 *)&pt1;
+ 
+ 	retval = mtd->write_oob(mtd, addr, &ops);
+ 	if (retval) {
+ 		T(YAFFS_TRACE_MTD,
+ 			(TSTR("write_oob failed, chunk %d, mtd error %d"TENDSTR),
+ 			chunkInNAND, retval));
+ 	}
+ 	return retval ? YAFFS_FAIL : YAFFS_OK;
+ }
+ 
+ /* Return with empty ExtendedTags but add eccResult.
+  */
+ static int rettags(yaffs_ExtendedTags *etags, int eccResult, int retval)
+ {
+ 	if (etags) {
+ 		memset(etags, 0, sizeof(*etags));
+ 		etags->eccResult = eccResult;
+ 	}
+ 	return retval;
+ }
+ 
+ /* Read a chunk (page) from NAND.
+  *
+  * Caller expects ExtendedTags data to be usable even on error; that is,
+  * all members except eccResult and blockBad are zeroed.
+  *
+  *  - Check ECC results for data (if applicable)
+  *  - Check for blank/erased block (return empty ExtendedTags if blank)
+  *  - Check the PackedTags1 mini-ECC (correct if necessary/possible)
+  *  - Convert PackedTags1 to ExtendedTags
+  *  - Update eccResult and blockBad members to refect state.
+  *
+  * Returns YAFFS_OK or YAFFS_FAIL.
+  */
+ int nandmtd1_ReadChunkWithTagsFromNAND(yaffs_Device *dev,
+ 	int chunkInNAND, __u8 *data, yaffs_ExtendedTags *etags)
+ {
+ 	struct mtd_info *mtd = yaffs_DeviceToContext(dev)->mtd;
+ 	int chunkBytes = dev->nDataBytesPerChunk;
+ 	loff_t addr = ((loff_t)chunkInNAND) * chunkBytes;
+ 	int eccres = YAFFS_ECC_RESULT_NO_ERROR;
+ 	struct mtd_oob_ops ops;
+ 	yaffs_PackedTags1 pt1;
+ 	int retval;
+ 	int deleted;
+ 
+ 	memset(&ops, 0, sizeof(ops));
+ 	ops.mode = MTD_OOB_AUTO;
+ 	ops.len = (data) ? chunkBytes : 0;
+ 	ops.ooblen = YTAG1_SIZE;
+ 	ops.datbuf = data;
+ 	ops.oobbuf = (__u8 *)&pt1;
+ 
+ #if (MTD_VERSION_CODE < MTD_VERSION(2, 6, 20))
+ 	/* In MTD 2.6.18 to 2.6.19 nand_base.c:nand_do_read_oob() has a bug;
+ 	 * help it out with ops.len = ops.ooblen when ops.datbuf == NULL.
+ 	 */
+ 	ops.len = (ops.datbuf) ? ops.len : ops.ooblen;
+ #endif
+ 	/* Read page and oob using MTD.
+ 	 * Check status and determine ECC result.
+ 	 */
+ 	retval = mtd->read_oob(mtd, addr, &ops);
+ 	if (retval) {
+ 		T(YAFFS_TRACE_MTD,
+ 			(TSTR("read_oob failed, chunk %d, mtd error %d"TENDSTR),
+ 			chunkInNAND, retval));
+ 	}
+ 
+ 	switch (retval) {
+ 	case 0:
+ 		/* no error */
+ 		break;
+ 
+ 	case -EUCLEAN:
+ 		/* MTD's ECC fixed the data */
+ 		eccres = YAFFS_ECC_RESULT_FIXED;
+ 		dev->eccFixed++;
+ 		break;
+ 
+ 	case -EBADMSG:
+ 		/* MTD's ECC could not fix the data */
+ 		dev->eccUnfixed++;
+ 		/* fall into... */
+ 	default:
+ 		rettags(etags, YAFFS_ECC_RESULT_UNFIXED, 0);
+ 		etags->blockBad = (mtd->block_isbad)(mtd, addr);
+ 		return YAFFS_FAIL;
+ 	}
+ 
+ 	/* Check for a blank/erased chunk.
+ 	 */
+ 	if (yaffs_CheckFF((__u8 *)&pt1, 8)) {
+ 		/* when blank, upper layers want eccResult to be <= NO_ERROR */
+ 		return rettags(etags, YAFFS_ECC_RESULT_NO_ERROR, YAFFS_OK);
+ 	}
+ 
+ #ifndef CONFIG_YAFFS_9BYTE_TAGS
+ 	/* Read deleted status (bit) then return it to it's non-deleted
+ 	 * state before performing tags mini-ECC check. pt1.deleted is
+ 	 * inverted.
+ 	 */
+ 	deleted = !pt1.deleted;
+ 	pt1.deleted = 1;
+ #else
+ 	deleted = (yaffs_CountBits(((__u8 *)&pt1)[8]) < 7);
+ #endif
+ 
+ 	/* Check the packed tags mini-ECC and correct if necessary/possible.
+ 	 */
+ 	retval = yaffs_CheckECCOnTags((yaffs_Tags *)&pt1);
+ 	switch (retval) {
+ 	case 0:
+ 		/* no tags error, use MTD result */
+ 		break;
+ 	case 1:
+ 		/* recovered tags-ECC error */
+ 		dev->tagsEccFixed++;
+ 		if (eccres == YAFFS_ECC_RESULT_NO_ERROR)
+ 			eccres = YAFFS_ECC_RESULT_FIXED;
+ 		break;
+ 	default:
+ 		/* unrecovered tags-ECC error */
+ 		dev->tagsEccUnfixed++;
+ 		return rettags(etags, YAFFS_ECC_RESULT_UNFIXED, YAFFS_FAIL);
+ 	}
+ 
+ 	/* Unpack the tags to extended form and set ECC result.
+ 	 * [set shouldBeFF just to keep yaffs_UnpackTags1 happy]
+ 	 */
+ 	pt1.shouldBeFF = 0xFFFFFFFF;
+ 	yaffs_UnpackTags1(etags, &pt1);
+ 	etags->eccResult = eccres;
+ 
+ 	/* Set deleted state */
+ 	etags->chunkDeleted = deleted;
+ 	return YAFFS_OK;
+ }
+ 
+ /* Mark a block bad.
+  *
+  * This is a persistant state.
+  * Use of this function should be rare.
+  *
+  * Returns YAFFS_OK or YAFFS_FAIL.
+  */
+ int nandmtd1_MarkNANDBlockBad(struct yaffs_DeviceStruct *dev, int blockNo)
+ {
+ 	struct mtd_info *mtd = yaffs_DeviceToContext(dev)->mtd;
+ 	int blocksize = dev->param.nChunksPerBlock * dev->nDataBytesPerChunk;
+ 	int retval;
+ 
+ 	T(YAFFS_TRACE_BAD_BLOCKS,(TSTR("marking block %d bad"TENDSTR), blockNo));
+ 
+ 	retval = mtd->block_markbad(mtd, (loff_t)blocksize * blockNo);
+ 	return (retval) ? YAFFS_FAIL : YAFFS_OK;
+ }
+ 
+ /* Check any MTD prerequists.
+  *
+  * Returns YAFFS_OK or YAFFS_FAIL.
+  */
+ static int nandmtd1_TestPrerequists(struct mtd_info *mtd)
+ {
+ 	/* 2.6.18 has mtd->ecclayout->oobavail */
+ 	/* 2.6.21 has mtd->ecclayout->oobavail and mtd->oobavail */
+ 	int oobavail = mtd->ecclayout->oobavail;
+ 
+ 	if (oobavail < YTAG1_SIZE) {
+ 		T(YAFFS_TRACE_ERROR,
+ 			(TSTR("mtd device has only %d bytes for tags, need %d"TENDSTR),
+ 			oobavail, YTAG1_SIZE));
+ 		return YAFFS_FAIL;
+ 	}
+ 	return YAFFS_OK;
+ }
+ 
+ /* Query for the current state of a specific block.
+  *
+  * Examine the tags of the first chunk of the block and return the state:
+  *  - YAFFS_BLOCK_STATE_DEAD, the block is marked bad
+  *  - YAFFS_BLOCK_STATE_NEEDS_SCANNING, the block is in use
+  *  - YAFFS_BLOCK_STATE_EMPTY, the block is clean
+  *
+  * Always returns YAFFS_OK.
+  */
+ int nandmtd1_QueryNANDBlock(struct yaffs_DeviceStruct *dev, int blockNo,
+ 	yaffs_BlockState *pState, __u32 *pSequenceNumber)
+ {
+ 	struct mtd_info *mtd = yaffs_DeviceToContext(dev)->mtd;
+ 	int chunkNo = blockNo * dev->param.nChunksPerBlock;
+ 	loff_t addr = (loff_t)chunkNo * dev->nDataBytesPerChunk;
+ 	yaffs_ExtendedTags etags;
+ 	int state = YAFFS_BLOCK_STATE_DEAD;
+ 	int seqnum = 0;
+ 	int retval;
+ 
+ 	/* We don't yet have a good place to test for MTD config prerequists.
+ 	 * Do it here as we are called during the initial scan.
+ 	 */
+ 	if (nandmtd1_TestPrerequists(mtd) != YAFFS_OK)
+ 		return YAFFS_FAIL;
+ 
+ 	retval = nandmtd1_ReadChunkWithTagsFromNAND(dev, chunkNo, NULL, &etags);
+ 	etags.blockBad = (mtd->block_isbad)(mtd, addr);
+ 	if (etags.blockBad) {
+ 		T(YAFFS_TRACE_BAD_BLOCKS,
+ 			(TSTR("block %d is marked bad"TENDSTR), blockNo));
+ 		state = YAFFS_BLOCK_STATE_DEAD;
+ 	} else if (etags.eccResult != YAFFS_ECC_RESULT_NO_ERROR) {
+ 		/* bad tags, need to look more closely */
+ 		state = YAFFS_BLOCK_STATE_NEEDS_SCANNING;
+ 	} else if (etags.chunkUsed) {
+ 		state = YAFFS_BLOCK_STATE_NEEDS_SCANNING;
+ 		seqnum = etags.sequenceNumber;
+ 	} else {
+ 		state = YAFFS_BLOCK_STATE_EMPTY;
+ 	}
+ 
+ 	*pState = state;
+ 	*pSequenceNumber = seqnum;
+ 
+ 	/* query always succeeds */
+ 	return YAFFS_OK;
+ }
+ 
+ #endif /*MTD_VERSION*/
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/yaffs_mtdif1.h liab-linux-2.6.29.4/fs/yaffs2/yaffs_mtdif1.h
*** linux-2.6.29.4/fs/yaffs2/yaffs_mtdif1.h	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/yaffs_mtdif1.h	2012-01-20 14:48:21.869306031 +0100
***************
*** 0 ****
--- 1,28 ----
+ /*
+  * YAFFS: Yet another Flash File System. A NAND-flash specific file system.
+  *
+  * Copyright (C) 2002-2010 Aleph One Ltd.
+  *   for Toby Churchill Ltd and Brightstar Engineering
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU Lesser General Public License version 2.1 as
+  * published by the Free Software Foundation.
+  *
+  * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+  */
+ 
+ #ifndef __YAFFS_MTDIF1_H__
+ #define __YAFFS_MTDIF1_H__
+ 
+ int nandmtd1_WriteChunkWithTagsToNAND(yaffs_Device *dev, int chunkInNAND,
+ 	const __u8 *data, const yaffs_ExtendedTags *tags);
+ 
+ int nandmtd1_ReadChunkWithTagsFromNAND(yaffs_Device *dev, int chunkInNAND,
+ 	__u8 *data, yaffs_ExtendedTags *tags);
+ 
+ int nandmtd1_MarkNANDBlockBad(struct yaffs_DeviceStruct *dev, int blockNo);
+ 
+ int nandmtd1_QueryNANDBlock(struct yaffs_DeviceStruct *dev, int blockNo,
+ 	yaffs_BlockState *state, __u32 *sequenceNumber);
+ 
+ #endif
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/yaffs_mtdif2.c liab-linux-2.6.29.4/fs/yaffs2/yaffs_mtdif2.c
*** linux-2.6.29.4/fs/yaffs2/yaffs_mtdif2.c	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/yaffs_mtdif2.c	2012-01-20 14:48:21.865306031 +0100
***************
*** 0 ****
--- 1,257 ----
+ /*
+  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+  *
+  * Copyright (C) 2002-2010 Aleph One Ltd.
+  *   for Toby Churchill Ltd and Brightstar Engineering
+  *
+  * Created by Charles Manning <charles@aleph1.co.uk>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2 as
+  * published by the Free Software Foundation.
+  */
+ 
+ /* mtd interface for YAFFS2 */
+ 
+ #include "yportenv.h"
+ #include "yaffs_trace.h"
+ 
+ #include "yaffs_mtdif2.h"
+ 
+ #include "linux/mtd/mtd.h"
+ #include "linux/types.h"
+ #include "linux/time.h"
+ 
+ #include "yaffs_packedtags2.h"
+ 
+ #include "yaffs_linux.h"
+ 
+ /* NB For use with inband tags....
+  * We assume that the data buffer is of size totalBytersPerChunk so that we can also
+  * use it to load the tags.
+  */
+ int nandmtd2_WriteChunkWithTagsToNAND(yaffs_Device *dev, int chunkInNAND,
+ 				      const __u8 *data,
+ 				      const yaffs_ExtendedTags *tags)
+ {
+ 	struct mtd_info *mtd = yaffs_DeviceToContext(dev)->mtd;
+ #if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
+ 	struct mtd_oob_ops ops;
+ #else
+ 	size_t dummy;
+ #endif
+ 	int retval = 0;
+ 
+ 	loff_t addr;
+ 
+ 	yaffs_PackedTags2 pt;
+ 
+ 	int packed_tags_size = dev->param.noTagsECC ? sizeof(pt.t) : sizeof(pt);
+ 	void * packed_tags_ptr = dev->param.noTagsECC ? (void *) &pt.t : (void *)&pt;
+ 
+ 	T(YAFFS_TRACE_MTD,
+ 	  (TSTR
+ 	   ("nandmtd2_WriteChunkWithTagsToNAND chunk %d data %p tags %p"
+ 	    TENDSTR), chunkInNAND, data, tags));
+ 
+ 
+ 	addr  = ((loff_t) chunkInNAND) * dev->param.totalBytesPerChunk;
+ 
+ 	/* For yaffs2 writing there must be both data and tags.
+ 	 * If we're using inband tags, then the tags are stuffed into
+ 	 * the end of the data buffer.
+ 	 */
+ 	if (!data || !tags)
+ 		BUG();
+ 	else if (dev->param.inbandTags) {
+ 		yaffs_PackedTags2TagsPart *pt2tp;
+ 		pt2tp = (yaffs_PackedTags2TagsPart *)(data + dev->nDataBytesPerChunk);
+ 		yaffs_PackTags2TagsPart(pt2tp, tags);
+ 	} else
+ 		yaffs_PackTags2(&pt, tags, !dev->param.noTagsECC);
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+ 	ops.mode = MTD_OOB_AUTO;
+ 	ops.ooblen = (dev->param.inbandTags) ? 0 : packed_tags_size;
+ 	ops.len = dev->param.totalBytesPerChunk;
+ 	ops.ooboffs = 0;
+ 	ops.datbuf = (__u8 *)data;
+ 	ops.oobbuf = (dev->param.inbandTags) ? NULL : packed_tags_ptr;
+ 	retval = mtd->write_oob(mtd, addr, &ops);
+ 
+ #else
+ 	if (!dev->param.inbandTags) {
+ 		retval =
+ 		    mtd->write_ecc(mtd, addr, dev->nDataBytesPerChunk,
+ 				   &dummy, data, (__u8 *) packed_tags_ptr, NULL);
+ 	} else {
+ 		retval =
+ 		    mtd->write(mtd, addr, dev->param.totalBytesPerChunk, &dummy,
+ 			       data);
+ 	}
+ #endif
+ 
+ 	if (retval == 0)
+ 		return YAFFS_OK;
+ 	else
+ 		return YAFFS_FAIL;
+ }
+ 
+ int nandmtd2_ReadChunkWithTagsFromNAND(yaffs_Device *dev, int chunkInNAND,
+ 				       __u8 *data, yaffs_ExtendedTags *tags)
+ {
+ 	struct mtd_info *mtd = yaffs_DeviceToContext(dev)->mtd;
+ #if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
+ 	struct mtd_oob_ops ops;
+ #endif
+ 	size_t dummy;
+ 	int retval = 0;
+ 	int localData = 0;
+ 
+ 	loff_t addr = ((loff_t) chunkInNAND) * dev->param.totalBytesPerChunk;
+ 
+ 	yaffs_PackedTags2 pt;
+ 
+ 	int packed_tags_size = dev->param.noTagsECC ? sizeof(pt.t) : sizeof(pt);
+ 	void * packed_tags_ptr = dev->param.noTagsECC ? (void *) &pt.t: (void *)&pt;
+ 
+ 	T(YAFFS_TRACE_MTD,
+ 	  (TSTR
+ 	   ("nandmtd2_ReadChunkWithTagsFromNAND chunk %d data %p tags %p"
+ 	    TENDSTR), chunkInNAND, data, tags));
+ 
+ 	if (dev->param.inbandTags) {
+ 
+ 		if (!data) {
+ 			localData = 1;
+ 			data = yaffs_GetTempBuffer(dev, __LINE__);
+ 		}
+ 
+ 
+ 	}
+ 
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+ 	if (dev->param.inbandTags || (data && !tags))
+ 		retval = mtd->read(mtd, addr, dev->param.totalBytesPerChunk,
+ 				&dummy, data);
+ 	else if (tags) {
+ 		ops.mode = MTD_OOB_AUTO;
+ 		ops.ooblen = packed_tags_size;
+ 		ops.len = data ? dev->nDataBytesPerChunk : packed_tags_size;
+ 		ops.ooboffs = 0;
+ 		ops.datbuf = data;
+ 		ops.oobbuf = yaffs_DeviceToContext(dev)->spareBuffer;
+ 		retval = mtd->read_oob(mtd, addr, &ops);
+ 	}
+ #else
+ 	if (!dev->param.inbandTags && data && tags) {
+ 
+ 		retval = mtd->read_ecc(mtd, addr, dev->nDataBytesPerChunk,
+ 					  &dummy, data, dev->spareBuffer,
+ 					  NULL);
+ 	} else {
+ 		if (data)
+ 			retval =
+ 			    mtd->read(mtd, addr, dev->nDataBytesPerChunk, &dummy,
+ 				      data);
+ 		if (!dev->param.inbandTags && tags)
+ 			retval =
+ 			    mtd->read_oob(mtd, addr, mtd->oobsize, &dummy,
+ 					  dev->spareBuffer);
+ 	}
+ #endif
+ 
+ 
+ 	if (dev->param.inbandTags) {
+ 		if (tags) {
+ 			yaffs_PackedTags2TagsPart *pt2tp;
+ 			pt2tp = (yaffs_PackedTags2TagsPart *)&data[dev->nDataBytesPerChunk];
+ 			yaffs_UnpackTags2TagsPart(tags, pt2tp);
+ 		}
+ 	} else {
+ 		if (tags) {
+ 			memcpy(packed_tags_ptr, yaffs_DeviceToContext(dev)->spareBuffer, packed_tags_size);
+ 			yaffs_UnpackTags2(tags, &pt, !dev->param.noTagsECC);
+ 		}
+ 	}
+ 
+ 	if (localData)
+ 		yaffs_ReleaseTempBuffer(dev, data, __LINE__);
+ 
+ 	if (tags && retval == -EBADMSG && tags->eccResult == YAFFS_ECC_RESULT_NO_ERROR) {
+ 		tags->eccResult = YAFFS_ECC_RESULT_UNFIXED;
+ 		dev->eccUnfixed++;
+ 	}
+ 	if(tags && retval == -EUCLEAN && tags->eccResult == YAFFS_ECC_RESULT_NO_ERROR) {
+ 		tags->eccResult = YAFFS_ECC_RESULT_FIXED;
+ 		dev->eccFixed++;
+ 	}
+ 	if (retval == 0)
+ 		return YAFFS_OK;
+ 	else
+ 		return YAFFS_FAIL;
+ }
+ 
+ int nandmtd2_MarkNANDBlockBad(struct yaffs_DeviceStruct *dev, int blockNo)
+ {
+ 	struct mtd_info *mtd = yaffs_DeviceToContext(dev)->mtd;
+ 	int retval;
+ 	T(YAFFS_TRACE_MTD,
+ 	  (TSTR("nandmtd2_MarkNANDBlockBad %d" TENDSTR), blockNo));
+ 
+ 	retval =
+ 	    mtd->block_markbad(mtd,
+ 			       blockNo * dev->param.nChunksPerBlock *
+ 			       dev->param.totalBytesPerChunk);
+ 
+ 	if (retval == 0)
+ 		return YAFFS_OK;
+ 	else
+ 		return YAFFS_FAIL;
+ 
+ }
+ 
+ int nandmtd2_QueryNANDBlock(struct yaffs_DeviceStruct *dev, int blockNo,
+ 			    yaffs_BlockState *state, __u32 *sequenceNumber)
+ {
+ 	struct mtd_info *mtd = yaffs_DeviceToContext(dev)->mtd;
+ 	int retval;
+ 
+ 	T(YAFFS_TRACE_MTD,
+ 	  (TSTR("nandmtd2_QueryNANDBlock %d" TENDSTR), blockNo));
+ 	retval =
+ 	    mtd->block_isbad(mtd,
+ 			     blockNo * dev->param.nChunksPerBlock *
+ 			     dev->param.totalBytesPerChunk);
+ 
+ 	if (retval) {
+ 		T(YAFFS_TRACE_MTD, (TSTR("block is bad" TENDSTR)));
+ 
+ 		*state = YAFFS_BLOCK_STATE_DEAD;
+ 		*sequenceNumber = 0;
+ 	} else {
+ 		yaffs_ExtendedTags t;
+ 		nandmtd2_ReadChunkWithTagsFromNAND(dev,
+ 						   blockNo *
+ 						   dev->param.nChunksPerBlock, NULL,
+ 						   &t);
+ 
+ 		if (t.chunkUsed) {
+ 			*sequenceNumber = t.sequenceNumber;
+ 			*state = YAFFS_BLOCK_STATE_NEEDS_SCANNING;
+ 		} else {
+ 			*sequenceNumber = 0;
+ 			*state = YAFFS_BLOCK_STATE_EMPTY;
+ 		}
+ 	}
+ 	T(YAFFS_TRACE_MTD,
+ 	  (TSTR("block is bad seq %d state %d" TENDSTR), *sequenceNumber,
+ 	   *state));
+ 
+ 	if (retval == 0)
+ 		return YAFFS_OK;
+ 	else
+ 		return YAFFS_FAIL;
+ }
+ 
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/yaffs_mtdif2.h liab-linux-2.6.29.4/fs/yaffs2/yaffs_mtdif2.h
*** linux-2.6.29.4/fs/yaffs2/yaffs_mtdif2.h	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/yaffs_mtdif2.h	2012-01-20 14:48:21.869306031 +0100
***************
*** 0 ****
--- 1,29 ----
+ /*
+  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+  *
+  * Copyright (C) 2002-2010 Aleph One Ltd.
+  *   for Toby Churchill Ltd and Brightstar Engineering
+  *
+  * Created by Charles Manning <charles@aleph1.co.uk>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU Lesser General Public License version 2.1 as
+  * published by the Free Software Foundation.
+  *
+  * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+  */
+ 
+ #ifndef __YAFFS_MTDIF2_H__
+ #define __YAFFS_MTDIF2_H__
+ 
+ #include "yaffs_guts.h"
+ int nandmtd2_WriteChunkWithTagsToNAND(yaffs_Device *dev, int chunkInNAND,
+ 				const __u8 *data,
+ 				const yaffs_ExtendedTags *tags);
+ int nandmtd2_ReadChunkWithTagsFromNAND(yaffs_Device *dev, int chunkInNAND,
+ 				__u8 *data, yaffs_ExtendedTags *tags);
+ int nandmtd2_MarkNANDBlockBad(struct yaffs_DeviceStruct *dev, int blockNo);
+ int nandmtd2_QueryNANDBlock(struct yaffs_DeviceStruct *dev, int blockNo,
+ 			yaffs_BlockState *state, __u32 *sequenceNumber);
+ 
+ #endif
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/yaffs_mtdif.c liab-linux-2.6.29.4/fs/yaffs2/yaffs_mtdif.c
*** linux-2.6.29.4/fs/yaffs2/yaffs_mtdif.c	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/yaffs_mtdif.c	2012-01-20 14:48:21.869306031 +0100
***************
*** 0 ****
--- 1,56 ----
+ /*
+  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+  *
+  * Copyright (C) 2002-2010 Aleph One Ltd.
+  *   for Toby Churchill Ltd and Brightstar Engineering
+  *
+  * Created by Charles Manning <charles@aleph1.co.uk>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2 as
+  * published by the Free Software Foundation.
+  */
+ 
+ #include "yportenv.h"
+ 
+ 
+ #include "yaffs_mtdif.h"
+ 
+ #include "linux/mtd/mtd.h"
+ #include "linux/types.h"
+ #include "linux/time.h"
+ #include "linux/mtd/nand.h"
+ 
+ #include "yaffs_linux.h"
+ 
+ int nandmtd_EraseBlockInNAND(yaffs_Device *dev, int blockNumber)
+ {
+ 	struct mtd_info *mtd = yaffs_DeviceToContext(dev)->mtd;
+ 	__u32 addr =
+ 	    ((loff_t) blockNumber) * dev->param.totalBytesPerChunk
+ 		* dev->param.nChunksPerBlock;
+ 	struct erase_info ei;
+ 	
+ 	int retval = 0;
+ 
+ 	ei.mtd = mtd;
+ 	ei.addr = addr;
+ 	ei.len = dev->param.totalBytesPerChunk * dev->param.nChunksPerBlock;
+ 	ei.time = 1000;
+ 	ei.retries = 2;
+ 	ei.callback = NULL;
+ 	ei.priv = (u_long) dev;
+ 
+ 	retval = mtd->erase(mtd, &ei);
+ 
+ 	if (retval == 0)
+ 		return YAFFS_OK;
+ 	else
+ 		return YAFFS_FAIL;
+ }
+ 
+ int nandmtd_InitialiseNAND(yaffs_Device *dev)
+ {
+ 	return YAFFS_OK;
+ }
+ 
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/yaffs_mtdif.h liab-linux-2.6.29.4/fs/yaffs2/yaffs_mtdif.h
*** linux-2.6.29.4/fs/yaffs2/yaffs_mtdif.h	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/yaffs_mtdif.h	2012-01-20 14:48:21.861306032 +0100
***************
*** 0 ****
--- 1,27 ----
+ /*
+  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+  *
+  * Copyright (C) 2002-2010 Aleph One Ltd.
+  *   for Toby Churchill Ltd and Brightstar Engineering
+  *
+  * Created by Charles Manning <charles@aleph1.co.uk>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU Lesser General Public License version 2.1 as
+  * published by the Free Software Foundation.
+  *
+  * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+  */
+ 
+ #ifndef __YAFFS_MTDIF_H__
+ #define __YAFFS_MTDIF_H__
+ 
+ #include "yaffs_guts.h"
+ 
+ #if (MTD_VERSION_CODE < MTD_VERSION(2, 6, 18))
+ extern struct nand_oobinfo yaffs_oobinfo;
+ extern struct nand_oobinfo yaffs_noeccinfo;
+ #endif
+ int nandmtd_EraseBlockInNAND(yaffs_Device *dev, int blockNumber);
+ int nandmtd_InitialiseNAND(yaffs_Device *dev);
+ #endif
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/yaffs_nand.c liab-linux-2.6.29.4/fs/yaffs2/yaffs_nand.c
*** linux-2.6.29.4/fs/yaffs2/yaffs_nand.c	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/yaffs_nand.c	2012-01-20 14:48:21.865306031 +0100
***************
*** 0 ****
--- 1,140 ----
+ /*
+  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+  *
+  * Copyright (C) 2002-2010 Aleph One Ltd.
+  *   for Toby Churchill Ltd and Brightstar Engineering
+  *
+  * Created by Charles Manning <charles@aleph1.co.uk>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2 as
+  * published by the Free Software Foundation.
+  */
+ 
+ #include "yaffs_nand.h"
+ #include "yaffs_tagscompat.h"
+ #include "yaffs_tagsvalidity.h"
+ 
+ #include "yaffs_getblockinfo.h"
+ 
+ int yaffs_ReadChunkWithTagsFromNAND(yaffs_Device *dev, int chunkInNAND,
+ 					   __u8 *buffer,
+ 					   yaffs_ExtendedTags *tags)
+ {
+ 	int result;
+ 	yaffs_ExtendedTags localTags;
+ 
+ 	int realignedChunkInNAND = chunkInNAND - dev->chunkOffset;
+ 
+ 	dev->nPageReads++;
+ 
+ 	/* If there are no tags provided, use local tags to get prioritised gc working */
+ 	if (!tags)
+ 		tags = &localTags;
+ 
+ 	if (dev->param.readChunkWithTagsFromNAND)
+ 		result = dev->param.readChunkWithTagsFromNAND(dev, realignedChunkInNAND, buffer,
+ 						      tags);
+ 	else
+ 		result = yaffs_TagsCompatabilityReadChunkWithTagsFromNAND(dev,
+ 									realignedChunkInNAND,
+ 									buffer,
+ 									tags);
+ 	if (tags &&
+ 	   tags->eccResult > YAFFS_ECC_RESULT_NO_ERROR) {
+ 
+ 		yaffs_BlockInfo *bi;
+ 		bi = yaffs_GetBlockInfo(dev, chunkInNAND/dev->param.nChunksPerBlock);
+ 		yaffs_HandleChunkError(dev, bi);
+ 	}
+ 
+ 	return result;
+ }
+ 
+ int yaffs_WriteChunkWithTagsToNAND(yaffs_Device *dev,
+ 						   int chunkInNAND,
+ 						   const __u8 *buffer,
+ 						   yaffs_ExtendedTags *tags)
+ {
+ 
+ 	dev->nPageWrites++;
+ 
+ 	chunkInNAND -= dev->chunkOffset;
+ 
+ 
+ 	if (tags) {
+ 		tags->sequenceNumber = dev->sequenceNumber;
+ 		tags->chunkUsed = 1;
+ 		if (!yaffs_ValidateTags(tags)) {
+ 			T(YAFFS_TRACE_ERROR,
+ 			  (TSTR("Writing uninitialised tags" TENDSTR)));
+ 			YBUG();
+ 		}
+ 		T(YAFFS_TRACE_WRITE,
+ 		  (TSTR("Writing chunk %d tags %d %d" TENDSTR), chunkInNAND,
+ 		   tags->objectId, tags->chunkId));
+ 	} else {
+ 		T(YAFFS_TRACE_ERROR, (TSTR("Writing with no tags" TENDSTR)));
+ 		YBUG();
+ 	}
+ 
+ 	if (dev->param.writeChunkWithTagsToNAND)
+ 		return dev->param.writeChunkWithTagsToNAND(dev, chunkInNAND, buffer,
+ 						     tags);
+ 	else
+ 		return yaffs_TagsCompatabilityWriteChunkWithTagsToNAND(dev,
+ 								       chunkInNAND,
+ 								       buffer,
+ 								       tags);
+ }
+ 
+ int yaffs_MarkBlockBad(yaffs_Device *dev, int blockNo)
+ {
+ 	blockNo -= dev->blockOffset;
+ 
+ 
+ 	if (dev->param.markNANDBlockBad)
+ 		return dev->param.markNANDBlockBad(dev, blockNo);
+ 	else
+ 		return yaffs_TagsCompatabilityMarkNANDBlockBad(dev, blockNo);
+ }
+ 
+ int yaffs_QueryInitialBlockState(yaffs_Device *dev,
+ 						 int blockNo,
+ 						 yaffs_BlockState *state,
+ 						 __u32 *sequenceNumber)
+ {
+ 	blockNo -= dev->blockOffset;
+ 
+ 	if (dev->param.queryNANDBlock)
+ 		return dev->param.queryNANDBlock(dev, blockNo, state, sequenceNumber);
+ 	else
+ 		return yaffs_TagsCompatabilityQueryNANDBlock(dev, blockNo,
+ 							     state,
+ 							     sequenceNumber);
+ }
+ 
+ 
+ int yaffs_EraseBlockInNAND(struct yaffs_DeviceStruct *dev,
+ 				  int blockInNAND)
+ {
+ 	int result;
+ 
+ 	blockInNAND -= dev->blockOffset;
+ 
+ 	dev->nBlockErasures++;
+ 
+ 	result = dev->param.eraseBlockInNAND(dev, blockInNAND);
+ 
+ 	return result;
+ }
+ 
+ int yaffs_InitialiseNAND(struct yaffs_DeviceStruct *dev)
+ {
+ 	if(dev->param.initialiseNAND)
+ 		return dev->param.initialiseNAND(dev);
+ 	return YAFFS_OK;
+ }
+ 
+ 
+ 
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/yaffs_nandemul2k.h liab-linux-2.6.29.4/fs/yaffs2/yaffs_nandemul2k.h
*** linux-2.6.29.4/fs/yaffs2/yaffs_nandemul2k.h	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/yaffs_nandemul2k.h	2012-01-20 14:48:21.869306031 +0100
***************
*** 0 ****
--- 1,39 ----
+ /*
+  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+  *
+  * Copyright (C) 2002-2010 Aleph One Ltd.
+  *   for Toby Churchill Ltd and Brightstar Engineering
+  *
+  * Created by Charles Manning <charles@aleph1.co.uk>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU Lesser General Public License version 2.1 as
+  * published by the Free Software Foundation.
+  *
+  * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+  */
+ 
+ /* Interface to emulated NAND functions (2k page size) */
+ 
+ #ifndef __YAFFS_NANDEMUL2K_H__
+ #define __YAFFS_NANDEMUL2K_H__
+ 
+ #include "yaffs_guts.h"
+ 
+ int nandemul2k_WriteChunkWithTagsToNAND(struct yaffs_DeviceStruct *dev,
+ 					int chunkInNAND, const __u8 *data,
+ 					const yaffs_ExtendedTags *tags);
+ int nandemul2k_ReadChunkWithTagsFromNAND(struct yaffs_DeviceStruct *dev,
+ 					 int chunkInNAND, __u8 *data,
+ 					 yaffs_ExtendedTags *tags);
+ int nandemul2k_MarkNANDBlockBad(struct yaffs_DeviceStruct *dev, int blockNo);
+ int nandemul2k_QueryNANDBlock(struct yaffs_DeviceStruct *dev, int blockNo,
+ 			      yaffs_BlockState *state, __u32 *sequenceNumber);
+ int nandemul2k_EraseBlockInNAND(struct yaffs_DeviceStruct *dev,
+ 				int blockInNAND);
+ int nandemul2k_InitialiseNAND(struct yaffs_DeviceStruct *dev);
+ int nandemul2k_GetBytesPerChunk(void);
+ int nandemul2k_GetChunksPerBlock(void);
+ int nandemul2k_GetNumberOfBlocks(void);
+ 
+ #endif
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/yaffs_nand.h liab-linux-2.6.29.4/fs/yaffs2/yaffs_nand.h
*** linux-2.6.29.4/fs/yaffs2/yaffs_nand.h	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/yaffs_nand.h	2012-01-20 14:48:21.865306031 +0100
***************
*** 0 ****
--- 1,44 ----
+ /*
+  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+  *
+  * Copyright (C) 2002-2010 Aleph One Ltd.
+  *   for Toby Churchill Ltd and Brightstar Engineering
+  *
+  * Created by Charles Manning <charles@aleph1.co.uk>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU Lesser General Public License version 2.1 as
+  * published by the Free Software Foundation.
+  *
+  * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+  */
+ 
+ #ifndef __YAFFS_NAND_H__
+ #define __YAFFS_NAND_H__
+ #include "yaffs_guts.h"
+ 
+ 
+ 
+ int yaffs_ReadChunkWithTagsFromNAND(yaffs_Device *dev, int chunkInNAND,
+ 					__u8 *buffer,
+ 					yaffs_ExtendedTags *tags);
+ 
+ int yaffs_WriteChunkWithTagsToNAND(yaffs_Device *dev,
+ 						int chunkInNAND,
+ 						const __u8 *buffer,
+ 						yaffs_ExtendedTags *tags);
+ 
+ int yaffs_MarkBlockBad(yaffs_Device *dev, int blockNo);
+ 
+ int yaffs_QueryInitialBlockState(yaffs_Device *dev,
+ 						int blockNo,
+ 						yaffs_BlockState *state,
+ 						unsigned *sequenceNumber);
+ 
+ int yaffs_EraseBlockInNAND(struct yaffs_DeviceStruct *dev,
+ 				  int blockInNAND);
+ 
+ int yaffs_InitialiseNAND(struct yaffs_DeviceStruct *dev);
+ 
+ #endif
+ 
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/yaffs_packedtags1.c liab-linux-2.6.29.4/fs/yaffs2/yaffs_packedtags1.c
*** linux-2.6.29.4/fs/yaffs2/yaffs_packedtags1.c	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/yaffs_packedtags1.c	2012-01-20 14:48:21.861306032 +0100
***************
*** 0 ****
--- 1,50 ----
+ /*
+  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+  *
+  * Copyright (C) 2002-2010 Aleph One Ltd.
+  *   for Toby Churchill Ltd and Brightstar Engineering
+  *
+  * Created by Charles Manning <charles@aleph1.co.uk>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2 as
+  * published by the Free Software Foundation.
+  */
+ 
+ #include "yaffs_packedtags1.h"
+ #include "yportenv.h"
+ 
+ void yaffs_PackTags1(yaffs_PackedTags1 *pt, const yaffs_ExtendedTags *t)
+ {
+ 	pt->chunkId = t->chunkId;
+ 	pt->serialNumber = t->serialNumber;
+ 	pt->byteCount = t->byteCount;
+ 	pt->objectId = t->objectId;
+ 	pt->ecc = 0;
+ 	pt->deleted = (t->chunkDeleted) ? 0 : 1;
+ 	pt->unusedStuff = 0;
+ 	pt->shouldBeFF = 0xFFFFFFFF;
+ 
+ }
+ 
+ void yaffs_UnpackTags1(yaffs_ExtendedTags *t, const yaffs_PackedTags1 *pt)
+ {
+ 	static const __u8 allFF[] =
+ 	    { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+ 0xff };
+ 
+ 	if (memcmp(allFF, pt, sizeof(yaffs_PackedTags1))) {
+ 		t->blockBad = 0;
+ 		if (pt->shouldBeFF != 0xFFFFFFFF)
+ 			t->blockBad = 1;
+ 		t->chunkUsed = 1;
+ 		t->objectId = pt->objectId;
+ 		t->chunkId = pt->chunkId;
+ 		t->byteCount = pt->byteCount;
+ 		t->eccResult = YAFFS_ECC_RESULT_NO_ERROR;
+ 		t->chunkDeleted = (pt->deleted) ? 0 : 1;
+ 		t->serialNumber = pt->serialNumber;
+ 	} else {
+ 		memset(t, 0, sizeof(yaffs_ExtendedTags));
+ 	}
+ }
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/yaffs_packedtags1.h liab-linux-2.6.29.4/fs/yaffs2/yaffs_packedtags1.h
*** linux-2.6.29.4/fs/yaffs2/yaffs_packedtags1.h	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/yaffs_packedtags1.h	2012-01-20 14:48:21.861306032 +0100
***************
*** 0 ****
--- 1,37 ----
+ /*
+  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+  *
+  * Copyright (C) 2002-2010 Aleph One Ltd.
+  *   for Toby Churchill Ltd and Brightstar Engineering
+  *
+  * Created by Charles Manning <charles@aleph1.co.uk>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU Lesser General Public License version 2.1 as
+  * published by the Free Software Foundation.
+  *
+  * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+  */
+ 
+ /* This is used to pack YAFFS1 tags, not YAFFS2 tags. */
+ 
+ #ifndef __YAFFS_PACKEDTAGS1_H__
+ #define __YAFFS_PACKEDTAGS1_H__
+ 
+ #include "yaffs_guts.h"
+ 
+ typedef struct {
+ 	unsigned chunkId:20;
+ 	unsigned serialNumber:2;
+ 	unsigned byteCount:10;
+ 	unsigned objectId:18;
+ 	unsigned ecc:12;
+ 	unsigned deleted:1;
+ 	unsigned unusedStuff:1;
+ 	unsigned shouldBeFF;
+ 
+ } yaffs_PackedTags1;
+ 
+ void yaffs_PackTags1(yaffs_PackedTags1 *pt, const yaffs_ExtendedTags *t);
+ void yaffs_UnpackTags1(yaffs_ExtendedTags *t, const yaffs_PackedTags1 *pt);
+ #endif
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/yaffs_packedtags2.c liab-linux-2.6.29.4/fs/yaffs2/yaffs_packedtags2.c
*** linux-2.6.29.4/fs/yaffs2/yaffs_packedtags2.c	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/yaffs_packedtags2.c	2012-01-20 14:48:21.861306032 +0100
***************
*** 0 ****
--- 1,198 ----
+ /*
+  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+  *
+  * Copyright (C) 2002-2010 Aleph One Ltd.
+  *   for Toby Churchill Ltd and Brightstar Engineering
+  *
+  * Created by Charles Manning <charles@aleph1.co.uk>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2 as
+  * published by the Free Software Foundation.
+  */
+ 
+ #include "yaffs_packedtags2.h"
+ #include "yportenv.h"
+ #include "yaffs_trace.h"
+ #include "yaffs_tagsvalidity.h"
+ 
+ /* This code packs a set of extended tags into a binary structure for
+  * NAND storage
+  */
+ 
+ /* Some of the information is "extra" struff which can be packed in to
+  * speed scanning
+  * This is defined by having the EXTRA_HEADER_INFO_FLAG set.
+  */
+ 
+ /* Extra flags applied to chunkId */
+ 
+ #define EXTRA_HEADER_INFO_FLAG	0x80000000
+ #define EXTRA_SHRINK_FLAG	0x40000000
+ #define EXTRA_SHADOWS_FLAG	0x20000000
+ #define EXTRA_SPARE_FLAGS	0x10000000
+ 
+ #define ALL_EXTRA_FLAGS		0xF0000000
+ 
+ /* Also, the top 4 bits of the object Id are set to the object type. */
+ #define EXTRA_OBJECT_TYPE_SHIFT (28)
+ #define EXTRA_OBJECT_TYPE_MASK  ((0x0F) << EXTRA_OBJECT_TYPE_SHIFT)
+ 
+ 
+ static void yaffs_DumpPackedTags2TagsPart(const yaffs_PackedTags2TagsPart *ptt)
+ {
+ 	T(YAFFS_TRACE_MTD,
+ 	  (TSTR("packed tags obj %d chunk %d byte %d seq %d" TENDSTR),
+ 	   ptt->objectId, ptt->chunkId, ptt->byteCount,
+ 	   ptt->sequenceNumber));
+ }
+ static void yaffs_DumpPackedTags2(const yaffs_PackedTags2 *pt)
+ {
+ 	yaffs_DumpPackedTags2TagsPart(&pt->t);
+ }
+ 
+ static void yaffs_DumpTags2(const yaffs_ExtendedTags *t)
+ {
+ 	T(YAFFS_TRACE_MTD,
+ 	  (TSTR
+ 	   ("ext.tags eccres %d blkbad %d chused %d obj %d chunk%d byte %d del %d ser %d seq %d"
+ 	    TENDSTR), t->eccResult, t->blockBad, t->chunkUsed, t->objectId,
+ 	   t->chunkId, t->byteCount, t->chunkDeleted, t->serialNumber,
+ 	   t->sequenceNumber));
+ 
+ }
+ 
+ void yaffs_PackTags2TagsPart(yaffs_PackedTags2TagsPart *ptt,
+ 		const yaffs_ExtendedTags *t)
+ {
+ 	ptt->chunkId = t->chunkId;
+ 	ptt->sequenceNumber = t->sequenceNumber;
+ 	ptt->byteCount = t->byteCount;
+ 	ptt->objectId = t->objectId;
+ 
+ 	if (t->chunkId == 0 && t->extraHeaderInfoAvailable) {
+ 		/* Store the extra header info instead */
+ 		/* We save the parent object in the chunkId */
+ 		ptt->chunkId = EXTRA_HEADER_INFO_FLAG
+ 			| t->extraParentObjectId;
+ 		if (t->extraIsShrinkHeader)
+ 			ptt->chunkId |= EXTRA_SHRINK_FLAG;
+ 		if (t->extraShadows)
+ 			ptt->chunkId |= EXTRA_SHADOWS_FLAG;
+ 
+ 		ptt->objectId &= ~EXTRA_OBJECT_TYPE_MASK;
+ 		ptt->objectId |=
+ 		    (t->extraObjectType << EXTRA_OBJECT_TYPE_SHIFT);
+ 
+ 		if (t->extraObjectType == YAFFS_OBJECT_TYPE_HARDLINK)
+ 			ptt->byteCount = t->extraEquivalentObjectId;
+ 		else if (t->extraObjectType == YAFFS_OBJECT_TYPE_FILE)
+ 			ptt->byteCount = t->extraFileLength;
+ 		else
+ 			ptt->byteCount = 0;
+ 	}
+ 
+ 	yaffs_DumpPackedTags2TagsPart(ptt);
+ 	yaffs_DumpTags2(t);
+ }
+ 
+ 
+ void yaffs_PackTags2(yaffs_PackedTags2 *pt, const yaffs_ExtendedTags *t, int tagsECC)
+ {
+ 	yaffs_PackTags2TagsPart(&pt->t, t);
+ 
+ 	if(tagsECC)
+ 		yaffs_ECCCalculateOther((unsigned char *)&pt->t,
+ 					sizeof(yaffs_PackedTags2TagsPart),
+ 					&pt->ecc);
+ }
+ 
+ 
+ void yaffs_UnpackTags2TagsPart(yaffs_ExtendedTags *t,
+ 		yaffs_PackedTags2TagsPart *ptt)
+ {
+ 
+ 	memset(t, 0, sizeof(yaffs_ExtendedTags));
+ 
+ 	yaffs_InitialiseTags(t);
+ 
+ 	if (ptt->sequenceNumber != 0xFFFFFFFF) {
+ 		t->blockBad = 0;
+ 		t->chunkUsed = 1;
+ 		t->objectId = ptt->objectId;
+ 		t->chunkId = ptt->chunkId;
+ 		t->byteCount = ptt->byteCount;
+ 		t->chunkDeleted = 0;
+ 		t->serialNumber = 0;
+ 		t->sequenceNumber = ptt->sequenceNumber;
+ 
+ 		/* Do extra header info stuff */
+ 
+ 		if (ptt->chunkId & EXTRA_HEADER_INFO_FLAG) {
+ 			t->chunkId = 0;
+ 			t->byteCount = 0;
+ 
+ 			t->extraHeaderInfoAvailable = 1;
+ 			t->extraParentObjectId =
+ 			    ptt->chunkId & (~(ALL_EXTRA_FLAGS));
+ 			t->extraIsShrinkHeader =
+ 			    (ptt->chunkId & EXTRA_SHRINK_FLAG) ? 1 : 0;
+ 			t->extraShadows =
+ 			    (ptt->chunkId & EXTRA_SHADOWS_FLAG) ? 1 : 0;
+ 			t->extraObjectType =
+ 			    ptt->objectId >> EXTRA_OBJECT_TYPE_SHIFT;
+ 			t->objectId &= ~EXTRA_OBJECT_TYPE_MASK;
+ 
+ 			if (t->extraObjectType == YAFFS_OBJECT_TYPE_HARDLINK)
+ 				t->extraEquivalentObjectId = ptt->byteCount;
+ 			else
+ 				t->extraFileLength = ptt->byteCount;
+ 		}
+ 	}
+ 
+ 	yaffs_DumpPackedTags2TagsPart(ptt);
+ 	yaffs_DumpTags2(t);
+ 
+ }
+ 
+ 
+ void yaffs_UnpackTags2(yaffs_ExtendedTags *t, yaffs_PackedTags2 *pt, int tagsECC)
+ {
+ 
+ 	yaffs_ECCResult eccResult = YAFFS_ECC_RESULT_NO_ERROR;
+ 
+ 	if (pt->t.sequenceNumber != 0xFFFFFFFF &&
+ 	    tagsECC){
+ 		/* Chunk is in use and we need to do ECC */
+ 		
+ 		yaffs_ECCOther ecc;
+ 		int result;
+ 		yaffs_ECCCalculateOther((unsigned char *)&pt->t,
+ 					sizeof(yaffs_PackedTags2TagsPart),
+ 					&ecc);
+ 		result = yaffs_ECCCorrectOther((unsigned char *)&pt->t,
+ 						sizeof(yaffs_PackedTags2TagsPart),
+ 						&pt->ecc, &ecc);
+ 		switch (result) {
+ 			case 0:
+ 				eccResult = YAFFS_ECC_RESULT_NO_ERROR;
+ 				break;
+ 			case 1:
+ 				eccResult = YAFFS_ECC_RESULT_FIXED;
+ 				break;
+ 			case -1:
+ 				eccResult = YAFFS_ECC_RESULT_UNFIXED;
+ 				break;
+ 			default:
+ 				eccResult = YAFFS_ECC_RESULT_UNKNOWN;
+ 		}
+ 	}
+ 
+ 	yaffs_UnpackTags2TagsPart(t, &pt->t);
+ 
+ 	t->eccResult = eccResult;
+ 
+ 	yaffs_DumpPackedTags2(pt);
+ 	yaffs_DumpTags2(t);
+ }
+ 
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/yaffs_packedtags2.h liab-linux-2.6.29.4/fs/yaffs2/yaffs_packedtags2.h
*** linux-2.6.29.4/fs/yaffs2/yaffs_packedtags2.h	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/yaffs_packedtags2.h	2012-01-20 14:48:21.861306032 +0100
***************
*** 0 ****
--- 1,43 ----
+ /*
+  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+  *
+  * Copyright (C) 2002-2010 Aleph One Ltd.
+  *   for Toby Churchill Ltd and Brightstar Engineering
+  *
+  * Created by Charles Manning <charles@aleph1.co.uk>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU Lesser General Public License version 2.1 as
+  * published by the Free Software Foundation.
+  *
+  * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+  */
+ 
+ /* This is used to pack YAFFS2 tags, not YAFFS1tags. */
+ 
+ #ifndef __YAFFS_PACKEDTAGS2_H__
+ #define __YAFFS_PACKEDTAGS2_H__
+ 
+ #include "yaffs_guts.h"
+ #include "yaffs_ecc.h"
+ 
+ typedef struct {
+ 	unsigned sequenceNumber;
+ 	unsigned objectId;
+ 	unsigned chunkId;
+ 	unsigned byteCount;
+ } yaffs_PackedTags2TagsPart;
+ 
+ typedef struct {
+ 	yaffs_PackedTags2TagsPart t;
+ 	yaffs_ECCOther ecc;
+ } yaffs_PackedTags2;
+ 
+ /* Full packed tags with ECC, used for oob tags */
+ void yaffs_PackTags2(yaffs_PackedTags2 *pt, const yaffs_ExtendedTags *t, int tagsECC);
+ void yaffs_UnpackTags2(yaffs_ExtendedTags *t, yaffs_PackedTags2 *pt, int tagsECC);
+ 
+ /* Only the tags part (no ECC for use with inband tags */
+ void yaffs_PackTags2TagsPart(yaffs_PackedTags2TagsPart *pt, const yaffs_ExtendedTags *t);
+ void yaffs_UnpackTags2TagsPart(yaffs_ExtendedTags *t, yaffs_PackedTags2TagsPart *pt);
+ #endif
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/yaffs_qsort.c liab-linux-2.6.29.4/fs/yaffs2/yaffs_qsort.c
*** linux-2.6.29.4/fs/yaffs2/yaffs_qsort.c	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/yaffs_qsort.c	2012-01-20 14:48:21.865306031 +0100
***************
*** 0 ****
--- 1,163 ----
+ /*
+  * Copyright (c) 1992, 1993
+  *	The Regents of the University of California.  All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions
+  * are met:
+  * 1. Redistributions of source code must retain the above copyright
+  *    notice, this list of conditions and the following disclaimer.
+  * 2. Redistributions in binary form must reproduce the above copyright
+  *    notice, this list of conditions and the following disclaimer in the
+  *    documentation and/or other materials provided with the distribution.
+  * 3. Neither the name of the University nor the names of its contributors
+  *    may be used to endorse or promote products derived from this software
+  *    without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+  * SUCH DAMAGE.
+  */
+ 
+ #include "yportenv.h"
+ /* #include <linux/string.h> */
+ 
+ /*
+  * Qsort routine from Bentley & McIlroy's "Engineering a Sort Function".
+  */
+ #define swapcode(TYPE, parmi, parmj, n) do { 		\
+ 	long i = (n) / sizeof (TYPE); 			\
+ 	register TYPE *pi = (TYPE *) (parmi); 		\
+ 	register TYPE *pj = (TYPE *) (parmj); 		\
+ 	do { 						\
+ 		register TYPE	t = *pi;		\
+ 		*pi++ = *pj;				\
+ 		*pj++ = t;				\
+ 	} while (--i > 0);				\
+ } while (0)
+ 
+ #define SWAPINIT(a, es) swaptype = ((char *)a - (char *)0) % sizeof(long) || \
+ 	es % sizeof(long) ? 2 : es == sizeof(long) ? 0 : 1;
+ 
+ static __inline void
+ swapfunc(char *a, char *b, int n, int swaptype)
+ {
+ 	if (swaptype <= 1)
+ 		swapcode(long, a, b, n);
+ 	else
+ 		swapcode(char, a, b, n);
+ }
+ 
+ #define yswap(a, b) do {					\
+ 	if (swaptype == 0) {				\
+ 		long t = *(long *)(a);			\
+ 		*(long *)(a) = *(long *)(b);		\
+ 		*(long *)(b) = t;			\
+ 	} else						\
+ 		swapfunc(a, b, es, swaptype);		\
+ } while (0)
+ 
+ #define vecswap(a, b, n) 	if ((n) > 0) swapfunc(a, b, n, swaptype)
+ 
+ static __inline char *
+ med3(char *a, char *b, char *c, int (*cmp)(const void *, const void *))
+ {
+ 	return cmp(a, b) < 0 ?
+ 		(cmp(b, c) < 0 ? b : (cmp(a, c) < 0 ? c : a))
+ 		: (cmp(b, c) > 0 ? b : (cmp(a, c) < 0 ? a : c));
+ }
+ 
+ #ifndef min
+ #define min(a, b) (((a) < (b)) ? (a) : (b))
+ #endif
+ 
+ void
+ yaffs_qsort(void *aa, size_t n, size_t es,
+ 	int (*cmp)(const void *, const void *))
+ {
+ 	char *pa, *pb, *pc, *pd, *pl, *pm, *pn;
+ 	int d, r, swaptype, swap_cnt;
+ 	register char *a = aa;
+ 
+ loop:	SWAPINIT(a, es);
+ 	swap_cnt = 0;
+ 	if (n < 7) {
+ 		for (pm = (char *)a + es; pm < (char *) a + n * es; pm += es)
+ 			for (pl = pm; pl > (char *) a && cmp(pl - es, pl) > 0;
+ 			     pl -= es)
+ 				yswap(pl, pl - es);
+ 		return;
+ 	}
+ 	pm = (char *)a + (n / 2) * es;
+ 	if (n > 7) {
+ 		pl = (char *)a;
+ 		pn = (char *)a + (n - 1) * es;
+ 		if (n > 40) {
+ 			d = (n / 8) * es;
+ 			pl = med3(pl, pl + d, pl + 2 * d, cmp);
+ 			pm = med3(pm - d, pm, pm + d, cmp);
+ 			pn = med3(pn - 2 * d, pn - d, pn, cmp);
+ 		}
+ 		pm = med3(pl, pm, pn, cmp);
+ 	}
+ 	yswap(a, pm);
+ 	pa = pb = (char *)a + es;
+ 
+ 	pc = pd = (char *)a + (n - 1) * es;
+ 	for (;;) {
+ 		while (pb <= pc && (r = cmp(pb, a)) <= 0) {
+ 			if (r == 0) {
+ 				swap_cnt = 1;
+ 				yswap(pa, pb);
+ 				pa += es;
+ 			}
+ 			pb += es;
+ 		}
+ 		while (pb <= pc && (r = cmp(pc, a)) >= 0) {
+ 			if (r == 0) {
+ 				swap_cnt = 1;
+ 				yswap(pc, pd);
+ 				pd -= es;
+ 			}
+ 			pc -= es;
+ 		}
+ 		if (pb > pc)
+ 			break;
+ 		yswap(pb, pc);
+ 		swap_cnt = 1;
+ 		pb += es;
+ 		pc -= es;
+ 	}
+ 	if (swap_cnt == 0) {  /* Switch to insertion sort */
+ 		for (pm = (char *) a + es; pm < (char *) a + n * es; pm += es)
+ 			for (pl = pm; pl > (char *) a && cmp(pl - es, pl) > 0;
+ 			     pl -= es)
+ 				yswap(pl, pl - es);
+ 		return;
+ 	}
+ 
+ 	pn = (char *)a + n * es;
+ 	r = min(pa - (char *)a, pb - pa);
+ 	vecswap(a, pb - r, r);
+ 	r = min((long)(pd - pc), (long)(pn - pd - es));
+ 	vecswap(pb, pn - r, r);
+ 	r = pb - pa;
+ 	if (r > es)
+ 		yaffs_qsort(a, r / es, es, cmp);
+ 	r = pd - pc;
+ 	if (r > es) {
+ 		/* Iterate rather than recurse to save stack space */
+ 		a = pn - r;
+ 		n = r / es;
+ 		goto loop;
+ 	}
+ /*		yaffs_qsort(pn - r, r / es, es, cmp);*/
+ }
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/yaffs_qsort.h liab-linux-2.6.29.4/fs/yaffs2/yaffs_qsort.h
*** linux-2.6.29.4/fs/yaffs2/yaffs_qsort.h	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/yaffs_qsort.h	2012-01-20 14:48:21.865306031 +0100
***************
*** 0 ****
--- 1,23 ----
+ /*
+  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+  *
+  * Copyright (C) 2002-2010 Aleph One Ltd.
+  *   for Toby Churchill Ltd and Brightstar Engineering
+  *
+  * Created by Charles Manning <charles@aleph1.co.uk>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU Lesser General Public License version 2.1 as
+  * published by the Free Software Foundation.
+  *
+  * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+  */
+ 
+ 
+ #ifndef __YAFFS_QSORT_H__
+ #define __YAFFS_QSORT_H__
+ 
+ extern void yaffs_qsort(void *const base, size_t total_elems, size_t size,
+ 			int (*cmp)(const void *, const void *));
+ 
+ #endif
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/yaffs_tagscompat.c liab-linux-2.6.29.4/fs/yaffs2/yaffs_tagscompat.c
*** linux-2.6.29.4/fs/yaffs2/yaffs_tagscompat.c	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/yaffs_tagscompat.c	2012-01-20 14:48:21.869306031 +0100
***************
*** 0 ****
--- 1,539 ----
+ /*
+  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+  *
+  * Copyright (C) 2002-2010 Aleph One Ltd.
+  *   for Toby Churchill Ltd and Brightstar Engineering
+  *
+  * Created by Charles Manning <charles@aleph1.co.uk>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2 as
+  * published by the Free Software Foundation.
+  */
+ 
+ #include "yaffs_guts.h"
+ #include "yaffs_tagscompat.h"
+ #include "yaffs_ecc.h"
+ #include "yaffs_getblockinfo.h"
+ #include "yaffs_trace.h"
+ 
+ static void yaffs_HandleReadDataError(yaffs_Device *dev, int chunkInNAND);
+ #ifdef NOTYET
+ static void yaffs_CheckWrittenBlock(yaffs_Device *dev, int chunkInNAND);
+ static void yaffs_HandleWriteChunkOk(yaffs_Device *dev, int chunkInNAND,
+ 				     const __u8 *data,
+ 				     const yaffs_Spare *spare);
+ static void yaffs_HandleUpdateChunk(yaffs_Device *dev, int chunkInNAND,
+ 				    const yaffs_Spare *spare);
+ static void yaffs_HandleWriteChunkError(yaffs_Device *dev, int chunkInNAND);
+ #endif
+ 
+ static const char yaffs_countBitsTable[256] = {
+ 	0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
+ 	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+ 	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+ 	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+ 	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+ 	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+ 	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+ 	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+ 	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+ 	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+ 	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+ 	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+ 	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+ 	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+ 	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+ 	4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
+ };
+ 
+ int yaffs_CountBits(__u8 x)
+ {
+ 	int retVal;
+ 	retVal = yaffs_countBitsTable[x];
+ 	return retVal;
+ }
+ 
+ /********** Tags ECC calculations  *********/
+ 
+ void yaffs_CalcECC(const __u8 *data, yaffs_Spare *spare)
+ {
+ 	yaffs_ECCCalculate(data, spare->ecc1);
+ 	yaffs_ECCCalculate(&data[256], spare->ecc2);
+ }
+ 
+ void yaffs_CalcTagsECC(yaffs_Tags *tags)
+ {
+ 	/* Calculate an ecc */
+ 
+ 	unsigned char *b = ((yaffs_TagsUnion *) tags)->asBytes;
+ 	unsigned i, j;
+ 	unsigned ecc = 0;
+ 	unsigned bit = 0;
+ 
+ 	tags->ecc = 0;
+ 
+ 	for (i = 0; i < 8; i++) {
+ 		for (j = 1; j & 0xff; j <<= 1) {
+ 			bit++;
+ 			if (b[i] & j)
+ 				ecc ^= bit;
+ 		}
+ 	}
+ 
+ 	tags->ecc = ecc;
+ 
+ }
+ 
+ int yaffs_CheckECCOnTags(yaffs_Tags *tags)
+ {
+ 	unsigned ecc = tags->ecc;
+ 
+ 	yaffs_CalcTagsECC(tags);
+ 
+ 	ecc ^= tags->ecc;
+ 
+ 	if (ecc && ecc <= 64) {
+ 		/* TODO: Handle the failure better. Retire? */
+ 		unsigned char *b = ((yaffs_TagsUnion *) tags)->asBytes;
+ 
+ 		ecc--;
+ 
+ 		b[ecc / 8] ^= (1 << (ecc & 7));
+ 
+ 		/* Now recvalc the ecc */
+ 		yaffs_CalcTagsECC(tags);
+ 
+ 		return 1;	/* recovered error */
+ 	} else if (ecc) {
+ 		/* Wierd ecc failure value */
+ 		/* TODO Need to do somethiong here */
+ 		return -1;	/* unrecovered error */
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /********** Tags **********/
+ 
+ static void yaffs_LoadTagsIntoSpare(yaffs_Spare *sparePtr,
+ 				yaffs_Tags *tagsPtr)
+ {
+ 	yaffs_TagsUnion *tu = (yaffs_TagsUnion *) tagsPtr;
+ 
+ 	yaffs_CalcTagsECC(tagsPtr);
+ 
+ 	sparePtr->tagByte0 = tu->asBytes[0];
+ 	sparePtr->tagByte1 = tu->asBytes[1];
+ 	sparePtr->tagByte2 = tu->asBytes[2];
+ 	sparePtr->tagByte3 = tu->asBytes[3];
+ 	sparePtr->tagByte4 = tu->asBytes[4];
+ 	sparePtr->tagByte5 = tu->asBytes[5];
+ 	sparePtr->tagByte6 = tu->asBytes[6];
+ 	sparePtr->tagByte7 = tu->asBytes[7];
+ }
+ 
+ static void yaffs_GetTagsFromSpare(yaffs_Device *dev, yaffs_Spare *sparePtr,
+ 				yaffs_Tags *tagsPtr)
+ {
+ 	yaffs_TagsUnion *tu = (yaffs_TagsUnion *) tagsPtr;
+ 	int result;
+ 
+ 	tu->asBytes[0] = sparePtr->tagByte0;
+ 	tu->asBytes[1] = sparePtr->tagByte1;
+ 	tu->asBytes[2] = sparePtr->tagByte2;
+ 	tu->asBytes[3] = sparePtr->tagByte3;
+ 	tu->asBytes[4] = sparePtr->tagByte4;
+ 	tu->asBytes[5] = sparePtr->tagByte5;
+ 	tu->asBytes[6] = sparePtr->tagByte6;
+ 	tu->asBytes[7] = sparePtr->tagByte7;
+ 
+ 	result = yaffs_CheckECCOnTags(tagsPtr);
+ 	if (result > 0)
+ 		dev->tagsEccFixed++;
+ 	else if (result < 0)
+ 		dev->tagsEccUnfixed++;
+ }
+ 
+ static void yaffs_SpareInitialise(yaffs_Spare *spare)
+ {
+ 	memset(spare, 0xFF, sizeof(yaffs_Spare));
+ }
+ 
+ static int yaffs_WriteChunkToNAND(struct yaffs_DeviceStruct *dev,
+ 				int chunkInNAND, const __u8 *data,
+ 				yaffs_Spare *spare)
+ {
+ 	if (chunkInNAND < dev->param.startBlock * dev->param.nChunksPerBlock) {
+ 		T(YAFFS_TRACE_ERROR,
+ 		  (TSTR("**>> yaffs chunk %d is not valid" TENDSTR),
+ 		   chunkInNAND));
+ 		return YAFFS_FAIL;
+ 	}
+ 
+ 	return dev->param.writeChunkToNAND(dev, chunkInNAND, data, spare);
+ }
+ 
+ static int yaffs_ReadChunkFromNAND(struct yaffs_DeviceStruct *dev,
+ 				   int chunkInNAND,
+ 				   __u8 *data,
+ 				   yaffs_Spare *spare,
+ 				   yaffs_ECCResult *eccResult,
+ 				   int doErrorCorrection)
+ {
+ 	int retVal;
+ 	yaffs_Spare localSpare;
+ 
+ 	if (!spare && data) {
+ 		/* If we don't have a real spare, then we use a local one. */
+ 		/* Need this for the calculation of the ecc */
+ 		spare = &localSpare;
+ 	}
+ 
+ 	if (!dev->param.useNANDECC) {
+ 		retVal = dev->param.readChunkFromNAND(dev, chunkInNAND, data, spare);
+ 		if (data && doErrorCorrection) {
+ 			/* Do ECC correction */
+ 			/* Todo handle any errors */
+ 			int eccResult1, eccResult2;
+ 			__u8 calcEcc[3];
+ 
+ 			yaffs_ECCCalculate(data, calcEcc);
+ 			eccResult1 =
+ 			    yaffs_ECCCorrect(data, spare->ecc1, calcEcc);
+ 			yaffs_ECCCalculate(&data[256], calcEcc);
+ 			eccResult2 =
+ 			    yaffs_ECCCorrect(&data[256], spare->ecc2, calcEcc);
+ 
+ 			if (eccResult1 > 0) {
+ 				T(YAFFS_TRACE_ERROR,
+ 				  (TSTR
+ 				   ("**>>yaffs ecc error fix performed on chunk %d:0"
+ 				    TENDSTR), chunkInNAND));
+ 				dev->eccFixed++;
+ 			} else if (eccResult1 < 0) {
+ 				T(YAFFS_TRACE_ERROR,
+ 				  (TSTR
+ 				   ("**>>yaffs ecc error unfixed on chunk %d:0"
+ 				    TENDSTR), chunkInNAND));
+ 				dev->eccUnfixed++;
+ 			}
+ 
+ 			if (eccResult2 > 0) {
+ 				T(YAFFS_TRACE_ERROR,
+ 				  (TSTR
+ 				   ("**>>yaffs ecc error fix performed on chunk %d:1"
+ 				    TENDSTR), chunkInNAND));
+ 				dev->eccFixed++;
+ 			} else if (eccResult2 < 0) {
+ 				T(YAFFS_TRACE_ERROR,
+ 				  (TSTR
+ 				   ("**>>yaffs ecc error unfixed on chunk %d:1"
+ 				    TENDSTR), chunkInNAND));
+ 				dev->eccUnfixed++;
+ 			}
+ 
+ 			if (eccResult1 || eccResult2) {
+ 				/* We had a data problem on this page */
+ 				yaffs_HandleReadDataError(dev, chunkInNAND);
+ 			}
+ 
+ 			if (eccResult1 < 0 || eccResult2 < 0)
+ 				*eccResult = YAFFS_ECC_RESULT_UNFIXED;
+ 			else if (eccResult1 > 0 || eccResult2 > 0)
+ 				*eccResult = YAFFS_ECC_RESULT_FIXED;
+ 			else
+ 				*eccResult = YAFFS_ECC_RESULT_NO_ERROR;
+ 		}
+ 	} else {
+ 		/* Must allocate enough memory for spare+2*sizeof(int) */
+ 		/* for ecc results from device. */
+ 		struct yaffs_NANDSpare nspare;
+ 
+ 		memset(&nspare, 0, sizeof(nspare));
+ 
+ 		retVal = dev->param.readChunkFromNAND(dev, chunkInNAND, data,
+ 					(yaffs_Spare *) &nspare);
+ 		memcpy(spare, &nspare, sizeof(yaffs_Spare));
+ 		if (data && doErrorCorrection) {
+ 			if (nspare.eccres1 > 0) {
+ 				T(YAFFS_TRACE_ERROR,
+ 				  (TSTR
+ 				   ("**>>mtd ecc error fix performed on chunk %d:0"
+ 				    TENDSTR), chunkInNAND));
+ 			} else if (nspare.eccres1 < 0) {
+ 				T(YAFFS_TRACE_ERROR,
+ 				  (TSTR
+ 				   ("**>>mtd ecc error unfixed on chunk %d:0"
+ 				    TENDSTR), chunkInNAND));
+ 			}
+ 
+ 			if (nspare.eccres2 > 0) {
+ 				T(YAFFS_TRACE_ERROR,
+ 				  (TSTR
+ 				   ("**>>mtd ecc error fix performed on chunk %d:1"
+ 				    TENDSTR), chunkInNAND));
+ 			} else if (nspare.eccres2 < 0) {
+ 				T(YAFFS_TRACE_ERROR,
+ 				  (TSTR
+ 				   ("**>>mtd ecc error unfixed on chunk %d:1"
+ 				    TENDSTR), chunkInNAND));
+ 			}
+ 
+ 			if (nspare.eccres1 || nspare.eccres2) {
+ 				/* We had a data problem on this page */
+ 				yaffs_HandleReadDataError(dev, chunkInNAND);
+ 			}
+ 
+ 			if (nspare.eccres1 < 0 || nspare.eccres2 < 0)
+ 				*eccResult = YAFFS_ECC_RESULT_UNFIXED;
+ 			else if (nspare.eccres1 > 0 || nspare.eccres2 > 0)
+ 				*eccResult = YAFFS_ECC_RESULT_FIXED;
+ 			else
+ 				*eccResult = YAFFS_ECC_RESULT_NO_ERROR;
+ 
+ 		}
+ 	}
+ 	return retVal;
+ }
+ 
+ #ifdef NOTYET
+ static int yaffs_CheckChunkErased(struct yaffs_DeviceStruct *dev,
+ 				  int chunkInNAND)
+ {
+ 	static int init;
+ 	static __u8 cmpbuf[YAFFS_BYTES_PER_CHUNK];
+ 	static __u8 data[YAFFS_BYTES_PER_CHUNK];
+ 	/* Might as well always allocate the larger size for */
+ 	/* dev->param.useNANDECC == true; */
+ 	static __u8 spare[sizeof(struct yaffs_NANDSpare)];
+ 
+ 	dev->param.readChunkFromNAND(dev, chunkInNAND, data, (yaffs_Spare *) spare);
+ 
+ 	if (!init) {
+ 		memset(cmpbuf, 0xff, YAFFS_BYTES_PER_CHUNK);
+ 		init = 1;
+ 	}
+ 
+ 	if (memcmp(cmpbuf, data, YAFFS_BYTES_PER_CHUNK))
+ 		return YAFFS_FAIL;
+ 	if (memcmp(cmpbuf, spare, 16))
+ 		return YAFFS_FAIL;
+ 
+ 	return YAFFS_OK;
+ 
+ }
+ #endif
+ 
+ /*
+  * Functions for robustisizing
+  */
+ 
+ static void yaffs_HandleReadDataError(yaffs_Device *dev, int chunkInNAND)
+ {
+ 	int blockInNAND = chunkInNAND / dev->param.nChunksPerBlock;
+ 
+ 	/* Mark the block for retirement */
+ 	yaffs_GetBlockInfo(dev, blockInNAND + dev->blockOffset)->needsRetiring = 1;
+ 	T(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
+ 	  (TSTR("**>>Block %d marked for retirement" TENDSTR), blockInNAND));
+ 
+ 	/* TODO:
+ 	 * Just do a garbage collection on the affected block
+ 	 * then retire the block
+ 	 * NB recursion
+ 	 */
+ }
+ 
+ #ifdef NOTYET
+ static void yaffs_CheckWrittenBlock(yaffs_Device *dev, int chunkInNAND)
+ {
+ }
+ 
+ static void yaffs_HandleWriteChunkOk(yaffs_Device *dev, int chunkInNAND,
+ 				     const __u8 *data,
+ 				     const yaffs_Spare *spare)
+ {
+ }
+ 
+ static void yaffs_HandleUpdateChunk(yaffs_Device *dev, int chunkInNAND,
+ 				    const yaffs_Spare *spare)
+ {
+ }
+ 
+ static void yaffs_HandleWriteChunkError(yaffs_Device *dev, int chunkInNAND)
+ {
+ 	int blockInNAND = chunkInNAND / dev->param.nChunksPerBlock;
+ 
+ 	/* Mark the block for retirement */
+ 	yaffs_GetBlockInfo(dev, blockInNAND)->needsRetiring = 1;
+ 	/* Delete the chunk */
+ 	yaffs_DeleteChunk(dev, chunkInNAND, 1, __LINE__);
+ }
+ 
+ static int yaffs_VerifyCompare(const __u8 *d0, const __u8 *d1,
+ 			       const yaffs_Spare *s0, const yaffs_Spare *s1)
+ {
+ 
+ 	if (memcmp(d0, d1, YAFFS_BYTES_PER_CHUNK) != 0 ||
+ 	    s0->tagByte0 != s1->tagByte0 ||
+ 	    s0->tagByte1 != s1->tagByte1 ||
+ 	    s0->tagByte2 != s1->tagByte2 ||
+ 	    s0->tagByte3 != s1->tagByte3 ||
+ 	    s0->tagByte4 != s1->tagByte4 ||
+ 	    s0->tagByte5 != s1->tagByte5 ||
+ 	    s0->tagByte6 != s1->tagByte6 ||
+ 	    s0->tagByte7 != s1->tagByte7 ||
+ 	    s0->ecc1[0] != s1->ecc1[0] ||
+ 	    s0->ecc1[1] != s1->ecc1[1] ||
+ 	    s0->ecc1[2] != s1->ecc1[2] ||
+ 	    s0->ecc2[0] != s1->ecc2[0] ||
+ 	    s0->ecc2[1] != s1->ecc2[1] || s0->ecc2[2] != s1->ecc2[2]) {
+ 		return 0;
+ 	}
+ 
+ 	return 1;
+ }
+ #endif				/* NOTYET */
+ 
+ int yaffs_TagsCompatabilityWriteChunkWithTagsToNAND(yaffs_Device *dev,
+ 						int chunkInNAND,
+ 						const __u8 *data,
+ 						const yaffs_ExtendedTags *eTags)
+ {
+ 	yaffs_Spare spare;
+ 	yaffs_Tags tags;
+ 
+ 	yaffs_SpareInitialise(&spare);
+ 
+ 	if (eTags->chunkDeleted)
+ 		spare.pageStatus = 0;
+ 	else {
+ 		tags.objectId = eTags->objectId;
+ 		tags.chunkId = eTags->chunkId;
+ 
+ 		tags.byteCountLSB = eTags->byteCount & 0x3ff;
+ 
+ 		if (dev->nDataBytesPerChunk >= 1024)
+ 			tags.byteCountMSB = (eTags->byteCount >> 10) & 3;
+ 		else
+ 			tags.byteCountMSB = 3;
+ 
+ 
+ 		tags.serialNumber = eTags->serialNumber;
+ 
+ 		if (!dev->param.useNANDECC && data)
+ 			yaffs_CalcECC(data, &spare);
+ 
+ 		yaffs_LoadTagsIntoSpare(&spare, &tags);
+ 
+ 	}
+ 
+ 	return yaffs_WriteChunkToNAND(dev, chunkInNAND, data, &spare);
+ }
+ 
+ int yaffs_TagsCompatabilityReadChunkWithTagsFromNAND(yaffs_Device *dev,
+ 						     int chunkInNAND,
+ 						     __u8 *data,
+ 						     yaffs_ExtendedTags *eTags)
+ {
+ 
+ 	yaffs_Spare spare;
+ 	yaffs_Tags tags;
+ 	yaffs_ECCResult eccResult = YAFFS_ECC_RESULT_UNKNOWN;
+ 
+ 	static yaffs_Spare spareFF;
+ 	static int init;
+ 
+ 	if (!init) {
+ 		memset(&spareFF, 0xFF, sizeof(spareFF));
+ 		init = 1;
+ 	}
+ 
+ 	if (yaffs_ReadChunkFromNAND
+ 	    (dev, chunkInNAND, data, &spare, &eccResult, 1)) {
+ 		/* eTags may be NULL */
+ 		if (eTags) {
+ 
+ 			int deleted =
+ 			    (yaffs_CountBits(spare.pageStatus) < 7) ? 1 : 0;
+ 
+ 			eTags->chunkDeleted = deleted;
+ 			eTags->eccResult = eccResult;
+ 			eTags->blockBad = 0;	/* We're reading it */
+ 			/* therefore it is not a bad block */
+ 			eTags->chunkUsed =
+ 			    (memcmp(&spareFF, &spare, sizeof(spareFF)) !=
+ 			     0) ? 1 : 0;
+ 
+ 			if (eTags->chunkUsed) {
+ 				yaffs_GetTagsFromSpare(dev, &spare, &tags);
+ 
+ 				eTags->objectId = tags.objectId;
+ 				eTags->chunkId = tags.chunkId;
+ 				eTags->byteCount = tags.byteCountLSB;
+ 
+ 				if (dev->nDataBytesPerChunk >= 1024)
+ 					eTags->byteCount |= (((unsigned) tags.byteCountMSB) << 10);
+ 
+ 				eTags->serialNumber = tags.serialNumber;
+ 			}
+ 		}
+ 
+ 		return YAFFS_OK;
+ 	} else {
+ 		return YAFFS_FAIL;
+ 	}
+ }
+ 
+ int yaffs_TagsCompatabilityMarkNANDBlockBad(struct yaffs_DeviceStruct *dev,
+ 					    int blockInNAND)
+ {
+ 
+ 	yaffs_Spare spare;
+ 
+ 	memset(&spare, 0xff, sizeof(yaffs_Spare));
+ 
+ 	spare.blockStatus = 'Y';
+ 
+ 	yaffs_WriteChunkToNAND(dev, blockInNAND * dev->param.nChunksPerBlock, NULL,
+ 			       &spare);
+ 	yaffs_WriteChunkToNAND(dev, blockInNAND * dev->param.nChunksPerBlock + 1,
+ 			       NULL, &spare);
+ 
+ 	return YAFFS_OK;
+ 
+ }
+ 
+ int yaffs_TagsCompatabilityQueryNANDBlock(struct yaffs_DeviceStruct *dev,
+ 					  int blockNo,
+ 					  yaffs_BlockState *state,
+ 					  __u32 *sequenceNumber)
+ {
+ 
+ 	yaffs_Spare spare0, spare1;
+ 	static yaffs_Spare spareFF;
+ 	static int init;
+ 	yaffs_ECCResult dummy;
+ 
+ 	if (!init) {
+ 		memset(&spareFF, 0xFF, sizeof(spareFF));
+ 		init = 1;
+ 	}
+ 
+ 	*sequenceNumber = 0;
+ 
+ 	yaffs_ReadChunkFromNAND(dev, blockNo * dev->param.nChunksPerBlock, NULL,
+ 				&spare0, &dummy, 1);
+ 	yaffs_ReadChunkFromNAND(dev, blockNo * dev->param.nChunksPerBlock + 1, NULL,
+ 				&spare1, &dummy, 1);
+ 
+ 	if (yaffs_CountBits(spare0.blockStatus & spare1.blockStatus) < 7)
+ 		*state = YAFFS_BLOCK_STATE_DEAD;
+ 	else if (memcmp(&spareFF, &spare0, sizeof(spareFF)) == 0)
+ 		*state = YAFFS_BLOCK_STATE_EMPTY;
+ 	else
+ 		*state = YAFFS_BLOCK_STATE_NEEDS_SCANNING;
+ 
+ 	return YAFFS_OK;
+ }
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/yaffs_tagscompat.h liab-linux-2.6.29.4/fs/yaffs2/yaffs_tagscompat.h
*** linux-2.6.29.4/fs/yaffs2/yaffs_tagscompat.h	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/yaffs_tagscompat.h	2012-01-20 14:48:21.861306032 +0100
***************
*** 0 ****
--- 1,39 ----
+ /*
+  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+  *
+  * Copyright (C) 2002-2010 Aleph One Ltd.
+  *   for Toby Churchill Ltd and Brightstar Engineering
+  *
+  * Created by Charles Manning <charles@aleph1.co.uk>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU Lesser General Public License version 2.1 as
+  * published by the Free Software Foundation.
+  *
+  * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+  */
+ 
+ #ifndef __YAFFS_TAGSCOMPAT_H__
+ #define __YAFFS_TAGSCOMPAT_H__
+ 
+ #include "yaffs_guts.h"
+ int yaffs_TagsCompatabilityWriteChunkWithTagsToNAND(yaffs_Device *dev,
+ 						int chunkInNAND,
+ 						const __u8 *data,
+ 						const yaffs_ExtendedTags *tags);
+ int yaffs_TagsCompatabilityReadChunkWithTagsFromNAND(yaffs_Device *dev,
+ 						int chunkInNAND,
+ 						__u8 *data,
+ 						yaffs_ExtendedTags *tags);
+ int yaffs_TagsCompatabilityMarkNANDBlockBad(struct yaffs_DeviceStruct *dev,
+ 					    int blockNo);
+ int yaffs_TagsCompatabilityQueryNANDBlock(struct yaffs_DeviceStruct *dev,
+ 					  int blockNo,
+ 					  yaffs_BlockState *state,
+ 					  __u32 *sequenceNumber);
+ 
+ void yaffs_CalcTagsECC(yaffs_Tags *tags);
+ int yaffs_CheckECCOnTags(yaffs_Tags *tags);
+ int yaffs_CountBits(__u8 byte);
+ 
+ #endif
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/yaffs_tagsvalidity.c liab-linux-2.6.29.4/fs/yaffs2/yaffs_tagsvalidity.c
*** linux-2.6.29.4/fs/yaffs2/yaffs_tagsvalidity.c	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/yaffs_tagsvalidity.c	2012-01-20 14:48:21.869306031 +0100
***************
*** 0 ****
--- 1,28 ----
+ /*
+  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+  *
+  * Copyright (C) 2002-2010 Aleph One Ltd.
+  *   for Toby Churchill Ltd and Brightstar Engineering
+  *
+  * Created by Charles Manning <charles@aleph1.co.uk>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2 as
+  * published by the Free Software Foundation.
+  */
+ 
+ #include "yaffs_tagsvalidity.h"
+ 
+ void yaffs_InitialiseTags(yaffs_ExtendedTags *tags)
+ {
+ 	memset(tags, 0, sizeof(yaffs_ExtendedTags));
+ 	tags->validMarker0 = 0xAAAAAAAA;
+ 	tags->validMarker1 = 0x55555555;
+ }
+ 
+ int yaffs_ValidateTags(yaffs_ExtendedTags *tags)
+ {
+ 	return (tags->validMarker0 == 0xAAAAAAAA &&
+ 		tags->validMarker1 == 0x55555555);
+ 
+ }
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/yaffs_tagsvalidity.h liab-linux-2.6.29.4/fs/yaffs2/yaffs_tagsvalidity.h
*** linux-2.6.29.4/fs/yaffs2/yaffs_tagsvalidity.h	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/yaffs_tagsvalidity.h	2012-01-20 14:48:21.861306032 +0100
***************
*** 0 ****
--- 1,24 ----
+ /*
+  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+  *
+  * Copyright (C) 2002-2010 Aleph One Ltd.
+  *   for Toby Churchill Ltd and Brightstar Engineering
+  *
+  * Created by Charles Manning <charles@aleph1.co.uk>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU Lesser General Public License version 2.1 as
+  * published by the Free Software Foundation.
+  *
+  * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+  */
+ 
+ 
+ #ifndef __YAFFS_TAGS_VALIDITY_H__
+ #define __YAFFS_TAGS_VALIDITY_H__
+ 
+ #include "yaffs_guts.h"
+ 
+ void yaffs_InitialiseTags(yaffs_ExtendedTags *tags);
+ int yaffs_ValidateTags(yaffs_ExtendedTags *tags);
+ #endif
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/yaffs_trace.h liab-linux-2.6.29.4/fs/yaffs2/yaffs_trace.h
*** linux-2.6.29.4/fs/yaffs2/yaffs_trace.h	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/yaffs_trace.h	2012-01-20 14:48:21.869306031 +0100
***************
*** 0 ****
--- 1,60 ----
+ /*
+  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+  *
+  * Copyright (C) 2002-2010 Aleph One Ltd.
+  *   for Toby Churchill Ltd and Brightstar Engineering
+  *
+  * Created by Charles Manning <charles@aleph1.co.uk>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU Lesser General Public License version 2.1 as
+  * published by the Free Software Foundation.
+  *
+  * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+  */
+ 
+ 
+ #ifndef __YTRACE_H__
+ #define __YTRACE_H__
+ 
+ extern unsigned int yaffs_traceMask;
+ extern unsigned int yaffs_wr_attempts;
+ 
+ /*
+  * Tracing flags.
+  * The flags masked in YAFFS_TRACE_ALWAYS are always traced.
+  */
+ 
+ #define YAFFS_TRACE_OS			0x00000002
+ #define YAFFS_TRACE_ALLOCATE		0x00000004
+ #define YAFFS_TRACE_SCAN		0x00000008
+ #define YAFFS_TRACE_BAD_BLOCKS		0x00000010
+ #define YAFFS_TRACE_ERASE		0x00000020
+ #define YAFFS_TRACE_GC			0x00000040
+ #define YAFFS_TRACE_WRITE		0x00000080
+ #define YAFFS_TRACE_TRACING		0x00000100
+ #define YAFFS_TRACE_DELETION		0x00000200
+ #define YAFFS_TRACE_BUFFERS		0x00000400
+ #define YAFFS_TRACE_NANDACCESS		0x00000800
+ #define YAFFS_TRACE_GC_DETAIL		0x00001000
+ #define YAFFS_TRACE_SCAN_DEBUG		0x00002000
+ #define YAFFS_TRACE_MTD			0x00004000
+ #define YAFFS_TRACE_CHECKPOINT		0x00008000
+ 
+ #define YAFFS_TRACE_VERIFY		0x00010000
+ #define YAFFS_TRACE_VERIFY_NAND		0x00020000
+ #define YAFFS_TRACE_VERIFY_FULL		0x00040000
+ #define YAFFS_TRACE_VERIFY_ALL		0x000F0000
+ 
+ #define YAFFS_TRACE_SYNC		0x00100000
+ #define YAFFS_TRACE_BACKGROUND		0x00200000
+ #define YAFFS_TRACE_LOCK		0x00400000
+ 
+ #define YAFFS_TRACE_ERROR		0x40000000
+ #define YAFFS_TRACE_BUG			0x80000000
+ #define YAFFS_TRACE_ALWAYS		0xF0000000
+ 
+ 
+ #define T(mask, p) do { if ((mask) & (yaffs_traceMask | YAFFS_TRACE_ALWAYS)) TOUT(p); } while (0)
+ 
+ #endif
diff -r -C3 -P linux-2.6.29.4/fs/yaffs2/yportenv.h liab-linux-2.6.29.4/fs/yaffs2/yportenv.h
*** linux-2.6.29.4/fs/yaffs2/yportenv.h	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/fs/yaffs2/yportenv.h	2012-01-20 14:48:21.865306031 +0100
***************
*** 0 ****
--- 1,169 ----
+ /*
+  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+  *
+  * Copyright (C) 2002-2010 Aleph One Ltd.
+  *   for Toby Churchill Ltd and Brightstar Engineering
+  *
+  * Created by Charles Manning <charles@aleph1.co.uk>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU Lesser General Public License version 2.1 as
+  * published by the Free Software Foundation.
+  *
+  * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+  */
+ 
+ 
+ #ifndef __YPORTENV_H__
+ #define __YPORTENV_H__
+ 
+ /*
+  * Define the MTD version in terms of Linux Kernel versions
+  * This allows yaffs to be used independantly of the kernel
+  * as well as with it.
+  */
+ 
+ #define MTD_VERSION(a, b, c) (((a) << 16) + ((b) << 8) + (c))
+ 
+ #if defined CONFIG_YAFFS_WINCE
+ 
+ #include "ywinceenv.h"
+ 
+ #elif defined __KERNEL__
+ 
+ #include "moduleconfig.h"
+ 
+ /* Linux kernel */
+ 
+ #include <linux/version.h>
+ #define MTD_VERSION_CODE LINUX_VERSION_CODE
+ 
+ #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+ #include <linux/config.h>
+ #endif
+ #include <linux/kernel.h>
+ #include <linux/mm.h>
+ #include <linux/sched.h>
+ #include <linux/string.h>
+ #include <linux/slab.h>
+ #include <linux/vmalloc.h>
+ 
+ #define YCHAR char
+ #define YUCHAR unsigned char
+ #define _Y(x)     x
+ #define yaffs_strcat(a, b)     strcat(a, b)
+ #define yaffs_strcpy(a, b)     strcpy(a, b)
+ #define yaffs_strncpy(a, b, c) strncpy(a, b, c)
+ #define yaffs_strncmp(a, b, c) strncmp(a, b, c)
+ #define yaffs_strnlen(s,m)	strnlen(s,m)
+ #define yaffs_sprintf	       sprintf
+ #define yaffs_toupper(a)       toupper(a)
+ 
+ #define Y_INLINE inline
+ 
+ #define YAFFS_LOSTNFOUND_NAME		"lost+found"
+ #define YAFFS_LOSTNFOUND_PREFIX		"obj"
+ 
+ /* #define YPRINTF(x) printk x */
+ #define YMALLOC(x) kmalloc(x, GFP_NOFS)
+ #define YFREE(x)   kfree(x)
+ #define YMALLOC_ALT(x) vmalloc(x)
+ #define YFREE_ALT(x)   vfree(x)
+ #define YMALLOC_DMA(x) YMALLOC(x)
+ 
+ #define YYIELD() schedule()
+ #define Y_DUMP_STACK() dump_stack()
+ 
+ #define YAFFS_ROOT_MODE			0755
+ #define YAFFS_LOSTNFOUND_MODE		0700
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+ #define Y_CURRENT_TIME CURRENT_TIME.tv_sec
+ #define Y_TIME_CONVERT(x) (x).tv_sec
+ #else
+ #define Y_CURRENT_TIME CURRENT_TIME
+ #define Y_TIME_CONVERT(x) (x)
+ #endif
+ 
+ #define yaffs_SumCompare(x, y) ((x) == (y))
+ #define yaffs_strcmp(a, b) strcmp(a, b)
+ 
+ #define TENDSTR "\n"
+ #define TSTR(x) KERN_DEBUG x
+ #define TCONT(x) x
+ #define TOUT(p) printk p
+ 
+ #define compile_time_assertion(assertion) \
+ 	({ int x = __builtin_choose_expr(assertion, 0, (void)0); (void) x; })
+ 
+ #elif defined CONFIG_YAFFS_DIRECT
+ 
+ #define MTD_VERSION_CODE MTD_VERSION(2, 6, 22)
+ 
+ /* Direct interface */
+ #include "ydirectenv.h"
+ 
+ #elif defined CONFIG_YAFFS_UTIL
+ 
+ /* Stuff for YAFFS utilities */
+ 
+ #include "stdlib.h"
+ #include "stdio.h"
+ #include "string.h"
+ 
+ #include "devextras.h"
+ 
+ #define YMALLOC(x) malloc(x)
+ #define YFREE(x)   free(x)
+ #define YMALLOC_ALT(x) malloc(x)
+ #define YFREE_ALT(x) free(x)
+ 
+ #define YCHAR char
+ #define YUCHAR unsigned char
+ #define _Y(x)     x
+ #define yaffs_strcat(a, b)     strcat(a, b)
+ #define yaffs_strcpy(a, b)     strcpy(a, b)
+ #define yaffs_strncpy(a, b, c) strncpy(a, b, c)
+ #define yaffs_strnlen(s,m)	       strnlen(s,m)
+ #define yaffs_sprintf	       sprintf
+ #define yaffs_toupper(a)       toupper(a)
+ 
+ #define Y_INLINE inline
+ 
+ /* #define YINFO(s) YPRINTF(( __FILE__ " %d %s\n",__LINE__,s)) */
+ /* #define YALERT(s) YINFO(s) */
+ 
+ #define TENDSTR "\n"
+ #define TSTR(x) x
+ #define TOUT(p) printf p
+ 
+ #define YAFFS_LOSTNFOUND_NAME		"lost+found"
+ #define YAFFS_LOSTNFOUND_PREFIX		"obj"
+ /* #define YPRINTF(x) printf x */
+ 
+ #define YAFFS_ROOT_MODE			0755
+ #define YAFFS_LOSTNFOUND_MODE		0700
+ 
+ #define yaffs_SumCompare(x, y) ((x) == (y))
+ #define yaffs_strcmp(a, b) strcmp(a, b)
+ 
+ #else
+ /* Should have specified a configuration type */
+ #error Unknown configuration
+ 
+ #endif
+ 
+ #ifndef Y_DUMP_STACK
+ #define Y_DUMP_STACK() do { } while (0)
+ #endif
+ 
+ #ifndef YBUG
+ #define YBUG() do {\
+ 	T(YAFFS_TRACE_BUG,\
+ 		(TSTR("==>> yaffs bug: " __FILE__ " %d" TENDSTR),\
+ 		__LINE__));\
+ 	Y_DUMP_STACK();\
+ } while (0)
+ #endif
+ 
+ #endif
diff -r -C3 -P linux-2.6.29.4/gpiolib.patch liab-linux-2.6.29.4/gpiolib.patch
*** linux-2.6.29.4/gpiolib.patch	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/gpiolib.patch	2012-01-20 14:49:42.829307094 +0100
***************
*** 0 ****
--- 1,463 ----
+ diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
+ index dbfdf87..5e0c5ab 100644
+ --- a/arch/arm/Kconfig
+ +++ b/arch/arm/Kconfig
+ @@ -241,6 +241,7 @@ config ARCH_VERSATILE
+  config ARCH_AT91
+  	bool "Atmel AT91"
+  	select GENERIC_GPIO
+ +	select ARCH_REQUIRE_GPIOLIB
+  	select HAVE_CLK
+  	help
+  	  This enables support for systems based on the Atmel AT91RM9200,
+ diff --git a/arch/arm/mach-at91/generic.h b/arch/arm/mach-at91/generic.h
+ index 7b9ce7a..b5daf7f 100644
+ --- a/arch/arm/mach-at91/generic.h
+ +++ b/arch/arm/mach-at91/generic.h
+ @@ -47,9 +47,6 @@ extern void at91_irq_resume(void);
+  #define AT91RM9200_BGA		4	/* AT91RM9200 BGA package has 4 banks */
+  
+  struct at91_gpio_bank {
+ -	unsigned chipbase;		/* bank's first GPIO number */
+ -	void __iomem *regbase;		/* base of register bank */
+ -	struct at91_gpio_bank *next;	/* bank sharing same IRQ/clock/... */
+  	unsigned short id;		/* peripheral ID */
+  	unsigned long offset;		/* offset from system peripheral base */
+  	struct clk *clock;		/* associated clock */
+ diff --git a/arch/arm/mach-at91/gpio.c b/arch/arm/mach-at91/gpio.c
+ index 9b0447c..2b1232f 100644
+ --- a/arch/arm/mach-at91/gpio.c
+ +++ b/arch/arm/mach-at91/gpio.c
+ @@ -24,19 +24,59 @@
+  #include <mach/at91_pio.h>
+  #include <mach/gpio.h>
+  
+ +#include <asm/gpio.h>
+ +
+  #include "generic.h"
+  
+ +struct at91_gpio_chip {
+ +	struct gpio_chip	chip;
+ +	struct at91_gpio_chip	*next;		/* Bank sharing same clock */
+ +	struct at91_gpio_bank	*bank;		/* Bank definition */
+ +	void __iomem		*regbase;	/* Base of register bank */
+ +};
+  
+ -static struct at91_gpio_bank *gpio;
+ -static int gpio_banks;
+ +#define to_at91_gpio_chip(c) container_of(c, struct at91_gpio_chip, chip)
+ +
+ +static void at91_gpiolib_dbg_show(struct seq_file *s, struct gpio_chip *chip);
+ +static void at91_gpiolib_set(struct gpio_chip *chip, unsigned offset, int val);
+ +static int at91_gpiolib_get(struct gpio_chip *chip, unsigned offset);
+ +static int at91_gpiolib_direction_output(struct gpio_chip *chip,
+ +					 unsigned offset, int val);
+ +static int at91_gpiolib_direction_input(struct gpio_chip *chip,
+ +					unsigned offset);
+ +static int at91_gpiolib_request(struct gpio_chip *chip, unsigned offset);
+ +
+ +#define AT91_GPIO_CHIP(name, base_gpio, nr_gpio)			\
+ +	{								\
+ +		.chip = {						\
+ +			.label		  = name,			\
+ +			.request	  = at91_gpiolib_request,	\
+ +			.direction_input  = at91_gpiolib_direction_input, \
+ +			.direction_output = at91_gpiolib_direction_output, \
+ +			.get		  = at91_gpiolib_get,		\
+ +			.set		  = at91_gpiolib_set,		\
+ +			.dbg_show	  = at91_gpiolib_dbg_show,	\
+ +			.base		  = base_gpio,			\
+ +			.ngpio		  = nr_gpio,			\
+ +		},							\
+ +	}
+ +
+ +static struct at91_gpio_chip gpio_chip[] = {
+ +	AT91_GPIO_CHIP("A", 0x00 + PIN_BASE, 32),
+ +	AT91_GPIO_CHIP("B", 0x20 + PIN_BASE, 32),
+ +	AT91_GPIO_CHIP("C", 0x40 + PIN_BASE, 32),
+ +	AT91_GPIO_CHIP("D", 0x60 + PIN_BASE, 32),
+ +	AT91_GPIO_CHIP("E", 0x80 + PIN_BASE, 32),
+ +};
+  
+ +static int gpio_banks;
+  
+  static inline void __iomem *pin_to_controller(unsigned pin)
+  {
+  	pin -= PIN_BASE;
+  	pin /= 32;
+  	if (likely(pin < gpio_banks))
+ -		return gpio[pin].regbase;
+ +		return gpio_chip[pin].regbase;
+  
+  	return NULL;
+  }
+ @@ -197,39 +237,6 @@ int __init_or_module at91_set_multi_drive(unsigned pin, int is_on)
+  }
+  EXPORT_SYMBOL(at91_set_multi_drive);
+  
+ -/*--------------------------------------------------------------------------*/
+ -
+ -/* new-style GPIO calls; these expect at91_set_GPIO_periph to have been
+ - * called, and maybe at91_set_multi_drive() for putout pins.
+ - */
+ -
+ -int gpio_direction_input(unsigned pin)
+ -{
+ -	void __iomem	*pio = pin_to_controller(pin);
+ -	unsigned	mask = pin_to_mask(pin);
+ -
+ -	if (!pio || !(__raw_readl(pio + PIO_PSR) & mask))
+ -		return -EINVAL;
+ -	__raw_writel(mask, pio + PIO_ODR);
+ -	return 0;
+ -}
+ -EXPORT_SYMBOL(gpio_direction_input);
+ -
+ -int gpio_direction_output(unsigned pin, int value)
+ -{
+ -	void __iomem	*pio = pin_to_controller(pin);
+ -	unsigned	mask = pin_to_mask(pin);
+ -
+ -	if (!pio || !(__raw_readl(pio + PIO_PSR) & mask))
+ -		return -EINVAL;
+ -	__raw_writel(mask, pio + (value ? PIO_SODR : PIO_CODR));
+ -	__raw_writel(mask, pio + PIO_OER);
+ -	return 0;
+ -}
+ -EXPORT_SYMBOL(gpio_direction_output);
+ -
+ -/*--------------------------------------------------------------------------*/
+ -
+  /*
+   * assuming the pin is muxed as a gpio output, set its value.
+   */
+ @@ -282,7 +289,7 @@ static int gpio_irq_set_wake(unsigned pin, unsigned state)
+  	else
+  		wakeups[bank] &= ~mask;
+  
+ -	set_irq_wake(gpio[bank].id, state);
+ +	set_irq_wake(gpio_chip[bank].bank->id, state);
+  
+  	return 0;
+  }
+ @@ -292,14 +299,14 @@ void at91_gpio_suspend(void)
+  	int i;
+  
+  	for (i = 0; i < gpio_banks; i++) {
+ -		void __iomem	*pio = gpio[i].regbase;
+ +		void __iomem	*pio = gpio_chip[i].regbase;
+  
+  		backups[i] = __raw_readl(pio + PIO_IMR);
+  		__raw_writel(backups[i], pio + PIO_IDR);
+  		__raw_writel(wakeups[i], pio + PIO_IER);
+  
+  		if (!wakeups[i])
+ -			clk_disable(gpio[i].clock);
+ +			clk_disable(gpio_chip[i].bank->clock);
+  		else {
+  #ifdef CONFIG_PM_DEBUG
+  			printk(KERN_DEBUG "GPIO-%c may wake for %08x\n", 'A'+i, wakeups[i]);
+ @@ -313,10 +320,10 @@ void at91_gpio_resume(void)
+  	int i;
+  
+  	for (i = 0; i < gpio_banks; i++) {
+ -		void __iomem	*pio = gpio[i].regbase;
+ +		void __iomem	*pio = gpio_chip[i].regbase;
+  
+  		if (!wakeups[i])
+ -			clk_enable(gpio[i].clock);
+ +			clk_enable(gpio_chip[i].bank->clock);
+  
+  		__raw_writel(wakeups[i], pio + PIO_IDR);
+  		__raw_writel(backups[i], pio + PIO_IER);
+ @@ -380,12 +387,12 @@ static void gpio_irq_handler(unsigned irq, struct irq_desc *desc)
+  {
+  	unsigned	pin;
+  	struct irq_desc	*gpio;
+ -	struct at91_gpio_bank *bank;
+ +	struct at91_gpio_chip *at91_gpio;
+  	void __iomem	*pio;
+  	u32		isr;
+  
+ -	bank = get_irq_chip_data(irq);
+ -	pio = bank->regbase;
+ +	at91_gpio = get_irq_chip_data(irq);
+ +	pio = at91_gpio->regbase;
+  
+  	/* temporarily mask (level sensitive) parent IRQ */
+  	desc->chip->ack(irq);
+ @@ -396,14 +403,14 @@ static void gpio_irq_handler(unsigned irq, struct irq_desc *desc)
+  		 */
+  		isr = __raw_readl(pio + PIO_ISR) & __raw_readl(pio + PIO_IMR);
+  		if (!isr) {
+ -			if (!bank->next)
+ +			if (!at91_gpio->next)
+  				break;
+ -			bank = bank->next;
+ -			pio = bank->regbase;
+ +			at91_gpio = at91_gpio->next;
+ +			pio = at91_gpio->regbase;
+  			continue;
+  		}
+  
+ -		pin = bank->chipbase;
+ +		pin = at91_gpio->chip.base;
+  		gpio = &irq_desc[pin];
+  
+  		while (isr) {
+ @@ -430,66 +437,6 @@ static void gpio_irq_handler(unsigned irq, struct irq_desc *desc)
+  
+  /*--------------------------------------------------------------------------*/
+  
+ -#ifdef CONFIG_DEBUG_FS
+ -
+ -static int at91_gpio_show(struct seq_file *s, void *unused)
+ -{
+ -	int bank, j;
+ -
+ -	/* print heading */
+ -	seq_printf(s, "Pin\t");
+ -	for (bank = 0; bank < gpio_banks; bank++) {
+ -		seq_printf(s, "PIO%c\t", 'A' + bank);
+ -	};
+ -	seq_printf(s, "\n\n");
+ -
+ -	/* print pin status */
+ -	for (j = 0; j < 32; j++) {
+ -		seq_printf(s, "%i:\t", j);
+ -
+ -		for (bank = 0; bank < gpio_banks; bank++) {
+ -			unsigned	pin  = PIN_BASE + (32 * bank) + j;
+ -			void __iomem	*pio = pin_to_controller(pin);
+ -			unsigned	mask = pin_to_mask(pin);
+ -
+ -			if (__raw_readl(pio + PIO_PSR) & mask)
+ -				seq_printf(s, "GPIO:%s", __raw_readl(pio + PIO_PDSR) & mask ? "1" : "0");
+ -			else
+ -				seq_printf(s, "%s", __raw_readl(pio + PIO_ABSR) & mask ? "B" : "A");
+ -
+ -			seq_printf(s, "\t");
+ -		}
+ -
+ -		seq_printf(s, "\n");
+ -	}
+ -
+ -	return 0;
+ -}
+ -
+ -static int at91_gpio_open(struct inode *inode, struct file *file)
+ -{
+ -	return single_open(file, at91_gpio_show, NULL);
+ -}
+ -
+ -static const struct file_operations at91_gpio_operations = {
+ -	.open		= at91_gpio_open,
+ -	.read		= seq_read,
+ -	.llseek		= seq_lseek,
+ -	.release	= single_release,
+ -};
+ -
+ -static int __init at91_gpio_debugfs_init(void)
+ -{
+ -	/* /sys/kernel/debug/at91_gpio */
+ -	(void) debugfs_create_file("at91_gpio", S_IFREG | S_IRUGO, NULL, NULL, &at91_gpio_operations);
+ -	return 0;
+ -}
+ -postcore_initcall(at91_gpio_debugfs_init);
+ -
+ -#endif
+ -
+ -/*--------------------------------------------------------------------------*/
+ -
+  /* This lock class tells lockdep that GPIO irqs are in a different
+   * category than their parents, so it won't report false recursion.
+   */
+ @@ -501,20 +448,20 @@ static struct lock_class_key gpio_lock_class;
+  void __init at91_gpio_irq_setup(void)
+  {
+  	unsigned		pioc, pin;
+ -	struct at91_gpio_bank	*this, *prev;
+ +	struct at91_gpio_chip	*this, *prev;
+  
+ -	for (pioc = 0, pin = PIN_BASE, this = gpio, prev = NULL;
+ +	for (pioc = 0, pin = PIN_BASE, this = gpio_chip, prev = NULL;
+  			pioc++ < gpio_banks;
+  			prev = this, this++) {
+ -		unsigned	id = this->id;
+ +		unsigned	id = this->bank->id;
+  		unsigned	i;
+  
+  		/* enable PIO controller's clock */
+ -		clk_enable(this->clock);
+ +		clk_enable(this->bank->clock);
+  
+  		__raw_writel(~0, this->regbase + PIO_IDR);
+  
+ -		for (i = 0, pin = this->chipbase; i < 32; i++, pin++) {
+ +		for (i = 0, pin = this->chip.base; i < 32; i++, pin++) {
+  			lockdep_set_class(&irq_desc[pin].lock, &gpio_lock_class);
+  
+  			/*
+ @@ -539,25 +486,114 @@ void __init at91_gpio_irq_setup(void)
+  	pr_info("AT91: %d gpio irqs in %d banks\n", pin - PIN_BASE, gpio_banks);
+  }
+  
+ +/* gpiolib support */
+ +static int at91_gpiolib_direction_input(struct gpio_chip *chip,
+ +					unsigned offset)
+ +{
+ +	struct at91_gpio_chip *at91_gpio = to_at91_gpio_chip(chip);
+ +	void __iomem *pio = at91_gpio->regbase;
+ +	unsigned mask = 1 << offset;
+ +	
+ +	__raw_writel(mask, pio + PIO_ODR);
+ +	return 0;
+ +}
+ +
+ +static int at91_gpiolib_direction_output(struct gpio_chip *chip,
+ +					 unsigned offset, int val)
+ +{
+ +	struct at91_gpio_chip *at91_gpio = to_at91_gpio_chip(chip);
+ +	void __iomem *pio = at91_gpio->regbase;
+ +	unsigned mask = 1 << offset;
+ +
+ +	__raw_writel(mask, pio + (val ? PIO_SODR : PIO_CODR));
+ +	__raw_writel(mask, pio + PIO_OER);
+ +	return 0;
+ +}
+ +
+ +static int at91_gpiolib_get(struct gpio_chip *chip, unsigned offset)
+ +{
+ +	struct at91_gpio_chip *at91_gpio = to_at91_gpio_chip(chip);
+ +	void __iomem *pio = at91_gpio->regbase;
+ +	unsigned mask = 1 << offset;
+ +	u32 pdsr;
+ +
+ +	pdsr = __raw_readl(pio + PIO_PDSR);
+ +	return (pdsr & mask) != 0;
+ +}
+ +
+ +static void at91_gpiolib_set(struct gpio_chip *chip, unsigned offset, int val)
+ +{	
+ +	struct at91_gpio_chip *at91_gpio = to_at91_gpio_chip(chip);
+ +	void __iomem *pio = at91_gpio->regbase;
+ +	unsigned mask = 1 << offset;
+ +	
+ +	__raw_writel(mask, pio + (val ? PIO_SODR : PIO_CODR));
+ +}
+ +
+ +static int at91_gpiolib_request(struct gpio_chip *chip, unsigned offset)
+ +{
+ +	unsigned pin = chip->base + offset;
+ +	void __iomem *pio = pin_to_controller(pin);
+ +	unsigned mask = pin_to_mask(pin);
+ +	
+ +	/* Cannot request GPIOs that are in alternate function mode */
+ +	if (!(__raw_readl(pio + PIO_PSR) & mask))
+ +		return -EPERM;
+ +	
+ +	return 0;
+ +}
+ +
+ +static void at91_gpiolib_dbg_show(struct seq_file *s, struct gpio_chip *chip)
+ +{
+ +	int i;
+ +
+ +	for (i = 0; i < chip->ngpio; i++) {
+ +		unsigned pin = chip->base + i;
+ +		void __iomem *pio = pin_to_controller(pin);
+ +		unsigned mask = pin_to_mask(pin);
+ +		const char *gpio_label;
+ +
+ +		gpio_label = gpiochip_is_requested(chip, i);
+ +		if (gpio_label) {
+ +			seq_printf(s, "[%s] GPIO%s%d: ",
+ +				   gpio_label, chip->label, i);
+ +			if (__raw_readl(pio + PIO_PSR) & mask)
+ +				seq_printf(s, "[gpio] %s\n",
+ +					   at91_get_gpio_value(pin) ?
+ +					   "set" : "clear");
+ +			else
+ +				seq_printf(s, "[periph %s]\n",
+ +					   __raw_readl(pio + PIO_ABSR) &
+ +					   mask ? "B" : "A");
+ +		}
+ +	}
+ +}
+ +
+  /*
+   * Called from the processor-specific init to enable GPIO pin support.
+   */
+  void __init at91_gpio_init(struct at91_gpio_bank *data, int nr_banks)
+  {
+  	unsigned		i;
+ -	struct at91_gpio_bank	*last;
+ +	struct at91_gpio_chip *at91_gpio, *last = NULL;
+  
+  	BUG_ON(nr_banks > MAX_GPIO_BANKS);
+  
+ -	gpio = data;
+  	gpio_banks = nr_banks;
+  
+ -	for (i = 0, last = NULL; i < nr_banks; i++, last = data, data++) {
+ -		data->chipbase = PIN_BASE + i * 32;
+ -		data->regbase = data->offset + (void __iomem *)AT91_VA_BASE_SYS;
+ +	for (i = 0; i < nr_banks; i++) {
+ +		at91_gpio = &gpio_chip[i];
+ +
+ +		at91_gpio->bank = data;
+ +		at91_gpio->chip.base = PIN_BASE + i * 32;
+ +		at91_gpio->regbase = at91_gpio->bank->offset + 
+ +			(void __iomem *)AT91_VA_BASE_SYS;
+  
+  		/* AT91SAM9263_ID_PIOCDE groups PIOC, PIOD, PIOE */
+ -		if (last && last->id == data->id)
+ -			last->next = data;
+ +		if (last && last->bank->id == at91_gpio->bank->id)
+ +			last->next = at91_gpio;
+ +		last = at91_gpio;
+ +
+ +		gpiochip_add(&at91_gpio->chip);
+  	}
+  }
+ diff --git a/arch/arm/mach-at91/include/mach/gpio.h b/arch/arm/mach-at91/include/mach/gpio.h
+ index bffa674..04c91e3 100644
+ --- a/arch/arm/mach-at91/include/mach/gpio.h
+ +++ b/arch/arm/mach-at91/include/mach/gpio.h
+ @@ -213,32 +213,12 @@ extern void at91_gpio_resume(void);
+   */
+  
+  #include <asm/errno.h>
+ -
+ -static inline int gpio_request(unsigned gpio, const char *label)
+ -{
+ -	return 0;
+ -}
+ -
+ -static inline void gpio_free(unsigned gpio)
+ -{
+ -	might_sleep();
+ -}
+ -
+ -extern int gpio_direction_input(unsigned gpio);
+ -extern int gpio_direction_output(unsigned gpio, int value);
+ -
+ -static inline int gpio_get_value(unsigned gpio)
+ -{
+ -	return at91_get_gpio_value(gpio);
+ -}
+ -
+ -static inline void gpio_set_value(unsigned gpio, int value)
+ -{
+ -	at91_set_gpio_value(gpio, value);
+ -}
+ -
+  #include <asm-generic/gpio.h>		/* cansleep wrappers */
+  
+ +#define gpio_get_value	__gpio_get_value
+ +#define gpio_set_value	__gpio_set_value
+ +#define gpio_cansleep	__gpio_cansleep
+ +
+  static inline int gpio_to_irq(unsigned gpio)
+  {
+  	return gpio;
diff -r -C3 -P linux-2.6.29.4/include/linux/at91_pwm.h liab-linux-2.6.29.4/include/linux/at91_pwm.h
*** linux-2.6.29.4/include/linux/at91_pwm.h	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/include/linux/at91_pwm.h	2012-01-20 14:48:57.865306502 +0100
***************
*** 0 ****
--- 1,74 ----
+ #ifndef __LINUX_ATMEL_PWM_H
+ #define __LINUX_ATMEL_PWM_H
+ 
+ /**
+  * struct pwm_channel - driver handle to a PWM channel
+  * @regs: base of this channel's registers
+  * @index: number of this channel (0..31)
+  * @mck: base clock rate, which can be prescaled and maybe subdivided
+  *
+  * Drivers initialize a pwm_channel structure using pwm_channel_alloc().
+  * Then they configure its clock rate (derived from MCK), alignment,
+  * polarity, and duty cycle by writing directly to the channel registers,
+  * before enabling the channel by calling pwm_channel_enable().
+  *
+  * After emitting a PWM signal for the desired length of time, drivers
+  * may then pwm_channel_disable() or pwm_channel_free().  Both of these
+  * disable the channel, but when it's freed the IRQ is deconfigured and
+  * the channel must later be re-allocated and reconfigured.
+  *
+  * Note that if the period or duty cycle need to be changed while the
+  * PWM channel is operating, drivers must use the PWM_CUPD double buffer
+  * mechanism, either polling until they change or getting implicitly
+  * notified through a once-per-period interrupt handler.
+  */
+ struct pwm_channel {
+ 	void __iomem	*regs;
+ 	unsigned	index;
+ 	unsigned long	mck;
+ };
+ 
+ extern int pwm_channel_alloc(int index, struct pwm_channel *ch);
+ extern int pwm_channel_free(struct pwm_channel *ch);
+ 
+ extern int pwm_clk_alloc(unsigned prescale, unsigned div);
+ extern void pwm_clk_free(unsigned clk);
+ 
+ extern int __pwm_channel_onoff(struct pwm_channel *ch, int enabled);
+ 
+ #define pwm_channel_enable(ch)	__pwm_channel_onoff((ch), 1)
+ #define pwm_channel_disable(ch)	__pwm_channel_onoff((ch), 0)
+ 
+ /* periodic interrupts, mostly for CUPD changes to period or cycle */
+ extern int pwm_channel_handler(struct pwm_channel *ch,
+ 		void (*handler)(struct pwm_channel *ch));
+ 
+ /* per-channel registers (banked at pwm_channel->regs) */
+ #define PWM_CMR		0x00		/* mode register */
+ #define		PWM_CPR_CPD	(1 << 10)	/* set: CUPD modifies period */
+ #define		PWM_CPR_CPOL	(1 << 9)	/* set: idle high */
+ #define		PWM_CPR_CALG	(1 << 8)	/* set: center align */
+ #define		PWM_CPR_CPRE	(0xf << 0)	/* mask: rate is mck/(2^pre) */
+ #define		PWM_CPR_CLKA	(0xb << 0)	/* rate CLKA */
+ #define		PWM_CPR_CLKB	(0xc << 0)	/* rate CLKB */
+ #define PWM_CDTY	0x04		/* duty cycle (max of CPRD) */
+ #define PWM_CPRD	0x08		/* period (count up from zero) */
+ #define PWM_CCNT	0x0c		/* counter (20 bits?) */
+ #define PWM_CUPD	0x10		/* update CPRD (or CDTY) next period */
+ 
+ extern void
+ pwm_channel_writel(struct pwm_channel *pwmc, unsigned offset, u32 val);
+ extern u32 pwm_channel_readl(struct pwm_channel *pwmc, unsigned offset);
+ 
+ /* static inline void */
+ /* pwm_channel_writel(struct pwm_channel *pwmc, unsigned offset, u32 val) */
+ /* { */
+ /*   __raw_writel(val, pwmc->regs + offset); */
+ /* } */
+ 
+ /* static inline u32 pwm_channel_readl(struct pwm_channel *pwmc, unsigned offset) */
+ /* { */
+ /* 	return __raw_readl(pwmc->regs + offset); */
+ /* } */
+ 
+ #endif /* __LINUX_ATMEL_PWM_H */
diff -r -C3 -P linux-2.6.29.4/include/linux/liab.h liab-linux-2.6.29.4/include/linux/liab.h
*** linux-2.6.29.4/include/linux/liab.h	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/include/linux/liab.h	2012-01-20 14:48:57.877306506 +0100
***************
*** 0 ****
--- 1,25 ----
+ /*
+  * Driver model for LIAB class
+  *
+  * Copyright (C) 2011 LIAB aps
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2 as
+  * published by the Free Software Foundation.
+  *
+  */
+ #ifndef __LINUX_LIAB_H_INCLUDED
+ #define __LINUX_LIAB_H_INCLUDED
+ 
+ 
+ extern struct device *liab_device_create(struct device *parent,
+ 				    dev_t devt, void *drvdata,
+ 				    const char *fmt, ...)
+     __attribute__((format(printf, 4, 5)));
+ 
+ extern void liab_device_unregister(struct device *dev);
+ 
+ 
+ 
+ 
+ #endif		/* __LINUX_LIAB_H_INCLUDED */
diff -r -C3 -P linux-2.6.29.4/include/linux/tty.h liab-linux-2.6.29.4/include/linux/tty.h
*** linux-2.6.29.4/include/linux/tty.h	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/include/linux/tty.h	2012-01-20 14:48:57.949306506 +0100
***************
*** 23,29 ****
   */
  #define NR_UNIX98_PTY_DEFAULT	4096      /* Default maximum for Unix98 ptys */
  #define NR_UNIX98_PTY_MAX	(1 << MINORBITS) /* Absolute limit */
! #define NR_LDISCS		19
  
  /* line disciplines */
  #define N_TTY		0
--- 23,29 ----
   */
  #define NR_UNIX98_PTY_DEFAULT	4096      /* Default maximum for Unix98 ptys */
  #define NR_UNIX98_PTY_MAX	(1 << MINORBITS) /* Absolute limit */
! #define NR_LDISCS		20
  
  /* line disciplines */
  #define N_TTY		0
***************
*** 46,51 ****
--- 46,52 ----
  #define N_GIGASET_M101	16	/* Siemens Gigaset M101 serial DECT adapter */
  #define N_SLCAN		17	/* Serial / USB serial CAN Adaptors */
  #define N_PPS		18	/* Pulse per Second */
+ #define N_LIAB		19	/* LIAB line discipline hook */
  
  /*
   * This character is the same as _POSIX_VDISABLE: it cannot be used as
diff -r -C3 -P linux-2.6.29.4/init/do_mounts_rd.c liab-linux-2.6.29.4/init/do_mounts_rd.c
*** linux-2.6.29.4/init/do_mounts_rd.c	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/init/do_mounts_rd.c	2012-01-20 14:49:01.749306555 +0100
***************
*** 323,328 ****
--- 323,337 ----
  
  #include "../lib/inflate.c"
  
+ #ifdef    CONFIG_MACH_LIABARM
+  static int fill_inbuf_counter = 0;
+  #define KILOBYTESPERDOT      64
+  #define DOTDIVISOR         ((KILOBYTESPERDOT*1024)/INBUFSIZ)
+  #define DOTDIVISOR2         (KILOBYTESPERDOT*1024)
+  #define MEGABYTEDIVISOR    ((1024*1024)/INBUFSIZ)
+  #define MEGABYTEDIVISOR2    (1024*1024)
+ #endif /* CONFIG_MACH_LIABARM */
+ 
  /* ===========================================================================
   * Fill the input buffer. This is called only when the buffer is empty
   * and at least one byte is really needed.
***************
*** 340,345 ****
--- 349,365 ----
  
  	inptr = 1;
  
+ #ifdef    CONFIG_MACH_LIABARM
+   fill_inbuf_counter++;
+   if (fill_inbuf_counter % DOTDIVISOR == 0)
+     {
+       if (fill_inbuf_counter % MEGABYTEDIVISOR == 0)
+         printk("M");
+       else
+         printk(".");
+     }
+ #endif /* CONFIG_MACH_LIABARM */
+ 
  	return inbuf[0];
  }
  
***************
*** 402,407 ****
--- 422,430 ----
  	}
  	makecrc();
  	result = gunzip();
+ #ifdef    CONFIG_MACH_LIABARM
+   printk("\n");
+ #endif /* CONFIG_MACH_LIABARM */
  	if (unzip_error)
  		result = 1;
  	kfree(inbuf);
diff -r -C3 -P linux-2.6.29.4/init/initramfs.c liab-linux-2.6.29.4/init/initramfs.c
*** linux-2.6.29.4/init/initramfs.c	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/init/initramfs.c	2012-01-20 14:49:01.749306555 +0100
***************
*** 583,588 ****
--- 583,589 ----
  	if (initrd_start) {
  #ifdef CONFIG_BLK_DEV_RAM
  		int fd;
+ #ifndef   CONFIG_MACH_LIABARM
  		printk(KERN_INFO "checking if image is initramfs...");
  		err = unpack_to_rootfs((char *)initrd_start,
  			initrd_end - initrd_start, 1);
***************
*** 594,599 ****
--- 595,604 ----
  			return 0;
  		}
  		printk("it isn't (%s); looks like an initrd\n", err);
+ #else /* CONFIG_MACH_LIABARM */
+     printk("Using initrd at 0x%lx length 0x%lx\n",
+ 					 initrd_start, initrd_end-initrd_start);
+ #endif /* CONFIG_MACH_LIABARM */
  		fd = sys_open("/initrd.image", O_WRONLY|O_CREAT, 0700);
  		if (fd >= 0) {
  			sys_write(fd, (char *)initrd_start,
diff -r -C3 -P linux-2.6.29.4/liabdin-2.6.29.4.config liab-linux-2.6.29.4/liabdin-2.6.29.4.config
*** linux-2.6.29.4/liabdin-2.6.29.4.config	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/liabdin-2.6.29.4.config	2012-01-20 14:49:42.841307094 +0100
***************
*** 0 ****
--- 1,1462 ----
+ #
+ # Automatically generated make config: don't edit
+ # Linux kernel version: 2.6.29.4
+ # Fri Jan 22 15:28:53 2010
+ #
+ CONFIG_ARM=y
+ CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+ CONFIG_GENERIC_GPIO=y
+ CONFIG_GENERIC_TIME=y
+ CONFIG_GENERIC_CLOCKEVENTS=y
+ CONFIG_MMU=y
+ # CONFIG_NO_IOPORT is not set
+ CONFIG_GENERIC_HARDIRQS=y
+ CONFIG_STACKTRACE_SUPPORT=y
+ CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+ CONFIG_LOCKDEP_SUPPORT=y
+ CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+ CONFIG_HARDIRQS_SW_RESEND=y
+ CONFIG_GENERIC_IRQ_PROBE=y
+ CONFIG_RWSEM_GENERIC_SPINLOCK=y
+ # CONFIG_ARCH_HAS_ILOG2_U32 is not set
+ # CONFIG_ARCH_HAS_ILOG2_U64 is not set
+ CONFIG_GENERIC_HWEIGHT=y
+ CONFIG_GENERIC_CALIBRATE_DELAY=y
+ CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+ CONFIG_VECTORS_BASE=0xffff0000
+ CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+ 
+ #
+ # General setup
+ #
+ CONFIG_EXPERIMENTAL=y
+ CONFIG_BROKEN_ON_SMP=y
+ CONFIG_LOCK_KERNEL=y
+ CONFIG_INIT_ENV_ARG_LIMIT=32
+ CONFIG_LOCALVERSION=""
+ # CONFIG_LOCALVERSION_AUTO is not set
+ CONFIG_SWAP=y
+ CONFIG_SYSVIPC=y
+ CONFIG_SYSVIPC_SYSCTL=y
+ CONFIG_POSIX_MQUEUE=y
+ # CONFIG_BSD_PROCESS_ACCT is not set
+ # CONFIG_TASKSTATS is not set
+ # CONFIG_AUDIT is not set
+ 
+ #
+ # RCU Subsystem
+ #
+ # CONFIG_CLASSIC_RCU is not set
+ # CONFIG_TREE_RCU is not set
+ CONFIG_PREEMPT_RCU=y
+ # CONFIG_RCU_TRACE is not set
+ # CONFIG_TREE_RCU_TRACE is not set
+ # CONFIG_PREEMPT_RCU_TRACE is not set
+ CONFIG_IKCONFIG=y
+ CONFIG_IKCONFIG_PROC=y
+ CONFIG_LOG_BUF_SHIFT=14
+ CONFIG_GROUP_SCHED=y
+ CONFIG_FAIR_GROUP_SCHED=y
+ # CONFIG_RT_GROUP_SCHED is not set
+ CONFIG_USER_SCHED=y
+ # CONFIG_CGROUP_SCHED is not set
+ # CONFIG_CGROUPS is not set
+ CONFIG_SYSFS_DEPRECATED=y
+ CONFIG_SYSFS_DEPRECATED_V2=y
+ # CONFIG_RELAY is not set
+ # CONFIG_NAMESPACES is not set
+ CONFIG_BLK_DEV_INITRD=y
+ CONFIG_INITRAMFS_SOURCE=""
+ CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+ CONFIG_SYSCTL=y
+ CONFIG_ANON_INODES=y
+ CONFIG_EMBEDDED=y
+ CONFIG_UID16=y
+ CONFIG_SYSCTL_SYSCALL=y
+ # CONFIG_KALLSYMS is not set
+ CONFIG_HOTPLUG=y
+ CONFIG_PRINTK=y
+ CONFIG_BUG=y
+ # CONFIG_ELF_CORE is not set
+ CONFIG_BASE_FULL=y
+ CONFIG_FUTEX=y
+ CONFIG_EPOLL=y
+ CONFIG_SIGNALFD=y
+ CONFIG_TIMERFD=y
+ CONFIG_EVENTFD=y
+ CONFIG_SHMEM=y
+ CONFIG_AIO=y
+ CONFIG_VM_EVENT_COUNTERS=y
+ CONFIG_COMPAT_BRK=y
+ CONFIG_SLAB=y
+ # CONFIG_SLUB is not set
+ # CONFIG_SLOB is not set
+ # CONFIG_PROFILING is not set
+ CONFIG_HAVE_OPROFILE=y
+ CONFIG_HAVE_KPROBES=y
+ CONFIG_HAVE_KRETPROBES=y
+ CONFIG_HAVE_CLK=y
+ CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+ CONFIG_SLABINFO=y
+ CONFIG_RT_MUTEXES=y
+ CONFIG_BASE_SMALL=0
+ CONFIG_MODULES=y
+ # CONFIG_MODULE_FORCE_LOAD is not set
+ CONFIG_MODULE_UNLOAD=y
+ CONFIG_MODULE_FORCE_UNLOAD=y
+ # CONFIG_MODVERSIONS is not set
+ # CONFIG_MODULE_SRCVERSION_ALL is not set
+ CONFIG_BLOCK=y
+ # CONFIG_LBD is not set
+ # CONFIG_BLK_DEV_IO_TRACE is not set
+ # CONFIG_BLK_DEV_BSG is not set
+ # CONFIG_BLK_DEV_INTEGRITY is not set
+ 
+ #
+ # IO Schedulers
+ #
+ CONFIG_IOSCHED_NOOP=y
+ # CONFIG_IOSCHED_AS is not set
+ # CONFIG_IOSCHED_DEADLINE is not set
+ CONFIG_IOSCHED_CFQ=y
+ # CONFIG_DEFAULT_AS is not set
+ # CONFIG_DEFAULT_DEADLINE is not set
+ CONFIG_DEFAULT_CFQ=y
+ # CONFIG_DEFAULT_NOOP is not set
+ CONFIG_DEFAULT_IOSCHED="cfq"
+ # CONFIG_FREEZER is not set
+ 
+ #
+ # System Type
+ #
+ # CONFIG_ARCH_AAEC2000 is not set
+ # CONFIG_ARCH_INTEGRATOR is not set
+ # CONFIG_ARCH_REALVIEW is not set
+ # CONFIG_ARCH_VERSATILE is not set
+ CONFIG_ARCH_AT91=y
+ # CONFIG_ARCH_CLPS711X is not set
+ # CONFIG_ARCH_EBSA110 is not set
+ # CONFIG_ARCH_EP93XX is not set
+ # CONFIG_ARCH_FOOTBRIDGE is not set
+ # CONFIG_ARCH_NETX is not set
+ # CONFIG_ARCH_H720X is not set
+ # CONFIG_ARCH_IMX is not set
+ # CONFIG_ARCH_IOP13XX is not set
+ # CONFIG_ARCH_IOP32X is not set
+ # CONFIG_ARCH_IOP33X is not set
+ # CONFIG_ARCH_IXP23XX is not set
+ # CONFIG_ARCH_IXP2000 is not set
+ # CONFIG_ARCH_IXP4XX is not set
+ # CONFIG_ARCH_L7200 is not set
+ # CONFIG_ARCH_KIRKWOOD is not set
+ # CONFIG_ARCH_KS8695 is not set
+ # CONFIG_ARCH_NS9XXX is not set
+ # CONFIG_ARCH_LOKI is not set
+ # CONFIG_ARCH_MV78XX0 is not set
+ # CONFIG_ARCH_MXC is not set
+ # CONFIG_ARCH_ORION5X is not set
+ # CONFIG_ARCH_PNX4008 is not set
+ # CONFIG_ARCH_PXA is not set
+ # CONFIG_ARCH_RPC is not set
+ # CONFIG_ARCH_SA1100 is not set
+ # CONFIG_ARCH_S3C2410 is not set
+ # CONFIG_ARCH_S3C64XX is not set
+ # CONFIG_ARCH_SHARK is not set
+ # CONFIG_ARCH_LH7A40X is not set
+ # CONFIG_ARCH_DAVINCI is not set
+ # CONFIG_ARCH_OMAP is not set
+ # CONFIG_ARCH_MSM is not set
+ # CONFIG_ARCH_W90X900 is not set
+ 
+ #
+ # Atmel AT91 System-on-Chip
+ #
+ CONFIG_ARCH_AT91RM9200=y
+ # CONFIG_ARCH_AT91SAM9260 is not set
+ # CONFIG_ARCH_AT91SAM9261 is not set
+ # CONFIG_ARCH_AT91SAM9263 is not set
+ # CONFIG_ARCH_AT91SAM9RL is not set
+ # CONFIG_ARCH_AT91SAM9G20 is not set
+ # CONFIG_ARCH_AT91CAP9 is not set
+ # CONFIG_ARCH_AT91X40 is not set
+ CONFIG_AT91_PMC_UNIT=y
+ 
+ #
+ # AT91RM9200 Board Type
+ #
+ # CONFIG_MACH_ONEARM is not set
+ # CONFIG_ARCH_AT91RM9200DK is not set
+ CONFIG_MACH_LIABARM=y
+ # CONFIG_MACH_LIABARM9200 is not set
+ # CONFIG_MACH_NANOLIAB is not set
+ CONFIG_MACH_LIABDIN=y
+ # CONFIG_LIAB_TDC_LIABDIN_ADDON is not set
+ CONFIG_LIAB_LIABDIN_ADDON=y
+ CONFIG_LIAB_ENABLE_UART0=y
+ CONFIG_LIAB_ENABLE_UART1=y
+ CONFIG_LIAB_ENABLE_UART2=y
+ CONFIG_LIAB_ENABLE_UART3=y
+ # CONFIG_MACH_AT91RM9200EK is not set
+ # CONFIG_MACH_CSB337 is not set
+ # CONFIG_MACH_CSB637 is not set
+ # CONFIG_MACH_CARMEVA is not set
+ # CONFIG_MACH_ATEB9200 is not set
+ # CONFIG_MACH_KB9200 is not set
+ # CONFIG_MACH_PICOTUX2XX is not set
+ # CONFIG_MACH_KAFA is not set
+ # CONFIG_MACH_ECBAT91 is not set
+ # CONFIG_MACH_YL9200 is not set
+ 
+ #
+ # AT91 Board Options
+ #
+ CONFIG_ARCH_LIABAT91RM9200_HASMII=y
+ CONFIG_ARCH_LIABAT91RM9200_SELECTDBGUANDUART0=y
+ CONFIG_I2C_AT91_GPIO=y
+ 
+ #
+ # AT91 Feature Selections
+ #
+ # CONFIG_AT91_PROGRAMMABLE_CLOCKS is not set
+ CONFIG_AT91_TIMER_HZ=128
+ CONFIG_AT91_EARLY_DBGU=y
+ # CONFIG_AT91_EARLY_USART0 is not set
+ # CONFIG_AT91_EARLY_USART1 is not set
+ # CONFIG_AT91_EARLY_USART2 is not set
+ # CONFIG_AT91_EARLY_USART3 is not set
+ # CONFIG_AT91_EARLY_USART4 is not set
+ # CONFIG_AT91_EARLY_USART5 is not set
+ 
+ #
+ # Processor Type
+ #
+ CONFIG_CPU_32=y
+ CONFIG_CPU_ARM920T=y
+ CONFIG_CPU_32v4T=y
+ CONFIG_CPU_ABRT_EV4T=y
+ CONFIG_CPU_PABRT_NOIFAR=y
+ CONFIG_CPU_CACHE_V4WT=y
+ CONFIG_CPU_CACHE_VIVT=y
+ CONFIG_CPU_COPY_V4WB=y
+ CONFIG_CPU_TLB_V4WBI=y
+ CONFIG_CPU_CP15=y
+ CONFIG_CPU_CP15_MMU=y
+ 
+ #
+ # Processor Features
+ #
+ CONFIG_ARM_THUMB=y
+ # CONFIG_CPU_ICACHE_DISABLE is not set
+ # CONFIG_CPU_DCACHE_DISABLE is not set
+ # CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+ # CONFIG_OUTER_CACHE is not set
+ 
+ #
+ # Bus support
+ #
+ # CONFIG_PCI_SYSCALL is not set
+ # CONFIG_ARCH_SUPPORTS_MSI is not set
+ # CONFIG_PCCARD is not set
+ 
+ #
+ # Kernel Features
+ #
+ # CONFIG_NO_HZ is not set
+ # CONFIG_HIGH_RES_TIMERS is not set
+ CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+ CONFIG_VMSPLIT_3G=y
+ # CONFIG_VMSPLIT_2G is not set
+ # CONFIG_VMSPLIT_1G is not set
+ CONFIG_PAGE_OFFSET=0xC0000000
+ CONFIG_PREEMPT=y
+ CONFIG_HZ=128
+ # CONFIG_AEABI is not set
+ CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+ # CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+ # CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+ CONFIG_SELECT_MEMORY_MODEL=y
+ CONFIG_FLATMEM_MANUAL=y
+ # CONFIG_DISCONTIGMEM_MANUAL is not set
+ # CONFIG_SPARSEMEM_MANUAL is not set
+ CONFIG_FLATMEM=y
+ CONFIG_FLAT_NODE_MEM_MAP=y
+ CONFIG_PAGEFLAGS_EXTENDED=y
+ CONFIG_SPLIT_PTLOCK_CPUS=4096
+ # CONFIG_PHYS_ADDR_T_64BIT is not set
+ CONFIG_ZONE_DMA_FLAG=0
+ CONFIG_VIRT_TO_BUS=y
+ CONFIG_UNEVICTABLE_LRU=y
+ CONFIG_LEDS=y
+ CONFIG_LEDS_CPU=y
+ CONFIG_ALIGNMENT_TRAP=y
+ 
+ #
+ # Boot options
+ #
+ CONFIG_ZBOOT_ROM_TEXT=0x0
+ CONFIG_ZBOOT_ROM_BSS=0x0
+ CONFIG_CMDLINE=""
+ # CONFIG_XIP_KERNEL is not set
+ # CONFIG_KEXEC is not set
+ 
+ #
+ # CPU Power Management
+ #
+ # CONFIG_CPU_IDLE is not set
+ 
+ #
+ # Floating point emulation
+ #
+ 
+ #
+ # At least one emulation must be selected
+ #
+ CONFIG_FPE_NWFPE=y
+ # CONFIG_FPE_NWFPE_XP is not set
+ # CONFIG_FPE_FASTFPE is not set
+ 
+ #
+ # Userspace binary formats
+ #
+ CONFIG_BINFMT_ELF=y
+ CONFIG_HAVE_AOUT=y
+ # CONFIG_BINFMT_AOUT is not set
+ # CONFIG_BINFMT_MISC is not set
+ # CONFIG_ARTHUR is not set
+ 
+ #
+ # Power management options
+ #
+ # CONFIG_PM is not set
+ CONFIG_ARCH_SUSPEND_POSSIBLE=y
+ CONFIG_NET=y
+ 
+ #
+ # Networking options
+ #
+ CONFIG_COMPAT_NET_DEV_OPS=y
+ CONFIG_PACKET=y
+ CONFIG_PACKET_MMAP=y
+ CONFIG_UNIX=y
+ # CONFIG_NET_KEY is not set
+ CONFIG_INET=y
+ CONFIG_IP_MULTICAST=y
+ CONFIG_IP_ADVANCED_ROUTER=y
+ CONFIG_ASK_IP_FIB_HASH=y
+ # CONFIG_IP_FIB_TRIE is not set
+ CONFIG_IP_FIB_HASH=y
+ CONFIG_IP_MULTIPLE_TABLES=y
+ CONFIG_IP_ROUTE_MULTIPATH=y
+ CONFIG_IP_ROUTE_VERBOSE=y
+ CONFIG_IP_PNP=y
+ CONFIG_IP_PNP_DHCP=y
+ CONFIG_IP_PNP_BOOTP=y
+ CONFIG_IP_PNP_RARP=y
+ # CONFIG_NET_IPIP is not set
+ # CONFIG_NET_IPGRE is not set
+ CONFIG_IP_MROUTE=y
+ CONFIG_IP_PIMSM_V1=y
+ # CONFIG_IP_PIMSM_V2 is not set
+ # CONFIG_ARPD is not set
+ CONFIG_SYN_COOKIES=y
+ # CONFIG_INET_AH is not set
+ # CONFIG_INET_ESP is not set
+ # CONFIG_INET_IPCOMP is not set
+ # CONFIG_INET_XFRM_TUNNEL is not set
+ # CONFIG_INET_TUNNEL is not set
+ # CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+ # CONFIG_INET_XFRM_MODE_TUNNEL is not set
+ # CONFIG_INET_XFRM_MODE_BEET is not set
+ # CONFIG_INET_LRO is not set
+ # CONFIG_INET_DIAG is not set
+ # CONFIG_TCP_CONG_ADVANCED is not set
+ CONFIG_TCP_CONG_CUBIC=y
+ CONFIG_DEFAULT_TCP_CONG="cubic"
+ # CONFIG_TCP_MD5SIG is not set
+ # CONFIG_IPV6 is not set
+ # CONFIG_NETWORK_SECMARK is not set
+ # CONFIG_NETFILTER is not set
+ # CONFIG_IP_DCCP is not set
+ # CONFIG_IP_SCTP is not set
+ # CONFIG_TIPC is not set
+ # CONFIG_ATM is not set
+ # CONFIG_BRIDGE is not set
+ # CONFIG_NET_DSA is not set
+ # CONFIG_VLAN_8021Q is not set
+ # CONFIG_DECNET is not set
+ # CONFIG_LLC2 is not set
+ # CONFIG_IPX is not set
+ # CONFIG_ATALK is not set
+ # CONFIG_X25 is not set
+ # CONFIG_LAPB is not set
+ # CONFIG_ECONET is not set
+ # CONFIG_WAN_ROUTER is not set
+ # CONFIG_NET_SCHED is not set
+ # CONFIG_DCB is not set
+ 
+ #
+ # Network testing
+ #
+ # CONFIG_NET_PKTGEN is not set
+ # CONFIG_HAMRADIO is not set
+ # CONFIG_CAN is not set
+ # CONFIG_IRDA is not set
+ # CONFIG_BT is not set
+ # CONFIG_AF_RXRPC is not set
+ # CONFIG_PHONET is not set
+ CONFIG_FIB_RULES=y
+ # CONFIG_WIRELESS is not set
+ # CONFIG_WIMAX is not set
+ # CONFIG_RFKILL is not set
+ # CONFIG_NET_9P is not set
+ 
+ #
+ # Device Drivers
+ #
+ 
+ #
+ # Generic Driver Options
+ #
+ CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+ CONFIG_STANDALONE=y
+ CONFIG_PREVENT_FIRMWARE_BUILD=y
+ CONFIG_FW_LOADER=y
+ # CONFIG_FIRMWARE_IN_KERNEL is not set
+ CONFIG_EXTRA_FIRMWARE=""
+ # CONFIG_DEBUG_DRIVER is not set
+ # CONFIG_DEBUG_DEVRES is not set
+ # CONFIG_SYS_HYPERVISOR is not set
+ # CONFIG_CONNECTOR is not set
+ CONFIG_MTD=y
+ # CONFIG_MTD_DEBUG is not set
+ # CONFIG_MTD_CONCAT is not set
+ CONFIG_MTD_PARTITIONS=y
+ # CONFIG_MTD_TESTS is not set
+ # CONFIG_MTD_REDBOOT_PARTS is not set
+ # CONFIG_MTD_CMDLINE_PARTS is not set
+ # CONFIG_MTD_AFS_PARTS is not set
+ # CONFIG_MTD_AR7_PARTS is not set
+ 
+ #
+ # User Modules And Translation Layers
+ #
+ CONFIG_MTD_CHAR=y
+ CONFIG_MTD_BLKDEVS=y
+ CONFIG_MTD_BLOCK=y
+ # CONFIG_FTL is not set
+ # CONFIG_NFTL is not set
+ # CONFIG_INFTL is not set
+ # CONFIG_RFD_FTL is not set
+ # CONFIG_SSFDC is not set
+ # CONFIG_MTD_OOPS is not set
+ 
+ #
+ # RAM/ROM/Flash chip drivers
+ #
+ CONFIG_MTD_CFI=y
+ # CONFIG_MTD_JEDECPROBE is not set
+ CONFIG_MTD_GEN_PROBE=y
+ # CONFIG_MTD_CFI_ADV_OPTIONS is not set
+ CONFIG_MTD_MAP_BANK_WIDTH_1=y
+ CONFIG_MTD_MAP_BANK_WIDTH_2=y
+ CONFIG_MTD_MAP_BANK_WIDTH_4=y
+ # CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+ # CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+ # CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+ CONFIG_MTD_CFI_I1=y
+ CONFIG_MTD_CFI_I2=y
+ # CONFIG_MTD_CFI_I4 is not set
+ # CONFIG_MTD_CFI_I8 is not set
+ CONFIG_MTD_CFI_INTELEXT=y
+ CONFIG_MTD_CFI_AMDSTD=y
+ # CONFIG_MTD_CFI_STAA is not set
+ CONFIG_MTD_CFI_UTIL=y
+ # CONFIG_MTD_RAM is not set
+ # CONFIG_MTD_ROM is not set
+ # CONFIG_MTD_ABSENT is not set
+ 
+ #
+ # Mapping drivers for chip access
+ #
+ # CONFIG_MTD_COMPLEX_MAPPINGS is not set
+ # CONFIG_MTD_PHYSMAP is not set
+ # CONFIG_MTD_ARM_INTEGRATOR is not set
+ CONFIG_MTD_LIABARM=y
+ CONFIG_MTD_LIAB_FLASH_SIZE=16384
+ CONFIG_MTD_LIAB_NOFLASH=1
+ CONFIG_MTD_LIABARM_BOOTSIZE=128
+ CONFIG_MTD_LIABARM_KERNELSIZE=1536
+ CONFIG_MTD_LIABARM_ROOTSIZE=6144
+ CONFIG_MTD_LIABARM_PARAMSIZE=128
+ CONFIG_MTD_LIABARM_JFFS2SIZE=8448
+ # CONFIG_MTD_PLATRAM is not set
+ 
+ #
+ # Self-contained MTD device drivers
+ #
+ # CONFIG_MTD_DATAFLASH is not set
+ # CONFIG_MTD_M25P80 is not set
+ # CONFIG_MTD_SLRAM is not set
+ # CONFIG_MTD_PHRAM is not set
+ # CONFIG_MTD_MTDRAM is not set
+ # CONFIG_MTD_BLOCK2MTD is not set
+ 
+ #
+ # Disk-On-Chip Device Drivers
+ #
+ # CONFIG_MTD_DOC2000 is not set
+ # CONFIG_MTD_DOC2001 is not set
+ # CONFIG_MTD_DOC2001PLUS is not set
+ # CONFIG_MTD_NAND is not set
+ # CONFIG_MTD_ONENAND is not set
+ 
+ #
+ # LPDDR flash memory drivers
+ #
+ # CONFIG_MTD_LPDDR is not set
+ 
+ #
+ # UBI - Unsorted block images
+ #
+ # CONFIG_MTD_UBI is not set
+ # CONFIG_PARPORT is not set
+ CONFIG_BLK_DEV=y
+ # CONFIG_BLK_DEV_COW_COMMON is not set
+ # CONFIG_BLK_DEV_LOOP is not set
+ # CONFIG_BLK_DEV_NBD is not set
+ # CONFIG_BLK_DEV_UB is not set
+ CONFIG_BLK_DEV_RAM=y
+ CONFIG_BLK_DEV_RAM_COUNT=16
+ CONFIG_BLK_DEV_RAM_SIZE=32768
+ # CONFIG_BLK_DEV_XIP is not set
+ # CONFIG_CDROM_PKTCDVD is not set
+ # CONFIG_ATA_OVER_ETH is not set
+ CONFIG_MISC_DEVICES=y
+ # CONFIG_ATMEL_TCLIB is not set
+ CONFIG_AT91_PWM=y
+ # CONFIG_ICS932S401 is not set
+ # CONFIG_ATMEL_SSC is not set
+ # CONFIG_ENCLOSURE_SERVICES is not set
+ # CONFIG_C2PORT is not set
+ 
+ #
+ # EEPROM support
+ #
+ # CONFIG_EEPROM_AT24 is not set
+ # CONFIG_EEPROM_AT25 is not set
+ # CONFIG_EEPROM_LEGACY is not set
+ # CONFIG_EEPROM_93CX6 is not set
+ CONFIG_HAVE_IDE=y
+ # CONFIG_IDE is not set
+ 
+ #
+ # SCSI device support
+ #
+ # CONFIG_RAID_ATTRS is not set
+ CONFIG_SCSI=m
+ CONFIG_SCSI_DMA=y
+ # CONFIG_SCSI_TGT is not set
+ # CONFIG_SCSI_NETLINK is not set
+ CONFIG_SCSI_PROC_FS=y
+ 
+ #
+ # SCSI support type (disk, tape, CD-ROM)
+ #
+ CONFIG_BLK_DEV_SD=m
+ # CONFIG_CHR_DEV_ST is not set
+ # CONFIG_CHR_DEV_OSST is not set
+ # CONFIG_BLK_DEV_SR is not set
+ # CONFIG_CHR_DEV_SG is not set
+ # CONFIG_CHR_DEV_SCH is not set
+ 
+ #
+ # Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+ #
+ CONFIG_SCSI_MULTI_LUN=y
+ # CONFIG_SCSI_CONSTANTS is not set
+ CONFIG_SCSI_LOGGING=y
+ # CONFIG_SCSI_SCAN_ASYNC is not set
+ CONFIG_SCSI_WAIT_SCAN=m
+ 
+ #
+ # SCSI Transports
+ #
+ # CONFIG_SCSI_SPI_ATTRS is not set
+ # CONFIG_SCSI_FC_ATTRS is not set
+ # CONFIG_SCSI_ISCSI_ATTRS is not set
+ # CONFIG_SCSI_SAS_LIBSAS is not set
+ # CONFIG_SCSI_SRP_ATTRS is not set
+ CONFIG_SCSI_LOWLEVEL=y
+ # CONFIG_ISCSI_TCP is not set
+ # CONFIG_LIBFC is not set
+ # CONFIG_SCSI_DEBUG is not set
+ # CONFIG_SCSI_DH is not set
+ # CONFIG_ATA is not set
+ # CONFIG_MD is not set
+ CONFIG_NETDEVICES=y
+ # CONFIG_DUMMY is not set
+ # CONFIG_BONDING is not set
+ # CONFIG_MACVLAN is not set
+ # CONFIG_EQUALIZER is not set
+ CONFIG_TUN=y
+ # CONFIG_VETH is not set
+ # CONFIG_PHYLIB is not set
+ CONFIG_NET_ETHERNET=y
+ CONFIG_MII=y
+ CONFIG_ARM_AT91_ETHER=y
+ # CONFIG_AX88796 is not set
+ # CONFIG_SMC91X is not set
+ # CONFIG_DM9000 is not set
+ # CONFIG_ENC28J60 is not set
+ # CONFIG_SMC911X is not set
+ # CONFIG_SMSC911X is not set
+ # CONFIG_DNET is not set
+ # CONFIG_IBM_NEW_EMAC_ZMII is not set
+ # CONFIG_IBM_NEW_EMAC_RGMII is not set
+ # CONFIG_IBM_NEW_EMAC_TAH is not set
+ # CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+ # CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+ # CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+ # CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+ # CONFIG_B44 is not set
+ # CONFIG_NETDEV_1000 is not set
+ # CONFIG_NETDEV_10000 is not set
+ 
+ #
+ # Wireless LAN
+ #
+ # CONFIG_WLAN_PRE80211 is not set
+ # CONFIG_WLAN_80211 is not set
+ # CONFIG_IWLWIFI_LEDS is not set
+ 
+ #
+ # Enable WiMAX (Networking options) to see the WiMAX drivers
+ #
+ 
+ #
+ # USB Network Adapters
+ #
+ # CONFIG_USB_CATC is not set
+ # CONFIG_USB_KAWETH is not set
+ # CONFIG_USB_PEGASUS is not set
+ # CONFIG_USB_RTL8150 is not set
+ # CONFIG_USB_USBNET is not set
+ # CONFIG_WAN is not set
+ CONFIG_PPP=y
+ # CONFIG_PPP_MULTILINK is not set
+ CONFIG_PPP_FILTER=y
+ CONFIG_PPP_ASYNC=y
+ # CONFIG_PPP_SYNC_TTY is not set
+ CONFIG_PPP_DEFLATE=y
+ CONFIG_PPP_BSDCOMP=y
+ CONFIG_PPP_MPPE=y
+ CONFIG_PPPOE=y
+ # CONFIG_PPPOL2TP is not set
+ # CONFIG_SLIP is not set
+ CONFIG_SLHC=y
+ # CONFIG_NETCONSOLE is not set
+ # CONFIG_NETPOLL is not set
+ # CONFIG_NET_POLL_CONTROLLER is not set
+ # CONFIG_ISDN is not set
+ 
+ #
+ # Input device support
+ #
+ CONFIG_INPUT=y
+ # CONFIG_INPUT_FF_MEMLESS is not set
+ # CONFIG_INPUT_POLLDEV is not set
+ 
+ #
+ # Userland interfaces
+ #
+ # CONFIG_INPUT_MOUSEDEV is not set
+ # CONFIG_INPUT_JOYDEV is not set
+ CONFIG_INPUT_EVDEV=y
+ # CONFIG_INPUT_EVBUG is not set
+ 
+ #
+ # Input Device Drivers
+ #
+ CONFIG_INPUT_KEYBOARD=y
+ # CONFIG_KEYBOARD_ATKBD is not set
+ # CONFIG_KEYBOARD_SUNKBD is not set
+ # CONFIG_KEYBOARD_LKKBD is not set
+ # CONFIG_KEYBOARD_XTKBD is not set
+ # CONFIG_KEYBOARD_NEWTON is not set
+ # CONFIG_KEYBOARD_STOWAWAY is not set
+ CONFIG_KEYBOARD_GPIO=y
+ # CONFIG_INPUT_MOUSE is not set
+ # CONFIG_INPUT_JOYSTICK is not set
+ # CONFIG_INPUT_TABLET is not set
+ # CONFIG_INPUT_TOUCHSCREEN is not set
+ # CONFIG_INPUT_MISC is not set
+ 
+ #
+ # Hardware I/O ports
+ #
+ # CONFIG_SERIO is not set
+ # CONFIG_GAMEPORT is not set
+ 
+ #
+ # Character devices
+ #
+ # CONFIG_VT is not set
+ CONFIG_DEVKMEM=y
+ # CONFIG_SERIAL_NONSTANDARD is not set
+ 
+ #
+ # Serial drivers
+ #
+ # CONFIG_SERIAL_8250 is not set
+ 
+ #
+ # Non-8250 serial port support
+ #
+ CONFIG_SERIAL_ATMEL=y
+ CONFIG_SERIAL_ATMEL_CONSOLE=y
+ CONFIG_SERIAL_ATMEL_PDC=y
+ # CONFIG_SERIAL_ATMEL_TTYAT is not set
+ CONFIG_SERIAL_CORE=y
+ CONFIG_SERIAL_CORE_CONSOLE=y
+ CONFIG_UNIX98_PTYS=y
+ # CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+ CONFIG_LEGACY_PTYS=y
+ CONFIG_LEGACY_PTY_COUNT=256
+ # CONFIG_IPMI_HANDLER is not set
+ CONFIG_HW_RANDOM=y
+ # CONFIG_R3964 is not set
+ # CONFIG_RAW_DRIVER is not set
+ # CONFIG_TCG_TPM is not set
+ CONFIG_I2C=y
+ CONFIG_I2C_BOARDINFO=y
+ CONFIG_I2C_CHARDEV=y
+ CONFIG_I2C_HELPER_AUTO=y
+ CONFIG_I2C_ALGOBIT=y
+ 
+ #
+ # I2C Hardware Bus support
+ #
+ 
+ #
+ # I2C system bus drivers (mostly embedded / system-on-chip)
+ #
+ CONFIG_I2C_GPIO=y
+ # CONFIG_I2C_OCORES is not set
+ # CONFIG_I2C_SIMTEC is not set
+ 
+ #
+ # External I2C/SMBus adapter drivers
+ #
+ # CONFIG_I2C_PARPORT_LIGHT is not set
+ # CONFIG_I2C_TAOS_EVM is not set
+ # CONFIG_I2C_TINY_USB is not set
+ 
+ #
+ # Other I2C/SMBus bus drivers
+ #
+ # CONFIG_I2C_PCA_PLATFORM is not set
+ # CONFIG_I2C_STUB is not set
+ 
+ #
+ # Miscellaneous I2C Chip support
+ #
+ # CONFIG_DS1682 is not set
+ # CONFIG_SENSORS_PCF8574 is not set
+ # CONFIG_PCF8575 is not set
+ # CONFIG_SENSORS_PCA9539 is not set
+ # CONFIG_SENSORS_PCF8591 is not set
+ # CONFIG_SENSORS_MAX6875 is not set
+ # CONFIG_SENSORS_TSL2550 is not set
+ # CONFIG_I2C_DEBUG_CORE is not set
+ # CONFIG_I2C_DEBUG_ALGO is not set
+ # CONFIG_I2C_DEBUG_BUS is not set
+ # CONFIG_I2C_DEBUG_CHIP is not set
+ CONFIG_SPI=y
+ # CONFIG_SPI_DEBUG is not set
+ CONFIG_SPI_MASTER=y
+ 
+ #
+ # SPI Master Controller Drivers
+ #
+ CONFIG_SPI_ATMEL=y
+ # CONFIG_SPI_BITBANG is not set
+ # CONFIG_SPI_GPIO is not set
+ 
+ #
+ # SPI Protocol Masters
+ #
+ # CONFIG_SPI_SPIDEV is not set
+ # CONFIG_SPI_TLE62X0 is not set
+ # CONFIG_W1 is not set
+ # CONFIG_POWER_SUPPLY is not set
+ # CONFIG_HWMON is not set
+ # CONFIG_THERMAL is not set
+ # CONFIG_THERMAL_HWMON is not set
+ CONFIG_WATCHDOG=y
+ # CONFIG_WATCHDOG_NOWAYOUT is not set
+ 
+ #
+ # Watchdog Device Drivers
+ #
+ # CONFIG_SOFT_WATCHDOG is not set
+ CONFIG_AT91RM9200_WATCHDOG=m
+ 
+ #
+ # USB-based Watchdog Cards
+ #
+ # CONFIG_USBPCWATCHDOG is not set
+ CONFIG_SSB_POSSIBLE=y
+ 
+ #
+ # Sonics Silicon Backplane
+ #
+ # CONFIG_SSB is not set
+ 
+ #
+ # Multifunction device drivers
+ #
+ # CONFIG_MFD_CORE is not set
+ # CONFIG_MFD_SM501 is not set
+ # CONFIG_HTC_PASIC3 is not set
+ # CONFIG_TWL4030_CORE is not set
+ # CONFIG_MFD_TMIO is not set
+ # CONFIG_MFD_T7L66XB is not set
+ # CONFIG_MFD_TC6387XB is not set
+ # CONFIG_PMIC_DA903X is not set
+ # CONFIG_MFD_WM8400 is not set
+ # CONFIG_MFD_WM8350_I2C is not set
+ # CONFIG_MFD_PCF50633 is not set
+ 
+ #
+ # Multimedia devices
+ #
+ 
+ #
+ # Multimedia core support
+ #
+ # CONFIG_VIDEO_DEV is not set
+ # CONFIG_DVB_CORE is not set
+ # CONFIG_VIDEO_MEDIA is not set
+ 
+ #
+ # Multimedia drivers
+ #
+ # CONFIG_DAB is not set
+ 
+ #
+ # Graphics support
+ #
+ # CONFIG_VGASTATE is not set
+ # CONFIG_VIDEO_OUTPUT_CONTROL is not set
+ # CONFIG_FB is not set
+ # CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+ 
+ #
+ # Display device support
+ #
+ # CONFIG_DISPLAY_SUPPORT is not set
+ # CONFIG_SOUND is not set
+ CONFIG_HID_SUPPORT=y
+ CONFIG_HID=y
+ # CONFIG_HID_DEBUG is not set
+ # CONFIG_HIDRAW is not set
+ 
+ #
+ # USB Input Devices
+ #
+ # CONFIG_USB_HID is not set
+ # CONFIG_HID_PID is not set
+ 
+ #
+ # USB HID Boot Protocol drivers
+ #
+ # CONFIG_USB_KBD is not set
+ # CONFIG_USB_MOUSE is not set
+ 
+ #
+ # Special HID drivers
+ #
+ CONFIG_HID_COMPAT=y
+ CONFIG_USB_SUPPORT=y
+ CONFIG_USB_ARCH_HAS_HCD=y
+ CONFIG_USB_ARCH_HAS_OHCI=y
+ # CONFIG_USB_ARCH_HAS_EHCI is not set
+ CONFIG_USB=y
+ # CONFIG_USB_DEBUG is not set
+ # CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+ 
+ #
+ # Miscellaneous USB options
+ #
+ CONFIG_USB_DEVICEFS=y
+ CONFIG_USB_DEVICE_CLASS=y
+ # CONFIG_USB_DYNAMIC_MINORS is not set
+ # CONFIG_USB_OTG is not set
+ # CONFIG_USB_OTG_WHITELIST is not set
+ # CONFIG_USB_OTG_BLACKLIST_HUB is not set
+ CONFIG_USB_MON=y
+ # CONFIG_USB_WUSB is not set
+ # CONFIG_USB_WUSB_CBAF is not set
+ 
+ #
+ # USB Host Controller Drivers
+ #
+ # CONFIG_USB_C67X00_HCD is not set
+ # CONFIG_USB_OXU210HP_HCD is not set
+ # CONFIG_USB_ISP116X_HCD is not set
+ CONFIG_USB_OHCI_HCD=y
+ # CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+ # CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+ CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+ # CONFIG_USB_SL811_HCD is not set
+ # CONFIG_USB_R8A66597_HCD is not set
+ # CONFIG_USB_HWA_HCD is not set
+ # CONFIG_USB_MUSB_HDRC is not set
+ 
+ #
+ # USB Device Class drivers
+ #
+ CONFIG_USB_ACM=m
+ # CONFIG_USB_PRINTER is not set
+ # CONFIG_USB_WDM is not set
+ # CONFIG_USB_TMC is not set
+ 
+ #
+ # NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
+ #
+ 
+ #
+ # see USB_STORAGE Help for more information
+ #
+ CONFIG_USB_STORAGE=m
+ # CONFIG_USB_STORAGE_DEBUG is not set
+ # CONFIG_USB_STORAGE_DATAFAB is not set
+ # CONFIG_USB_STORAGE_FREECOM is not set
+ # CONFIG_USB_STORAGE_ISD200 is not set
+ # CONFIG_USB_STORAGE_USBAT is not set
+ # CONFIG_USB_STORAGE_SDDR09 is not set
+ # CONFIG_USB_STORAGE_SDDR55 is not set
+ # CONFIG_USB_STORAGE_JUMPSHOT is not set
+ # CONFIG_USB_STORAGE_ALAUDA is not set
+ # CONFIG_USB_STORAGE_ONETOUCH is not set
+ # CONFIG_USB_STORAGE_KARMA is not set
+ # CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+ # CONFIG_USB_LIBUSUAL is not set
+ 
+ #
+ # USB Imaging devices
+ #
+ # CONFIG_USB_MDC800 is not set
+ # CONFIG_USB_MICROTEK is not set
+ 
+ #
+ # USB port drivers
+ #
+ CONFIG_USB_SERIAL=m
+ # CONFIG_USB_EZUSB is not set
+ CONFIG_USB_SERIAL_GENERIC=y
+ # CONFIG_USB_SERIAL_AIRCABLE is not set
+ # CONFIG_USB_SERIAL_ARK3116 is not set
+ # CONFIG_USB_SERIAL_BELKIN is not set
+ # CONFIG_USB_SERIAL_CH341 is not set
+ # CONFIG_USB_SERIAL_WHITEHEAT is not set
+ # CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+ # CONFIG_USB_SERIAL_CP2101 is not set
+ # CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+ # CONFIG_USB_SERIAL_EMPEG is not set
+ # CONFIG_USB_SERIAL_FTDI_SIO is not set
+ # CONFIG_USB_SERIAL_FUNSOFT is not set
+ # CONFIG_USB_SERIAL_VISOR is not set
+ # CONFIG_USB_SERIAL_IPAQ is not set
+ # CONFIG_USB_SERIAL_IR is not set
+ # CONFIG_USB_SERIAL_EDGEPORT is not set
+ # CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+ # CONFIG_USB_SERIAL_GARMIN is not set
+ # CONFIG_USB_SERIAL_IPW is not set
+ # CONFIG_USB_SERIAL_IUU is not set
+ # CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+ # CONFIG_USB_SERIAL_KEYSPAN is not set
+ # CONFIG_USB_SERIAL_KLSI is not set
+ # CONFIG_USB_SERIAL_KOBIL_SCT is not set
+ # CONFIG_USB_SERIAL_MCT_U232 is not set
+ # CONFIG_USB_SERIAL_MOS7720 is not set
+ # CONFIG_USB_SERIAL_MOS7840 is not set
+ # CONFIG_USB_SERIAL_MOTOROLA is not set
+ # CONFIG_USB_SERIAL_NAVMAN is not set
+ CONFIG_USB_SERIAL_PL2303=m
+ # CONFIG_USB_SERIAL_OTI6858 is not set
+ # CONFIG_USB_SERIAL_SPCP8X5 is not set
+ # CONFIG_USB_SERIAL_HP4X is not set
+ # CONFIG_USB_SERIAL_SAFE is not set
+ # CONFIG_USB_SERIAL_SIEMENS_MPI is not set
+ # CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+ # CONFIG_USB_SERIAL_TI is not set
+ # CONFIG_USB_SERIAL_CYBERJACK is not set
+ # CONFIG_USB_SERIAL_XIRCOM is not set
+ # CONFIG_USB_SERIAL_OPTION is not set
+ # CONFIG_USB_SERIAL_OMNINET is not set
+ # CONFIG_USB_SERIAL_OPTICON is not set
+ # CONFIG_USB_SERIAL_DEBUG is not set
+ 
+ #
+ # USB Miscellaneous drivers
+ #
+ # CONFIG_USB_EMI62 is not set
+ # CONFIG_USB_EMI26 is not set
+ # CONFIG_USB_ADUTUX is not set
+ # CONFIG_USB_SEVSEG is not set
+ # CONFIG_USB_RIO500 is not set
+ # CONFIG_USB_LEGOTOWER is not set
+ # CONFIG_USB_LCD is not set
+ # CONFIG_USB_BERRY_CHARGE is not set
+ # CONFIG_USB_LED is not set
+ # CONFIG_USB_CYPRESS_CY7C63 is not set
+ # CONFIG_USB_CYTHERM is not set
+ # CONFIG_USB_PHIDGET is not set
+ # CONFIG_USB_IDMOUSE is not set
+ # CONFIG_USB_FTDI_ELAN is not set
+ # CONFIG_USB_APPLEDISPLAY is not set
+ # CONFIG_USB_LD is not set
+ # CONFIG_USB_TRANCEVIBRATOR is not set
+ # CONFIG_USB_IOWARRIOR is not set
+ # CONFIG_USB_TEST is not set
+ # CONFIG_USB_ISIGHTFW is not set
+ # CONFIG_USB_VST is not set
+ # CONFIG_USB_GADGET is not set
+ 
+ #
+ # OTG and related infrastructure
+ #
+ # CONFIG_USB_GPIO_VBUS is not set
+ # CONFIG_MMC is not set
+ # CONFIG_MEMSTICK is not set
+ # CONFIG_ACCESSIBILITY is not set
+ CONFIG_NEW_LEDS=y
+ CONFIG_LEDS_CLASS=y
+ 
+ #
+ # LED drivers
+ #
+ # CONFIG_LEDS_ATMEL_PWM is not set
+ CONFIG_LEDS_LIABDIN_ADDON=y
+ # CONFIG_LEDS_PCA9532 is not set
+ CONFIG_LEDS_GPIO=y
+ # CONFIG_LEDS_PCA955X is not set
+ 
+ #
+ # LED Triggers
+ #
+ CONFIG_LEDS_TRIGGERS=y
+ CONFIG_LEDS_TRIGGER_TIMER=y
+ CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+ # CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+ # CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+ CONFIG_RTC_LIB=y
+ CONFIG_RTC_CLASS=y
+ CONFIG_RTC_HCTOSYS=y
+ CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+ # CONFIG_RTC_DEBUG is not set
+ 
+ #
+ # RTC interfaces
+ #
+ CONFIG_RTC_INTF_SYSFS=y
+ CONFIG_RTC_INTF_PROC=y
+ CONFIG_RTC_INTF_DEV=y
+ CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+ # CONFIG_RTC_DRV_TEST is not set
+ 
+ #
+ # I2C RTC drivers
+ #
+ CONFIG_RTC_DRV_DS1307=y
+ # CONFIG_RTC_DRV_DS1374 is not set
+ # CONFIG_RTC_DRV_DS1672 is not set
+ # CONFIG_RTC_DRV_MAX6900 is not set
+ # CONFIG_RTC_DRV_RS5C372 is not set
+ # CONFIG_RTC_DRV_ISL1208 is not set
+ # CONFIG_RTC_DRV_X1205 is not set
+ # CONFIG_RTC_DRV_PCF8563 is not set
+ # CONFIG_RTC_DRV_PCF8583 is not set
+ # CONFIG_RTC_DRV_M41T80 is not set
+ # CONFIG_RTC_DRV_S35390A is not set
+ # CONFIG_RTC_DRV_FM3130 is not set
+ # CONFIG_RTC_DRV_RX8581 is not set
+ 
+ #
+ # SPI RTC drivers
+ #
+ # CONFIG_RTC_DRV_M41T94 is not set
+ # CONFIG_RTC_DRV_DS1305 is not set
+ # CONFIG_RTC_DRV_DS1390 is not set
+ # CONFIG_RTC_DRV_MAX6902 is not set
+ # CONFIG_RTC_DRV_R9701 is not set
+ # CONFIG_RTC_DRV_RS5C348 is not set
+ # CONFIG_RTC_DRV_DS3234 is not set
+ 
+ #
+ # Platform RTC drivers
+ #
+ # CONFIG_RTC_DRV_CMOS is not set
+ # CONFIG_RTC_DRV_DS1286 is not set
+ # CONFIG_RTC_DRV_DS1511 is not set
+ # CONFIG_RTC_DRV_DS1553 is not set
+ # CONFIG_RTC_DRV_DS1742 is not set
+ # CONFIG_RTC_DRV_STK17TA8 is not set
+ # CONFIG_RTC_DRV_M48T86 is not set
+ # CONFIG_RTC_DRV_M48T35 is not set
+ # CONFIG_RTC_DRV_M48T59 is not set
+ # CONFIG_RTC_DRV_BQ4802 is not set
+ # CONFIG_RTC_DRV_V3020 is not set
+ 
+ #
+ # on-CPU RTC drivers
+ #
+ # CONFIG_RTC_DRV_AT91RM9200 is not set
+ # CONFIG_DMADEVICES is not set
+ # CONFIG_REGULATOR is not set
+ # CONFIG_UIO is not set
+ # CONFIG_STAGING is not set
+ 
+ #
+ # File systems
+ #
+ CONFIG_EXT2_FS=y
+ CONFIG_EXT2_FS_XATTR=y
+ CONFIG_EXT2_FS_POSIX_ACL=y
+ CONFIG_EXT2_FS_SECURITY=y
+ # CONFIG_EXT2_FS_XIP is not set
+ CONFIG_EXT3_FS=y
+ CONFIG_EXT3_FS_XATTR=y
+ CONFIG_EXT3_FS_POSIX_ACL=y
+ CONFIG_EXT3_FS_SECURITY=y
+ # CONFIG_EXT4_FS is not set
+ CONFIG_JBD=y
+ CONFIG_FS_MBCACHE=y
+ # CONFIG_REISERFS_FS is not set
+ # CONFIG_JFS_FS is not set
+ CONFIG_FS_POSIX_ACL=y
+ CONFIG_FILE_LOCKING=y
+ # CONFIG_XFS_FS is not set
+ # CONFIG_OCFS2_FS is not set
+ # CONFIG_BTRFS_FS is not set
+ # CONFIG_DNOTIFY is not set
+ # CONFIG_INOTIFY is not set
+ # CONFIG_QUOTA is not set
+ # CONFIG_AUTOFS_FS is not set
+ # CONFIG_AUTOFS4_FS is not set
+ # CONFIG_FUSE_FS is not set
+ 
+ #
+ # CD-ROM/DVD Filesystems
+ #
+ # CONFIG_ISO9660_FS is not set
+ # CONFIG_UDF_FS is not set
+ 
+ #
+ # DOS/FAT/NT Filesystems
+ #
+ CONFIG_FAT_FS=y
+ CONFIG_MSDOS_FS=y
+ CONFIG_VFAT_FS=y
+ CONFIG_FAT_DEFAULT_CODEPAGE=850
+ CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+ # CONFIG_NTFS_FS is not set
+ 
+ #
+ # Pseudo filesystems
+ #
+ CONFIG_PROC_FS=y
+ CONFIG_PROC_SYSCTL=y
+ CONFIG_PROC_PAGE_MONITOR=y
+ CONFIG_SYSFS=y
+ CONFIG_TMPFS=y
+ # CONFIG_TMPFS_POSIX_ACL is not set
+ # CONFIG_HUGETLB_PAGE is not set
+ # CONFIG_CONFIGFS_FS is not set
+ CONFIG_MISC_FILESYSTEMS=y
+ # CONFIG_ADFS_FS is not set
+ # CONFIG_AFFS_FS is not set
+ # CONFIG_HFS_FS is not set
+ # CONFIG_HFSPLUS_FS is not set
+ # CONFIG_BEFS_FS is not set
+ # CONFIG_BFS_FS is not set
+ # CONFIG_EFS_FS is not set
+ CONFIG_JFFS2_FS=y
+ CONFIG_JFFS2_FS_DEBUG=0
+ CONFIG_JFFS2_FS_WRITEBUFFER=y
+ # CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+ # CONFIG_JFFS2_SUMMARY is not set
+ # CONFIG_JFFS2_FS_XATTR is not set
+ # CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+ CONFIG_JFFS2_ZLIB=y
+ # CONFIG_JFFS2_LZO is not set
+ CONFIG_JFFS2_RTIME=y
+ # CONFIG_JFFS2_RUBIN is not set
+ # CONFIG_CRAMFS is not set
+ # CONFIG_SQUASHFS is not set
+ # CONFIG_VXFS_FS is not set
+ # CONFIG_MINIX_FS is not set
+ # CONFIG_OMFS_FS is not set
+ # CONFIG_HPFS_FS is not set
+ # CONFIG_QNX4FS_FS is not set
+ # CONFIG_ROMFS_FS is not set
+ # CONFIG_SYSV_FS is not set
+ # CONFIG_UFS_FS is not set
+ CONFIG_NETWORK_FILESYSTEMS=y
+ CONFIG_NFS_FS=y
+ CONFIG_NFS_V3=y
+ # CONFIG_NFS_V3_ACL is not set
+ # CONFIG_NFS_V4 is not set
+ CONFIG_ROOT_NFS=y
+ # CONFIG_NFSD is not set
+ CONFIG_LOCKD=y
+ CONFIG_LOCKD_V4=y
+ CONFIG_NFS_COMMON=y
+ CONFIG_SUNRPC=y
+ # CONFIG_SUNRPC_REGISTER_V4 is not set
+ # CONFIG_RPCSEC_GSS_KRB5 is not set
+ # CONFIG_RPCSEC_GSS_SPKM3 is not set
+ # CONFIG_SMB_FS is not set
+ # CONFIG_CIFS is not set
+ # CONFIG_NCP_FS is not set
+ # CONFIG_CODA_FS is not set
+ # CONFIG_AFS_FS is not set
+ 
+ #
+ # Partition Types
+ #
+ # CONFIG_PARTITION_ADVANCED is not set
+ CONFIG_MSDOS_PARTITION=y
+ CONFIG_NLS=y
+ CONFIG_NLS_DEFAULT="iso8859-1"
+ # CONFIG_NLS_CODEPAGE_437 is not set
+ # CONFIG_NLS_CODEPAGE_737 is not set
+ # CONFIG_NLS_CODEPAGE_775 is not set
+ CONFIG_NLS_CODEPAGE_850=y
+ # CONFIG_NLS_CODEPAGE_852 is not set
+ # CONFIG_NLS_CODEPAGE_855 is not set
+ # CONFIG_NLS_CODEPAGE_857 is not set
+ # CONFIG_NLS_CODEPAGE_860 is not set
+ # CONFIG_NLS_CODEPAGE_861 is not set
+ # CONFIG_NLS_CODEPAGE_862 is not set
+ # CONFIG_NLS_CODEPAGE_863 is not set
+ # CONFIG_NLS_CODEPAGE_864 is not set
+ # CONFIG_NLS_CODEPAGE_865 is not set
+ # CONFIG_NLS_CODEPAGE_866 is not set
+ # CONFIG_NLS_CODEPAGE_869 is not set
+ # CONFIG_NLS_CODEPAGE_936 is not set
+ # CONFIG_NLS_CODEPAGE_950 is not set
+ # CONFIG_NLS_CODEPAGE_932 is not set
+ # CONFIG_NLS_CODEPAGE_949 is not set
+ # CONFIG_NLS_CODEPAGE_874 is not set
+ # CONFIG_NLS_ISO8859_8 is not set
+ # CONFIG_NLS_CODEPAGE_1250 is not set
+ # CONFIG_NLS_CODEPAGE_1251 is not set
+ # CONFIG_NLS_ASCII is not set
+ CONFIG_NLS_ISO8859_1=y
+ # CONFIG_NLS_ISO8859_2 is not set
+ # CONFIG_NLS_ISO8859_3 is not set
+ # CONFIG_NLS_ISO8859_4 is not set
+ # CONFIG_NLS_ISO8859_5 is not set
+ # CONFIG_NLS_ISO8859_6 is not set
+ # CONFIG_NLS_ISO8859_7 is not set
+ # CONFIG_NLS_ISO8859_9 is not set
+ # CONFIG_NLS_ISO8859_13 is not set
+ # CONFIG_NLS_ISO8859_14 is not set
+ # CONFIG_NLS_ISO8859_15 is not set
+ # CONFIG_NLS_KOI8_R is not set
+ # CONFIG_NLS_KOI8_U is not set
+ # CONFIG_NLS_UTF8 is not set
+ # CONFIG_DLM is not set
+ 
+ #
+ # Kernel hacking
+ #
+ # CONFIG_PRINTK_TIME is not set
+ CONFIG_ENABLE_WARN_DEPRECATED=y
+ CONFIG_ENABLE_MUST_CHECK=y
+ CONFIG_FRAME_WARN=1024
+ # CONFIG_MAGIC_SYSRQ is not set
+ # CONFIG_UNUSED_SYMBOLS is not set
+ # CONFIG_DEBUG_FS is not set
+ # CONFIG_HEADERS_CHECK is not set
+ CONFIG_DEBUG_KERNEL=y
+ # CONFIG_DEBUG_SHIRQ is not set
+ CONFIG_DETECT_SOFTLOCKUP=y
+ # CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+ CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+ CONFIG_SCHED_DEBUG=y
+ # CONFIG_SCHEDSTATS is not set
+ # CONFIG_TIMER_STATS is not set
+ # CONFIG_DEBUG_OBJECTS is not set
+ # CONFIG_DEBUG_SLAB is not set
+ CONFIG_DEBUG_PREEMPT=y
+ # CONFIG_DEBUG_RT_MUTEXES is not set
+ # CONFIG_RT_MUTEX_TESTER is not set
+ # CONFIG_DEBUG_SPINLOCK is not set
+ CONFIG_DEBUG_MUTEXES=y
+ # CONFIG_DEBUG_LOCK_ALLOC is not set
+ # CONFIG_PROVE_LOCKING is not set
+ # CONFIG_LOCK_STAT is not set
+ # CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+ # CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+ # CONFIG_DEBUG_KOBJECT is not set
+ # CONFIG_DEBUG_BUGVERBOSE is not set
+ # CONFIG_DEBUG_INFO is not set
+ # CONFIG_DEBUG_VM is not set
+ # CONFIG_DEBUG_WRITECOUNT is not set
+ # CONFIG_DEBUG_MEMORY_INIT is not set
+ # CONFIG_DEBUG_LIST is not set
+ # CONFIG_DEBUG_SG is not set
+ # CONFIG_DEBUG_NOTIFIERS is not set
+ CONFIG_FRAME_POINTER=y
+ # CONFIG_BOOT_PRINTK_DELAY is not set
+ # CONFIG_RCU_TORTURE_TEST is not set
+ # CONFIG_BACKTRACE_SELF_TEST is not set
+ # CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+ # CONFIG_FAULT_INJECTION is not set
+ # CONFIG_LATENCYTOP is not set
+ # CONFIG_SYSCTL_SYSCALL_CHECK is not set
+ CONFIG_HAVE_FUNCTION_TRACER=y
+ 
+ #
+ # Tracers
+ #
+ # CONFIG_FUNCTION_TRACER is not set
+ # CONFIG_IRQSOFF_TRACER is not set
+ # CONFIG_PREEMPT_TRACER is not set
+ # CONFIG_SCHED_TRACER is not set
+ # CONFIG_CONTEXT_SWITCH_TRACER is not set
+ # CONFIG_BOOT_TRACER is not set
+ # CONFIG_TRACE_BRANCH_PROFILING is not set
+ # CONFIG_STACK_TRACER is not set
+ # CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+ # CONFIG_SAMPLES is not set
+ CONFIG_HAVE_ARCH_KGDB=y
+ # CONFIG_KGDB is not set
+ # CONFIG_DEBUG_USER is not set
+ # CONFIG_DEBUG_ERRORS is not set
+ # CONFIG_DEBUG_STACK_USAGE is not set
+ CONFIG_DEBUG_LL=y
+ # CONFIG_DEBUG_ICEDCC is not set
+ 
+ #
+ # Security options
+ #
+ # CONFIG_KEYS is not set
+ # CONFIG_SECURITY is not set
+ # CONFIG_SECURITYFS is not set
+ # CONFIG_SECURITY_FILE_CAPABILITIES is not set
+ CONFIG_CRYPTO=y
+ 
+ #
+ # Crypto core or helper
+ #
+ # CONFIG_CRYPTO_FIPS is not set
+ CONFIG_CRYPTO_ALGAPI=y
+ CONFIG_CRYPTO_ALGAPI2=y
+ CONFIG_CRYPTO_AEAD2=y
+ CONFIG_CRYPTO_BLKCIPHER=y
+ CONFIG_CRYPTO_BLKCIPHER2=y
+ CONFIG_CRYPTO_HASH=y
+ CONFIG_CRYPTO_HASH2=y
+ CONFIG_CRYPTO_RNG2=y
+ CONFIG_CRYPTO_MANAGER=y
+ CONFIG_CRYPTO_MANAGER2=y
+ # CONFIG_CRYPTO_GF128MUL is not set
+ # CONFIG_CRYPTO_NULL is not set
+ # CONFIG_CRYPTO_CRYPTD is not set
+ # CONFIG_CRYPTO_AUTHENC is not set
+ # CONFIG_CRYPTO_TEST is not set
+ 
+ #
+ # Authenticated Encryption with Associated Data
+ #
+ # CONFIG_CRYPTO_CCM is not set
+ # CONFIG_CRYPTO_GCM is not set
+ # CONFIG_CRYPTO_SEQIV is not set
+ 
+ #
+ # Block modes
+ #
+ # CONFIG_CRYPTO_CBC is not set
+ # CONFIG_CRYPTO_CTR is not set
+ # CONFIG_CRYPTO_CTS is not set
+ CONFIG_CRYPTO_ECB=y
+ # CONFIG_CRYPTO_LRW is not set
+ # CONFIG_CRYPTO_PCBC is not set
+ # CONFIG_CRYPTO_XTS is not set
+ 
+ #
+ # Hash modes
+ #
+ # CONFIG_CRYPTO_HMAC is not set
+ # CONFIG_CRYPTO_XCBC is not set
+ 
+ #
+ # Digest
+ #
+ CONFIG_CRYPTO_CRC32C=y
+ # CONFIG_CRYPTO_MD4 is not set
+ # CONFIG_CRYPTO_MD5 is not set
+ # CONFIG_CRYPTO_MICHAEL_MIC is not set
+ # CONFIG_CRYPTO_RMD128 is not set
+ # CONFIG_CRYPTO_RMD160 is not set
+ # CONFIG_CRYPTO_RMD256 is not set
+ # CONFIG_CRYPTO_RMD320 is not set
+ CONFIG_CRYPTO_SHA1=y
+ # CONFIG_CRYPTO_SHA256 is not set
+ # CONFIG_CRYPTO_SHA512 is not set
+ # CONFIG_CRYPTO_TGR192 is not set
+ # CONFIG_CRYPTO_WP512 is not set
+ 
+ #
+ # Ciphers
+ #
+ CONFIG_CRYPTO_AES=y
+ # CONFIG_CRYPTO_ANUBIS is not set
+ CONFIG_CRYPTO_ARC4=y
+ # CONFIG_CRYPTO_BLOWFISH is not set
+ # CONFIG_CRYPTO_CAMELLIA is not set
+ # CONFIG_CRYPTO_CAST5 is not set
+ # CONFIG_CRYPTO_CAST6 is not set
+ # CONFIG_CRYPTO_DES is not set
+ # CONFIG_CRYPTO_FCRYPT is not set
+ # CONFIG_CRYPTO_KHAZAD is not set
+ # CONFIG_CRYPTO_SALSA20 is not set
+ # CONFIG_CRYPTO_SEED is not set
+ # CONFIG_CRYPTO_SERPENT is not set
+ # CONFIG_CRYPTO_TEA is not set
+ # CONFIG_CRYPTO_TWOFISH is not set
+ 
+ #
+ # Compression
+ #
+ # CONFIG_CRYPTO_DEFLATE is not set
+ # CONFIG_CRYPTO_LZO is not set
+ 
+ #
+ # Random Number Generation
+ #
+ # CONFIG_CRYPTO_ANSI_CPRNG is not set
+ CONFIG_CRYPTO_HW=y
+ 
+ #
+ # Library routines
+ #
+ CONFIG_BITREVERSE=y
+ CONFIG_GENERIC_FIND_LAST_BIT=y
+ CONFIG_CRC_CCITT=y
+ CONFIG_CRC16=y
+ # CONFIG_CRC_T10DIF is not set
+ CONFIG_CRC_ITU_T=y
+ CONFIG_CRC32=y
+ # CONFIG_CRC7 is not set
+ CONFIG_LIBCRC32C=y
+ CONFIG_ZLIB_INFLATE=y
+ CONFIG_ZLIB_DEFLATE=y
+ CONFIG_PLIST=y
+ CONFIG_HAS_IOMEM=y
+ CONFIG_HAS_IOPORT=y
+ CONFIG_HAS_DMA=y
diff -r -C3 -P linux-2.6.29.4/liabsg-2.6.29.4.config liab-linux-2.6.29.4/liabsg-2.6.29.4.config
*** linux-2.6.29.4/liabsg-2.6.29.4.config	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/liabsg-2.6.29.4.config	2012-04-03 14:04:24.464514974 +0200
***************
*** 0 ****
--- 1,1614 ----
+ #
+ # Automatically generated make config: don't edit
+ # Linux kernel version: 2.6.29.4
+ # Tue Apr  3 14:04:14 2012
+ #
+ CONFIG_ARM=y
+ CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+ CONFIG_GENERIC_GPIO=y
+ CONFIG_GENERIC_TIME=y
+ CONFIG_GENERIC_CLOCKEVENTS=y
+ CONFIG_MMU=y
+ # CONFIG_NO_IOPORT is not set
+ CONFIG_GENERIC_HARDIRQS=y
+ CONFIG_STACKTRACE_SUPPORT=y
+ CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+ CONFIG_LOCKDEP_SUPPORT=y
+ CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+ CONFIG_HARDIRQS_SW_RESEND=y
+ CONFIG_GENERIC_IRQ_PROBE=y
+ CONFIG_RWSEM_GENERIC_SPINLOCK=y
+ # CONFIG_ARCH_HAS_ILOG2_U32 is not set
+ # CONFIG_ARCH_HAS_ILOG2_U64 is not set
+ CONFIG_GENERIC_HWEIGHT=y
+ CONFIG_GENERIC_CALIBRATE_DELAY=y
+ CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+ CONFIG_VECTORS_BASE=0xffff0000
+ CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+ 
+ #
+ # General setup
+ #
+ CONFIG_EXPERIMENTAL=y
+ CONFIG_BROKEN_ON_SMP=y
+ CONFIG_LOCK_KERNEL=y
+ CONFIG_INIT_ENV_ARG_LIMIT=32
+ CONFIG_LOCALVERSION=""
+ # CONFIG_LOCALVERSION_AUTO is not set
+ CONFIG_SWAP=y
+ CONFIG_SYSVIPC=y
+ CONFIG_SYSVIPC_SYSCTL=y
+ CONFIG_POSIX_MQUEUE=y
+ # CONFIG_BSD_PROCESS_ACCT is not set
+ # CONFIG_TASKSTATS is not set
+ # CONFIG_AUDIT is not set
+ 
+ #
+ # RCU Subsystem
+ #
+ # CONFIG_CLASSIC_RCU is not set
+ # CONFIG_TREE_RCU is not set
+ CONFIG_PREEMPT_RCU=y
+ # CONFIG_RCU_TRACE is not set
+ # CONFIG_TREE_RCU_TRACE is not set
+ # CONFIG_PREEMPT_RCU_TRACE is not set
+ CONFIG_IKCONFIG=y
+ CONFIG_IKCONFIG_PROC=y
+ CONFIG_LOG_BUF_SHIFT=14
+ CONFIG_GROUP_SCHED=y
+ CONFIG_FAIR_GROUP_SCHED=y
+ # CONFIG_RT_GROUP_SCHED is not set
+ CONFIG_USER_SCHED=y
+ # CONFIG_CGROUP_SCHED is not set
+ # CONFIG_CGROUPS is not set
+ CONFIG_SYSFS_DEPRECATED=y
+ CONFIG_SYSFS_DEPRECATED_V2=y
+ # CONFIG_RELAY is not set
+ # CONFIG_NAMESPACES is not set
+ CONFIG_BLK_DEV_INITRD=y
+ CONFIG_INITRAMFS_SOURCE=""
+ CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+ CONFIG_SYSCTL=y
+ CONFIG_ANON_INODES=y
+ CONFIG_EMBEDDED=y
+ CONFIG_UID16=y
+ CONFIG_SYSCTL_SYSCALL=y
+ # CONFIG_KALLSYMS is not set
+ CONFIG_HOTPLUG=y
+ CONFIG_PRINTK=y
+ CONFIG_BUG=y
+ # CONFIG_ELF_CORE is not set
+ CONFIG_BASE_FULL=y
+ CONFIG_FUTEX=y
+ CONFIG_EPOLL=y
+ CONFIG_SIGNALFD=y
+ CONFIG_TIMERFD=y
+ CONFIG_EVENTFD=y
+ CONFIG_SHMEM=y
+ CONFIG_AIO=y
+ CONFIG_VM_EVENT_COUNTERS=y
+ CONFIG_COMPAT_BRK=y
+ CONFIG_SLAB=y
+ # CONFIG_SLUB is not set
+ # CONFIG_SLOB is not set
+ # CONFIG_PROFILING is not set
+ CONFIG_HAVE_OPROFILE=y
+ CONFIG_HAVE_KPROBES=y
+ CONFIG_HAVE_KRETPROBES=y
+ CONFIG_HAVE_CLK=y
+ CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+ CONFIG_SLABINFO=y
+ CONFIG_RT_MUTEXES=y
+ CONFIG_BASE_SMALL=0
+ CONFIG_MODULES=y
+ # CONFIG_MODULE_FORCE_LOAD is not set
+ CONFIG_MODULE_UNLOAD=y
+ CONFIG_MODULE_FORCE_UNLOAD=y
+ # CONFIG_MODVERSIONS is not set
+ # CONFIG_MODULE_SRCVERSION_ALL is not set
+ CONFIG_BLOCK=y
+ # CONFIG_LBD is not set
+ # CONFIG_BLK_DEV_IO_TRACE is not set
+ # CONFIG_BLK_DEV_BSG is not set
+ # CONFIG_BLK_DEV_INTEGRITY is not set
+ 
+ #
+ # IO Schedulers
+ #
+ CONFIG_IOSCHED_NOOP=y
+ # CONFIG_IOSCHED_AS is not set
+ # CONFIG_IOSCHED_DEADLINE is not set
+ CONFIG_IOSCHED_CFQ=y
+ # CONFIG_DEFAULT_AS is not set
+ # CONFIG_DEFAULT_DEADLINE is not set
+ CONFIG_DEFAULT_CFQ=y
+ # CONFIG_DEFAULT_NOOP is not set
+ CONFIG_DEFAULT_IOSCHED="cfq"
+ # CONFIG_FREEZER is not set
+ 
+ #
+ # System Type
+ #
+ # CONFIG_ARCH_AAEC2000 is not set
+ # CONFIG_ARCH_INTEGRATOR is not set
+ # CONFIG_ARCH_REALVIEW is not set
+ # CONFIG_ARCH_VERSATILE is not set
+ CONFIG_ARCH_AT91=y
+ # CONFIG_ARCH_CLPS711X is not set
+ # CONFIG_ARCH_EBSA110 is not set
+ # CONFIG_ARCH_EP93XX is not set
+ # CONFIG_ARCH_FOOTBRIDGE is not set
+ # CONFIG_ARCH_NETX is not set
+ # CONFIG_ARCH_H720X is not set
+ # CONFIG_ARCH_IMX is not set
+ # CONFIG_ARCH_IOP13XX is not set
+ # CONFIG_ARCH_IOP32X is not set
+ # CONFIG_ARCH_IOP33X is not set
+ # CONFIG_ARCH_IXP23XX is not set
+ # CONFIG_ARCH_IXP2000 is not set
+ # CONFIG_ARCH_IXP4XX is not set
+ # CONFIG_ARCH_L7200 is not set
+ # CONFIG_ARCH_KIRKWOOD is not set
+ # CONFIG_ARCH_KS8695 is not set
+ # CONFIG_ARCH_NS9XXX is not set
+ # CONFIG_ARCH_LOKI is not set
+ # CONFIG_ARCH_MV78XX0 is not set
+ # CONFIG_ARCH_MXC is not set
+ # CONFIG_ARCH_ORION5X is not set
+ # CONFIG_ARCH_PNX4008 is not set
+ # CONFIG_ARCH_PXA is not set
+ # CONFIG_ARCH_RPC is not set
+ # CONFIG_ARCH_SA1100 is not set
+ # CONFIG_ARCH_S3C2410 is not set
+ # CONFIG_ARCH_S3C64XX is not set
+ # CONFIG_ARCH_SHARK is not set
+ # CONFIG_ARCH_LH7A40X is not set
+ # CONFIG_ARCH_DAVINCI is not set
+ # CONFIG_ARCH_OMAP is not set
+ # CONFIG_ARCH_MSM is not set
+ # CONFIG_ARCH_W90X900 is not set
+ 
+ #
+ # Atmel AT91 System-on-Chip
+ #
+ # CONFIG_ARCH_AT91RM9200 is not set
+ CONFIG_ARCH_AT91SAM9260=y
+ # CONFIG_ARCH_AT91SAM9261 is not set
+ # CONFIG_ARCH_AT91SAM9263 is not set
+ # CONFIG_ARCH_AT91SAM9RL is not set
+ # CONFIG_ARCH_AT91SAM9G20 is not set
+ # CONFIG_ARCH_AT91CAP9 is not set
+ # CONFIG_ARCH_AT91X40 is not set
+ CONFIG_AT91_PMC_UNIT=y
+ CONFIG_MACH_LIABARM=y
+ 
+ #
+ # AT91SAM9260 Variants
+ #
+ # CONFIG_ARCH_AT91SAM9260_SAM9XE is not set
+ 
+ #
+ # AT91SAM9260 / AT91SAM9XE Board Type
+ #
+ # CONFIG_MACH_AT91SAM9260EK is not set
+ CONFIG_MACH_LIABSG=y
+ # CONFIG_MACH_CAM60 is not set
+ # CONFIG_MACH_SAM9_L9260 is not set
+ # CONFIG_MACH_AFEB9260 is not set
+ # CONFIG_MACH_USB_A9260 is not set
+ # CONFIG_MACH_QIL_A9260 is not set
+ 
+ #
+ # AT91 Board Options
+ #
+ 
+ #
+ # AT91 Feature Selections
+ #
+ # CONFIG_AT91_PROGRAMMABLE_CLOCKS is not set
+ CONFIG_AT91_TIMER_HZ=128
+ CONFIG_AT91_EARLY_DBGU=y
+ # CONFIG_AT91_EARLY_USART0 is not set
+ # CONFIG_AT91_EARLY_USART1 is not set
+ # CONFIG_AT91_EARLY_USART2 is not set
+ # CONFIG_AT91_EARLY_USART3 is not set
+ # CONFIG_AT91_EARLY_USART4 is not set
+ # CONFIG_AT91_EARLY_USART5 is not set
+ 
+ #
+ # Processor Type
+ #
+ CONFIG_CPU_32=y
+ CONFIG_CPU_ARM926T=y
+ CONFIG_CPU_32v5=y
+ CONFIG_CPU_ABRT_EV5TJ=y
+ CONFIG_CPU_PABRT_NOIFAR=y
+ CONFIG_CPU_CACHE_VIVT=y
+ CONFIG_CPU_COPY_V4WB=y
+ CONFIG_CPU_TLB_V4WBI=y
+ CONFIG_CPU_CP15=y
+ CONFIG_CPU_CP15_MMU=y
+ 
+ #
+ # Processor Features
+ #
+ CONFIG_ARM_THUMB=y
+ # CONFIG_CPU_ICACHE_DISABLE is not set
+ # CONFIG_CPU_DCACHE_DISABLE is not set
+ # CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+ # CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+ # CONFIG_OUTER_CACHE is not set
+ 
+ #
+ # Bus support
+ #
+ # CONFIG_PCI_SYSCALL is not set
+ # CONFIG_ARCH_SUPPORTS_MSI is not set
+ # CONFIG_PCCARD is not set
+ 
+ #
+ # Kernel Features
+ #
+ # CONFIG_NO_HZ is not set
+ # CONFIG_HIGH_RES_TIMERS is not set
+ CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+ CONFIG_VMSPLIT_3G=y
+ # CONFIG_VMSPLIT_2G is not set
+ # CONFIG_VMSPLIT_1G is not set
+ CONFIG_PAGE_OFFSET=0xC0000000
+ CONFIG_PREEMPT=y
+ CONFIG_HZ=128
+ # CONFIG_AEABI is not set
+ CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+ # CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+ # CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+ CONFIG_SELECT_MEMORY_MODEL=y
+ CONFIG_FLATMEM_MANUAL=y
+ # CONFIG_DISCONTIGMEM_MANUAL is not set
+ # CONFIG_SPARSEMEM_MANUAL is not set
+ CONFIG_FLATMEM=y
+ CONFIG_FLAT_NODE_MEM_MAP=y
+ CONFIG_PAGEFLAGS_EXTENDED=y
+ CONFIG_SPLIT_PTLOCK_CPUS=4096
+ # CONFIG_PHYS_ADDR_T_64BIT is not set
+ CONFIG_ZONE_DMA_FLAG=0
+ CONFIG_VIRT_TO_BUS=y
+ CONFIG_UNEVICTABLE_LRU=y
+ CONFIG_LEDS=y
+ CONFIG_LEDS_CPU=y
+ CONFIG_ALIGNMENT_TRAP=y
+ 
+ #
+ # Boot options
+ #
+ CONFIG_ZBOOT_ROM_TEXT=0x0
+ CONFIG_ZBOOT_ROM_BSS=0x0
+ CONFIG_CMDLINE=""
+ # CONFIG_XIP_KERNEL is not set
+ # CONFIG_KEXEC is not set
+ 
+ #
+ # CPU Power Management
+ #
+ # CONFIG_CPU_IDLE is not set
+ 
+ #
+ # Floating point emulation
+ #
+ 
+ #
+ # At least one emulation must be selected
+ #
+ CONFIG_FPE_NWFPE=y
+ # CONFIG_FPE_NWFPE_XP is not set
+ # CONFIG_FPE_FASTFPE is not set
+ # CONFIG_VFP is not set
+ 
+ #
+ # Userspace binary formats
+ #
+ CONFIG_BINFMT_ELF=y
+ CONFIG_HAVE_AOUT=y
+ # CONFIG_BINFMT_AOUT is not set
+ # CONFIG_BINFMT_MISC is not set
+ # CONFIG_ARTHUR is not set
+ 
+ #
+ # Power management options
+ #
+ # CONFIG_PM is not set
+ CONFIG_ARCH_SUSPEND_POSSIBLE=y
+ CONFIG_NET=y
+ 
+ #
+ # Networking options
+ #
+ CONFIG_COMPAT_NET_DEV_OPS=y
+ CONFIG_PACKET=y
+ CONFIG_PACKET_MMAP=y
+ CONFIG_UNIX=y
+ # CONFIG_NET_KEY is not set
+ CONFIG_INET=y
+ CONFIG_IP_MULTICAST=y
+ CONFIG_IP_ADVANCED_ROUTER=y
+ CONFIG_ASK_IP_FIB_HASH=y
+ # CONFIG_IP_FIB_TRIE is not set
+ CONFIG_IP_FIB_HASH=y
+ CONFIG_IP_MULTIPLE_TABLES=y
+ CONFIG_IP_ROUTE_MULTIPATH=y
+ CONFIG_IP_ROUTE_VERBOSE=y
+ CONFIG_IP_PNP=y
+ CONFIG_IP_PNP_DHCP=y
+ CONFIG_IP_PNP_BOOTP=y
+ CONFIG_IP_PNP_RARP=y
+ # CONFIG_NET_IPIP is not set
+ # CONFIG_NET_IPGRE is not set
+ CONFIG_IP_MROUTE=y
+ CONFIG_IP_PIMSM_V1=y
+ # CONFIG_IP_PIMSM_V2 is not set
+ # CONFIG_ARPD is not set
+ CONFIG_SYN_COOKIES=y
+ # CONFIG_INET_AH is not set
+ # CONFIG_INET_ESP is not set
+ # CONFIG_INET_IPCOMP is not set
+ # CONFIG_INET_XFRM_TUNNEL is not set
+ # CONFIG_INET_TUNNEL is not set
+ # CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+ # CONFIG_INET_XFRM_MODE_TUNNEL is not set
+ # CONFIG_INET_XFRM_MODE_BEET is not set
+ # CONFIG_INET_LRO is not set
+ # CONFIG_INET_DIAG is not set
+ # CONFIG_TCP_CONG_ADVANCED is not set
+ CONFIG_TCP_CONG_CUBIC=y
+ CONFIG_DEFAULT_TCP_CONG="cubic"
+ # CONFIG_TCP_MD5SIG is not set
+ # CONFIG_IPV6 is not set
+ # CONFIG_NETWORK_SECMARK is not set
+ # CONFIG_NETFILTER is not set
+ # CONFIG_IP_DCCP is not set
+ # CONFIG_IP_SCTP is not set
+ # CONFIG_TIPC is not set
+ # CONFIG_ATM is not set
+ # CONFIG_BRIDGE is not set
+ # CONFIG_NET_DSA is not set
+ # CONFIG_VLAN_8021Q is not set
+ # CONFIG_DECNET is not set
+ # CONFIG_LLC2 is not set
+ # CONFIG_IPX is not set
+ # CONFIG_ATALK is not set
+ # CONFIG_X25 is not set
+ # CONFIG_LAPB is not set
+ # CONFIG_ECONET is not set
+ # CONFIG_WAN_ROUTER is not set
+ # CONFIG_NET_SCHED is not set
+ # CONFIG_DCB is not set
+ 
+ #
+ # Network testing
+ #
+ # CONFIG_NET_PKTGEN is not set
+ # CONFIG_HAMRADIO is not set
+ # CONFIG_CAN is not set
+ # CONFIG_IRDA is not set
+ # CONFIG_BT is not set
+ # CONFIG_AF_RXRPC is not set
+ # CONFIG_PHONET is not set
+ CONFIG_FIB_RULES=y
+ # CONFIG_WIRELESS is not set
+ # CONFIG_WIMAX is not set
+ # CONFIG_RFKILL is not set
+ # CONFIG_NET_9P is not set
+ 
+ #
+ # Device Drivers
+ #
+ 
+ #
+ # Generic Driver Options
+ #
+ CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+ CONFIG_STANDALONE=y
+ CONFIG_PREVENT_FIRMWARE_BUILD=y
+ CONFIG_FW_LOADER=y
+ # CONFIG_FIRMWARE_IN_KERNEL is not set
+ CONFIG_EXTRA_FIRMWARE=""
+ # CONFIG_DEBUG_DRIVER is not set
+ # CONFIG_DEBUG_DEVRES is not set
+ # CONFIG_SYS_HYPERVISOR is not set
+ # CONFIG_CONNECTOR is not set
+ CONFIG_MTD=y
+ # CONFIG_MTD_DEBUG is not set
+ # CONFIG_MTD_CONCAT is not set
+ CONFIG_MTD_PARTITIONS=y
+ # CONFIG_MTD_TESTS is not set
+ # CONFIG_MTD_REDBOOT_PARTS is not set
+ # CONFIG_MTD_CMDLINE_PARTS is not set
+ # CONFIG_MTD_AFS_PARTS is not set
+ # CONFIG_MTD_AR7_PARTS is not set
+ 
+ #
+ # User Modules And Translation Layers
+ #
+ CONFIG_MTD_CHAR=y
+ CONFIG_MTD_BLKDEVS=y
+ CONFIG_MTD_BLOCK=y
+ # CONFIG_FTL is not set
+ CONFIG_NFTL=y
+ CONFIG_NFTL_RW=y
+ # CONFIG_INFTL is not set
+ # CONFIG_RFD_FTL is not set
+ # CONFIG_SSFDC is not set
+ # CONFIG_MTD_OOPS is not set
+ 
+ #
+ # RAM/ROM/Flash chip drivers
+ #
+ CONFIG_MTD_CFI=y
+ # CONFIG_MTD_JEDECPROBE is not set
+ CONFIG_MTD_GEN_PROBE=y
+ # CONFIG_MTD_CFI_ADV_OPTIONS is not set
+ CONFIG_MTD_MAP_BANK_WIDTH_1=y
+ CONFIG_MTD_MAP_BANK_WIDTH_2=y
+ CONFIG_MTD_MAP_BANK_WIDTH_4=y
+ # CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+ # CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+ # CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+ CONFIG_MTD_CFI_I1=y
+ CONFIG_MTD_CFI_I2=y
+ # CONFIG_MTD_CFI_I4 is not set
+ # CONFIG_MTD_CFI_I8 is not set
+ CONFIG_MTD_CFI_INTELEXT=y
+ CONFIG_MTD_CFI_AMDSTD=y
+ # CONFIG_MTD_CFI_STAA is not set
+ CONFIG_MTD_CFI_UTIL=y
+ # CONFIG_MTD_RAM is not set
+ # CONFIG_MTD_ROM is not set
+ # CONFIG_MTD_ABSENT is not set
+ 
+ #
+ # Mapping drivers for chip access
+ #
+ # CONFIG_MTD_COMPLEX_MAPPINGS is not set
+ # CONFIG_MTD_PHYSMAP is not set
+ # CONFIG_MTD_ARM_INTEGRATOR is not set
+ CONFIG_MTD_LIABARM=y
+ CONFIG_MTD_LIAB_FLASH_SIZE=16384
+ CONFIG_MTD_LIAB_NOFLASH=1
+ CONFIG_MTD_LIABARM_BOOTSIZE=128
+ CONFIG_MTD_LIABARM_KERNELSIZE=1536
+ CONFIG_MTD_LIABARM_ROOTSIZE=6144
+ CONFIG_MTD_LIABARM_PARAMSIZE=128
+ CONFIG_MTD_LIABARM_JFFS2SIZE=8448
+ # CONFIG_MTD_PLATRAM is not set
+ 
+ #
+ # Self-contained MTD device drivers
+ #
+ # CONFIG_MTD_DATAFLASH is not set
+ # CONFIG_MTD_M25P80 is not set
+ # CONFIG_MTD_SLRAM is not set
+ # CONFIG_MTD_PHRAM is not set
+ # CONFIG_MTD_MTDRAM is not set
+ # CONFIG_MTD_BLOCK2MTD is not set
+ 
+ #
+ # Disk-On-Chip Device Drivers
+ #
+ # CONFIG_MTD_DOC2000 is not set
+ # CONFIG_MTD_DOC2001 is not set
+ # CONFIG_MTD_DOC2001PLUS is not set
+ CONFIG_MTD_NAND=y
+ # CONFIG_MTD_NAND_VERIFY_WRITE is not set
+ # CONFIG_MTD_NAND_ECC_SMC is not set
+ # CONFIG_MTD_NAND_MUSEUM_IDS is not set
+ # CONFIG_MTD_NAND_GPIO is not set
+ CONFIG_MTD_NAND_IDS=y
+ # CONFIG_MTD_NAND_DISKONCHIP is not set
+ CONFIG_MTD_NAND_ATMEL=y
+ # CONFIG_MTD_NAND_ATMEL_ECC_HW is not set
+ CONFIG_MTD_NAND_ATMEL_ECC_SOFT=y
+ # CONFIG_MTD_NAND_ATMEL_ECC_NONE is not set
+ # CONFIG_MTD_NAND_NANDSIM is not set
+ # CONFIG_MTD_NAND_PLATFORM is not set
+ # CONFIG_MTD_ALAUDA is not set
+ # CONFIG_MTD_ONENAND is not set
+ 
+ #
+ # LPDDR flash memory drivers
+ #
+ # CONFIG_MTD_LPDDR is not set
+ 
+ #
+ # UBI - Unsorted block images
+ #
+ # CONFIG_MTD_UBI is not set
+ # CONFIG_PARPORT is not set
+ CONFIG_BLK_DEV=y
+ # CONFIG_BLK_DEV_COW_COMMON is not set
+ # CONFIG_BLK_DEV_LOOP is not set
+ # CONFIG_BLK_DEV_NBD is not set
+ # CONFIG_BLK_DEV_UB is not set
+ CONFIG_BLK_DEV_RAM=y
+ CONFIG_BLK_DEV_RAM_COUNT=16
+ CONFIG_BLK_DEV_RAM_SIZE=32768
+ # CONFIG_BLK_DEV_XIP is not set
+ # CONFIG_CDROM_PKTCDVD is not set
+ # CONFIG_ATA_OVER_ETH is not set
+ CONFIG_MISC_DEVICES=y
+ # CONFIG_ATMEL_TCLIB is not set
+ CONFIG_AT91_PWM=y
+ # CONFIG_ICS932S401 is not set
+ # CONFIG_ATMEL_SSC is not set
+ # CONFIG_ENCLOSURE_SERVICES is not set
+ # CONFIG_C2PORT is not set
+ 
+ #
+ # EEPROM support
+ #
+ CONFIG_EEPROM_AT24=y
+ # CONFIG_EEPROM_AT25 is not set
+ # CONFIG_EEPROM_LEGACY is not set
+ # CONFIG_EEPROM_93CX6 is not set
+ CONFIG_HAVE_IDE=y
+ # CONFIG_IDE is not set
+ 
+ #
+ # SCSI device support
+ #
+ # CONFIG_RAID_ATTRS is not set
+ CONFIG_SCSI=m
+ CONFIG_SCSI_DMA=y
+ # CONFIG_SCSI_TGT is not set
+ # CONFIG_SCSI_NETLINK is not set
+ CONFIG_SCSI_PROC_FS=y
+ 
+ #
+ # SCSI support type (disk, tape, CD-ROM)
+ #
+ CONFIG_BLK_DEV_SD=m
+ # CONFIG_CHR_DEV_ST is not set
+ # CONFIG_CHR_DEV_OSST is not set
+ # CONFIG_BLK_DEV_SR is not set
+ # CONFIG_CHR_DEV_SG is not set
+ # CONFIG_CHR_DEV_SCH is not set
+ 
+ #
+ # Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+ #
+ CONFIG_SCSI_MULTI_LUN=y
+ # CONFIG_SCSI_CONSTANTS is not set
+ CONFIG_SCSI_LOGGING=y
+ # CONFIG_SCSI_SCAN_ASYNC is not set
+ CONFIG_SCSI_WAIT_SCAN=m
+ 
+ #
+ # SCSI Transports
+ #
+ # CONFIG_SCSI_SPI_ATTRS is not set
+ # CONFIG_SCSI_FC_ATTRS is not set
+ # CONFIG_SCSI_ISCSI_ATTRS is not set
+ # CONFIG_SCSI_SAS_LIBSAS is not set
+ # CONFIG_SCSI_SRP_ATTRS is not set
+ CONFIG_SCSI_LOWLEVEL=y
+ # CONFIG_ISCSI_TCP is not set
+ # CONFIG_LIBFC is not set
+ # CONFIG_SCSI_DEBUG is not set
+ # CONFIG_SCSI_DH is not set
+ # CONFIG_ATA is not set
+ # CONFIG_MD is not set
+ CONFIG_NETDEVICES=y
+ # CONFIG_DUMMY is not set
+ # CONFIG_BONDING is not set
+ # CONFIG_MACVLAN is not set
+ # CONFIG_EQUALIZER is not set
+ CONFIG_TUN=y
+ # CONFIG_VETH is not set
+ CONFIG_PHYLIB=y
+ 
+ #
+ # MII PHY device drivers
+ #
+ # CONFIG_MARVELL_PHY is not set
+ CONFIG_DAVICOM_PHY=y
+ # CONFIG_QSEMI_PHY is not set
+ # CONFIG_LXT_PHY is not set
+ # CONFIG_CICADA_PHY is not set
+ # CONFIG_VITESSE_PHY is not set
+ # CONFIG_SMSC_PHY is not set
+ # CONFIG_BROADCOM_PHY is not set
+ # CONFIG_ICPLUS_PHY is not set
+ # CONFIG_REALTEK_PHY is not set
+ # CONFIG_NATIONAL_PHY is not set
+ # CONFIG_STE10XP is not set
+ # CONFIG_LSI_ET1011C_PHY is not set
+ # CONFIG_FIXED_PHY is not set
+ # CONFIG_MDIO_BITBANG is not set
+ CONFIG_NET_ETHERNET=y
+ CONFIG_MII=y
+ CONFIG_MACB=y
+ # CONFIG_AX88796 is not set
+ # CONFIG_SMC91X is not set
+ # CONFIG_DM9000 is not set
+ # CONFIG_ENC28J60 is not set
+ # CONFIG_SMC911X is not set
+ # CONFIG_SMSC911X is not set
+ # CONFIG_DNET is not set
+ # CONFIG_IBM_NEW_EMAC_ZMII is not set
+ # CONFIG_IBM_NEW_EMAC_RGMII is not set
+ # CONFIG_IBM_NEW_EMAC_TAH is not set
+ # CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+ # CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+ # CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+ # CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+ # CONFIG_B44 is not set
+ # CONFIG_NETDEV_1000 is not set
+ # CONFIG_NETDEV_10000 is not set
+ 
+ #
+ # Wireless LAN
+ #
+ # CONFIG_WLAN_PRE80211 is not set
+ # CONFIG_WLAN_80211 is not set
+ # CONFIG_IWLWIFI_LEDS is not set
+ 
+ #
+ # Enable WiMAX (Networking options) to see the WiMAX drivers
+ #
+ 
+ #
+ # USB Network Adapters
+ #
+ # CONFIG_USB_CATC is not set
+ # CONFIG_USB_KAWETH is not set
+ # CONFIG_USB_PEGASUS is not set
+ # CONFIG_USB_RTL8150 is not set
+ # CONFIG_USB_USBNET is not set
+ # CONFIG_WAN is not set
+ CONFIG_PPP=y
+ # CONFIG_PPP_MULTILINK is not set
+ CONFIG_PPP_FILTER=y
+ CONFIG_PPP_ASYNC=y
+ # CONFIG_PPP_SYNC_TTY is not set
+ CONFIG_PPP_DEFLATE=y
+ CONFIG_PPP_BSDCOMP=y
+ CONFIG_PPP_MPPE=y
+ CONFIG_PPPOE=y
+ # CONFIG_PPPOL2TP is not set
+ # CONFIG_SLIP is not set
+ CONFIG_SLHC=y
+ # CONFIG_NETCONSOLE is not set
+ # CONFIG_NETPOLL is not set
+ # CONFIG_NET_POLL_CONTROLLER is not set
+ # CONFIG_ISDN is not set
+ 
+ #
+ # Input device support
+ #
+ CONFIG_INPUT=y
+ # CONFIG_INPUT_FF_MEMLESS is not set
+ # CONFIG_INPUT_POLLDEV is not set
+ 
+ #
+ # Userland interfaces
+ #
+ # CONFIG_INPUT_MOUSEDEV is not set
+ # CONFIG_INPUT_JOYDEV is not set
+ CONFIG_INPUT_EVDEV=y
+ # CONFIG_INPUT_EVBUG is not set
+ 
+ #
+ # Input Device Drivers
+ #
+ CONFIG_INPUT_KEYBOARD=y
+ # CONFIG_KEYBOARD_ATKBD is not set
+ # CONFIG_KEYBOARD_SUNKBD is not set
+ # CONFIG_KEYBOARD_LKKBD is not set
+ # CONFIG_KEYBOARD_XTKBD is not set
+ # CONFIG_KEYBOARD_NEWTON is not set
+ # CONFIG_KEYBOARD_STOWAWAY is not set
+ CONFIG_KEYBOARD_GPIO=y
+ # CONFIG_INPUT_MOUSE is not set
+ # CONFIG_INPUT_JOYSTICK is not set
+ # CONFIG_INPUT_TABLET is not set
+ # CONFIG_INPUT_TOUCHSCREEN is not set
+ # CONFIG_INPUT_MISC is not set
+ 
+ #
+ # Hardware I/O ports
+ #
+ # CONFIG_SERIO is not set
+ # CONFIG_GAMEPORT is not set
+ 
+ #
+ # Character devices
+ #
+ # CONFIG_VT is not set
+ CONFIG_DEVKMEM=y
+ # CONFIG_SERIAL_NONSTANDARD is not set
+ 
+ #
+ # Serial drivers
+ #
+ # CONFIG_SERIAL_8250 is not set
+ 
+ #
+ # Non-8250 serial port support
+ #
+ CONFIG_SERIAL_ATMEL=y
+ CONFIG_SERIAL_ATMEL_CONSOLE=y
+ CONFIG_SERIAL_ATMEL_PDC=y
+ # CONFIG_SERIAL_ATMEL_TTYAT is not set
+ CONFIG_SERIAL_CORE=y
+ CONFIG_SERIAL_CORE_CONSOLE=y
+ CONFIG_UNIX98_PTYS=y
+ # CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+ CONFIG_LEGACY_PTYS=y
+ CONFIG_LEGACY_PTY_COUNT=256
+ # CONFIG_IPMI_HANDLER is not set
+ CONFIG_HW_RANDOM=y
+ # CONFIG_R3964 is not set
+ # CONFIG_RAW_DRIVER is not set
+ # CONFIG_TCG_TPM is not set
+ CONFIG_I2C=y
+ CONFIG_I2C_BOARDINFO=y
+ CONFIG_I2C_CHARDEV=y
+ CONFIG_I2C_HELPER_AUTO=y
+ CONFIG_I2C_ALGOBIT=y
+ 
+ #
+ # I2C Hardware Bus support
+ #
+ 
+ #
+ # I2C system bus drivers (mostly embedded / system-on-chip)
+ #
+ CONFIG_I2C_GPIO=y
+ # CONFIG_I2C_OCORES is not set
+ # CONFIG_I2C_SIMTEC is not set
+ 
+ #
+ # External I2C/SMBus adapter drivers
+ #
+ # CONFIG_I2C_PARPORT_LIGHT is not set
+ # CONFIG_I2C_TAOS_EVM is not set
+ # CONFIG_I2C_TINY_USB is not set
+ 
+ #
+ # Other I2C/SMBus bus drivers
+ #
+ # CONFIG_I2C_PCA_PLATFORM is not set
+ # CONFIG_I2C_STUB is not set
+ 
+ #
+ # Miscellaneous I2C Chip support
+ #
+ # CONFIG_DS1682 is not set
+ # CONFIG_SENSORS_PCF8574 is not set
+ # CONFIG_PCF8575 is not set
+ # CONFIG_SENSORS_PCF8591 is not set
+ # CONFIG_SENSORS_MAX6875 is not set
+ # CONFIG_SENSORS_TSL2550 is not set
+ # CONFIG_I2C_DEBUG_CORE is not set
+ # CONFIG_I2C_DEBUG_ALGO is not set
+ # CONFIG_I2C_DEBUG_BUS is not set
+ # CONFIG_I2C_DEBUG_CHIP is not set
+ CONFIG_SPI=y
+ # CONFIG_SPI_DEBUG is not set
+ CONFIG_SPI_MASTER=y
+ 
+ #
+ # SPI Master Controller Drivers
+ #
+ CONFIG_SPI_ATMEL=y
+ # CONFIG_SPI_BITBANG is not set
+ # CONFIG_SPI_GPIO is not set
+ 
+ #
+ # SPI Protocol Masters
+ #
+ # CONFIG_SPI_SPIDEV is not set
+ # CONFIG_SPI_TLE62X0 is not set
+ CONFIG_ARCH_REQUIRE_GPIOLIB=y
+ CONFIG_GPIOLIB=y
+ CONFIG_DEBUG_GPIO=y
+ CONFIG_GPIO_SYSFS=y
+ 
+ #
+ # Memory mapped GPIO expanders:
+ #
+ 
+ #
+ # I2C GPIO expanders:
+ #
+ # CONFIG_GPIO_MAX732X is not set
+ CONFIG_GPIO_PCA953X=y
+ # CONFIG_GPIO_PCF857X is not set
+ 
+ #
+ # PCI GPIO expanders:
+ #
+ 
+ #
+ # SPI GPIO expanders:
+ #
+ # CONFIG_GPIO_MAX7301 is not set
+ # CONFIG_GPIO_MCP23S08 is not set
+ # CONFIG_W1 is not set
+ # CONFIG_POWER_SUPPLY is not set
+ CONFIG_HWMON=y
+ CONFIG_HWMON_VID=y
+ # CONFIG_SENSORS_AD7414 is not set
+ # CONFIG_SENSORS_AD7418 is not set
+ # CONFIG_SENSORS_ADCXX is not set
+ # CONFIG_SENSORS_ADM1021 is not set
+ # CONFIG_SENSORS_ADM1025 is not set
+ # CONFIG_SENSORS_ADM1026 is not set
+ # CONFIG_SENSORS_ADM1029 is not set
+ # CONFIG_SENSORS_ADM1031 is not set
+ CONFIG_SENSORS_ADM9240=y
+ # CONFIG_SENSORS_ADT7462 is not set
+ # CONFIG_SENSORS_ADT7470 is not set
+ # CONFIG_SENSORS_ADT7473 is not set
+ # CONFIG_SENSORS_ADT7475 is not set
+ # CONFIG_SENSORS_ATXP1 is not set
+ # CONFIG_SENSORS_DS1621 is not set
+ # CONFIG_SENSORS_F71805F is not set
+ # CONFIG_SENSORS_F71882FG is not set
+ # CONFIG_SENSORS_F75375S is not set
+ # CONFIG_SENSORS_GL518SM is not set
+ # CONFIG_SENSORS_GL520SM is not set
+ # CONFIG_SENSORS_IT87 is not set
+ # CONFIG_SENSORS_LM63 is not set
+ # CONFIG_SENSORS_LM70 is not set
+ # CONFIG_SENSORS_LM75 is not set
+ # CONFIG_SENSORS_LM77 is not set
+ # CONFIG_SENSORS_LM78 is not set
+ # CONFIG_SENSORS_LM80 is not set
+ # CONFIG_SENSORS_LM83 is not set
+ # CONFIG_SENSORS_LM85 is not set
+ # CONFIG_SENSORS_LM87 is not set
+ # CONFIG_SENSORS_LM90 is not set
+ # CONFIG_SENSORS_LM92 is not set
+ # CONFIG_SENSORS_LM93 is not set
+ # CONFIG_SENSORS_LTC4245 is not set
+ # CONFIG_SENSORS_MAX1111 is not set
+ # CONFIG_SENSORS_MAX1619 is not set
+ # CONFIG_SENSORS_MAX6650 is not set
+ # CONFIG_SENSORS_PC87360 is not set
+ # CONFIG_SENSORS_PC87427 is not set
+ # CONFIG_SENSORS_DME1737 is not set
+ # CONFIG_SENSORS_SMSC47M1 is not set
+ # CONFIG_SENSORS_SMSC47M192 is not set
+ # CONFIG_SENSORS_SMSC47B397 is not set
+ # CONFIG_SENSORS_ADS7828 is not set
+ # CONFIG_SENSORS_THMC50 is not set
+ # CONFIG_SENSORS_VT1211 is not set
+ # CONFIG_SENSORS_W83781D is not set
+ # CONFIG_SENSORS_W83791D is not set
+ # CONFIG_SENSORS_W83792D is not set
+ # CONFIG_SENSORS_W83793 is not set
+ # CONFIG_SENSORS_W83L785TS is not set
+ # CONFIG_SENSORS_W83L786NG is not set
+ # CONFIG_SENSORS_W83627HF is not set
+ # CONFIG_SENSORS_W83627EHF is not set
+ # CONFIG_HWMON_DEBUG_CHIP is not set
+ # CONFIG_THERMAL is not set
+ # CONFIG_THERMAL_HWMON is not set
+ CONFIG_WATCHDOG=y
+ # CONFIG_WATCHDOG_NOWAYOUT is not set
+ 
+ #
+ # Watchdog Device Drivers
+ #
+ # CONFIG_SOFT_WATCHDOG is not set
+ CONFIG_AT91SAM9X_WATCHDOG=y
+ 
+ #
+ # USB-based Watchdog Cards
+ #
+ # CONFIG_USBPCWATCHDOG is not set
+ CONFIG_SSB_POSSIBLE=y
+ 
+ #
+ # Sonics Silicon Backplane
+ #
+ # CONFIG_SSB is not set
+ 
+ #
+ # Multifunction device drivers
+ #
+ # CONFIG_MFD_CORE is not set
+ # CONFIG_MFD_SM501 is not set
+ # CONFIG_MFD_ASIC3 is not set
+ # CONFIG_HTC_EGPIO is not set
+ # CONFIG_HTC_PASIC3 is not set
+ # CONFIG_TPS65010 is not set
+ # CONFIG_TWL4030_CORE is not set
+ # CONFIG_MFD_TMIO is not set
+ # CONFIG_MFD_T7L66XB is not set
+ # CONFIG_MFD_TC6387XB is not set
+ # CONFIG_MFD_TC6393XB is not set
+ # CONFIG_PMIC_DA903X is not set
+ # CONFIG_MFD_WM8400 is not set
+ # CONFIG_MFD_WM8350_I2C is not set
+ # CONFIG_MFD_PCF50633 is not set
+ 
+ #
+ # Multimedia devices
+ #
+ 
+ #
+ # Multimedia core support
+ #
+ # CONFIG_VIDEO_DEV is not set
+ # CONFIG_DVB_CORE is not set
+ # CONFIG_VIDEO_MEDIA is not set
+ 
+ #
+ # Multimedia drivers
+ #
+ # CONFIG_DAB is not set
+ 
+ #
+ # Graphics support
+ #
+ # CONFIG_VGASTATE is not set
+ # CONFIG_VIDEO_OUTPUT_CONTROL is not set
+ # CONFIG_FB is not set
+ # CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+ 
+ #
+ # Display device support
+ #
+ # CONFIG_DISPLAY_SUPPORT is not set
+ # CONFIG_SOUND is not set
+ CONFIG_HID_SUPPORT=y
+ CONFIG_HID=y
+ # CONFIG_HID_DEBUG is not set
+ # CONFIG_HIDRAW is not set
+ 
+ #
+ # USB Input Devices
+ #
+ # CONFIG_USB_HID is not set
+ # CONFIG_HID_PID is not set
+ 
+ #
+ # USB HID Boot Protocol drivers
+ #
+ # CONFIG_USB_KBD is not set
+ # CONFIG_USB_MOUSE is not set
+ 
+ #
+ # Special HID drivers
+ #
+ CONFIG_HID_COMPAT=y
+ CONFIG_USB_SUPPORT=y
+ CONFIG_USB_ARCH_HAS_HCD=y
+ CONFIG_USB_ARCH_HAS_OHCI=y
+ # CONFIG_USB_ARCH_HAS_EHCI is not set
+ CONFIG_USB=y
+ # CONFIG_USB_DEBUG is not set
+ # CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+ 
+ #
+ # Miscellaneous USB options
+ #
+ CONFIG_USB_DEVICEFS=y
+ CONFIG_USB_DEVICE_CLASS=y
+ # CONFIG_USB_DYNAMIC_MINORS is not set
+ # CONFIG_USB_OTG is not set
+ # CONFIG_USB_OTG_WHITELIST is not set
+ # CONFIG_USB_OTG_BLACKLIST_HUB is not set
+ CONFIG_USB_MON=y
+ # CONFIG_USB_WUSB is not set
+ # CONFIG_USB_WUSB_CBAF is not set
+ 
+ #
+ # USB Host Controller Drivers
+ #
+ # CONFIG_USB_C67X00_HCD is not set
+ # CONFIG_USB_OXU210HP_HCD is not set
+ # CONFIG_USB_ISP116X_HCD is not set
+ CONFIG_USB_OHCI_HCD=y
+ # CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+ # CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+ CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+ # CONFIG_USB_SL811_HCD is not set
+ # CONFIG_USB_R8A66597_HCD is not set
+ # CONFIG_USB_HWA_HCD is not set
+ # CONFIG_USB_MUSB_HDRC is not set
+ # CONFIG_USB_GADGET_MUSB_HDRC is not set
+ 
+ #
+ # USB Device Class drivers
+ #
+ CONFIG_USB_ACM=m
+ # CONFIG_USB_PRINTER is not set
+ # CONFIG_USB_WDM is not set
+ # CONFIG_USB_TMC is not set
+ 
+ #
+ # NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
+ #
+ 
+ #
+ # see USB_STORAGE Help for more information
+ #
+ CONFIG_USB_STORAGE=m
+ # CONFIG_USB_STORAGE_DEBUG is not set
+ # CONFIG_USB_STORAGE_DATAFAB is not set
+ # CONFIG_USB_STORAGE_FREECOM is not set
+ # CONFIG_USB_STORAGE_ISD200 is not set
+ # CONFIG_USB_STORAGE_USBAT is not set
+ # CONFIG_USB_STORAGE_SDDR09 is not set
+ # CONFIG_USB_STORAGE_SDDR55 is not set
+ # CONFIG_USB_STORAGE_JUMPSHOT is not set
+ # CONFIG_USB_STORAGE_ALAUDA is not set
+ # CONFIG_USB_STORAGE_ONETOUCH is not set
+ # CONFIG_USB_STORAGE_KARMA is not set
+ # CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+ # CONFIG_USB_LIBUSUAL is not set
+ 
+ #
+ # USB Imaging devices
+ #
+ # CONFIG_USB_MDC800 is not set
+ # CONFIG_USB_MICROTEK is not set
+ 
+ #
+ # USB port drivers
+ #
+ CONFIG_USB_SERIAL=m
+ # CONFIG_USB_EZUSB is not set
+ CONFIG_USB_SERIAL_GENERIC=y
+ # CONFIG_USB_SERIAL_AIRCABLE is not set
+ # CONFIG_USB_SERIAL_ARK3116 is not set
+ # CONFIG_USB_SERIAL_BELKIN is not set
+ # CONFIG_USB_SERIAL_CH341 is not set
+ # CONFIG_USB_SERIAL_WHITEHEAT is not set
+ # CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+ # CONFIG_USB_SERIAL_CP2101 is not set
+ # CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+ # CONFIG_USB_SERIAL_EMPEG is not set
+ # CONFIG_USB_SERIAL_FTDI_SIO is not set
+ # CONFIG_USB_SERIAL_FUNSOFT is not set
+ # CONFIG_USB_SERIAL_VISOR is not set
+ # CONFIG_USB_SERIAL_IPAQ is not set
+ # CONFIG_USB_SERIAL_IR is not set
+ # CONFIG_USB_SERIAL_EDGEPORT is not set
+ # CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+ # CONFIG_USB_SERIAL_GARMIN is not set
+ # CONFIG_USB_SERIAL_IPW is not set
+ # CONFIG_USB_SERIAL_IUU is not set
+ # CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+ # CONFIG_USB_SERIAL_KEYSPAN is not set
+ # CONFIG_USB_SERIAL_KLSI is not set
+ # CONFIG_USB_SERIAL_KOBIL_SCT is not set
+ # CONFIG_USB_SERIAL_MCT_U232 is not set
+ # CONFIG_USB_SERIAL_MOS7720 is not set
+ # CONFIG_USB_SERIAL_MOS7840 is not set
+ # CONFIG_USB_SERIAL_MOTOROLA is not set
+ # CONFIG_USB_SERIAL_NAVMAN is not set
+ CONFIG_USB_SERIAL_PL2303=m
+ # CONFIG_USB_SERIAL_OTI6858 is not set
+ # CONFIG_USB_SERIAL_SPCP8X5 is not set
+ # CONFIG_USB_SERIAL_HP4X is not set
+ # CONFIG_USB_SERIAL_SAFE is not set
+ # CONFIG_USB_SERIAL_SIEMENS_MPI is not set
+ # CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+ # CONFIG_USB_SERIAL_TI is not set
+ # CONFIG_USB_SERIAL_CYBERJACK is not set
+ # CONFIG_USB_SERIAL_XIRCOM is not set
+ # CONFIG_USB_SERIAL_OPTION is not set
+ # CONFIG_USB_SERIAL_OMNINET is not set
+ # CONFIG_USB_SERIAL_OPTICON is not set
+ # CONFIG_USB_SERIAL_DEBUG is not set
+ 
+ #
+ # USB Miscellaneous drivers
+ #
+ # CONFIG_USB_EMI62 is not set
+ # CONFIG_USB_EMI26 is not set
+ # CONFIG_USB_ADUTUX is not set
+ # CONFIG_USB_SEVSEG is not set
+ # CONFIG_USB_RIO500 is not set
+ # CONFIG_USB_LEGOTOWER is not set
+ # CONFIG_USB_LCD is not set
+ # CONFIG_USB_BERRY_CHARGE is not set
+ # CONFIG_USB_LED is not set
+ # CONFIG_USB_CYPRESS_CY7C63 is not set
+ # CONFIG_USB_CYTHERM is not set
+ # CONFIG_USB_PHIDGET is not set
+ # CONFIG_USB_IDMOUSE is not set
+ # CONFIG_USB_FTDI_ELAN is not set
+ # CONFIG_USB_APPLEDISPLAY is not set
+ # CONFIG_USB_LD is not set
+ # CONFIG_USB_TRANCEVIBRATOR is not set
+ # CONFIG_USB_IOWARRIOR is not set
+ # CONFIG_USB_TEST is not set
+ # CONFIG_USB_ISIGHTFW is not set
+ # CONFIG_USB_VST is not set
+ CONFIG_USB_GADGET=m
+ CONFIG_USB_GADGET_DEBUG=y
+ CONFIG_USB_GADGET_DEBUG_FILES=y
+ CONFIG_USB_GADGET_VBUS_DRAW=2
+ CONFIG_USB_GADGET_SELECTED=y
+ CONFIG_USB_GADGET_AT91=y
+ CONFIG_USB_AT91=m
+ # CONFIG_USB_GADGET_ATMEL_USBA is not set
+ # CONFIG_USB_GADGET_FSL_USB2 is not set
+ # CONFIG_USB_GADGET_LH7A40X is not set
+ # CONFIG_USB_GADGET_OMAP is not set
+ # CONFIG_USB_GADGET_PXA25X is not set
+ # CONFIG_USB_GADGET_PXA27X is not set
+ # CONFIG_USB_GADGET_S3C2410 is not set
+ # CONFIG_USB_GADGET_IMX is not set
+ # CONFIG_USB_GADGET_M66592 is not set
+ # CONFIG_USB_GADGET_AMD5536UDC is not set
+ # CONFIG_USB_GADGET_FSL_QE is not set
+ # CONFIG_USB_GADGET_CI13XXX is not set
+ # CONFIG_USB_GADGET_NET2280 is not set
+ # CONFIG_USB_GADGET_GOKU is not set
+ # CONFIG_USB_GADGET_DUMMY_HCD is not set
+ # CONFIG_USB_GADGET_DUALSPEED is not set
+ # CONFIG_USB_ZERO is not set
+ CONFIG_USB_ETH=m
+ CONFIG_USB_ETH_RNDIS=y
+ # CONFIG_USB_GADGETFS is not set
+ # CONFIG_USB_FILE_STORAGE is not set
+ CONFIG_USB_G_SERIAL=m
+ # CONFIG_USB_MIDI_GADGET is not set
+ # CONFIG_USB_G_PRINTER is not set
+ CONFIG_USB_CDC_COMPOSITE=m
+ 
+ #
+ # OTG and related infrastructure
+ #
+ # CONFIG_USB_GPIO_VBUS is not set
+ # CONFIG_MMC is not set
+ # CONFIG_MEMSTICK is not set
+ # CONFIG_ACCESSIBILITY is not set
+ CONFIG_NEW_LEDS=y
+ CONFIG_LEDS_CLASS=y
+ 
+ #
+ # LED drivers
+ #
+ # CONFIG_LEDS_ATMEL_PWM is not set
+ CONFIG_LEDS_LIABDIN_ADDON=y
+ # CONFIG_LEDS_PCA9532 is not set
+ CONFIG_LEDS_GPIO=y
+ # CONFIG_LEDS_PCA955X is not set
+ 
+ #
+ # LED Triggers
+ #
+ CONFIG_LEDS_TRIGGERS=y
+ CONFIG_LEDS_TRIGGER_TIMER=y
+ CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+ # CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+ # CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+ CONFIG_LIAB=y
+ CONFIG_RTC_LIB=y
+ CONFIG_RTC_CLASS=y
+ CONFIG_RTC_HCTOSYS=y
+ CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+ # CONFIG_RTC_DEBUG is not set
+ 
+ #
+ # RTC interfaces
+ #
+ CONFIG_RTC_INTF_SYSFS=y
+ CONFIG_RTC_INTF_PROC=y
+ CONFIG_RTC_INTF_DEV=y
+ CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+ # CONFIG_RTC_DRV_TEST is not set
+ 
+ #
+ # I2C RTC drivers
+ #
+ CONFIG_RTC_DRV_DS1307=y
+ # CONFIG_RTC_DRV_DS1374 is not set
+ # CONFIG_RTC_DRV_DS1672 is not set
+ # CONFIG_RTC_DRV_MAX6900 is not set
+ # CONFIG_RTC_DRV_RS5C372 is not set
+ # CONFIG_RTC_DRV_ISL1208 is not set
+ # CONFIG_RTC_DRV_X1205 is not set
+ # CONFIG_RTC_DRV_PCF8563 is not set
+ # CONFIG_RTC_DRV_PCF8583 is not set
+ # CONFIG_RTC_DRV_M41T80 is not set
+ # CONFIG_RTC_DRV_S35390A is not set
+ # CONFIG_RTC_DRV_FM3130 is not set
+ # CONFIG_RTC_DRV_RX8581 is not set
+ 
+ #
+ # SPI RTC drivers
+ #
+ # CONFIG_RTC_DRV_M41T94 is not set
+ # CONFIG_RTC_DRV_DS1305 is not set
+ # CONFIG_RTC_DRV_DS1390 is not set
+ # CONFIG_RTC_DRV_MAX6902 is not set
+ # CONFIG_RTC_DRV_R9701 is not set
+ # CONFIG_RTC_DRV_RS5C348 is not set
+ # CONFIG_RTC_DRV_DS3234 is not set
+ 
+ #
+ # Platform RTC drivers
+ #
+ # CONFIG_RTC_DRV_CMOS is not set
+ # CONFIG_RTC_DRV_DS1286 is not set
+ # CONFIG_RTC_DRV_DS1511 is not set
+ # CONFIG_RTC_DRV_DS1553 is not set
+ # CONFIG_RTC_DRV_DS1742 is not set
+ # CONFIG_RTC_DRV_STK17TA8 is not set
+ # CONFIG_RTC_DRV_M48T86 is not set
+ # CONFIG_RTC_DRV_M48T35 is not set
+ # CONFIG_RTC_DRV_M48T59 is not set
+ # CONFIG_RTC_DRV_BQ4802 is not set
+ # CONFIG_RTC_DRV_V3020 is not set
+ 
+ #
+ # on-CPU RTC drivers
+ #
+ # CONFIG_RTC_DRV_AT91SAM9 is not set
+ # CONFIG_DMADEVICES is not set
+ # CONFIG_REGULATOR is not set
+ # CONFIG_UIO is not set
+ # CONFIG_STAGING is not set
+ 
+ #
+ # File systems
+ #
+ CONFIG_EXT2_FS=y
+ CONFIG_EXT2_FS_XATTR=y
+ CONFIG_EXT2_FS_POSIX_ACL=y
+ CONFIG_EXT2_FS_SECURITY=y
+ # CONFIG_EXT2_FS_XIP is not set
+ CONFIG_EXT3_FS=y
+ CONFIG_EXT3_FS_XATTR=y
+ CONFIG_EXT3_FS_POSIX_ACL=y
+ CONFIG_EXT3_FS_SECURITY=y
+ # CONFIG_EXT4_FS is not set
+ CONFIG_JBD=y
+ CONFIG_FS_MBCACHE=y
+ # CONFIG_REISERFS_FS is not set
+ # CONFIG_JFS_FS is not set
+ CONFIG_FS_POSIX_ACL=y
+ CONFIG_FILE_LOCKING=y
+ # CONFIG_XFS_FS is not set
+ # CONFIG_OCFS2_FS is not set
+ # CONFIG_BTRFS_FS is not set
+ # CONFIG_DNOTIFY is not set
+ # CONFIG_INOTIFY is not set
+ # CONFIG_QUOTA is not set
+ # CONFIG_AUTOFS_FS is not set
+ # CONFIG_AUTOFS4_FS is not set
+ # CONFIG_FUSE_FS is not set
+ 
+ #
+ # CD-ROM/DVD Filesystems
+ #
+ # CONFIG_ISO9660_FS is not set
+ # CONFIG_UDF_FS is not set
+ 
+ #
+ # DOS/FAT/NT Filesystems
+ #
+ CONFIG_FAT_FS=y
+ CONFIG_MSDOS_FS=y
+ CONFIG_VFAT_FS=y
+ CONFIG_FAT_DEFAULT_CODEPAGE=850
+ CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+ # CONFIG_NTFS_FS is not set
+ 
+ #
+ # Pseudo filesystems
+ #
+ CONFIG_PROC_FS=y
+ CONFIG_PROC_SYSCTL=y
+ CONFIG_PROC_PAGE_MONITOR=y
+ CONFIG_SYSFS=y
+ CONFIG_TMPFS=y
+ # CONFIG_TMPFS_POSIX_ACL is not set
+ # CONFIG_HUGETLB_PAGE is not set
+ # CONFIG_CONFIGFS_FS is not set
+ CONFIG_MISC_FILESYSTEMS=y
+ # CONFIG_ADFS_FS is not set
+ # CONFIG_AFFS_FS is not set
+ # CONFIG_HFS_FS is not set
+ # CONFIG_HFSPLUS_FS is not set
+ # CONFIG_BEFS_FS is not set
+ # CONFIG_BFS_FS is not set
+ # CONFIG_EFS_FS is not set
+ CONFIG_YAFFS_FS=y
+ CONFIG_YAFFS_YAFFS1=y
+ # CONFIG_YAFFS_9BYTE_TAGS is not set
+ # CONFIG_YAFFS_DOES_ECC is not set
+ CONFIG_YAFFS_YAFFS2=y
+ CONFIG_YAFFS_AUTO_YAFFS2=y
+ # CONFIG_YAFFS_DISABLE_TAGS_ECC is not set
+ # CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
+ # CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED is not set
+ CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
+ # CONFIG_YAFFS_EMPTY_LOST_AND_FOUND is not set
+ # CONFIG_YAFFS_DISABLE_BLOCK_REFRESHING is not set
+ # CONFIG_YAFFS_DISABLE_BACKGROUND is not set
+ CONFIG_JFFS2_FS=y
+ CONFIG_JFFS2_FS_DEBUG=0
+ CONFIG_JFFS2_FS_WRITEBUFFER=y
+ # CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+ # CONFIG_JFFS2_SUMMARY is not set
+ # CONFIG_JFFS2_FS_XATTR is not set
+ # CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+ CONFIG_JFFS2_ZLIB=y
+ # CONFIG_JFFS2_LZO is not set
+ CONFIG_JFFS2_RTIME=y
+ # CONFIG_JFFS2_RUBIN is not set
+ # CONFIG_CRAMFS is not set
+ # CONFIG_SQUASHFS is not set
+ # CONFIG_VXFS_FS is not set
+ # CONFIG_MINIX_FS is not set
+ # CONFIG_OMFS_FS is not set
+ # CONFIG_HPFS_FS is not set
+ # CONFIG_QNX4FS_FS is not set
+ # CONFIG_ROMFS_FS is not set
+ # CONFIG_SYSV_FS is not set
+ # CONFIG_UFS_FS is not set
+ CONFIG_NETWORK_FILESYSTEMS=y
+ CONFIG_NFS_FS=y
+ CONFIG_NFS_V3=y
+ # CONFIG_NFS_V3_ACL is not set
+ # CONFIG_NFS_V4 is not set
+ CONFIG_ROOT_NFS=y
+ # CONFIG_NFSD is not set
+ CONFIG_LOCKD=y
+ CONFIG_LOCKD_V4=y
+ CONFIG_NFS_COMMON=y
+ CONFIG_SUNRPC=y
+ # CONFIG_SUNRPC_REGISTER_V4 is not set
+ # CONFIG_RPCSEC_GSS_KRB5 is not set
+ # CONFIG_RPCSEC_GSS_SPKM3 is not set
+ # CONFIG_SMB_FS is not set
+ # CONFIG_CIFS is not set
+ # CONFIG_NCP_FS is not set
+ # CONFIG_CODA_FS is not set
+ # CONFIG_AFS_FS is not set
+ 
+ #
+ # Partition Types
+ #
+ # CONFIG_PARTITION_ADVANCED is not set
+ CONFIG_MSDOS_PARTITION=y
+ CONFIG_NLS=y
+ CONFIG_NLS_DEFAULT="iso8859-1"
+ # CONFIG_NLS_CODEPAGE_437 is not set
+ # CONFIG_NLS_CODEPAGE_737 is not set
+ # CONFIG_NLS_CODEPAGE_775 is not set
+ CONFIG_NLS_CODEPAGE_850=y
+ # CONFIG_NLS_CODEPAGE_852 is not set
+ # CONFIG_NLS_CODEPAGE_855 is not set
+ # CONFIG_NLS_CODEPAGE_857 is not set
+ # CONFIG_NLS_CODEPAGE_860 is not set
+ # CONFIG_NLS_CODEPAGE_861 is not set
+ # CONFIG_NLS_CODEPAGE_862 is not set
+ # CONFIG_NLS_CODEPAGE_863 is not set
+ # CONFIG_NLS_CODEPAGE_864 is not set
+ # CONFIG_NLS_CODEPAGE_865 is not set
+ # CONFIG_NLS_CODEPAGE_866 is not set
+ # CONFIG_NLS_CODEPAGE_869 is not set
+ # CONFIG_NLS_CODEPAGE_936 is not set
+ # CONFIG_NLS_CODEPAGE_950 is not set
+ # CONFIG_NLS_CODEPAGE_932 is not set
+ # CONFIG_NLS_CODEPAGE_949 is not set
+ # CONFIG_NLS_CODEPAGE_874 is not set
+ # CONFIG_NLS_ISO8859_8 is not set
+ # CONFIG_NLS_CODEPAGE_1250 is not set
+ # CONFIG_NLS_CODEPAGE_1251 is not set
+ # CONFIG_NLS_ASCII is not set
+ CONFIG_NLS_ISO8859_1=y
+ # CONFIG_NLS_ISO8859_2 is not set
+ # CONFIG_NLS_ISO8859_3 is not set
+ # CONFIG_NLS_ISO8859_4 is not set
+ # CONFIG_NLS_ISO8859_5 is not set
+ # CONFIG_NLS_ISO8859_6 is not set
+ # CONFIG_NLS_ISO8859_7 is not set
+ # CONFIG_NLS_ISO8859_9 is not set
+ # CONFIG_NLS_ISO8859_13 is not set
+ # CONFIG_NLS_ISO8859_14 is not set
+ # CONFIG_NLS_ISO8859_15 is not set
+ # CONFIG_NLS_KOI8_R is not set
+ # CONFIG_NLS_KOI8_U is not set
+ # CONFIG_NLS_UTF8 is not set
+ # CONFIG_DLM is not set
+ 
+ #
+ # Kernel hacking
+ #
+ # CONFIG_PRINTK_TIME is not set
+ CONFIG_ENABLE_WARN_DEPRECATED=y
+ CONFIG_ENABLE_MUST_CHECK=y
+ CONFIG_FRAME_WARN=1024
+ # CONFIG_MAGIC_SYSRQ is not set
+ # CONFIG_UNUSED_SYMBOLS is not set
+ # CONFIG_DEBUG_FS is not set
+ # CONFIG_HEADERS_CHECK is not set
+ CONFIG_DEBUG_KERNEL=y
+ # CONFIG_DEBUG_SHIRQ is not set
+ CONFIG_DETECT_SOFTLOCKUP=y
+ # CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+ CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+ CONFIG_SCHED_DEBUG=y
+ # CONFIG_SCHEDSTATS is not set
+ # CONFIG_TIMER_STATS is not set
+ # CONFIG_DEBUG_OBJECTS is not set
+ # CONFIG_DEBUG_SLAB is not set
+ CONFIG_DEBUG_PREEMPT=y
+ # CONFIG_DEBUG_RT_MUTEXES is not set
+ # CONFIG_RT_MUTEX_TESTER is not set
+ # CONFIG_DEBUG_SPINLOCK is not set
+ CONFIG_DEBUG_MUTEXES=y
+ # CONFIG_DEBUG_LOCK_ALLOC is not set
+ # CONFIG_PROVE_LOCKING is not set
+ # CONFIG_LOCK_STAT is not set
+ # CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+ # CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+ # CONFIG_DEBUG_KOBJECT is not set
+ # CONFIG_DEBUG_BUGVERBOSE is not set
+ # CONFIG_DEBUG_INFO is not set
+ # CONFIG_DEBUG_VM is not set
+ # CONFIG_DEBUG_WRITECOUNT is not set
+ # CONFIG_DEBUG_MEMORY_INIT is not set
+ # CONFIG_DEBUG_LIST is not set
+ # CONFIG_DEBUG_SG is not set
+ # CONFIG_DEBUG_NOTIFIERS is not set
+ CONFIG_FRAME_POINTER=y
+ # CONFIG_BOOT_PRINTK_DELAY is not set
+ # CONFIG_RCU_TORTURE_TEST is not set
+ # CONFIG_BACKTRACE_SELF_TEST is not set
+ # CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+ # CONFIG_FAULT_INJECTION is not set
+ # CONFIG_LATENCYTOP is not set
+ # CONFIG_SYSCTL_SYSCALL_CHECK is not set
+ CONFIG_HAVE_FUNCTION_TRACER=y
+ 
+ #
+ # Tracers
+ #
+ # CONFIG_FUNCTION_TRACER is not set
+ # CONFIG_IRQSOFF_TRACER is not set
+ # CONFIG_PREEMPT_TRACER is not set
+ # CONFIG_SCHED_TRACER is not set
+ # CONFIG_CONTEXT_SWITCH_TRACER is not set
+ # CONFIG_BOOT_TRACER is not set
+ # CONFIG_TRACE_BRANCH_PROFILING is not set
+ # CONFIG_STACK_TRACER is not set
+ # CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+ # CONFIG_SAMPLES is not set
+ CONFIG_HAVE_ARCH_KGDB=y
+ # CONFIG_KGDB is not set
+ # CONFIG_DEBUG_USER is not set
+ # CONFIG_DEBUG_ERRORS is not set
+ # CONFIG_DEBUG_STACK_USAGE is not set
+ CONFIG_DEBUG_LL=y
+ # CONFIG_DEBUG_ICEDCC is not set
+ 
+ #
+ # Security options
+ #
+ # CONFIG_KEYS is not set
+ # CONFIG_SECURITY is not set
+ # CONFIG_SECURITYFS is not set
+ # CONFIG_SECURITY_FILE_CAPABILITIES is not set
+ CONFIG_CRYPTO=y
+ 
+ #
+ # Crypto core or helper
+ #
+ # CONFIG_CRYPTO_FIPS is not set
+ CONFIG_CRYPTO_ALGAPI=y
+ CONFIG_CRYPTO_ALGAPI2=y
+ CONFIG_CRYPTO_AEAD2=y
+ CONFIG_CRYPTO_BLKCIPHER=y
+ CONFIG_CRYPTO_BLKCIPHER2=y
+ CONFIG_CRYPTO_HASH=y
+ CONFIG_CRYPTO_HASH2=y
+ CONFIG_CRYPTO_RNG2=y
+ CONFIG_CRYPTO_MANAGER=y
+ CONFIG_CRYPTO_MANAGER2=y
+ # CONFIG_CRYPTO_GF128MUL is not set
+ # CONFIG_CRYPTO_NULL is not set
+ # CONFIG_CRYPTO_CRYPTD is not set
+ # CONFIG_CRYPTO_AUTHENC is not set
+ # CONFIG_CRYPTO_TEST is not set
+ 
+ #
+ # Authenticated Encryption with Associated Data
+ #
+ # CONFIG_CRYPTO_CCM is not set
+ # CONFIG_CRYPTO_GCM is not set
+ # CONFIG_CRYPTO_SEQIV is not set
+ 
+ #
+ # Block modes
+ #
+ # CONFIG_CRYPTO_CBC is not set
+ # CONFIG_CRYPTO_CTR is not set
+ # CONFIG_CRYPTO_CTS is not set
+ CONFIG_CRYPTO_ECB=y
+ # CONFIG_CRYPTO_LRW is not set
+ # CONFIG_CRYPTO_PCBC is not set
+ # CONFIG_CRYPTO_XTS is not set
+ 
+ #
+ # Hash modes
+ #
+ # CONFIG_CRYPTO_HMAC is not set
+ # CONFIG_CRYPTO_XCBC is not set
+ 
+ #
+ # Digest
+ #
+ CONFIG_CRYPTO_CRC32C=y
+ # CONFIG_CRYPTO_MD4 is not set
+ # CONFIG_CRYPTO_MD5 is not set
+ # CONFIG_CRYPTO_MICHAEL_MIC is not set
+ # CONFIG_CRYPTO_RMD128 is not set
+ # CONFIG_CRYPTO_RMD160 is not set
+ # CONFIG_CRYPTO_RMD256 is not set
+ # CONFIG_CRYPTO_RMD320 is not set
+ CONFIG_CRYPTO_SHA1=y
+ # CONFIG_CRYPTO_SHA256 is not set
+ # CONFIG_CRYPTO_SHA512 is not set
+ # CONFIG_CRYPTO_TGR192 is not set
+ # CONFIG_CRYPTO_WP512 is not set
+ 
+ #
+ # Ciphers
+ #
+ CONFIG_CRYPTO_AES=y
+ # CONFIG_CRYPTO_ANUBIS is not set
+ CONFIG_CRYPTO_ARC4=y
+ # CONFIG_CRYPTO_BLOWFISH is not set
+ # CONFIG_CRYPTO_CAMELLIA is not set
+ # CONFIG_CRYPTO_CAST5 is not set
+ # CONFIG_CRYPTO_CAST6 is not set
+ # CONFIG_CRYPTO_DES is not set
+ # CONFIG_CRYPTO_FCRYPT is not set
+ # CONFIG_CRYPTO_KHAZAD is not set
+ # CONFIG_CRYPTO_SALSA20 is not set
+ # CONFIG_CRYPTO_SEED is not set
+ # CONFIG_CRYPTO_SERPENT is not set
+ # CONFIG_CRYPTO_TEA is not set
+ # CONFIG_CRYPTO_TWOFISH is not set
+ 
+ #
+ # Compression
+ #
+ # CONFIG_CRYPTO_DEFLATE is not set
+ # CONFIG_CRYPTO_LZO is not set
+ 
+ #
+ # Random Number Generation
+ #
+ # CONFIG_CRYPTO_ANSI_CPRNG is not set
+ CONFIG_CRYPTO_HW=y
+ 
+ #
+ # Library routines
+ #
+ CONFIG_BITREVERSE=y
+ CONFIG_GENERIC_FIND_LAST_BIT=y
+ CONFIG_CRC_CCITT=y
+ CONFIG_CRC16=y
+ # CONFIG_CRC_T10DIF is not set
+ CONFIG_CRC_ITU_T=y
+ CONFIG_CRC32=y
+ # CONFIG_CRC7 is not set
+ CONFIG_LIBCRC32C=y
+ CONFIG_ZLIB_INFLATE=y
+ CONFIG_ZLIB_DEFLATE=y
+ CONFIG_PLIST=y
+ CONFIG_HAS_IOMEM=y
+ CONFIG_HAS_IOPORT=y
+ CONFIG_HAS_DMA=y
diff -r -C3 -P linux-2.6.29.4/liabsg.patch liab-linux-2.6.29.4/liabsg.patch
*** linux-2.6.29.4/liabsg.patch	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/liabsg.patch	2012-01-20 14:49:42.841307094 +0100
***************
*** 0 ****
--- 1,9145 ----
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/arch/arm/Kconfig liab-linux-2.6.29.4/arch/arm/Kconfig
+ *** linux-2.6.29.4/arch/arm/Kconfig	2009-05-19 01:52:34.000000000 +0200
+ --- liab-linux-2.6.29.4/arch/arm/Kconfig	2010-05-28 13:41:52.293653374 +0200
+ ***************
+ *** 241,246 ****
+ --- 241,247 ----
+   config ARCH_AT91
+   	bool "Atmel AT91"
+   	select GENERIC_GPIO
+ + 	select ARCH_REQUIRE_GPIOLIB
+   	select HAVE_CLK
+   	help
+   	  This enables support for systems based on the Atmel AT91RM9200,
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/arch/arm/mach-at91/at91rm9200_devices.c liab-linux-2.6.29.4/arch/arm/mach-at91/at91rm9200_devices.c
+ *** linux-2.6.29.4/arch/arm/mach-at91/at91rm9200_devices.c	2009-05-19 01:52:34.000000000 +0200
+ --- liab-linux-2.6.29.4/arch/arm/mach-at91/at91rm9200_devices.c	2009-09-28 17:30:24.000000000 +0200
+ ***************
+ *** 22,27 ****
+ --- 22,29 ----
+   #include <mach/at91rm9200.h>
+   #include <mach/at91rm9200_mc.h>
+   
+ + #include <linux/i2c-gpio.h>
+ + 
+   #include "generic.h"
+   
+   
+ ***************
+ *** 160,166 ****
+   		return;
+   
+   	if (data->phy_irq_pin) {
+ ! 		at91_set_gpio_input(data->phy_irq_pin, 0);
+   		at91_set_deglitch(data->phy_irq_pin, 1);
+   	}
+   
+ --- 162,168 ----
+   		return;
+   
+   	if (data->phy_irq_pin) {
+ ! 		at91_set_gpio_input(data->phy_irq_pin, 1);
+   		at91_set_deglitch(data->phy_irq_pin, 1);
+   	}
+   
+ ***************
+ *** 432,437 ****
+ --- 434,466 ----
+   void __init at91_add_device_nand(struct atmel_nand_data *data) {}
+   #endif
+   
+ + /* msawh */
+ + 
+ + /* --------------------------------------------------------------------
+ +  *  TLC320 SoC Audio
+ +  * -------------------------------------------------------------------- */
+ + 
+ + #if defined(CONFIG_ARCH_AT91) && defined(CONFIG_SND_SOC)
+ + static struct tlv320_setup_data audio_data;
+ + 
+ + static struct platform_device tlv320_audio_device = {
+ +   .name           = "tlv320",
+ +   .id             = -1,
+ + 	.dev		= {
+ +     .platform_data	= &audio_data,
+ + 	},
+ + };
+ + 
+ + void __init at91_add_device_audio(struct tlv320_setup_data *data)
+ + {
+ +   int ret;
+ +   audio_data = *data;
+ + 	ret = platform_device_register(&tlv320_audio_device);
+ + }
+ + #else
+ + void __init at91_add_device_audio(struct tlv320_setup_data *data) {}
+ + #endif
+ + /* end msawh */
+   
+   /* --------------------------------------------------------------------
+    *  TWI (i2c)
+ ***************
+ *** 494,499 ****
+ --- 523,529 ----
+   
+   void __init at91_add_device_i2c(struct i2c_board_info *devices, int nr_devices)
+   {
+ +   int ret;
+   	/* pins used for TWI interface */
+   	at91_set_A_periph(AT91_PIN_PA25, 0);		/* TWD */
+   	at91_set_multi_drive(AT91_PIN_PA25, 1);
+ ***************
+ *** 510,515 ****
+ --- 540,610 ----
+   
+   
+   /* --------------------------------------------------------------------
+ +  *  TWI (i2c) GPIO interface
+ +  * -------------------------------------------------------------------- */
+ + 
+ + #if defined(CONFIG_I2C_AT91_GPIO)
+ + 
+ + // Control interface for TLV320 audio codec
+ + // DS1337 RTC
+ + static struct i2c_gpio_platform_data at91_i2c_gpio_pins = {
+ + 	.sda_pin	= AT91_PIN_PA21,
+ + 	.scl_pin	= AT91_PIN_PA24,
+ + 	.udelay   = 500, // (500/udelay) kHz
+ + 	.timeout  = 10,  // jiffies
+ + 	.sda_is_open_drain = 0,
+ + 	.sda_is_open_drain = 0,
+ + 	.sda_is_open_drain = 0
+ + };
+ + 
+ + static struct platform_device at91_gpio_i2c_controller = {
+ + 	.name		= "i2c-gpio",
+ + 	.id		= 0,
+ + 	.dev		= {
+ + 		.platform_data = &at91_i2c_gpio_pins,
+ + 	},
+ + 	.num_resources	= 0
+ + };
+ + 
+ + 
+ + #ifdef undef
+ + static struct i2c_gpio_platform_data at91_i2c_gpio_pins2 = {
+ + 	.sda_pin	= AT91_PIN_PB2,
+ + 	.scl_pin	= AT91_PIN_PB1,
+ + 	.udelay   = 500, // (500/udelay) kHz
+ + 	.timeout  = 10,  // jiffies
+ + 	.sda_is_open_drain = 0,
+ + 	.sda_is_open_drain = 0,
+ + 	.sda_is_open_drain = 0
+ + };
+ + 
+ + static struct platform_device at91_gpio_i2c_controller2 = {
+ + 	.name		= "i2c-gpio",
+ + 	.id		= 1,
+ + 	.dev		= {
+ + 		.platform_data = &at91_i2c_gpio_pins2,
+ + 	},
+ + 	.num_resources	= 0
+ + };
+ + #endif
+ + 
+ + void __init at91_add_device_gpio_i2c(void)
+ + {
+ + 	at91_set_gpio_output(at91_i2c_gpio_pins.sda_pin, 1);		/* TWD */
+ + 	at91_set_gpio_output(at91_i2c_gpio_pins.scl_pin, 1);		/* TWCK */
+ + 
+ + 	platform_device_register(&at91_gpio_i2c_controller);
+ + 
+ + 	//	at91_set_gpio_output(at91_i2c_gpio_pins2.sda_pin, 1);		/* TWD */
+ + 	//	at91_set_gpio_output(at91_i2c_gpio_pins2.scl_pin, 1);		/* TWCK */
+ + 
+ + 	//	platform_device_register(&at91_gpio_i2c_controller2);
+ + }
+ + #else
+ + void __init at91_add_device_gpio_i2c(void){}
+ + #endif
+ + 
+ + /* --------------------------------------------------------------------
+    *  SPI
+    * -------------------------------------------------------------------- */
+   
+ ***************
+ *** 1100,1106 ****
+ --- 1195,1206 ----
+   	if (pins & ATMEL_UART_CTS)
+   		at91_set_B_periph(AT91_PIN_PB1, 0);	/* CTS3 */
+   	if (pins & ATMEL_UART_RTS)
+ + #ifdef CONFIG_LIAB_ENABLE_UART3
+ + 		at91_set_A_periph(AT91_PIN_PD24, 0);	/* RTS3 */
+ + #else
+ + prut
+   		at91_set_B_periph(AT91_PIN_PB0, 0);	/* RTS3 */
+ + #endif
+   }
+   
+   static struct platform_device *__initdata at91_uarts[ATMEL_MAX_UART];	/* the UARTs to use */
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/arch/arm/mach-at91/board-dk.c liab-linux-2.6.29.4/arch/arm/mach-at91/board-dk.c
+ *** linux-2.6.29.4/arch/arm/mach-at91/board-dk.c	2009-05-19 01:52:34.000000000 +0200
+ --- liab-linux-2.6.29.4/arch/arm/mach-at91/board-dk.c	2009-07-31 11:37:22.000000000 +0200
+ ***************
+ *** 71,78 ****
+   }
+   
+   static struct at91_eth_data __initdata dk_eth_data = {
+ ! 	.phy_irq_pin	= AT91_PIN_PC4,
+ ! 	.is_rmii	= 1,
+   };
+   
+   static struct at91_usbh_data __initdata dk_usbh_data = {
+ --- 71,78 ----
+   }
+   
+   static struct at91_eth_data __initdata dk_eth_data = {
+ ! 	.phy_irq_pin	= AT91_PIN_PC0,
+ ! 	.is_rmii	= 0,
+   };
+   
+   static struct at91_usbh_data __initdata dk_usbh_data = {
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/arch/arm/mach-at91/board-liabdin.c liab-linux-2.6.29.4/arch/arm/mach-at91/board-liabdin.c
+ *** linux-2.6.29.4/arch/arm/mach-at91/board-liabdin.c	1970-01-01 01:00:00.000000000 +0100
+ --- liab-linux-2.6.29.4/arch/arm/mach-at91/board-liabdin.c	2010-03-24 13:36:17.000000000 +0100
+ ***************
+ *** 0 ****
+ --- 1,564 ----
+ + /*
+ +  * linux/arch/arm/mach-at91/board-nanoliab.c
+ +  *
+ +  *  Shamelessly ripped off from the original AT91RM9200-DK
+ +  *  by Mikkel S. Andersen <msa@liab.dk> 2007.
+ +  * 
+ +  *  Copyright (C) 2005 SAN People
+ +  *
+ +  *  Epson S1D framebuffer glue code is:
+ +  *     Copyright (C) 2005 Thibaut VARENE <varenet@parisc-linux.org>
+ +  *
+ +  * This program is free software; you can redistribute it and/or modify
+ +  * it under the terms of the GNU General Public License as published by
+ +  * the Free Software Foundation; either version 2 of the License, or
+ +  * (at your option) any later version.
+ +  *
+ +  * This program is distributed in the hope that it will be useful,
+ +  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ +  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ +  * GNU General Public License for more details.
+ +  *
+ +  * You should have received a copy of the GNU General Public License
+ +  * along with this program; if not, write to the Free Software
+ +  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ +  */
+ + 
+ + #include <linux/types.h>
+ + #include <linux/init.h>
+ + #include <linux/mm.h>
+ + #include <linux/module.h>
+ + #include <linux/platform_device.h>
+ + #include <linux/spi/spi.h>
+ + #include <linux/mtd/physmap.h>
+ + #include <linux/i2c.h>
+ + #include <linux/input.h>
+ + #include <linux/gpio_keys.h>
+ + 
+ + #include <asm/setup.h>
+ + #include <asm/mach-types.h>
+ + #include <asm/irq.h>
+ + 
+ + #include <asm/mach/arch.h>
+ + #include <asm/mach/map.h>
+ + #include <asm/mach/irq.h>
+ + 
+ + #include <mach/hardware.h>
+ + #include <mach/board.h>
+ + #include <mach/gpio.h>
+ + #include <mach/at91rm9200_mc.h>
+ + 
+ + #ifdef CONFIG_LIAB_TDC_LIABDIN_ADDON
+ + #  include <linux/dm9000.h>
+ + #endif 
+ + 
+ + #include <linux/sound.h>
+ + 
+ + #include "generic.h"
+ + 
+ + 
+ + static void __init liabdin_map_io(void)
+ + {
+ + 	/* Initialize processor: 14.7456 MHz crystal */
+ + 	at91rm9200_initialize(14745600, AT91RM9200_BGA);
+ + 
+ +   /* Debug on ttyS0 */
+ +   at91_register_uart(0, 0, 0);
+ +   at91_set_serial_console(0);
+ + 
+ + #ifdef CONFIG_LIAB_ENABLE_UART0
+ +   at91_register_uart(AT91RM9200_ID_US0, 1, 
+ +                      ATMEL_UART_CTS | 
+ +                      ATMEL_UART_RTS);
+ + #endif
+ + #ifdef CONFIG_LIAB_ENABLE_UART1
+ +   at91_register_uart(AT91RM9200_ID_US1, 2, 
+ +                      ATMEL_UART_CTS | 
+ +                      ATMEL_UART_RTS | 
+ +                      ATMEL_UART_DSR | 
+ +                      ATMEL_UART_DTR);
+ + #endif
+ + #ifdef CONFIG_LIAB_ENABLE_UART2
+ +   at91_register_uart(AT91RM9200_ID_US2, 3, 0);
+ + #endif
+ + #ifdef CONFIG_LIAB_ENABLE_UART3
+ + 	/* USART3 on ttyS3. (Rx, Tx, RTS - RS485 interface) */
+ + 	at91_register_uart(AT91RM9200_ID_US3, 4, ATMEL_UART_RTS);
+ + #endif
+ + 
+ + 	/* Setup the LEDs */
+ + 	at91_init_leds(AT91_PIN_PC13, AT91_PIN_PC13);
+ + }
+ + 
+ + static void __init liabdin_init_irq(void)
+ + {
+ + 	at91rm9200_init_interrupts(NULL);
+ + }
+ + 
+ + static struct at91_eth_data __initdata liabdin_eth_data = {
+ +   /* msawh - removed to that at timer
+ +      check will be done instead */
+ +   //.phy_irq_pin = AT91_PIN_PC0, 
+ + 	.is_rmii	= 0,
+ + };
+ + 
+ + static struct at91_usbh_data __initdata liabdin_usbh_data = {
+ + 	.ports		= 2,
+ + };
+ + 
+ + #ifdef CONFIG_LIAB_TDC_LIABDIN_ADDON
+ + static struct at91_udc_data __initdata liabdin_udc_data = {
+ + 	.vbus_pin	= AT91_PIN_PA29,
+ + 	.pullup_pin	= AT91_PIN_PA28,
+ + };
+ + #endif
+ + 
+ + static struct at91_mmc_data __initdata liabdin_mmc_data = {
+ + 	.slot_b		= 0,
+ + 	.wire4		= 1,
+ + };
+ + 
+ + 
+ + static struct i2c_board_info __initdata liabdin_i2c_devices[] = 
+ + {	{ I2C_BOARD_INFO("rtc-ds1307", 0x68),
+ + 	  .type = "ds1307",
+ + 	},
+ + 	{ I2C_BOARD_INFO("eeprom", 0x50),
+ + 	  .type = "eeprom",
+ + 	},
+ + };
+ + 
+ + 
+ + static struct resource timer_resources[] = {
+ +   [0] = {
+ +     .start	= AT91RM9200_BASE_TC0,
+ +     .end	= AT91RM9200_BASE_TC0 + 64 - 1,
+ +     .flags	= IORESOURCE_MEM,
+ +   },
+ +   [1] = {
+ +     .start	= AT91RM9200_BASE_TC1,
+ +     .end	= AT91RM9200_BASE_TC1 + 64 - 1,
+ +     .flags	= IORESOURCE_MEM,
+ +   },
+ +   [2] = {
+ +     .start	= AT91RM9200_BASE_TC2,
+ +     .end	= AT91RM9200_BASE_TC2 + 64 - 1,
+ +     .flags	= IORESOURCE_MEM,
+ +   },
+ + };
+ + 
+ + static u32 no = 1;
+ + static struct platform_device at91_timer_device = {
+ +   .name		= "at91_pwm",
+ +   .id		= -1,
+ +   .dev		= {
+ +     .platform_data		= &no,
+ +   },
+ +   .resource	= timer_resources,
+ + 	.num_resources	= ARRAY_SIZE(timer_resources),
+ + };
+ + 
+ + void __init at91_add_device_pwm(u32 mask)
+ + {
+ + 
+ +   at91_set_B_periph(AT91_PIN_PA19, 0);
+ +   platform_device_register(&at91_timer_device);
+ + }
+ + 
+ + /**** Modem device ****/
+ + static struct platform_device liabdin_modem_device = {
+ +   .name		= "liabdin_modem",
+ +   .id		= -1,
+ +   .dev		= {
+ +     .platform_data		= NULL,
+ +   },
+ + 	.num_resources	= 0,
+ + };
+ + 
+ + void __init at91_add_device_modem(void)
+ + {
+ +   platform_device_register(&liabdin_modem_device);
+ + }
+ + 
+ + 
+ + #ifdef CONFIG_LIAB_TDC_LIABDIN_ADDON
+ + /* DM9000 ethernet devices */
+ + 
+ + static struct resource liabdin_dm9k_resource[] = {
+ + 	[0] = {
+ + 		.start = AT91_CHIPSELECT_2,
+ + 		.end   = AT91_CHIPSELECT_2 + 3,
+ + 		.flags = IORESOURCE_MEM
+ + 	},
+ + 	[1] = {
+ + 		.start = AT91_CHIPSELECT_2 + 4,
+ + 		.end   = AT91_CHIPSELECT_2 + 0x7f,
+ + 		.flags = IORESOURCE_MEM
+ + 	},
+ + 	[2] = {
+ + 		.start = AT91RM9200_ID_IRQ0,
+ + 		.end   = AT91RM9200_ID_IRQ0,
+ + 		.flags = IORESOURCE_IRQ /*| IORESOURCE_IRQ_HIGHLEVEL*/,
+ + 	},
+ + };
+ + 
+ + 
+ + /* for the moment we limit ourselves to 16bit IO until some
+ +  * better IO routines can be written and tested
+ + */
+ + 
+ + static struct dm9000_plat_data liabdin_dm9k_platdata = {
+ + 	.flags		= DM9000_PLATF_16BITONLY,
+ + };
+ + 
+ + static struct platform_device liabdin_dm9k = {
+ + 	.name		= "dm9000",
+ + 	.id		= 0,
+ + 	.num_resources	= ARRAY_SIZE(liabdin_dm9k_resource),
+ + 	.resource	= liabdin_dm9k_resource,
+ + 	.dev		= {
+ + 		.platform_data = &liabdin_dm9k_platdata,
+ + 	}
+ + };
+ + 
+ + void __init at91_add_device_dm9000(void)
+ + {
+ +   unsigned int csa;
+ + 
+ +   /* enable the address range of CS2 */
+ + 	csa = at91_sys_read(AT91_EBI_CSA);
+ + 	at91_sys_write(AT91_EBI_CSA, csa | AT91_EBI_CS3A_SMC); // msawh <--- wtf... should map to cs2?!
+ + 	/*
+ + 	 * Static memory controller timing adjustments.
+ + 	 * REVISIT:  these timings are in terms of MCK cycles, so
+ + 	 * when MCK changes (cpufreq etc) so must these values...
+ + 	 */
+ + 	at91_sys_write(AT91_SMC_CSR(2),
+ + 				  AT91_SMC_ACSS_STD
+ + 				| AT91_SMC_DBW_16
+ + 				| AT91_SMC_BAT
+ + 				| AT91_SMC_WSEN
+ + 				| AT91_SMC_NWS_(32)	/* wait states */
+ + 				| AT91_SMC_RWSETUP_(6)	/* setup time */
+ + 				| AT91_SMC_RWHOLD_(4)	/* hold time */
+ + 	);
+ + 
+ +   platform_device_register(&liabdin_dm9k);
+ + }
+ + #else
+ + void __init at91_add_device_dm9000(void) {return; }
+ + #endif
+ + 
+ + 
+ + #if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
+ + static struct gpio_keys_button liabdin_buttons[] = {
+ + 	{
+ + 		.gpio		= AT91_PIN_PC2,
+ + 		.code		= BTN_0,
+ + 		.desc		= "bot-sw2",
+ + 		.active_low	= 1,
+ + 	},
+ + 	{
+ + 		.gpio		= AT91_PIN_PC10,
+ + 		.code		= BTN_1,
+ + 		.desc		= "addon-sw1",
+ + 		.active_low	= 1,
+ + 	},
+ + 	{
+ + 		.gpio		= AT91_PIN_PC11,
+ + 		.code		= BTN_2,
+ + 		.desc		= "addon-sw2",
+ + 		.active_low	= 1,
+ + 	},
+ + 	{ /* Opto X5 */
+ + 		.gpio		= AT91_PIN_PD4,
+ + 		.code		= BTN_3,
+ + 		.desc		= "opto-X5",
+ + 		.active_low	= 1,
+ + 	},
+ + 	{ /* Opto X6 */
+ + 		.gpio		= AT91_PIN_PD5,
+ + 		.code		= BTN_4,
+ + 		.desc		= "opto-X6",
+ + 		.active_low	= 1,
+ + 	},
+ + 	{ /* Opto X7 */
+ + 		.gpio		= AT91_PIN_PD6,
+ + 		.code		= BTN_5,
+ + 		.desc		= "opto-X7",
+ + 		.active_low	= 1,
+ + 	},
+ + 	{ /* Opto X8 */
+ + 		.gpio		= AT91_PIN_PD7,
+ + 		.code		= BTN_6,
+ + 		.desc		= "opto-X8",
+ + 		.active_low	= 1,
+ + 	},
+ + };
+ + 
+ + static struct gpio_keys_platform_data liabdin_button_data = {
+ + 	.buttons	= liabdin_buttons,
+ + 	.nbuttons	= ARRAY_SIZE(liabdin_buttons),
+ + };
+ + 
+ + static struct platform_device liabdin_button_device = {
+ + 	.name		= "gpio-keys",
+ + 	.id		= -1,
+ + 	.num_resources	= 0,
+ + 	.dev		= {
+ + 		.platform_data	= &liabdin_button_data,
+ + 	}
+ + };
+ + 
+ + static void __init din_add_device_buttons(void)
+ + {
+ +   int i;
+ +   for(i=0; i<ARRAY_SIZE(liabdin_buttons); i++) {
+ +     at91_set_gpio_input(liabdin_buttons[i].gpio, 0);
+ +     at91_set_deglitch(liabdin_buttons[i].gpio, 1);
+ +   }
+ + 
+ +   platform_device_register(&liabdin_button_device);
+ + }
+ + #else
+ + static void __init din_add_device_buttons(void) {}
+ + #endif
+ + 
+ + 
+ + 
+ + static struct gpio_led liabdin_leds[] = {
+ + #ifndef CONFIG_LEDS
+ +   {	/* "D0" */
+ +     .name		= "led-d2",
+ +     .gpio		= AT91_PIN_PC13,
+ +     .active_low		= 1,
+ +     .default_trigger	= "led-d2",
+ +   },
+ + #endif
+ +   {	/* "D1" */
+ +     .name	       	= "led-d3",
+ +     .gpio		= AT91_PIN_PC14,
+ +     .active_low		= 1,
+ +     .default_trigger	= "led-d3",
+ +   },
+ +   {	/* "D2" */
+ +     .name	       	= "led-d4",
+ +     .gpio		= AT91_PIN_PC15,
+ +     .active_low		= 1,
+ +     .default_trigger	= "led-d4",
+ +   },
+ +   {	/* "relay X1" */
+ +     .name	       	= "relay-X1",
+ +     .gpio		= AT91_PIN_PD0,
+ +     .active_low		= 0,
+ +   },
+ +   {	/* "relay X2" */
+ +     .gpio		= AT91_PIN_PD1,
+ +     .name	       	= "relay-X2",
+ +     .active_low		= 0,
+ +   },
+ +   {	/* "relay X3" */
+ +     .name	       	= "relay-X3",
+ +     .gpio		= AT91_PIN_PD2,
+ +     .active_low		= 0,
+ +   },
+ +   {	/* "relay X4" */
+ +     .name	       	= "relay-X4",
+ +     .gpio		= AT91_PIN_PD3,
+ +     .active_low		= 0,
+ +   },
+ +   {	/* "USB Power - top" */
+ +     .name	       	= "usbpwr-top",
+ +     .gpio		= AT91_PIN_PC3,
+ +     .active_low		= 0,
+ +     .default_trigger	= "default-on",
+ +   },
+ +   {	/* "USB Power - bottom" */
+ +     .name	       	= "usbpwr-bot",
+ +     .gpio		= AT91_PIN_PC4,
+ +     .active_low		= 0,
+ +     .default_trigger	= "default-on",
+ +   },
+ + };
+ + 
+ + #ifdef CONFIG_LIAB_TDC_LIABDIN_ADDON
+ + static struct gpio_led addon_leds[] = {
+ +   {	
+ +     .name		= "addon-led-0",
+ +     .default_trigger	= "heartbeat",
+ +   },
+ +   {	
+ +     .name		= "addon-led-1",
+ +     .default_trigger	= "timer",
+ +   },
+ +   {	
+ +     .name		= "addon-led-2",
+ +   },
+ +   {	
+ +     .name		= "addon-led-3",
+ +   },
+ +   {	
+ +     .name		= "addon-led-4",
+ +   },
+ +   {	
+ +     .name		= "addon-led-5",
+ +   },
+ +   {	
+ +     .name		= "addon-led-6",
+ +   },
+ +   {	
+ +     .name		= "addon-led-7",
+ +   },
+ +   {	
+ +     .name		= "addon-led-8",
+ +   },
+ +   {	
+ +     .name		= "addon-led-9",
+ +   },
+ + };
+ + #else
+ + static struct gpio_led addon_leds[] = {
+ +   {	
+ +     .name		= "addon-led-0",
+ +     .default_trigger	= "heartbeat",
+ +   },
+ +   {	
+ +     .name		= "addon-led-1",
+ +     .default_trigger	= "timer",
+ +   },
+ +   {	
+ +     .name		= "addon-led-2",
+ +   },
+ +   {	
+ +     .name		= "addon-led-3",
+ +   },
+ +   {	
+ +     .name		= "addon-led-4",
+ +   },
+ +   {	
+ +     .name		= "addon-led-5",
+ +   },
+ +   {	
+ +     .name		= "addon-led-6",
+ +   },
+ +   {	
+ +     .name		= "addon-led-7",
+ +   },
+ +   {	
+ +     .name		= "addon-led-8",
+ +   },
+ +   {	
+ +     .name		= "addon-led-9",
+ +   },
+ +   {	
+ +     .name		= "addon-led-10",
+ +   },
+ +   {	
+ +     .name		= "addon-led-11",
+ +   },
+ +   {	
+ +     .name		= "addon-led-12",
+ +   },
+ +   {	
+ +     .name		= "addon-led-13",
+ +   },
+ +   {	
+ +     .name		= "addon-led-14",
+ +   },
+ + };
+ + #endif
+ + 
+ + static struct gpio_led_platform_data led_data;
+ + 
+ + static struct platform_device liabdin_addon_device = {
+ + 	.name		= "leds-liabdin-addon",
+ + 	.id		= -1,
+ + 	.num_resources	= 0,
+ + 	.dev		= {
+ + 		.platform_data	= &led_data,
+ + 	}
+ + };
+ + 
+ + void __init liabdin_addon_leds(struct gpio_led *leds, int nr)
+ + {
+ + 	if (!nr)
+ + 		return;
+ + 
+ + 	led_data.leds = leds;
+ + 	led_data.num_leds = nr;
+ + 	platform_device_register(&liabdin_addon_device);
+ + }
+ + 
+ + 
+ + /*
+ +  * SPI devices.
+ +  */
+ + static struct spi_board_info ipatu_spi_devices[] = {
+ + 	{	/* MAX1098 5-port A/D */
+ + 		.modalias	= "max1098",
+ + 		.chip_select	= 0,
+ +     .bus_num	= 0,
+ + 		.max_speed_hz	= 2 * 1000 * 1000,
+ + 	},
+ + 	{	/* MAX5513 2-port D/A */
+ + 		.modalias	= "spidev",
+ + 		.chip_select	= 1,
+ +     .bus_num	= 0,
+ + 		.max_speed_hz	= 6 * 1000 * 1000,
+ + 	},
+ + };
+ + 
+ + 
+ + static void __init liabdin_board_init(void)
+ + {
+ + 	/* Serial */
+ + 	at91_add_device_serial();
+ + 	/* Ethernet */
+ + 	at91_add_device_eth(&liabdin_eth_data);
+ + 	/* USB Host */
+ + 	at91_add_device_usbh(&liabdin_usbh_data);
+ +   /*
+ +   at91_set_gpio_output(AT91_PIN_PC3, 1);
+ +   at91_set_gpio_output(AT91_PIN_PC4, 1);
+ +   */
+ + 	/* USB Device */
+ + #ifdef CONFIG_LIAB_TDC_LIABDIN_ADDON
+ + 	at91_add_device_udc(&liabdin_udc_data);
+ + 	at91_set_multi_drive(liabdin_udc_data.pullup_pin, 1);	/* pullup_pin is connected to reset */
+ + #endif
+ + 	/* I2C */
+ + 	at91_add_device_i2c(liabdin_i2c_devices, ARRAY_SIZE(liabdin_i2c_devices));
+ + 	/* SPI */
+ + 	at91_add_device_spi(ipatu_spi_devices, ARRAY_SIZE(ipatu_spi_devices));
+ +   /* Buttons */
+ +   din_add_device_buttons();
+ + 
+ + #ifdef CONFIG_LIAB_LIABDIN_ADDON
+ +   /* Addon board LEDs */
+ +   liabdin_addon_leds(addon_leds, ARRAY_SIZE(addon_leds));
+ + #endif
+ + 
+ + #ifdef CONFIG_LIAB_TDC_LIABDIN_ADDON
+ +   at91_add_device_dm9000();
+ + #endif
+ + 
+ +   at91_add_device_pwm(0);
+ +   at91_add_device_modem();
+ + 
+ + #ifdef CONFIG_LEDS_GPIO
+ + 	/* LEDs */
+ + 	at91_gpio_leds(liabdin_leds, ARRAY_SIZE(liabdin_leds));
+ + #endif
+ + 
+ + }
+ + 
+ + MACHINE_START(AT91RM9200DK, "Atmel AT91RM9200-DK")
+ + 	/* Maintainer: SAN People/Atmel */
+ + 	.phys_io	= AT91_BASE_SYS,
+ + 	.io_pg_offst	= (AT91_VA_BASE_SYS >> 18) & 0xfffc,
+ + 	.boot_params	= AT91_SDRAM_BASE + 0x100,
+ + 	.timer		= &at91rm9200_timer,
+ + 	.map_io		= liabdin_map_io,
+ + 	.init_irq	= liabdin_init_irq,
+ + 	.init_machine	= liabdin_board_init,
+ + MACHINE_END
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/arch/arm/mach-at91/board-liabrcserv.c liab-linux-2.6.29.4/arch/arm/mach-at91/board-liabrcserv.c
+ *** linux-2.6.29.4/arch/arm/mach-at91/board-liabrcserv.c	1970-01-01 01:00:00.000000000 +0100
+ --- liab-linux-2.6.29.4/arch/arm/mach-at91/board-liabrcserv.c	2010-05-28 09:28:03.718652428 +0200
+ ***************
+ *** 0 ****
+ --- 1,314 ----
+ + /*
+ +  * linux/arch/arm/mach-at91/board-rcserv.c
+ +  *
+ +  * Shamelessly ripped of from
+ +  * linux/arch/arm/mach-at91/board-sam9260ek.c
+ +  *
+ +  * By LIAB ApS 2008
+ +  *
+ +  *  Copyright (C) 2005 SAN People
+ +  *  Copyright (C) 2006 Atmel
+ +  *
+ +  * This program is free software; you can redistribute it and/or modify
+ +  * it under the terms of the GNU General Public License as published by
+ +  * the Free Software Foundation; either version 2 of the License, or
+ +  * (at your option) any later version.
+ +  *
+ +  * This program is distributed in the hope that it will be useful,
+ +  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ +  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ +  * GNU General Public License for more details.
+ +  *
+ +  * You should have received a copy of the GNU General Public License
+ +  * along with this program; if not, write to the Free Software
+ +  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ +  */
+ + 
+ + #include <linux/types.h>
+ + #include <linux/init.h>
+ + #include <linux/mm.h>
+ + #include <linux/module.h>
+ + #include <linux/platform_device.h>
+ + #include <linux/spi/spi.h>
+ + #include <linux/spi/flash.h>
+ + #include <linux/input.h>
+ + #include <linux/gpio_keys.h>
+ + 
+ + #include <asm/hardware.h>
+ + #include <asm/setup.h>
+ + #include <asm/mach-types.h>
+ + #include <asm/irq.h>
+ + 
+ + #include <asm/mach/arch.h>
+ + #include <asm/mach/map.h>
+ + #include <asm/mach/irq.h>
+ + 
+ + #include <asm/arch/board.h>
+ + #include <asm/arch/gpio.h>
+ + #include <asm/arch/at91sam926x_mc.h>
+ + 
+ + #include "generic.h"
+ + 
+ + 
+ + /*
+ +  * Serial port configuration.
+ +  *    0 .. 5 = USART0 .. USART5
+ +  *    6      = DBGU
+ +  */
+ + static struct at91_uart_config __initdata rcserv_uart_config = {
+ + 	.console_tty	= 0,				/* ttyS0 */
+ + 	.nr_tty		= 3,
+ + 	.tty_map	= { 6, 0, 1, -1, -1, -1, -1 }	/* ttyS0, ..., ttyS6 */
+ + };
+ + 
+ + static void __init rcserv_map_io(void)
+ + {
+ +   /* Initialize processor: 14.7456 MHz crystal */
+ +   at91sam9260_initialize(14745600);
+ +   
+ +   /* Setup the LEDs */
+ +   //  at91_init_leds(AT91_PIN_PC6, AT91_PIN_PC6);
+ +   
+ +   /* Setup the serial ports and console */
+ +   at91_init_serial(&rcserv_uart_config);
+ + }
+ + 
+ + static void __init rcserv_init_irq(void)
+ + {
+ + 	at91sam9260_init_interrupts(NULL);
+ + }
+ + 
+ + 
+ + /*
+ +  * USB Host port
+ +  */
+ + static struct at91_usbh_data __initdata rcserv_usbh_data = {
+ + 	.ports		 = 2,
+ +   .vbus_pin        = {AT91_PIN_PC7, AT91_PIN_PC7},
+ +   .vbus_active_low = 0,
+ + };
+ + 
+ + 
+ + /*
+ +  * USB Device port
+ +  */
+ + static struct at91_udc_data __initdata rcserv_udc_data = {
+ + 	.vbus_pin	= AT91_PIN_PC8,
+ + 	.pullup_pin	= AT91_PIN_PC13, 
+ + };
+ + 
+ + 
+ + /*
+ +  * SPI devices.
+ +  */
+ + static struct spi_board_info rcserv_spi_devices[] = {
+ + 	{	/* DataFlash chip */
+ + 		.modalias	= "mtd_dataflash",
+ + 		.chip_select	= 1,
+ + 		.max_speed_hz	= 1 * 1000 * 1000, /* 1 MHz */
+ + 		.bus_num	= 0,
+ + 	},
+ + };
+ + 
+ + 
+ + /*
+ +  * MACB Ethernet device
+ +  */
+ + static struct at91_eth_data __initdata rcserv_macb_data = {
+ + 	.phy_irq_pin	= AT91_PIN_PC5,
+ + 	.is_rmii	= 0,
+ + };
+ + 
+ + 
+ + /*
+ +  * NAND flash
+ +  */
+ + static struct mtd_partition __initdata rcserv_nand_partition[] = {
+ + 	{
+ + 		.name	= "Kernel+Root partition",
+ + 		.offset	= 0,
+ + 		.size	= 16*1024*1024,
+ + 	},
+ + 	{
+ + 		.name	= "JFFS2 User storage",
+ + 		.offset	= (16*1024*1024),
+ + 		.size	= MTDPART_SIZ_FULL,
+ + 	},
+ + };
+ + 
+ + static struct mtd_partition * __init nand_partitions(int size, int *num_partitions)
+ + {
+ + 	*num_partitions = ARRAY_SIZE(rcserv_nand_partition);
+ + 	return rcserv_nand_partition;
+ + };
+ + 
+ + static struct at91_nand_data __initdata rcserv_nand_data = {
+ + 	.ale		= 21,
+ + 	.cle		= 22,
+ + //	.det_pin	= ... not connected
+ + 	.rdy_pin	= AT91_PIN_PC4,
+ +   .enable_pin	= AT91_PIN_PC14,
+ + 	.partition_info	= nand_partitions,
+ + 	.bus_width_16	= 0,
+ + };
+ + 
+ + static struct i2c_board_info __initdata rcserv_i2c_devices[] = {
+ + 	{
+ + 		I2C_BOARD_INFO("rtc-ds1307", 0x68),
+ + 		.type	= "ds1307",
+ + 	},
+ + 	{
+ + 		I2C_BOARD_INFO("adm9240", (0x2c<<1)),
+ + 		.type	= "adm9240",
+ + 	},
+ + };
+ + 
+ + #if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
+ + static struct gpio_keys_button rcserv_buttons[] = {
+ + 	{
+ + 		.gpio		= AT91_PIN_PA8,
+ + 		.code		= BTN_0,
+ + 		.desc		= "sw1",
+ + 		.active_low	= 1,
+ + 	},
+ + 	{
+ + 		.gpio		= AT91_PIN_PA9,
+ + 		.code		= BTN_1,
+ + 		.desc		= "sw2",
+ + 		.active_low	= 1,
+ + 	},
+ + 	{
+ + 		.gpio		= AT91_PIN_PC12,
+ + 		.code		= BTN_2,
+ + 		.desc		= "opto1",
+ + 		.active_low	= 1,
+ + 	},
+ + 	{
+ + 		.gpio		= AT91_PIN_PC13,
+ + 		.code		= BTN_3,
+ + 		.desc		= "opto2",
+ + 		.active_low	= 1,
+ + 	},
+ + };
+ + 
+ + static struct gpio_keys_platform_data rcserv_button_data = {
+ + 	.buttons	= rcserv_buttons,
+ + 	.nbuttons	= ARRAY_SIZE(rcserv_buttons),
+ + };
+ + 
+ + static struct platform_device rcserv_button_device = {
+ + 	.name		= "gpio-keys",
+ + 	.id		= -1,
+ + 	.num_resources	= 0,
+ + 	.dev		= {
+ + 		.platform_data	= &rcserv_button_data,
+ + 	}
+ + };
+ + 
+ + static void __init rcserv_add_device_buttons(void)
+ + {
+ +   int i;
+ +   for(i=0; i<ARRAY_SIZE(rcserv_buttons); i++) {
+ +     at91_set_gpio_input(rcserv_buttons[i].gpio, 0);
+ +     at91_set_deglitch(rcserv_buttons[i].gpio, 1);
+ +   }
+ + 
+ +   platform_device_register(&rcserv_button_device);
+ + }
+ + #else
+ + static void __init rcserv_add_device_buttons(void) {}
+ + #endif
+ + 
+ + 
+ + static struct gpio_led rcserv_leds[] = {
+ +   {
+ +     .name		= "system-ok-green",
+ +     .gpio		= AT91_PIN_PA6,
+ +     .active_low		= 0,
+ +     .default_trigger	= "key-red",
+ +   },
+ +   /* Ahem... tiny nomenclature hack. */
+ +   {	/* Relay 1 */
+ +     .name		= "relay1",
+ +     .gpio		= AT91_PIN_PB30,
+ +     .active_low		= 0,
+ +   },
+ +   {	/* Relay 2 */
+ +     .name		= "relay2",
+ +     .gpio		= AT91_PIN_PB31,
+ +     .active_low		= 0,
+ +   },
+ + };
+ + 
+ + 
+ + static struct resource timer_resources[] = {
+ +   [0] = {
+ +     .start	= AT91SAM9260_BASE_TC0,
+ +     .end	= AT91SAM9260_BASE_TC0 + 64 - 1,
+ +     .flags	= IORESOURCE_MEM,
+ +   },
+ +   [1] = {
+ +     .start	= AT91SAM9260_BASE_TC1,
+ +     .end	= AT91SAM9260_BASE_TC1 + 64 - 1,
+ +     .flags	= IORESOURCE_MEM,
+ +   },
+ +   [2] = {
+ +     .start	= AT91SAM9260_BASE_TC2,
+ +     .end	= AT91SAM9260_BASE_TC2 + 64 - 1,
+ +     .flags	= IORESOURCE_MEM,
+ +   },
+ + };
+ + 
+ + static u32 no = 1;
+ + static struct platform_device at91_timer_device = {
+ +   .name		= "at91_pwm",
+ +   .id		= -1,
+ +   .dev		= {
+ +     .platform_data		= &no,
+ +   },
+ +   .resource	= timer_resources,
+ + 	.num_resources	= ARRAY_SIZE(timer_resources),
+ + };
+ + 
+ + void __init at91_add_device_pwm(void)
+ + {
+ + 
+ +   at91_set_B_periph(AT91_PIN_PC9, 0);
+ +   platform_device_register(&at91_timer_device);
+ +   
+ + }
+ + 
+ + static void __init rcserv_board_init(void)
+ + {
+ + 	/* Serial */
+ + 	at91_add_device_serial();
+ + 	/* USB Host */
+ + 	at91_add_device_usbh(&rcserv_usbh_data);
+ + 	/* USB Device */
+ + 	at91_add_device_udc(&rcserv_udc_data);
+ + 	/* SPI */
+ + 	at91_add_device_spi(rcserv_spi_devices, ARRAY_SIZE(rcserv_spi_devices));
+ + 	/* NAND */
+ + 	at91_add_device_nand(&rcserv_nand_data);
+ + 	/* Ethernet */
+ + 	at91_add_device_eth(&rcserv_macb_data);
+ + 	/* I2C */
+ + 	at91_add_device_i2c(rcserv_i2c_devices, ARRAY_SIZE(rcserv_i2c_devices));
+ +   /* Buttons */
+ +   rcserv_add_device_buttons();
+ + #ifdef CONFIG_LEDS_GPIO
+ + 	/* LEDs */
+ + 	at91_gpio_leds(rcserv_leds, ARRAY_SIZE(rcserv_leds));
+ + #endif
+ + }
+ + 
+ + MACHINE_START(LIABARM, "Atmel AT91SAM9260 LIAB-board")
+ + 	/* Maintainer: Atmel */
+ + 	.phys_io	= AT91_BASE_SYS,
+ + 	.io_pg_offst	= (AT91_VA_BASE_SYS >> 18) & 0xfffc,
+ + 	.boot_params	= AT91_SDRAM_BASE + 0x100,
+ + 	.timer		= &at91sam926x_timer,
+ + 	.map_io		= rcserv_map_io,
+ + 	.init_irq	= rcserv_init_irq,
+ + 	.init_machine	= rcserv_board_init,
+ + MACHINE_END
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/arch/arm/mach-at91/board-liabsg.c liab-linux-2.6.29.4/arch/arm/mach-at91/board-liabsg.c
+ *** linux-2.6.29.4/arch/arm/mach-at91/board-liabsg.c	1970-01-01 01:00:00.000000000 +0100
+ --- liab-linux-2.6.29.4/arch/arm/mach-at91/board-liabsg.c	2010-05-28 12:40:15.637650793 +0200
+ ***************
+ *** 0 ****
+ --- 1,288 ----
+ + /*
+ +  * linux/arch/arm/mach-at91/board-sam9260ek.c
+ +  *
+ +  *  Copyright (C) 2005 SAN People
+ +  *  Copyright (C) 2006 Atmel
+ +  *
+ +  * This program is free software; you can redistribute it and/or modify
+ +  * it under the terms of the GNU General Public License as published by
+ +  * the Free Software Foundation; either version 2 of the License, or
+ +  * (at your option) any later version.
+ +  *
+ +  * This program is distributed in the hope that it will be useful,
+ +  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ +  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ +  * GNU General Public License for more details.
+ +  *
+ +  * You should have received a copy of the GNU General Public License
+ +  * along with this program; if not, write to the Free Software
+ +  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ +  */
+ + 
+ + #include <linux/types.h>
+ + #include <linux/init.h>
+ + #include <linux/mm.h>
+ + #include <linux/module.h>
+ + #include <linux/platform_device.h>
+ + #include <linux/spi/spi.h>
+ + #include <linux/spi/at73c213.h>
+ + #include <linux/clk.h>
+ + #include <linux/i2c/at24.h>
+ + #include <linux/gpio_keys.h>
+ + #include <linux/input.h>
+ + 
+ + #include <asm/setup.h>
+ + #include <asm/mach-types.h>
+ + #include <asm/irq.h>
+ + 
+ + #include <asm/mach/arch.h>
+ + #include <asm/mach/map.h>
+ + #include <asm/mach/irq.h>
+ + 
+ + #include <mach/hardware.h>
+ + #include <mach/board.h>
+ + #include <mach/gpio.h>
+ + #include <mach/at91sam9_smc.h>
+ + #include <mach/at91_shdwc.h>
+ + 
+ + #include "sam9_smc.h"
+ + #include "generic.h"
+ + 
+ + 
+ + static void __init liabsg_map_io(void)
+ + {
+ + 	/* Initialize processor: 18.432 MHz crystal */
+ + 	at91sam9260_initialize(25000000);
+ + 
+ + 	/* DGBU on ttyS0. (Rx & Tx only) */
+ + 	at91_register_uart(0, 0, 0);
+ + 
+ + 	/* USART0 on ttyS1. (Rx, Tx, CTS, RTS, DTR, DSR, DCD, RI) */
+ + 	at91_register_uart(AT91SAM9260_ID_US0, 1, ATMEL_UART_CTS | ATMEL_UART_RTS
+ + 			   | ATMEL_UART_DTR | ATMEL_UART_DSR | ATMEL_UART_DCD
+ + 			   | ATMEL_UART_RI);
+ + 
+ + 	/* USART1 on ttyS2. (Rx, Tx, RTS, CTS) */
+ + 	at91_register_uart(AT91SAM9260_ID_US1, 2, ATMEL_UART_CTS | ATMEL_UART_RTS);
+ + 
+ + 	/* set serial console to ttyS0 (ie, DBGU) */
+ + 	at91_set_serial_console(0);
+ + }
+ + 
+ + static void __init liabsg_init_irq(void)
+ + {
+ + 	at91sam9260_init_interrupts(NULL);
+ + }
+ + 
+ + 
+ + /*
+ +  * USB Host port
+ +  */
+ + static struct at91_usbh_data __initdata liabsg_usbh_data = {
+ + 	.ports		= 2,
+ + };
+ + 
+ + /*
+ +  * USB Device port
+ +  */
+ + static struct at91_udc_data __initdata liabsg_udc_data = {
+ + 	.vbus_pin	= AT91_PIN_PC5,
+ + 	.pullup_pin	= 0,		/* pull-up driven by UDC */
+ + };
+ + 
+ + /*
+ +  * SPI devices.
+ +  */
+ + static struct spi_board_info liabsg_spi_devices[] = {
+ + 	{	/* DataFlash chip */
+ + 		.modalias	= "mtd_dataflash",
+ + 		.chip_select	= 1,
+ + 		.max_speed_hz	= 15 * 1000 * 1000,
+ + 		.bus_num	= 0,
+ + 	},
+ + };
+ + 
+ + 
+ + /*
+ +  * MACB Ethernet device
+ +  */
+ + static struct at91_eth_data __initdata liabsg_macb_data = {
+ + 	.phy_irq_pin	= AT91_PIN_PB31,
+ + 	.is_rmii	= 0,
+ + };
+ + 
+ + 
+ + /*
+ +  * NAND flash
+ +  */
+ + static struct mtd_partition __initdata liabsg_nand_partition[] = {
+ + 	{
+ + 		.name	= "Bootstrap",
+ + 		.offset	= 0,
+ + 		.size	= (16 * SZ_1M),
+ + 	},
+ + 	{
+ + 		.name	= "FLASH Storage",
+ + 		.offset	= MTDPART_OFS_NXTBLK,
+ + 		.size	= MTDPART_SIZ_FULL,
+ + 	},
+ + };
+ + 
+ + static struct mtd_partition * __init nand_partitions(int size, int *num_partitions)
+ + {
+ + 	*num_partitions = ARRAY_SIZE(liabsg_nand_partition);
+ + 	return liabsg_nand_partition;
+ + }
+ + 
+ + static struct atmel_nand_data __initdata liabsg_nand_data = {
+ + 	.ale		= 21,
+ + 	.cle		= 22,
+ + //	.det_pin	= ... not connected
+ + 	.rdy_pin	= AT91_PIN_PC10,
+ + 	.enable_pin	= AT91_PIN_PC14,
+ + 	.partition_info	= nand_partitions,
+ + 	.bus_width_16	= 0,
+ + };
+ + 
+ + static struct sam9_smc_config __initdata liabsg_nand_smc_config = {
+ + 	.ncs_read_setup		= 0,
+ + 	.nrd_setup		= 1,
+ + 	.ncs_write_setup	= 0,
+ + 	.nwe_setup		= 1,
+ + 
+ + 	.ncs_read_pulse		= 3,
+ + 	.nrd_pulse		= 3,
+ + 	.ncs_write_pulse	= 3,
+ + 	.nwe_pulse		= 3,
+ + 
+ + 	.read_cycle		= 5,
+ + 	.write_cycle		= 5,
+ + 
+ + 	.mode			= AT91_SMC_READMODE | AT91_SMC_WRITEMODE | AT91_SMC_EXNWMODE_DISABLE,
+ + 	.tdf_cycles		= 2,
+ + };
+ + 
+ + static void __init liabsg_add_device_nand(void)
+ + {
+ + 	/* setup bus-width (8 or 16) */
+ +   liabsg_nand_smc_config.mode |= AT91_SMC_DBW_8;
+ + 
+ + 	/* configure chip-select 3 (NAND) */
+ + 	sam9_smc_configure(3, &liabsg_nand_smc_config);
+ + 
+ + 	at91_add_device_nand(&liabsg_nand_data);
+ + }
+ + 
+ + /*
+ +  * LEDs
+ +  */
+ + static struct gpio_led liabsg_leds[] = {
+ + 	{	/* "bottom" led, green, userled1 to be defined */
+ + 		.name			= "ds5",
+ + 		.gpio			= AT91_PIN_PA6,
+ + 		.active_low		= 1,
+ + 		.default_trigger	= "none",
+ + 	},
+ + 	{	/* "power" led, yellow */
+ + 		.name			= "ds1",
+ + 		.gpio			= AT91_PIN_PA9,
+ + 		.default_trigger	= "heartbeat",
+ + 	}
+ + };
+ + 
+ + /*
+ +  * I2C devices
+ +  */
+ + 
+ + static struct i2c_board_info __initdata liabsg_i2c_devices[] = {
+ + 	{
+ + 		I2C_BOARD_INFO("rtc-ds1307", 0x68),
+ + 		.type	= "ds1307",
+ + 	},
+ + 	/* more devices can be added using expansion connectors */
+ + };
+ + 
+ + 
+ + /*
+ +  * GPIO Buttons
+ +  */
+ + #if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
+ + static struct gpio_keys_button liabsg_buttons[] = {
+ + 	{
+ + 		.gpio		= AT91_PIN_PA30,
+ + 		.code		= BTN_3,
+ + 		.desc		= "Button 3",
+ + 		.active_low	= 1,
+ + 		.wakeup		= 1,
+ + 	},
+ + 	{
+ + 		.gpio		= AT91_PIN_PA31,
+ + 		.code		= BTN_4,
+ + 		.desc		= "Button 4",
+ + 		.active_low	= 1,
+ + 		.wakeup		= 1,
+ + 	}
+ + };
+ + 
+ + static struct gpio_keys_platform_data liabsg_button_data = {
+ + 	.buttons	= liabsg_buttons,
+ + 	.nbuttons	= ARRAY_SIZE(liabsg_buttons),
+ + };
+ + 
+ + static struct platform_device liabsg_button_device = {
+ + 	.name		= "gpio-keys",
+ + 	.id		= -1,
+ + 	.num_resources	= 0,
+ + 	.dev		= {
+ + 		.platform_data	= &liabsg_button_data,
+ + 	}
+ + };
+ + 
+ + static void __init liabsg_add_device_buttons(void)
+ + {
+ + 	at91_set_gpio_input(AT91_PIN_PA30, 1);	/* btn3 */
+ + 	at91_set_deglitch(AT91_PIN_PA30, 1);
+ + 	at91_set_gpio_input(AT91_PIN_PA31, 1);	/* btn4 */
+ + 	at91_set_deglitch(AT91_PIN_PA31, 1);
+ + 
+ + 	platform_device_register(&liabsg_button_device);
+ + }
+ + #else
+ + static void __init liabsg_add_device_buttons(void) {}
+ + #endif
+ + 
+ + 
+ + static void __init liabsg_board_init(void)
+ + {
+ + 	/* Serial */
+ + 	at91_add_device_serial();
+ + 	/* USB Host */
+ + 	at91_add_device_usbh(&liabsg_usbh_data);
+ + 	/* USB Device */
+ + 	at91_add_device_udc(&liabsg_udc_data);
+ + 	/* SPI */
+ + 	at91_add_device_spi(liabsg_spi_devices, ARRAY_SIZE(liabsg_spi_devices));
+ + 	/* NAND */
+ + 	liabsg_add_device_nand();
+ + 	/* Ethernet */
+ + 	at91_add_device_eth(&liabsg_macb_data);
+ + 	/* I2C */
+ + 	at91_add_device_i2c(liabsg_i2c_devices, ARRAY_SIZE(liabsg_i2c_devices));
+ + 	/* LEDs */
+ + 	//at91_gpio_leds(liabsg_leds, ARRAY_SIZE(liabsg_leds));
+ + 	/* Push Buttons */
+ + 	//liabsg_add_device_buttons();
+ + }
+ + 
+ + MACHINE_START(AT91SAM9260EK, "Atmel AT91SAM9260-EK")
+ + 	/* Maintainer: Atmel */
+ + 	.phys_io	= AT91_BASE_SYS,
+ + 	.io_pg_offst	= (AT91_VA_BASE_SYS >> 18) & 0xfffc,
+ + 	.boot_params	= AT91_SDRAM_BASE + 0x100,
+ + 	.timer		= &at91sam926x_timer,
+ + 	.map_io		= liabsg_map_io,
+ + 	.init_irq	= liabsg_init_irq,
+ + 	.init_machine	= liabsg_board_init,
+ + MACHINE_END
+ + 
+ + 
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/arch/arm/mach-at91/board-nanoliab.c liab-linux-2.6.29.4/arch/arm/mach-at91/board-nanoliab.c
+ *** linux-2.6.29.4/arch/arm/mach-at91/board-nanoliab.c	1970-01-01 01:00:00.000000000 +0100
+ --- liab-linux-2.6.29.4/arch/arm/mach-at91/board-nanoliab.c	2009-07-31 11:37:22.000000000 +0200
+ ***************
+ *** 0 ****
+ --- 1,286 ----
+ + /*
+ +  * linux/arch/arm/mach-at91/board-nanoliab.c
+ +  *
+ +  *  Shamelessly ripped off from the original AT91RM9200-DK
+ +  *  by Mikkel S. Andersen <msa@liab.dk> 2007.
+ +  * 
+ +  *  Copyright (C) 2005 SAN People
+ +  *
+ +  *  Epson S1D framebuffer glue code is:
+ +  *     Copyright (C) 2005 Thibaut VARENE <varenet@parisc-linux.org>
+ +  *
+ +  * This program is free software; you can redistribute it and/or modify
+ +  * it under the terms of the GNU General Public License as published by
+ +  * the Free Software Foundation; either version 2 of the License, or
+ +  * (at your option) any later version.
+ +  *
+ +  * This program is distributed in the hope that it will be useful,
+ +  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ +  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ +  * GNU General Public License for more details.
+ +  *
+ +  * You should have received a copy of the GNU General Public License
+ +  * along with this program; if not, write to the Free Software
+ +  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ +  */
+ + 
+ + #include <linux/types.h>
+ + #include <linux/init.h>
+ + #include <linux/mm.h>
+ + #include <linux/module.h>
+ + #include <linux/platform_device.h>
+ + #include <linux/spi/spi.h>
+ + #include <linux/mtd/physmap.h>
+ + #include <linux/i2c.h>
+ + #include <linux/input.h>
+ + #include <linux/gpio_keys.h>
+ + 
+ + #include <asm/setup.h>
+ + #include <asm/mach-types.h>
+ + #include <asm/irq.h>
+ + 
+ + #include <asm/mach/arch.h>
+ + #include <asm/mach/map.h>
+ + #include <asm/mach/irq.h>
+ + 
+ + #include <mach/hardware.h>
+ + #include <mach/board.h>
+ + #include <mach/gpio.h>
+ + #include <mach/at91rm9200_mc.h>
+ + 
+ + #include <linux/sound.h>
+ + 
+ + #include "generic.h"
+ + 
+ + 
+ + static void __init nano_map_io(void)
+ + {
+ + 	/* Initialize processor: 14.7456 MHz crystal */
+ + 	at91rm9200_initialize(14745600, AT91RM9200_BGA);
+ + 
+ +   /* Debug on ttyS0 */
+ +   at91_register_uart(0, 0, 0);
+ +   at91_set_serial_console(0);
+ + 
+ + #ifdef CONFIG_LIAB_ENABLE_UART0
+ +   at91_register_uart(AT91RM9200_ID_US0, 1, 
+ +                      ATMEL_UART_CTS | 
+ +                      ATMEL_UART_RTS);
+ + #endif
+ + #ifdef CONFIG_LIAB_ENABLE_UART1
+ +   at91_register_uart(AT91RM9200_ID_US1, 2, 
+ +                      ATMEL_UART_CTS | 
+ +                      ATMEL_UART_RTS | 
+ +                      ATMEL_UART_DSR | 
+ +                      ATMEL_UART_DTR);
+ + #endif
+ + #ifdef CONFIG_LIAB_ENABLE_UART2
+ +   at91_register_uart(AT91RM9200_ID_US2, 3, 0);
+ + #endif
+ + #ifdef CONFIG_LIAB_ENABLE_UART3
+ +   at91_register_uart(AT91RM9200_ID_US3, 4, 0);  
+ + #endif
+ + 
+ + 	/* Setup the LEDs */
+ + 	at91_init_leds(AT91_PIN_PD2, AT91_PIN_PD2);
+ + }
+ + 
+ + static void __init nano_init_irq(void)
+ + {
+ + 	at91rm9200_init_interrupts(NULL);
+ + }
+ + 
+ + static struct at91_eth_data __initdata nano_eth_data = {
+ + 	.phy_irq_pin	= 0,
+ + 	.is_rmii	= 0,
+ + };
+ + 
+ + static struct at91_usbh_data __initdata nano_usbh_data = {
+ + 	.ports		= 2,
+ + };
+ + 
+ + static struct at91_udc_data __initdata nano_udc_data = {
+ + 	.vbus_pin	= AT91_PIN_PD4,
+ + 	.pullup_pin	= AT91_PIN_PD5,
+ + };
+ + 
+ + static struct at91_mmc_data __initdata nano_mmc_data = {
+ + 	.slot_b		= 0,
+ + 	.wire4		= 1,
+ + };
+ + 
+ + 
+ + static struct i2c_board_info __initdata nano_i2c_devices[] = {
+ + 	{ I2C_BOARD_INFO("rtc-ds1307", 0x68),
+ + 	  .type = "ds1307",
+ + 	},
+ + };
+ + 
+ + 
+ + #if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
+ + static struct gpio_keys_button nano_buttons[] = {
+ + 	{
+ + 		.gpio		= AT91_PIN_PD0,
+ + 		.code		= BTN_0,
+ + 		.desc		= "top-sw2",
+ + 		.active_low	= 1,
+ + 	},
+ + 	{
+ + 		.gpio		= AT91_PIN_PD1,
+ + 		.code		= BTN_1,
+ + 		.desc		= "top-sw3",
+ + 		.active_low	= 1,
+ + 	},
+ + };
+ + 
+ + static struct gpio_keys_platform_data nano_button_data = {
+ + 	.buttons	= nano_buttons,
+ + 	.nbuttons	= ARRAY_SIZE(nano_buttons),
+ + };
+ + 
+ + static struct platform_device nano_button_device = {
+ + 	.name		= "gpio-keys",
+ + 	.id		= -1,
+ + 	.num_resources	= 0,
+ + 	.dev		= {
+ + 		.platform_data	= &nano_button_data,
+ + 	}
+ + };
+ + 
+ + static struct resource nano_sound_resources[] = {
+ + 	[0] = {
+ + 		.start	= AT91RM9200_BASE_SSC0,
+ + 		.end	  = AT91RM9200_BASE_SSC0 + SZ_16K - 1,
+ + 		.flags	= IORESOURCE_MEM,
+ + 	},
+ + };
+ + 
+ + static struct platform_device nano_sound_device = {
+ + 	.name		= "nanosound",
+ + 	.id		= -1,
+ + 	.resource	= nano_sound_resources,
+ + 	.num_resources	= ARRAY_SIZE(nano_sound_resources),
+ + };
+ + 
+ + 
+ + static void __init nano_add_device_buttons(void)
+ + {
+ +   int i;
+ +   for(i=0; i<ARRAY_SIZE(nano_buttons); i++) {
+ +     at91_set_gpio_input(nano_buttons[i].gpio, 0);
+ +     at91_set_deglitch(nano_buttons[i].gpio, 1);
+ +   }
+ + 
+ +   platform_device_register(&nano_button_device);
+ + }
+ + #else
+ + static void __init nano_add_device_buttons(void) {}
+ + #endif
+ + 
+ + 
+ + static struct gpio_led nano_leds[] = {
+ + #ifndef CONFIG_LEDS
+ +   {	/* "D0" */
+ +     .name		= "led-d0",
+ +     .gpio		= AT91_PIN_PD2,
+ +     .active_low		= 1,
+ +     .default_trigger	= "led-d0",
+ +   },
+ + #endif
+ +   {	/* "D1" */
+ +     .name	       	= "led-d1",
+ +     .gpio		= AT91_PIN_PD3,
+ +     .active_low		= 1,
+ +     .default_trigger	= "led-d1",
+ +   },
+ +   {	/* "D2" */
+ +     .name	       	= "led-d2",
+ +     .gpio		= AT91_PIN_PD4,
+ +     .active_low		= 1,
+ +     .default_trigger	= "led-d2",
+ +   },
+ +   {	/* "D3" */
+ +     .name	       	= "led-d3",
+ +     .gpio		= AT91_PIN_PD5,
+ +     .active_low		= 1,
+ +     .default_trigger	= "led-d3",
+ +   },
+ +   {	/* "AUX serial enable" */
+ +     .name	       	= "AUX-serial",
+ +     .gpio		= AT91_PIN_PA19,
+ +     .active_low		= 0,
+ +   },
+ + #ifdef CONFIG_LIAB_RELAY_ADDON
+ +   {	/* relay-0 */
+ +     .name	       	= "relay-0",
+ +     .gpio		= AT91_PIN_PB23,
+ +     .active_low		= 0,
+ +   },
+ +   {	/* relay-0 */
+ +     .name	       	= "relay-1",
+ +     .gpio		= AT91_PIN_PB24,
+ +     .active_low		= 0,
+ +   },
+ +   {	/* relay-0 */
+ +     .name	       	= "relay-2",
+ +     .gpio		= AT91_PIN_PB25,
+ +     .active_low		= 0,
+ +   },
+ + #endif
+ + };
+ + 
+ + 
+ + /*
+ +  * SPI devices.
+ +  */
+ + static struct spi_board_info ipatu_spi_devices[] = {
+ + 	{	
+ + 		.modalias	= "spidev",
+ + 		.chip_select	= 0,
+ +     .bus_num	= 0,
+ + 		.max_speed_hz	= 6 * 1000 * 1000,
+ + 	},
+ + };
+ + 
+ + 
+ + static void __init nano_board_init(void)
+ + {
+ + 	/* Serial */
+ + 	at91_add_device_serial();
+ + 	/* Ethernet */
+ + 	at91_add_device_eth(&nano_eth_data);
+ + 	/* USB Host */
+ + 	at91_add_device_usbh(&nano_usbh_data);
+ + 	/* USB Device */
+ + 	at91_add_device_udc(&nano_udc_data);
+ + 	at91_set_multi_drive(nano_udc_data.pullup_pin, 1);	/* pullup_pin is connected to reset */
+ + 	/* I2C */
+ +   at91_add_device_gpio_i2c();
+ +   i2c_register_board_info(0, nano_i2c_devices, ARRAY_SIZE(nano_i2c_devices));
+ + 	//at91_add_device_i2c(nano_i2c_devices, ARRAY_SIZE(nano_i2c_devices));
+ + 	/* SPI */
+ + 	at91_add_device_spi(ipatu_spi_devices, ARRAY_SIZE(ipatu_spi_devices));
+ +   /* SoC Audio */
+ +   platform_device_register(&nano_sound_device);
+ + 	/* MMC */
+ + 	at91_set_gpio_output(AT91_PIN_PB7, 1);	/* this MMC card slot can optionally use SPI signaling (CS3). */
+ + 	at91_add_device_mmc(0, &nano_mmc_data);
+ +         /* Buttons */
+ +         nano_add_device_buttons();
+ + #ifdef CONFIG_LEDS_GPIO
+ + 	/* LEDs */
+ + 	at91_gpio_leds(nano_leds, ARRAY_SIZE(nano_leds));
+ + #endif
+ + 
+ + }
+ + 
+ + MACHINE_START(AT91RM9200DK, "Atmel AT91RM9200-DK")
+ + 	/* Maintainer: SAN People/Atmel */
+ + 	.phys_io	= AT91_BASE_SYS,
+ + 	.io_pg_offst	= (AT91_VA_BASE_SYS >> 18) & 0xfffc,
+ + 	.boot_params	= AT91_SDRAM_BASE + 0x100,
+ + 	.timer		= &at91rm9200_timer,
+ + 	.map_io		= nano_map_io,
+ + 	.init_irq	= nano_init_irq,
+ + 	.init_machine	= nano_board_init,
+ + MACHINE_END
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/arch/arm/mach-at91/board-sam9260ek.c liab-linux-2.6.29.4/arch/arm/mach-at91/board-sam9260ek.c
+ *** linux-2.6.29.4/arch/arm/mach-at91/board-sam9260ek.c	2009-05-19 01:52:34.000000000 +0200
+ --- liab-linux-2.6.29.4/arch/arm/mach-at91/board-sam9260ek.c	2010-05-28 13:31:59.409651643 +0200
+ ***************
+ *** 52,58 ****
+   static void __init ek_map_io(void)
+   {
+   	/* Initialize processor: 18.432 MHz crystal */
+ ! 	at91sam9260_initialize(18432000);
+   
+   	/* DGBU on ttyS0. (Rx & Tx only) */
+   	at91_register_uart(0, 0, 0);
+ --- 52,58 ----
+   static void __init ek_map_io(void)
+   {
+   	/* Initialize processor: 18.432 MHz crystal */
+ !  	at91sam9260_initialize(25000000);
+   
+   	/* DGBU on ttyS0. (Rx & Tx only) */
+   	at91_register_uart(0, 0, 0);
+ ***************
+ *** 86,155 ****
+    * USB Device port
+    */
+   static struct at91_udc_data __initdata ek_udc_data = {
+ ! 	.vbus_pin	= AT91_PIN_PC5,
+   	.pullup_pin	= 0,		/* pull-up driven by UDC */
+   };
+   
+ - 
+ - /*
+ -  * Audio
+ -  */
+ - static struct at73c213_board_info at73c213_data = {
+ - 	.ssc_id		= 0,
+ - 	.shortname	= "AT91SAM9260-EK external DAC",
+ - };
+ - 
+ - #if defined(CONFIG_SND_AT73C213) || defined(CONFIG_SND_AT73C213_MODULE)
+ - static void __init at73c213_set_clk(struct at73c213_board_info *info)
+ - {
+ - 	struct clk *pck0;
+ - 	struct clk *plla;
+ - 
+ - 	pck0 = clk_get(NULL, "pck0");
+ - 	plla = clk_get(NULL, "plla");
+ - 
+ - 	/* AT73C213 MCK Clock */
+ - 	at91_set_B_periph(AT91_PIN_PC1, 0);	/* PCK0 */
+ - 
+ - 	clk_set_parent(pck0, plla);
+ - 	clk_put(plla);
+ - 
+ - 	info->dac_clk = pck0;
+ - }
+ - #else
+ - static void __init at73c213_set_clk(struct at73c213_board_info *info) {}
+ - #endif
+ - 
+   /*
+    * SPI devices.
+    */
+   static struct spi_board_info ek_spi_devices[] = {
+ - #if !defined(CONFIG_MMC_AT91)
+   	{	/* DataFlash chip */
+   		.modalias	= "mtd_dataflash",
+   		.chip_select	= 1,
+   		.max_speed_hz	= 15 * 1000 * 1000,
+   		.bus_num	= 0,
+   	},
+ - #if defined(CONFIG_MTD_AT91_DATAFLASH_CARD)
+ - 	{	/* DataFlash card */
+ - 		.modalias	= "mtd_dataflash",
+ - 		.chip_select	= 0,
+ - 		.max_speed_hz	= 15 * 1000 * 1000,
+ - 		.bus_num	= 0,
+ - 	},
+ - #endif
+ - #endif
+ - #if defined(CONFIG_SND_AT73C213) || defined(CONFIG_SND_AT73C213_MODULE)
+ - 	{	/* AT73C213 DAC */
+ - 		.modalias	= "at73c213",
+ - 		.chip_select	= 0,
+ - 		.max_speed_hz	= 10 * 1000 * 1000,
+ - 		.bus_num	= 1,
+ - 		.mode		= SPI_MODE_1,
+ - 		.platform_data	= &at73c213_data,
+ - 	},
+ - #endif
+   };
+   
+   
+ --- 86,105 ----
+    * USB Device port
+    */
+   static struct at91_udc_data __initdata ek_udc_data = {
+ ! 	.vbus_pin	= AT91_PIN_PC9,
+   	.pullup_pin	= 0,		/* pull-up driven by UDC */
+   };
+   
+   /*
+    * SPI devices.
+    */
+   static struct spi_board_info ek_spi_devices[] = {
+   	{	/* DataFlash chip */
+   		.modalias	= "mtd_dataflash",
+   		.chip_select	= 1,
+   		.max_speed_hz	= 15 * 1000 * 1000,
+   		.bus_num	= 0,
+   	},
+   };
+   
+   
+ ***************
+ *** 157,164 ****
+    * MACB Ethernet device
+    */
+   static struct at91_eth_data __initdata ek_macb_data = {
+ ! 	.phy_irq_pin	= AT91_PIN_PA7,
+ ! 	.is_rmii	= 1,
+   };
+   
+   
+ --- 107,114 ----
+    * MACB Ethernet device
+    */
+   static struct at91_eth_data __initdata ek_macb_data = {
+ ! 	.phy_irq_pin	= AT91_PIN_PB31,
+ ! 	.is_rmii	= 0,
+   };
+   
+   
+ ***************
+ *** 167,178 ****
+    */
+   static struct mtd_partition __initdata ek_nand_partition[] = {
+   	{
+ ! 		.name	= "Partition 1",
+   		.offset	= 0,
+ ! 		.size	= SZ_256K,
+   	},
+   	{
+ ! 		.name	= "Partition 2",
+   		.offset	= MTDPART_OFS_NXTBLK,
+   		.size	= MTDPART_SIZ_FULL,
+   	},
+ --- 117,128 ----
+    */
+   static struct mtd_partition __initdata ek_nand_partition[] = {
+   	{
+ ! 		.name	= "Bootstrap",
+   		.offset	= 0,
+ ! 		.size	= (32*SZ_1M),
+   	},
+   	{
+ ! 		.name	= "FLASH storage",
+   		.offset	= MTDPART_OFS_NXTBLK,
+   		.size	= MTDPART_SIZ_FULL,
+   	},
+ ***************
+ *** 188,201 ****
+   	.ale		= 21,
+   	.cle		= 22,
+   //	.det_pin	= ... not connected
+ ! 	.rdy_pin	= AT91_PIN_PC13,
+   	.enable_pin	= AT91_PIN_PC14,
+   	.partition_info	= nand_partitions,
+ - #if defined(CONFIG_MTD_NAND_ATMEL_BUSWIDTH_16)
+ - 	.bus_width_16	= 1,
+ - #else
+   	.bus_width_16	= 0,
+ - #endif
+   };
+   
+   static struct sam9_smc_config __initdata ek_nand_smc_config = {
+ --- 138,147 ----
+   	.ale		= 21,
+   	.cle		= 22,
+   //	.det_pin	= ... not connected
+ ! 	.rdy_pin	= AT91_PIN_PC10,
+   	.enable_pin	= AT91_PIN_PC14,
+   	.partition_info	= nand_partitions,
+   	.bus_width_16	= 0,
+   };
+   
+   static struct sam9_smc_config __initdata ek_nand_smc_config = {
+ ***************
+ *** 219,228 ****
+   static void __init ek_add_device_nand(void)
+   {
+   	/* setup bus-width (8 or 16) */
+ ! 	if (ek_nand_data.bus_width_16)
+ ! 		ek_nand_smc_config.mode |= AT91_SMC_DBW_16;
+ ! 	else
+ ! 		ek_nand_smc_config.mode |= AT91_SMC_DBW_8;
+   
+   	/* configure chip-select 3 (NAND) */
+   	sam9_smc_configure(3, &ek_nand_smc_config);
+ --- 165,171 ----
+   static void __init ek_add_device_nand(void)
+   {
+   	/* setup bus-width (8 or 16) */
+ !   ek_nand_smc_config.mode |= AT91_SMC_DBW_8;
+   
+   	/* configure chip-select 3 (NAND) */
+   	sam9_smc_configure(3, &ek_nand_smc_config);
+ ***************
+ *** 231,247 ****
+   }
+   
+   
+ - /*
+ -  * MCI (SD/MMC)
+ -  */
+ - static struct at91_mmc_data __initdata ek_mmc_data = {
+ - 	.slot_b		= 1,
+ - 	.wire4		= 1,
+ - //	.det_pin	= ... not connected
+ - //	.wp_pin		= ... not connected
+ - //	.vcc_pin	= ... not connected
+ - };
+ - 
+   
+   /*
+    * LEDs
+ --- 174,179 ----
+ ***************
+ *** 263,279 ****
+   /*
+    * I2C devices
+    */
+ - static struct at24_platform_data at24c512 = {
+ - 	.byte_len	= SZ_512K / 8,
+ - 	.page_size	= 128,
+ - 	.flags		= AT24_FLAG_ADDR16,
+ - };
+ - 
+   static struct i2c_board_info __initdata ek_i2c_devices[] = {
+   	{
+ ! 		I2C_BOARD_INFO("24c512", 0x50),
+ ! 		.platform_data = &at24c512,
+   	},
+   	/* more devices can be added using expansion connectors */
+   };
+   
+ --- 195,218 ----
+   /*
+    * I2C devices
+    */
+   static struct i2c_board_info __initdata ek_i2c_devices[] = {
+   	{
+ ! 		I2C_BOARD_INFO("rtc-ds1307", 0x68),
+ ! 		.type	= "ds1307",
+   	},
+ + 	{ I2C_BOARD_INFO("pca953x", 0x20),
+ + 	  .type = "pca953x",
+ +   },
+ + 	{ I2C_BOARD_INFO("pca953x", 0x21),
+ + 	  .type = "pca953x",
+ +   },
+ + 	{ I2C_BOARD_INFO("pca953x", 0x40),
+ + 	  .type = "pca953x",
+ +   },
+ + 	{ I2C_BOARD_INFO("pca953x", 0x41),
+ + 	  .type = "pca953x",
+ +   },
+ + 
+   	/* more devices can be added using expansion connectors */
+   };
+   
+ ***************
+ *** 341,357 ****
+   	ek_add_device_nand();
+   	/* Ethernet */
+   	at91_add_device_eth(&ek_macb_data);
+ - 	/* MMC */
+ - 	at91_add_device_mmc(0, &ek_mmc_data);
+   	/* I2C */
+   	at91_add_device_i2c(ek_i2c_devices, ARRAY_SIZE(ek_i2c_devices));
+ ! 	/* SSC (to AT73C213) */
+ ! 	at73c213_set_clk(&at73c213_data);
+ ! 	at91_add_device_ssc(AT91SAM9260_ID_SSC, ATMEL_SSC_TX);
+   	/* LEDs */
+   	at91_gpio_leds(ek_leds, ARRAY_SIZE(ek_leds));
+   	/* Push Buttons */
+   	ek_add_device_buttons();
+   }
+   
+   MACHINE_START(AT91SAM9260EK, "Atmel AT91SAM9260-EK")
+ --- 280,294 ----
+   	ek_add_device_nand();
+   	/* Ethernet */
+   	at91_add_device_eth(&ek_macb_data);
+   	/* I2C */
+   	at91_add_device_i2c(ek_i2c_devices, ARRAY_SIZE(ek_i2c_devices));
+ ! 
+ ! #ifdef udnef
+   	/* LEDs */
+   	at91_gpio_leds(ek_leds, ARRAY_SIZE(ek_leds));
+   	/* Push Buttons */
+   	ek_add_device_buttons();
+ + #endif
+   }
+   
+   MACHINE_START(AT91SAM9260EK, "Atmel AT91SAM9260-EK")
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/arch/arm/mach-at91/generic.h liab-linux-2.6.29.4/arch/arm/mach-at91/generic.h
+ *** linux-2.6.29.4/arch/arm/mach-at91/generic.h	2009-05-19 01:52:34.000000000 +0200
+ --- liab-linux-2.6.29.4/arch/arm/mach-at91/generic.h	2010-05-28 14:12:05.313678298 +0200
+ ***************
+ *** 1,4 ****
+ ! /*
+    * linux/arch/arm/mach-at91/generic.h
+    *
+    *  Copyright (C) 2005 David Brownell
+ --- 1,4 ----
+ ! *
+    * linux/arch/arm/mach-at91/generic.h
+    *
+    *  Copyright (C) 2005 David Brownell
+ ***************
+ *** 47,55 ****
+   #define AT91RM9200_BGA		4	/* AT91RM9200 BGA package has 4 banks */
+   
+   struct at91_gpio_bank {
+ - 	unsigned chipbase;		/* bank's first GPIO number */
+ - 	void __iomem *regbase;		/* base of register bank */
+ - 	struct at91_gpio_bank *next;	/* bank sharing same IRQ/clock/... */
+   	unsigned short id;		/* peripheral ID */
+   	unsigned long offset;		/* offset from system peripheral base */
+   	struct clk *clock;		/* associated clock */
+ --- 47,52 ----
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/arch/arm/mach-at91/gpio.c liab-linux-2.6.29.4/arch/arm/mach-at91/gpio.c
+ *** linux-2.6.29.4/arch/arm/mach-at91/gpio.c	2009-05-19 01:52:34.000000000 +0200
+ --- liab-linux-2.6.29.4/arch/arm/mach-at91/gpio.c	2010-05-28 13:57:30.593667616 +0200
+ ***************
+ *** 24,42 ****
+   #include <mach/at91_pio.h>
+   #include <mach/gpio.h>
+   
+   #include "generic.h"
+   
+   
+ ! static struct at91_gpio_bank *gpio;
+ ! static int gpio_banks;
+   
+   
+   static inline void __iomem *pin_to_controller(unsigned pin)
+   {
+   	pin -= PIN_BASE;
+   	pin /= 32;
+   	if (likely(pin < gpio_banks))
+ ! 		return gpio[pin].regbase;
+   
+   	return NULL;
+   }
+ --- 24,82 ----
+   #include <mach/at91_pio.h>
+   #include <mach/gpio.h>
+   
+ + #include <asm/gpio.h>
+ + 
+   #include "generic.h"
+   
+ + struct at91_gpio_chip {
+ + 	struct gpio_chip	chip;
+ + 	struct at91_gpio_chip	*next;		/* Bank sharing same clock */
+ + 	struct at91_gpio_bank	*bank;		/* Bank definition */
+ + 	void __iomem		*regbase;	/* Base of register bank */
+ + };
+   
+ ! #define to_at91_gpio_chip(c) container_of(c, struct at91_gpio_chip, chip)
+   
+ + static void at91_gpiolib_dbg_show(struct seq_file *s, struct gpio_chip *chip);
+ + static void at91_gpiolib_set(struct gpio_chip *chip, unsigned offset, int val);
+ + static int at91_gpiolib_get(struct gpio_chip *chip, unsigned offset);
+ + static int at91_gpiolib_direction_output(struct gpio_chip *chip,
+ + 					 unsigned offset, int val);
+ + static int at91_gpiolib_direction_input(struct gpio_chip *chip,
+ + 					unsigned offset);
+ + static int at91_gpiolib_request(struct gpio_chip *chip, unsigned offset);
+ + 
+ + #define AT91_GPIO_CHIP(name, base_gpio, nr_gpio)			\
+ + 	{								\
+ + 		.chip = {						\
+ + 			.label		  = name,			\
+ + 			.request	  = at91_gpiolib_request,	\
+ + 			.direction_input  = at91_gpiolib_direction_input, \
+ + 			.direction_output = at91_gpiolib_direction_output, \
+ + 			.get		  = at91_gpiolib_get,		\
+ + 			.set		  = at91_gpiolib_set,		\
+ + 			.dbg_show	  = at91_gpiolib_dbg_show,	\
+ + 			.base		  = base_gpio,			\
+ + 			.ngpio		  = nr_gpio,			\
+ + 		},							\
+ + 	}
+ + 
+ + static struct at91_gpio_chip gpio_chip[] = {
+ + 	AT91_GPIO_CHIP("A", 0x00 + PIN_BASE, 32),
+ + 	AT91_GPIO_CHIP("B", 0x20 + PIN_BASE, 32),
+ + 	AT91_GPIO_CHIP("C", 0x40 + PIN_BASE, 32),
+ + 	AT91_GPIO_CHIP("D", 0x60 + PIN_BASE, 32),
+ + 	AT91_GPIO_CHIP("E", 0x80 + PIN_BASE, 32),
+ + };
+ + 
+ + static int gpio_banks;
+   
+   static inline void __iomem *pin_to_controller(unsigned pin)
+   {
+   	pin -= PIN_BASE;
+   	pin /= 32;
+   	if (likely(pin < gpio_banks))
+ ! 		return gpio_chip[pin].regbase;
+   
+   	return NULL;
+   }
+ ***************
+ *** 197,235 ****
+   }
+   EXPORT_SYMBOL(at91_set_multi_drive);
+   
+ - /*--------------------------------------------------------------------------*/
+ - 
+ - /* new-style GPIO calls; these expect at91_set_GPIO_periph to have been
+ -  * called, and maybe at91_set_multi_drive() for putout pins.
+ -  */
+ - 
+ - int gpio_direction_input(unsigned pin)
+ - {
+ - 	void __iomem	*pio = pin_to_controller(pin);
+ - 	unsigned	mask = pin_to_mask(pin);
+ - 
+ - 	if (!pio || !(__raw_readl(pio + PIO_PSR) & mask))
+ - 		return -EINVAL;
+ - 	__raw_writel(mask, pio + PIO_ODR);
+ - 	return 0;
+ - }
+ - EXPORT_SYMBOL(gpio_direction_input);
+ - 
+ - int gpio_direction_output(unsigned pin, int value)
+ - {
+ - 	void __iomem	*pio = pin_to_controller(pin);
+ - 	unsigned	mask = pin_to_mask(pin);
+ - 
+ - 	if (!pio || !(__raw_readl(pio + PIO_PSR) & mask))
+ - 		return -EINVAL;
+ - 	__raw_writel(mask, pio + (value ? PIO_SODR : PIO_CODR));
+ - 	__raw_writel(mask, pio + PIO_OER);
+ - 	return 0;
+ - }
+ - EXPORT_SYMBOL(gpio_direction_output);
+ - 
+ - /*--------------------------------------------------------------------------*/
+ - 
+   /*
+    * assuming the pin is muxed as a gpio output, set its value.
+    */
+ --- 237,242 ----
+ ***************
+ *** 282,288 ****
+   	else
+   		wakeups[bank] &= ~mask;
+   
+ ! 	set_irq_wake(gpio[bank].id, state);
+   
+   	return 0;
+   }
+ --- 289,295 ----
+   	else
+   		wakeups[bank] &= ~mask;
+   
+ ! 	set_irq_wake(gpio_chip[bank].bank->id, state);
+   
+   	return 0;
+   }
+ ***************
+ *** 292,305 ****
+   	int i;
+   
+   	for (i = 0; i < gpio_banks; i++) {
+ ! 		void __iomem	*pio = gpio[i].regbase;
+   
+   		backups[i] = __raw_readl(pio + PIO_IMR);
+   		__raw_writel(backups[i], pio + PIO_IDR);
+   		__raw_writel(wakeups[i], pio + PIO_IER);
+   
+   		if (!wakeups[i])
+ ! 			clk_disable(gpio[i].clock);
+   		else {
+   #ifdef CONFIG_PM_DEBUG
+   			printk(KERN_DEBUG "GPIO-%c may wake for %08x\n", 'A'+i, wakeups[i]);
+ --- 299,312 ----
+   	int i;
+   
+   	for (i = 0; i < gpio_banks; i++) {
+ ! 		void __iomem	*pio = gpio_chip[i].regbase;
+   
+   		backups[i] = __raw_readl(pio + PIO_IMR);
+   		__raw_writel(backups[i], pio + PIO_IDR);
+   		__raw_writel(wakeups[i], pio + PIO_IER);
+   
+   		if (!wakeups[i])
+ ! 			clk_disable(gpio_chip[i].bank->clock);
+   		else {
+   #ifdef CONFIG_PM_DEBUG
+   			printk(KERN_DEBUG "GPIO-%c may wake for %08x\n", 'A'+i, wakeups[i]);
+ ***************
+ *** 313,322 ****
+   	int i;
+   
+   	for (i = 0; i < gpio_banks; i++) {
+ ! 		void __iomem	*pio = gpio[i].regbase;
+   
+   		if (!wakeups[i])
+ ! 			clk_enable(gpio[i].clock);
+   
+   		__raw_writel(wakeups[i], pio + PIO_IDR);
+   		__raw_writel(backups[i], pio + PIO_IER);
+ --- 320,329 ----
+   	int i;
+   
+   	for (i = 0; i < gpio_banks; i++) {
+ ! 		void __iomem	*pio = gpio_chip[i].regbase;
+   
+   		if (!wakeups[i])
+ ! 			clk_enable(gpio_chip[i].bank->clock);
+   
+   		__raw_writel(wakeups[i], pio + PIO_IDR);
+   		__raw_writel(backups[i], pio + PIO_IER);
+ ***************
+ *** 380,391 ****
+   {
+   	unsigned	pin;
+   	struct irq_desc	*gpio;
+ ! 	struct at91_gpio_bank *bank;
+   	void __iomem	*pio;
+   	u32		isr;
+   
+ ! 	bank = get_irq_chip_data(irq);
+ ! 	pio = bank->regbase;
+   
+   	/* temporarily mask (level sensitive) parent IRQ */
+   	desc->chip->ack(irq);
+ --- 387,398 ----
+   {
+   	unsigned	pin;
+   	struct irq_desc	*gpio;
+ ! 	struct at91_gpio_chip *at91_gpio;
+   	void __iomem	*pio;
+   	u32		isr;
+   
+ ! 	at91_gpio = get_irq_chip_data(irq);
+ ! 	pio = at91_gpio->regbase;
+   
+   	/* temporarily mask (level sensitive) parent IRQ */
+   	desc->chip->ack(irq);
+ ***************
+ *** 396,409 ****
+   		 */
+   		isr = __raw_readl(pio + PIO_ISR) & __raw_readl(pio + PIO_IMR);
+   		if (!isr) {
+ ! 			if (!bank->next)
+   				break;
+ ! 			bank = bank->next;
+ ! 			pio = bank->regbase;
+   			continue;
+   		}
+   
+ ! 		pin = bank->chipbase;
+   		gpio = &irq_desc[pin];
+   
+   		while (isr) {
+ --- 403,416 ----
+   		 */
+   		isr = __raw_readl(pio + PIO_ISR) & __raw_readl(pio + PIO_IMR);
+   		if (!isr) {
+ ! 			if (!at91_gpio->next)
+   				break;
+ ! 			at91_gpio = at91_gpio->next;
+ ! 			pio = at91_gpio->regbase;
+   			continue;
+   		}
+   
+ ! 		pin = at91_gpio->chip.base;
+   		gpio = &irq_desc[pin];
+   
+   		while (isr) {
+ ***************
+ *** 430,495 ****
+   
+   /*--------------------------------------------------------------------------*/
+   
+ - #ifdef CONFIG_DEBUG_FS
+ - 
+ - static int at91_gpio_show(struct seq_file *s, void *unused)
+ - {
+ - 	int bank, j;
+ - 
+ - 	/* print heading */
+ - 	seq_printf(s, "Pin\t");
+ - 	for (bank = 0; bank < gpio_banks; bank++) {
+ - 		seq_printf(s, "PIO%c\t", 'A' + bank);
+ - 	};
+ - 	seq_printf(s, "\n\n");
+ - 
+ - 	/* print pin status */
+ - 	for (j = 0; j < 32; j++) {
+ - 		seq_printf(s, "%i:\t", j);
+ - 
+ - 		for (bank = 0; bank < gpio_banks; bank++) {
+ - 			unsigned	pin  = PIN_BASE + (32 * bank) + j;
+ - 			void __iomem	*pio = pin_to_controller(pin);
+ - 			unsigned	mask = pin_to_mask(pin);
+ - 
+ - 			if (__raw_readl(pio + PIO_PSR) & mask)
+ - 				seq_printf(s, "GPIO:%s", __raw_readl(pio + PIO_PDSR) & mask ? "1" : "0");
+ - 			else
+ - 				seq_printf(s, "%s", __raw_readl(pio + PIO_ABSR) & mask ? "B" : "A");
+ - 
+ - 			seq_printf(s, "\t");
+ - 		}
+ - 
+ - 		seq_printf(s, "\n");
+ - 	}
+ - 
+ - 	return 0;
+ - }
+ - 
+ - static int at91_gpio_open(struct inode *inode, struct file *file)
+ - {
+ - 	return single_open(file, at91_gpio_show, NULL);
+ - }
+ - 
+ - static const struct file_operations at91_gpio_operations = {
+ - 	.open		= at91_gpio_open,
+ - 	.read		= seq_read,
+ - 	.llseek		= seq_lseek,
+ - 	.release	= single_release,
+ - };
+ - 
+ - static int __init at91_gpio_debugfs_init(void)
+ - {
+ - 	/* /sys/kernel/debug/at91_gpio */
+ - 	(void) debugfs_create_file("at91_gpio", S_IFREG | S_IRUGO, NULL, NULL, &at91_gpio_operations);
+ - 	return 0;
+ - }
+ - postcore_initcall(at91_gpio_debugfs_init);
+ - 
+ - #endif
+ - 
+ - /*--------------------------------------------------------------------------*/
+ - 
+   /*
+    * This lock class tells lockdep that GPIO irqs are in a different
+    * category than their parents, so it won't report false recursion.
+ --- 437,442 ----
+ ***************
+ *** 502,518 ****
+   void __init at91_gpio_irq_setup(void)
+   {
+   	unsigned		pioc, pin;
+ ! 	struct at91_gpio_bank	*this, *prev;
+   
+ ! 	for (pioc = 0, pin = PIN_BASE, this = gpio, prev = NULL;
+ ! 			pioc++ < gpio_banks;
+ ! 			prev = this, this++) {
+ ! 		unsigned	id = this->id;
+   		unsigned	i;
+   
+   		__raw_writel(~0, this->regbase + PIO_IDR);
+   
+ ! 		for (i = 0, pin = this->chipbase; i < 32; i++, pin++) {
+   			lockdep_set_class(&irq_desc[pin].lock, &gpio_lock_class);
+   
+   			/*
+ --- 449,470 ----
+   void __init at91_gpio_irq_setup(void)
+   {
+   	unsigned		pioc, pin;
+ ! 	struct at91_gpio_chip	*this, *prev;
+   
+ ! 
+ !   for (pioc = 0, pin = PIN_BASE, this = gpio_chip, prev = NULL;
+ !        pioc++ < gpio_banks;
+ !        prev = this, this++) {
+ ! 
+ !     unsigned	id = this->bank->id;
+   		unsigned	i;
+   
+ +     /* enable PIO controller's clock */
+ +     clk_enable(this->bank->clock);
+ + 
+   		__raw_writel(~0, this->regbase + PIO_IDR);
+   
+ !     for (i = 0, pin = this->chip.base; i < 32; i++, pin++) {
+   			lockdep_set_class(&irq_desc[pin].lock, &gpio_lock_class);
+   
+   			/*
+ ***************
+ *** 537,568 ****
+   	pr_info("AT91: %d gpio irqs in %d banks\n", pin - PIN_BASE, gpio_banks);
+   }
+   
+   /*
+    * Called from the processor-specific init to enable GPIO pin support.
+    */
+   void __init at91_gpio_init(struct at91_gpio_bank *data, int nr_banks)
+   {
+   	unsigned		i;
+ ! 	struct at91_gpio_bank	*last;
+   
+   	BUG_ON(nr_banks > MAX_GPIO_BANKS);
+   
+ - 	gpio = data;
+   	gpio_banks = nr_banks;
+   
+ ! 	for (i = 0, last = NULL; i < nr_banks; i++, last = data, data++) {
+ ! 		data->chipbase = PIN_BASE + i * 32;
+ ! 		data->regbase = data->offset + (void __iomem *)AT91_VA_BASE_SYS;
+ ! 
+ ! 		/* enable PIO controller's clock */
+ ! 		clk_enable(data->clock);
+ ! 
+ ! 		/*
+ ! 		 * Some processors share peripheral ID between multiple GPIO banks.
+ ! 		 *  SAM9263 (PIOC, PIOD, PIOE)
+ ! 		 *  CAP9 (PIOA, PIOB, PIOC, PIOD)
+ ! 		 */
+ ! 		if (last && last->id == data->id)
+ ! 			last->next = data;
+   	}
+   }
+ --- 489,606 ----
+   	pr_info("AT91: %d gpio irqs in %d banks\n", pin - PIN_BASE, gpio_banks);
+   }
+   
+ + /* gpiolib support */
+ + static int at91_gpiolib_direction_input(struct gpio_chip *chip,
+ + 					unsigned offset)
+ + {
+ + 	struct at91_gpio_chip *at91_gpio = to_at91_gpio_chip(chip);
+ + 	void __iomem *pio = at91_gpio->regbase;
+ + 	unsigned mask = 1 << offset;
+ + 	
+ + 	__raw_writel(mask, pio + PIO_ODR);
+ + 	return 0;
+ + }
+ + 
+ + static int at91_gpiolib_direction_output(struct gpio_chip *chip,
+ + 					 unsigned offset, int val)
+ + {
+ + 	struct at91_gpio_chip *at91_gpio = to_at91_gpio_chip(chip);
+ + 	void __iomem *pio = at91_gpio->regbase;
+ + 	unsigned mask = 1 << offset;
+ + 
+ + 	__raw_writel(mask, pio + (val ? PIO_SODR : PIO_CODR));
+ + 	__raw_writel(mask, pio + PIO_OER);
+ + 	return 0;
+ + }
+ + 
+ + static int at91_gpiolib_get(struct gpio_chip *chip, unsigned offset)
+ + {
+ + 	struct at91_gpio_chip *at91_gpio = to_at91_gpio_chip(chip);
+ + 	void __iomem *pio = at91_gpio->regbase;
+ + 	unsigned mask = 1 << offset;
+ + 	u32 pdsr;
+ + 
+ + 	pdsr = __raw_readl(pio + PIO_PDSR);
+ + 	return (pdsr & mask) != 0;
+ + }
+ + 
+ + static void at91_gpiolib_set(struct gpio_chip *chip, unsigned offset, int val)
+ + {	
+ + 	struct at91_gpio_chip *at91_gpio = to_at91_gpio_chip(chip);
+ + 	void __iomem *pio = at91_gpio->regbase;
+ + 	unsigned mask = 1 << offset;
+ + 	
+ + 	__raw_writel(mask, pio + (val ? PIO_SODR : PIO_CODR));
+ + }
+ + 
+ + static int at91_gpiolib_request(struct gpio_chip *chip, unsigned offset)
+ + {
+ + 	unsigned pin = chip->base + offset;
+ + 	void __iomem *pio = pin_to_controller(pin);
+ + 	unsigned mask = pin_to_mask(pin);
+ + 	
+ + 	/* Cannot request GPIOs that are in alternate function mode */
+ + 	if (!(__raw_readl(pio + PIO_PSR) & mask))
+ + 		return -EPERM;
+ + 	
+ + 	return 0;
+ + }
+ + 
+ + static void at91_gpiolib_dbg_show(struct seq_file *s, struct gpio_chip *chip)
+ + {
+ + 	int i;
+ + 
+ + 	for (i = 0; i < chip->ngpio; i++) {
+ + 		unsigned pin = chip->base + i;
+ + 		void __iomem *pio = pin_to_controller(pin);
+ + 		unsigned mask = pin_to_mask(pin);
+ + 		const char *gpio_label;
+ + 
+ + 		gpio_label = gpiochip_is_requested(chip, i);
+ + 		if (gpio_label) {
+ + 			seq_printf(s, "[%s] GPIO%s%d: ",
+ + 				   gpio_label, chip->label, i);
+ + 			if (__raw_readl(pio + PIO_PSR) & mask)
+ + 				seq_printf(s, "[gpio] %s\n",
+ + 					   at91_get_gpio_value(pin) ?
+ + 					   "set" : "clear");
+ + 			else
+ + 				seq_printf(s, "[periph %s]\n",
+ + 					   __raw_readl(pio + PIO_ABSR) &
+ + 					   mask ? "B" : "A");
+ + 		}
+ + 	}
+ + }
+ + 
+ + 
+   /*
+    * Called from the processor-specific init to enable GPIO pin support.
+    */
+   void __init at91_gpio_init(struct at91_gpio_bank *data, int nr_banks)
+   {
+   	unsigned		i;
+ !   struct at91_gpio_chip *at91_gpio, *last = NULL;
+ !  
+   
+   	BUG_ON(nr_banks > MAX_GPIO_BANKS);
+   
+   	gpio_banks = nr_banks;
+   
+ ! 
+ ! 	for (i = 0; i < nr_banks; i++) {
+ ! 		at91_gpio = &gpio_chip[i];
+ ! 
+ ! 		at91_gpio->bank = &data[i];
+ ! 		at91_gpio->chip.base = PIN_BASE + i * 32;
+ ! 		at91_gpio->regbase = at91_gpio->bank->offset + 
+ ! 			(void __iomem *)AT91_VA_BASE_SYS;
+ ! 
+ ! 		/* AT91SAM9263_ID_PIOCDE groups PIOC, PIOD, PIOE */
+ ! 		if (last && last->bank->id == at91_gpio->bank->id)
+ ! 			last->next = at91_gpio;
+ ! 		last = at91_gpio;
+ ! 
+ ! 		gpiochip_add(&at91_gpio->chip);
+ ! 
+   	}
+   }
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/arch/arm/mach-at91/include/mach/board.h liab-linux-2.6.29.4/arch/arm/mach-at91/include/mach/board.h
+ *** linux-2.6.29.4/arch/arm/mach-at91/include/mach/board.h	2009-05-19 01:52:34.000000000 +0200
+ --- liab-linux-2.6.29.4/arch/arm/mach-at91/include/mach/board.h	2009-07-31 11:37:22.000000000 +0200
+ ***************
+ *** 106,111 ****
+ --- 106,112 ----
+   
+    /* I2C*/
+   extern void __init at91_add_device_i2c(struct i2c_board_info *devices, int nr_devices);
+ + extern void __init at91_add_device_gpio_i2c(void);
+   
+    /* SPI */
+   extern void __init at91_add_device_spi(struct spi_board_info *devices, int nr_devices);
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/arch/arm/mach-at91/include/mach/gpio.h liab-linux-2.6.29.4/arch/arm/mach-at91/include/mach/gpio.h
+ *** linux-2.6.29.4/arch/arm/mach-at91/include/mach/gpio.h	2009-05-19 01:52:34.000000000 +0200
+ --- liab-linux-2.6.29.4/arch/arm/mach-at91/include/mach/gpio.h	2010-05-28 13:41:52.310652394 +0200
+ ***************
+ *** 213,244 ****
+    */
+   
+   #include <asm/errno.h>
+ - 
+ - static inline int gpio_request(unsigned gpio, const char *label)
+ - {
+ - 	return 0;
+ - }
+ - 
+ - static inline void gpio_free(unsigned gpio)
+ - {
+ - 	might_sleep();
+ - }
+ - 
+ - extern int gpio_direction_input(unsigned gpio);
+ - extern int gpio_direction_output(unsigned gpio, int value);
+ - 
+ - static inline int gpio_get_value(unsigned gpio)
+ - {
+ - 	return at91_get_gpio_value(gpio);
+ - }
+ - 
+ - static inline void gpio_set_value(unsigned gpio, int value)
+ - {
+ - 	at91_set_gpio_value(gpio, value);
+ - }
+ - 
+   #include <asm-generic/gpio.h>		/* cansleep wrappers */
+   
+   static inline int gpio_to_irq(unsigned gpio)
+   {
+   	return gpio;
+ --- 213,224 ----
+    */
+   
+   #include <asm/errno.h>
+   #include <asm-generic/gpio.h>		/* cansleep wrappers */
+   
+ + #define gpio_get_value	__gpio_get_value
+ + #define gpio_set_value	__gpio_set_value
+ + #define gpio_cansleep	__gpio_cansleep
+ + 
+   static inline int gpio_to_irq(unsigned gpio)
+   {
+   	return gpio;
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/arch/arm/mach-at91/Kconfig liab-linux-2.6.29.4/arch/arm/mach-at91/Kconfig
+ *** linux-2.6.29.4/arch/arm/mach-at91/Kconfig	2009-05-19 01:52:34.000000000 +0200
+ --- liab-linux-2.6.29.4/arch/arm/mach-at91/Kconfig	2010-05-28 13:29:08.593651908 +0200
+ ***************
+ *** 56,61 ****
+ --- 56,68 ----
+   	bool
+   	default !ARCH_AT91X40
+   
+ + 
+ + config MACH_LIABARM
+ + 	bool "LIAB (Linux-In-A-Box) board"
+ + 	depends on ARCH_AT91RM9200 || ARCH_AT91SAM9260
+ + 	help
+ + 	  Select this if you are using an ARM-based LIAB board.
+ + 
+   # ----------------------------------------------------------
+   
+   if ARCH_AT91RM9200
+ ***************
+ *** 76,81 ****
+ --- 83,145 ----
+   	  Select this if you are using Atmel's AT91RM9200-DK Development board.
+   	  (Discontinued)
+   
+ + choice
+ +   depends on MACH_LIABARM  
+ +   prompt "LIAB board type"
+ +   default MACH_LIABARM9200
+ + 
+ +   config MACH_LIABARM9200
+ +     bool "LIABARM9200 board"
+ + 
+ +   config MACH_NANOLIAB
+ +     bool "nanoLIAB board"
+ + 
+ +   config MACH_LIABDIN
+ +     bool "LIABDIN board"
+ + endchoice
+ + 
+ + config LIAB_TDC_LIABDIN_ADDON
+ +   bool "Enable TDC LIABDIN addon board features"
+ + 	depends on MACH_LIABDIN
+ + 	help
+ + 	  Select this if you have the TDC addon board with SD-card, DM9000A network adapter, USB slave, etc.
+ + 
+ + config LIAB_LIABDIN_ADDON
+ +   bool "Enable Standard LIABDIN addon board features"
+ + 	depends on MACH_LIABDIN
+ + 	help
+ + 	  Select this if you have the standard LIAB addon board with LEDs, antenna bezel, and SIM card holder
+ + 
+ + config LIAB_ENABLE_UART0
+ + 	bool "Enable UART0"
+ + 	depends on MACH_LIABARM
+ + 	help
+ + 	  Select this if you want to enable UART0 on ttyS1.
+ + 
+ + config LIAB_ENABLE_UART1
+ + 	bool "Enable UART1"
+ + 	depends on MACH_LIABARM
+ + 	help
+ + 	  Select this if you want to enable UART1 on ttyS2.
+ + 
+ + config LIAB_ENABLE_UART2
+ + 	bool "Enable UART2"
+ + 	depends on MACH_LIABARM
+ + 	help
+ + 	  Select this if you want to enable UART2 on ttyS3.
+ + 
+ + config LIAB_ENABLE_UART3
+ + 	bool "Enable UART3"
+ + 	depends on MACH_LIABARM
+ + 	help
+ + 	  Select this if you want to enable UART3 on ttyS4.
+ + 
+ + config LIAB_RELAY_ADDON
+ +   depends on MACH_LIABARM && MACH_NANOLIAB
+ +   bool "nanoLIAB relay board V1"
+ +   help
+ + 	  Select this if you are using a version 1 nanoLIAB relay board.
+ + 
+   config MACH_AT91RM9200EK
+   	bool "Atmel AT91RM9200-EK Evaluation Kit"
+   	depends on ARCH_AT91RM9200
+ ***************
+ *** 144,149 ****
+ --- 208,215 ----
+   	help
+   	  Select this if you are using the ucDragon YL-9200 board.
+   
+ + 
+ + 
+   endif
+   
+   # ----------------------------------------------------------
+ ***************
+ *** 164,173 ****
+ --- 230,246 ----
+   config MACH_AT91SAM9260EK
+   	bool "Atmel AT91SAM9260-EK / AT91SAM9XE Evaluation Kit"
+   	depends on ARCH_AT91SAM9260
+ +   select ARCH_WANT_OPTIONAL_GPIOLIB
+   	help
+   	  Select this if you are using Atmel's AT91SAM9260-EK or AT91SAM9XE Evaluation Kit
+   	  <http://www.atmel.com/dyn/products/tools_card.asp?tool_id=3933>
+   
+ + config MACH_LIABSG
+ +   bool "LIAB SG board"
+ +   depends on (ARCH_AT91SAM9260 && MACH_LIABARM)   
+ +   help
+ +     Select this if you have a LIAB SmartGrid board.
+ + 
+   config MACH_CAM60
+   	bool "KwikByte KB9260 (CAM60) board"
+   	depends on ARCH_AT91SAM9260
+ ***************
+ *** 326,331 ****
+ --- 399,422 ----
+   	  On AT91SAM926x boards both types of NAND flash can be present
+   	  (8 and 16 bit data bus width).
+   
+ + config ARCH_LIABAT91RM9200_HASMII
+ + 	bool "Use MII (default is RMII) ethernet"
+ + 	depends on ARCH_AT91RM9200 && MACH_LIABARM
+ + 	help
+ + 	  Select this if you are using MII on LIAB boards, e.g. nanoLIAB.
+ + 
+ + config ARCH_LIABAT91RM9200_SELECTDBGUANDUART0
+ + 	bool "AT91RM9200-DK and LIABARM boards has support for DBGU and UART0"
+ + 	depends on ARCH_AT91RM9200 && MACH_LIABARM
+ + 	help
+ + 	  Select this if you want compiled-in support for two UARTS: DBGU and UART0
+ + 
+ + config I2C_AT91_GPIO
+ + 	bool "LIABARM support for GPIO I2C"
+ + 	depends on ARCH_AT91RM9200 && MACH_LIABARM
+ + 	help
+ + 
+ + 
+   # ----------------------------------------------------------
+   
+   comment "AT91 Feature Selections"
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/arch/arm/mach-at91/Makefile liab-linux-2.6.29.4/arch/arm/mach-at91/Makefile
+ *** linux-2.6.29.4/arch/arm/mach-at91/Makefile	2009-05-19 01:52:34.000000000 +0200
+ --- liab-linux-2.6.29.4/arch/arm/mach-at91/Makefile	2010-05-28 09:21:39.630676374 +0200
+ ***************
+ *** 32,37 ****
+ --- 32,39 ----
+   obj-$(CONFIG_MACH_PICOTUX2XX)	+= board-picotux200.o
+   obj-$(CONFIG_MACH_ECBAT91)	+= board-ecbat91.o
+   obj-$(CONFIG_MACH_YL9200)	+= board-yl-9200.o
+ + obj-$(CONFIG_MACH_NANOLIAB)	+= board-nanoliab.o
+ + obj-$(CONFIG_MACH_LIABDIN)	+= board-liabdin.o
+   
+   # AT91SAM9260 board-specific support
+   obj-$(CONFIG_MACH_AT91SAM9260EK) += board-sam9260ek.o
+ ***************
+ *** 41,46 ****
+ --- 43,51 ----
+   obj-$(CONFIG_MACH_QIL_A9260)	+= board-qil-a9260.o
+   obj-$(CONFIG_MACH_AFEB9260)	+= board-afeb-9260v1.o
+   
+ + # AT91SAM9260-based LIAB SG board
+ + obj-$(CONFIG_MACH_LIABSG) += board-liabsg.o
+ + 
+   # AT91SAM9261 board-specific support
+   obj-$(CONFIG_MACH_AT91SAM9261EK) += board-sam9261ek.o
+   
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/arch/arm/tools/mach-types liab-linux-2.6.29.4/arch/arm/tools/mach-types
+ *** linux-2.6.29.4/arch/arm/tools/mach-types	2009-05-19 01:52:34.000000000 +0200
+ --- liab-linux-2.6.29.4/arch/arm/tools/mach-types	2009-07-31 11:37:14.000000000 +0200
+ ***************
+ *** 277,282 ****
+ --- 277,283 ----
+   ixcdp1100		ARCH_IXCDP1100		IXCDP1100		260
+   prpmc1100		ARCH_PRPMC1100		PRPMC1100		261
+   at91rm9200dk		ARCH_AT91RM9200DK	AT91RM9200DK		262
+ + liabarm		MACH_LIABARM	LIABARM		262
+   armstick		ARCH_ARMSTICK		ARMSTICK		263
+   armonie			ARCH_ARMONIE		ARMONIE			264
+   mport1			ARCH_MPORT1		MPORT1			265
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/arch/x86/kernel/cpu/capflags.c liab-linux-2.6.29.4/arch/x86/kernel/cpu/capflags.c
+ *** linux-2.6.29.4/arch/x86/kernel/cpu/capflags.c	1970-01-01 01:00:00.000000000 +0100
+ --- liab-linux-2.6.29.4/arch/x86/kernel/cpu/capflags.c	2009-07-31 11:38:14.000000000 +0200
+ ***************
+ *** 0 ****
+ --- 1,115 ----
+ + #include <asm/cpufeature.h>
+ + 
+ + const char * const x86_cap_flags[NCAPINTS*32] = {
+ + 	[X86_FEATURE_FPU]                = "fpu",
+ + 	[X86_FEATURE_VME]                = "vme",
+ + 	[X86_FEATURE_DE]                 = "de",
+ + 	[X86_FEATURE_PSE]                = "pse",
+ + 	[X86_FEATURE_TSC]                = "tsc",
+ + 	[X86_FEATURE_MSR]                = "msr",
+ + 	[X86_FEATURE_PAE]                = "pae",
+ + 	[X86_FEATURE_MCE]                = "mce",
+ + 	[X86_FEATURE_CX8]                = "cx8",
+ + 	[X86_FEATURE_APIC]               = "apic",
+ + 	[X86_FEATURE_SEP]                = "sep",
+ + 	[X86_FEATURE_MTRR]               = "mtrr",
+ + 	[X86_FEATURE_PGE]                = "pge",
+ + 	[X86_FEATURE_MCA]                = "mca",
+ + 	[X86_FEATURE_CMOV]               = "cmov",
+ + 	[X86_FEATURE_PAT]                = "pat",
+ + 	[X86_FEATURE_PSE36]              = "pse36",
+ + 	[X86_FEATURE_PN]                 = "pn",
+ + 	[X86_FEATURE_CLFLSH]             = "clflush",
+ + 	[X86_FEATURE_DS]                 = "dts",
+ + 	[X86_FEATURE_ACPI]               = "acpi",
+ + 	[X86_FEATURE_MMX]                = "mmx",
+ + 	[X86_FEATURE_FXSR]               = "fxsr",
+ + 	[X86_FEATURE_XMM]                = "sse",
+ + 	[X86_FEATURE_XMM2]               = "sse2",
+ + 	[X86_FEATURE_SELFSNOOP]          = "ss",
+ + 	[X86_FEATURE_HT]                 = "ht",
+ + 	[X86_FEATURE_ACC]                = "tm",
+ + 	[X86_FEATURE_IA64]               = "ia64",
+ + 	[X86_FEATURE_PBE]                = "pbe",
+ + 	[X86_FEATURE_SYSCALL]            = "syscall",
+ + 	[X86_FEATURE_MP]                 = "mp",
+ + 	[X86_FEATURE_NX]                 = "nx",
+ + 	[X86_FEATURE_MMXEXT]             = "mmxext",
+ + 	[X86_FEATURE_FXSR_OPT]           = "fxsr_opt",
+ + 	[X86_FEATURE_GBPAGES]            = "pdpe1gb",
+ + 	[X86_FEATURE_RDTSCP]             = "rdtscp",
+ + 	[X86_FEATURE_LM]                 = "lm",
+ + 	[X86_FEATURE_3DNOWEXT]           = "3dnowext",
+ + 	[X86_FEATURE_3DNOW]              = "3dnow",
+ + 	[X86_FEATURE_RECOVERY]           = "recovery",
+ + 	[X86_FEATURE_LONGRUN]            = "longrun",
+ + 	[X86_FEATURE_LRTI]               = "lrti",
+ + 	[X86_FEATURE_CXMMX]              = "cxmmx",
+ + 	[X86_FEATURE_K6_MTRR]            = "k6_mtrr",
+ + 	[X86_FEATURE_CYRIX_ARR]          = "cyrix_arr",
+ + 	[X86_FEATURE_CENTAUR_MCR]        = "centaur_mcr",
+ + 	[X86_FEATURE_CONSTANT_TSC]       = "constant_tsc",
+ + 	[X86_FEATURE_UP]                 = "up",
+ + 	[X86_FEATURE_ARCH_PERFMON]       = "arch_perfmon",
+ + 	[X86_FEATURE_PEBS]               = "pebs",
+ + 	[X86_FEATURE_BTS]                = "bts",
+ + 	[X86_FEATURE_REP_GOOD]           = "rep_good",
+ + 	[X86_FEATURE_NOPL]               = "nopl",
+ + 	[X86_FEATURE_AMDC1E]             = "amdc1e",
+ + 	[X86_FEATURE_XTOPOLOGY]          = "xtopology",
+ + 	[X86_FEATURE_TSC_RELIABLE]       = "tsc_reliable",
+ + 	[X86_FEATURE_NONSTOP_TSC]        = "nonstop_tsc",
+ + 	[X86_FEATURE_XMM3]               = "pni",
+ + 	[X86_FEATURE_PCLMULQDQ]          = "pclmulqdq",
+ + 	[X86_FEATURE_DTES64]             = "dtes64",
+ + 	[X86_FEATURE_MWAIT]              = "monitor",
+ + 	[X86_FEATURE_DSCPL]              = "ds_cpl",
+ + 	[X86_FEATURE_VMX]                = "vmx",
+ + 	[X86_FEATURE_SMX]                = "smx",
+ + 	[X86_FEATURE_EST]                = "est",
+ + 	[X86_FEATURE_TM2]                = "tm2",
+ + 	[X86_FEATURE_SSSE3]              = "ssse3",
+ + 	[X86_FEATURE_CID]                = "cid",
+ + 	[X86_FEATURE_FMA]                = "fma",
+ + 	[X86_FEATURE_CX16]               = "cx16",
+ + 	[X86_FEATURE_XTPR]               = "xtpr",
+ + 	[X86_FEATURE_PDCM]               = "pdcm",
+ + 	[X86_FEATURE_DCA]                = "dca",
+ + 	[X86_FEATURE_XMM4_1]             = "sse4_1",
+ + 	[X86_FEATURE_XMM4_2]             = "sse4_2",
+ + 	[X86_FEATURE_X2APIC]             = "x2apic",
+ + 	[X86_FEATURE_AES]                = "aes",
+ + 	[X86_FEATURE_XSAVE]              = "xsave",
+ + 	[X86_FEATURE_AVX]                = "avx",
+ + 	[X86_FEATURE_HYPERVISOR]         = "hypervisor",
+ + 	[X86_FEATURE_XSTORE]             = "rng",
+ + 	[X86_FEATURE_XSTORE_EN]          = "rng_en",
+ + 	[X86_FEATURE_XCRYPT]             = "ace",
+ + 	[X86_FEATURE_XCRYPT_EN]          = "ace_en",
+ + 	[X86_FEATURE_ACE2]               = "ace2",
+ + 	[X86_FEATURE_ACE2_EN]            = "ace2_en",
+ + 	[X86_FEATURE_PHE]                = "phe",
+ + 	[X86_FEATURE_PHE_EN]             = "phe_en",
+ + 	[X86_FEATURE_PMM]                = "pmm",
+ + 	[X86_FEATURE_PMM_EN]             = "pmm_en",
+ + 	[X86_FEATURE_LAHF_LM]            = "lahf_lm",
+ + 	[X86_FEATURE_CMP_LEGACY]         = "cmp_legacy",
+ + 	[X86_FEATURE_SVM]                = "svm",
+ + 	[X86_FEATURE_EXTAPIC]            = "extapic",
+ + 	[X86_FEATURE_CR8_LEGACY]         = "cr8_legacy",
+ + 	[X86_FEATURE_ABM]                = "abm",
+ + 	[X86_FEATURE_SSE4A]              = "sse4a",
+ + 	[X86_FEATURE_MISALIGNSSE]        = "misalignsse",
+ + 	[X86_FEATURE_3DNOWPREFETCH]      = "3dnowprefetch",
+ + 	[X86_FEATURE_OSVW]               = "osvw",
+ + 	[X86_FEATURE_IBS]                = "ibs",
+ + 	[X86_FEATURE_SSE5]               = "sse5",
+ + 	[X86_FEATURE_SKINIT]             = "skinit",
+ + 	[X86_FEATURE_WDT]                = "wdt",
+ + 	[X86_FEATURE_IDA]                = "ida",
+ + 	[X86_FEATURE_TPR_SHADOW]         = "tpr_shadow",
+ + 	[X86_FEATURE_VNMI]               = "vnmi",
+ + 	[X86_FEATURE_FLEXPRIORITY]       = "flexpriority",
+ + 	[X86_FEATURE_EPT]                = "ept",
+ + 	[X86_FEATURE_VPID]               = "vpid",
+ + };
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.alias liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.alias
+ *** linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.alias	1970-01-01 01:00:00.000000000 +0100
+ --- liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.alias	2009-07-31 11:36:16.000000000 +0200
+ ***************
+ *** 0 ****
+ --- 1,391 ----
+ + # Aliases extracted from modules themselves.
+ + alias usb:v*p*d*dc*dsc*dp*ic08isc06ip50* usb_storage
+ + alias usb:v*p*d*dc*dsc*dp*ic08isc05ip50* usb_storage
+ + alias usb:v*p*d*dc*dsc*dp*ic08isc04ip50* usb_storage
+ + alias usb:v*p*d*dc*dsc*dp*ic08isc03ip50* usb_storage
+ + alias usb:v*p*d*dc*dsc*dp*ic08isc02ip50* usb_storage
+ + alias usb:v*p*d*dc*dsc*dp*ic08isc01ip50* usb_storage
+ + alias usb:v*p*d*dc*dsc*dp*ic08isc06ip00* usb_storage
+ + alias usb:v*p*d*dc*dsc*dp*ic08isc05ip00* usb_storage
+ + alias usb:v*p*d*dc*dsc*dp*ic08isc04ip00* usb_storage
+ + alias usb:v*p*d*dc*dsc*dp*ic08isc03ip00* usb_storage
+ + alias usb:v*p*d*dc*dsc*dp*ic08isc02ip00* usb_storage
+ + alias usb:v*p*d*dc*dsc*dp*ic08isc01ip00* usb_storage
+ + alias usb:v*p*d*dc*dsc*dp*ic08isc06ip01* usb_storage
+ + alias usb:v*p*d*dc*dsc*dp*ic08isc05ip01* usb_storage
+ + alias usb:v*p*d*dc*dsc*dp*ic08isc04ip01* usb_storage
+ + alias usb:v*p*d*dc*dsc*dp*ic08isc03ip01* usb_storage
+ + alias usb:v*p*d*dc*dsc*dp*ic08isc02ip01* usb_storage
+ + alias usb:v*p*d*dc*dsc*dp*ic08isc01ip01* usb_storage
+ + alias usb:vED10p7636d0001dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:vED06p4500d0001dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v4146pBA01d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v4102p1020d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v3340pFFFFd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v2770p915Dd0010dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v2735p100Bd*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v22B8p6426d0101dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v22B8p3010d0001dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v2116p0320d0001dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v1652p6600d0201dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v152Dp2329d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v14CDp6600d0201dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v1370p6828d0110dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v132Bp000Bd0001dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p143Fd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p143Ed0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p143Dd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p143Cd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p143Bd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p143Ad0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1439d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1438d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1437d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1436d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1435d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1434d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1433d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1432d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1431d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1430d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p142Fd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p142Ed0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p142Dd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p142Cd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p142Bd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p142Ad0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1429d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1428d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1427d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1426d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1425d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1424d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1423d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1422d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1421d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1420d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p141Fd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p141Ed0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p141Dd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p141Cd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p141Bd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p141Ad0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1419d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1418d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1417d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1416d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1415d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1414d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1413d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1412d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1411d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1410d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p140Fd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p140Ed0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p140Dd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p140Cd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p140Bd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p140Ad0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1409d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1408d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1407d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1406d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1405d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1404d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1403d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1402d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1401d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1004d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1003d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v12D1p1001d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v1210p0003d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v1199p0FFFd*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v10D6p2200d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v1058p0704d*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v1019p0C55d00*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v1019p0C55d010*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v1019p0C55d0110dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0FCEpE092d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0FCEpE031d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0FCEpE030d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0FCEpD0E1d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0FCEpD008d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0F19p0105d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0F19p0103d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0ED1p7636d0103dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0EA0p6828d0110dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0EA0p2168d0110dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0ED1p6660d0[1-2]*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0ED1p6660d0300dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0E21p0520d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0DDAp0301d0012dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0DDAp0001d0012dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0DD8pD202d*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0DD8p1060d*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0DC4p0073d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0D96p5200d01*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0D96p5200d00[1-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0D96p5200d0200dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0D96p5200d000[1-9]dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0D96p410Ad[1-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0D96p410Ad0[1-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0D96p410Ad00[1-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0D96p410Ad000[1-9]dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0C45p1060d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0D49p7310d*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0BC2p3010d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0AF0p7501d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0AF0p7401d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0AF0p6971d*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0ACEp20FFd0101dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0ACEp2011d0101dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0A17p0004d1000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v090Cp1132d*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v090Ap1200d*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v090Ap1050d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v090Ap1001d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v08CAp3103d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v08BDp1100d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0851p1543d0200dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v084Dp0011d0110dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0840p0085d0001dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0840p0084d0001dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0840p0082d0001dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0839p000Ad0001dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v07CFp1001d[1-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v07C4pA4A5d*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v07C4pA400d*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v07AFp0006d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v07AFp0005d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v07AFp0004d01[0-2]*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v07AFp0004d013[0-3]dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v07ABpFCCDd*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0781p0100d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0781p0002d0009dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0781p0001d0200dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0727p0306d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v071Bp3203d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v071Bp32BBd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v071Bp3203d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v069Bp3004d0001dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0693p0005d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0686p4017d0001dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0686p4011d0001dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v067Bp3507d00[1-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v067Bp3507d010[0-1]dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v067Bp3507d000[1-9]dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v067Bp2507d00[1-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v067Bp2507d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v067Bp2507d000[1-9]dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v066Fp8000d0001dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0644p0000d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0636p0003d*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v05E3p0723d9451dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v05E3p0702d*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v05E3p0701d*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v05DCpB002d00*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v05DCpB002d010*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v05DCpB002d011[0-3]dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v05C6p1000d*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v05ACp120Ad*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v05ACp1205d*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v05ACp1204d*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v05ACp1203d*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v05ACp1202d*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v05ABp0060d1110dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v05ABp0060d110[4-9]dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v059Fp0643d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v059Bp0001d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0595p4343d[0-1]*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0595p4343d2[0-1]*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0595p4343d220*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0595p4343d2210dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v058Fp6387d0141dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v057Bp0022d*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v057Bp0000d[1-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v057Bp0000d0[3-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v057Bp0000d0[0-2]*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v055Dp2020d0[0-1]*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v055Dp2020d020*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v055Dp2020d0210dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v054Cp016Ad*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v054Cp0099d*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v054Cp006Dd*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v054Cp0069d*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v054Cp0058d*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v054Cp0032d*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v054Cp002Ed0500dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v054Cp002Ed02*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v054Cp002Ed030*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v054Cp002Ed01[1-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v054Cp002Ed0310dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v054Cp002Ed010[6-9]dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v054Cp002Dd0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v054Cp002Cd1*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v054Cp002Cd0[6-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v054Cp002Cd05[1-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v054Cp002Cd2000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v054Cp002Cd050[1-9]dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v054Cp0025d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v054Cp0010d05*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v054Cp0010d060*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v054Cp0010d0610dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v054Cp0010d0[2-3]*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v054Cp0010d04[0-4]*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v054Cp0010d01[1-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v054Cp0010d0450dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v054Cp0010d010[6-9]dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v052Bp1911d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v052Bp1905d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v052Bp1807d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v052Bp1804d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v052Bp1801d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0525pA4A5d*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0525pA140d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v050Dp0115d0133dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v04FCp80C2d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v04E8p507Cd0220dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v04E6p0101d0200dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v04E6p000Cd0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v04E6p000Bd0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v04E6p000Ad0200dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v04E6p0009d0200dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v04E6p0007d01*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v04E6p0007d0200dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v04E6p0006d0205dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v04E6p0006d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v04E6p0005d01*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v04E6p0005d020[0-8]dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v04E6p0002d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v04E6p0001d0200dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v04DAp2373d*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v04DAp2372d*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v04DAp0D05d0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v04DAp0901d01*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v04DAp0901d0200dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v04CEp0002d0074dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v04CBp0100d[0-1]*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v04CBp0100d2[0-1]*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v04CBp0100d220*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v04CBp0100d2210dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v04B8p0602d0110dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v04B8p0601d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v04B3p4001d0110dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v04B0p0301d0010dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v04A5p3010d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v04A4p0004d0001dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0482p0107d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0482p0103d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0482p0101d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0482p0100d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v046BpFF40d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v045EpFFFFd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0457p0151d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0457p0150d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0451p5416d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0436p0005d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0424p0FDCd0210dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0421p0495d0370dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0421p0492d[1-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0421p0492d0[5-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0421p0492d04[6-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0421p0492d045[2-9]dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0421p047Cd0[4-5]*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0421p047Cd060*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0421p047Cd03[7-9]*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0421p047Cd0610dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0421p044Ed0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0421p0446d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0421p0444d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0421p0434d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0421p0433d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0421p042Ed0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0421p0019d0592dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0420p0001d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0419pAAF6d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0419pAAF5d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0419pAACEd0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0419p0100d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0411p001Cd0113dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v040Dp6205d0003dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v0409p0040d*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v03F0p4002d0001dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v03F0p070Cd0000dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v03F0p0107d0200dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v03EEp6906d0003dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v03EEp6901d0[0-1]*dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v03EEp6901d0200dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v03EBp2002d0100dc*dsc*dp*ic*isc*ip* usb_storage
+ + alias usb:v03F0p3524d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v5372p2303d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v05ADp0FBAd*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v07AAp002Ad*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v11F6p2001d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v058Fp9720d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v050Dp0257d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v0731p2003d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v0E55p110Bd*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v0413p2101d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v079Bp0027d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v10B5pAC70d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v078Bp1234d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v0745p0001d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v11F5p0005d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v11F5p0004d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v11F5p0003d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v11F5p0001d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v04E8p8001d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v11F7p02DFd*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v6189p2068d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v0731p0528d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v1453p4026d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v2478p2008d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v0584pB000d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v0DF7p0620d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v0EBAp2080d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v0EBAp1080d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v056Ep5004d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v056Ep5003d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v0547p2008d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v0557p2008d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v04BBp0A0Ed*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v04BBp0A03d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v067Bp0609d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v067Bp0612d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v067Bp0611d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v067BpAAA0d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v067BpAAA2d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v067Bp1234d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v067Bp04BBd*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias usb:v067Bp2303d*dc*dsc*dp*ic*isc*ip* pl2303
+ + alias scsi:t-0x0e* sd_mod
+ + alias scsi:t-0x07* sd_mod
+ + alias scsi:t-0x00* sd_mod
+ + alias block-major-135-* sd_mod
+ + alias block-major-134-* sd_mod
+ + alias block-major-133-* sd_mod
+ + alias block-major-132-* sd_mod
+ + alias block-major-131-* sd_mod
+ + alias block-major-130-* sd_mod
+ + alias block-major-129-* sd_mod
+ + alias block-major-128-* sd_mod
+ + alias block-major-71-* sd_mod
+ + alias block-major-70-* sd_mod
+ + alias block-major-69-* sd_mod
+ + alias block-major-68-* sd_mod
+ + alias block-major-67-* sd_mod
+ + alias block-major-66-* sd_mod
+ + alias block-major-65-* sd_mod
+ + alias block-major-8-* sd_mod
+ + alias nfct-helper-ftp nf_conntrack_ftp
+ + alias ip_conntrack_ftp nf_conntrack_ftp
+ + alias ip6t_tcp xt_tcpudp
+ + alias ip6t_udp xt_tcpudp
+ + alias ipt_tcp xt_tcpudp
+ + alias ipt_udp xt_tcpudp
+ + alias xt_udp xt_tcpudp
+ + alias xt_tcp xt_tcpudp
+ + alias ip6t_conntrack xt_conntrack
+ + alias ipt_conntrack xt_conntrack
+ + alias ip6t_state xt_state
+ + alias ipt_state xt_state
+ Binary files linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.alias.bin and liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.alias.bin differ
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.ccwmap liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.ccwmap
+ *** linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.ccwmap	1970-01-01 01:00:00.000000000 +0100
+ --- liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.ccwmap	2009-07-31 11:36:16.000000000 +0200
+ ***************
+ *** 0 ****
+ --- 1 ----
+ + # ccw module         match_flags cu_type cu_model dev_type dev_model
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.dep liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.dep
+ *** linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.dep	1970-01-01 01:00:00.000000000 +0100
+ --- liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.dep	2009-07-31 11:36:16.000000000 +0200
+ ***************
+ *** 0 ****
+ --- 1,17 ----
+ + kernel/drivers/base/firmware_class.ko:
+ + kernel/drivers/usb/storage/usb-storage.ko: kernel/drivers/scsi/scsi_mod.ko
+ + kernel/drivers/usb/serial/usbserial.ko:
+ + kernel/drivers/usb/serial/pl2303.ko: kernel/drivers/usb/serial/usbserial.ko
+ + kernel/drivers/hid/hid-dummy.ko:
+ + kernel/drivers/connector/cn.ko:
+ + kernel/drivers/scsi/scsi_mod.ko:
+ + kernel/drivers/scsi/sd_mod.ko: kernel/drivers/scsi/scsi_mod.ko
+ + kernel/drivers/scsi/scsi_wait_scan.ko: kernel/drivers/scsi/scsi_mod.ko
+ + kernel/net/netfilter/nf_conntrack.ko:
+ + kernel/net/netfilter/nf_conntrack_ftp.ko: kernel/net/netfilter/nf_conntrack.ko
+ + kernel/net/netfilter/x_tables.ko:
+ + kernel/net/netfilter/xt_tcpudp.ko: kernel/net/netfilter/x_tables.ko
+ + kernel/net/netfilter/xt_conntrack.ko: kernel/net/netfilter/nf_conntrack.ko kernel/net/netfilter/x_tables.ko
+ + kernel/net/netfilter/xt_state.ko: kernel/net/netfilter/nf_conntrack.ko kernel/net/netfilter/x_tables.ko
+ + kernel/net/ipv4/netfilter/ip_tables.ko: kernel/net/netfilter/x_tables.ko
+ + kernel/net/ipv4/netfilter/iptable_filter.ko: kernel/net/ipv4/netfilter/ip_tables.ko kernel/net/netfilter/x_tables.ko
+ Binary files linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.dep.bin and liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.dep.bin differ
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.ieee1394map liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.ieee1394map
+ *** linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.ieee1394map	1970-01-01 01:00:00.000000000 +0100
+ --- liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.ieee1394map	2009-07-31 11:36:16.000000000 +0200
+ ***************
+ *** 0 ****
+ --- 1 ----
+ + # ieee1394 module    match_flags vendor_id model_id specifier_id version
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.inputmap liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.inputmap
+ *** linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.inputmap	1970-01-01 01:00:00.000000000 +0100
+ --- liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.inputmap	2009-07-31 11:36:16.000000000 +0200
+ ***************
+ *** 0 ****
+ --- 1 ----
+ + # module         matchBits bustype vendor product version evBits keyBits relBits absBits mscBits ledBits sndBits ffBits [swBits] driver_info
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.isapnpmap liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.isapnpmap
+ *** linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.isapnpmap	1970-01-01 01:00:00.000000000 +0100
+ --- liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.isapnpmap	2009-07-31 11:36:16.000000000 +0200
+ ***************
+ *** 0 ****
+ --- 1 ----
+ + # isapnp module      cardvendor carddevice driver_data vendor     function   ...
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.ofmap liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.ofmap
+ *** linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.ofmap	1970-01-01 01:00:00.000000000 +0100
+ --- liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.ofmap	2009-07-31 11:36:16.000000000 +0200
+ ***************
+ *** 0 ****
+ --- 1 ----
+ + # of module          name                 type                 compatible
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.pcimap liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.pcimap
+ *** linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.pcimap	1970-01-01 01:00:00.000000000 +0100
+ --- liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.pcimap	2009-07-31 11:36:16.000000000 +0200
+ ***************
+ *** 0 ****
+ --- 1 ----
+ + # pci module         vendor     device     subvendor  subdevice  class      class_mask driver_data
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.seriomap liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.seriomap
+ *** linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.seriomap	1970-01-01 01:00:00.000000000 +0100
+ --- liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.seriomap	2009-07-31 11:36:16.000000000 +0200
+ ***************
+ *** 0 ****
+ --- 1 ----
+ + # serio module       type extra id   proto
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.symbols liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.symbols
+ *** linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.symbols	1970-01-01 01:00:00.000000000 +0100
+ --- liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.symbols	2009-07-31 11:36:16.000000000 +0200
+ ***************
+ *** 0 ****
+ --- 1,233 ----
+ + # Aliases for symbols, used by symbol_request().
+ + alias symbol:scsi_sense_key_string scsi_mod
+ + alias symbol:request_firmware firmware_class
+ + alias symbol:scsi_execute scsi_mod
+ + alias symbol:usb_serial_generic_write_bulk_callback usbserial
+ + alias symbol:scsi_get_command scsi_mod
+ + alias symbol:scsi_target_quiesce scsi_mod
+ + alias symbol:nf_conntrack_l4proto_tcp4 nf_conntrack
+ + alias symbol:xt_proto_fini x_tables
+ + alias symbol:scsi_normalize_sense scsi_mod
+ + alias symbol:cn_del_callback cn
+ + alias symbol:nf_ct_l4proto_put nf_conntrack
+ + alias symbol:nf_ct_l3proto_put nf_conntrack
+ + alias symbol:scsicam_bios_param scsi_mod
+ + alias symbol:scsi_reset_provider scsi_mod
+ + alias symbol:scsi_extd_sense_format scsi_mod
+ + alias symbol:nfnetlink_parse_nat_setup_hook nf_conntrack
+ + alias symbol:scsi_flush_work scsi_mod
+ + alias symbol:scsi_host_get scsi_mod
+ + alias symbol:__nf_conntrack_confirm nf_conntrack
+ + alias symbol:scsi_device_set_state scsi_mod
+ + alias symbol:__scsi_device_lookup_by_target scsi_mod
+ + alias symbol:nf_ct_unlink_expect nf_conntrack
+ + alias symbol:usb_serial_register usbserial
+ + alias symbol:nf_ct_invert_tuple nf_conntrack
+ + alias symbol:nf_ct_l3proto_module_put nf_conntrack
+ + alias symbol:xt_register_table x_tables
+ + alias symbol:scsi_device_lookup_by_target scsi_mod
+ + alias symbol:scsi_scan_target scsi_mod
+ + alias symbol:scsi_setup_blk_pc_cmnd scsi_mod
+ + alias symbol:sdev_evt_send scsi_mod
+ + alias symbol:nf_ct_l3protos nf_conntrack
+ + alias symbol:scsi_init_io scsi_mod
+ + alias symbol:scsi_logging_level scsi_mod
+ + alias symbol:scsi_rescan_device scsi_mod
+ + alias symbol:scsi_device_quiesce scsi_mod
+ + alias symbol:nf_ct_invert_tuplepr nf_conntrack
+ + alias symbol:scsi_is_sdev_device scsi_mod
+ + alias symbol:scsi_block_requests scsi_mod
+ + alias symbol:print_tuple nf_conntrack
+ + alias symbol:scsi_eh_restore_cmnd scsi_mod
+ + alias symbol:__scsi_device_lookup scsi_mod
+ + alias symbol:nf_ct_expect_init nf_conntrack
+ + alias symbol:nf_conntrack_alter_reply nf_conntrack
+ + alias symbol:request_firmware_nowait firmware_class
+ + alias symbol:scsi_mode_sense scsi_mod
+ + alias symbol:scsi_show_sense_hdr scsi_mod
+ + alias symbol:nf_ct_get_tuple nf_conntrack
+ + alias symbol:scsi_mode_select scsi_mod
+ + alias symbol:__starget_for_each_device scsi_mod
+ + alias symbol:xt_check_match x_tables
+ + alias symbol:nf_ct_l3proto_try_module_get nf_conntrack
+ + alias symbol:xt_unregister_matches x_tables
+ + alias symbol:scsi_test_unit_ready scsi_mod
+ + alias symbol:usb_serial_deregister usbserial
+ + alias symbol:scsi_remove_target scsi_mod
+ + alias symbol:scsi_show_result scsi_mod
+ + alias symbol:usb_serial_suspend usbserial
+ + alias symbol:nf_conntrack_chain nf_conntrack
+ + alias symbol:xt_table_unlock x_tables
+ + alias symbol:scsi_ioctl scsi_mod
+ + alias symbol:scsi_report_device_reset scsi_mod
+ + alias symbol:scsi_print_sense scsi_mod
+ + alias symbol:nf_conntrack_l4proto_tcp6 nf_conntrack
+ + alias symbol:__nf_ct_ext_add nf_conntrack
+ + alias symbol:scsi_unregister scsi_mod
+ + alias symbol:scsi_internal_device_unblock scsi_mod
+ + alias symbol:scsi_host_alloc scsi_mod
+ + alias symbol:xt_proto_init x_tables
+ + alias symbol:nf_conntrack_l3proto_unregister nf_conntrack
+ + alias symbol:nf_conntrack_l4proto_unregister nf_conntrack
+ + alias symbol:scsi_eh_flush_done_q scsi_mod
+ + alias symbol:scsi_remove_host scsi_mod
+ + alias symbol:scsi_is_host_device scsi_mod
+ + alias symbol:scsi_prep_state_check scsi_mod
+ + alias symbol:scsi_target_block scsi_mod
+ + alias symbol:scsilun_to_int scsi_mod
+ + alias symbol:nf_ct_expect_chain nf_conntrack
+ + alias symbol:nf_ct_remove_expectations nf_conntrack
+ + alias symbol:nf_conntrack_in nf_conntrack
+ + alias symbol:nf_conntrack_set_hashsize nf_conntrack
+ + alias symbol:xt_find_match x_tables
+ + alias symbol:nf_ct_unexpect_related nf_conntrack
+ + alias symbol:scsi_release_buffers scsi_mod
+ + alias symbol:scsi_scan_host scsi_mod
+ + alias symbol:scsi_setup_fs_cmnd scsi_mod
+ + alias symbol:scsi_track_queue_full scsi_mod
+ + alias symbol:scsi_set_medium_removal scsi_mod
+ + alias symbol:scsi_device_get scsi_mod
+ + alias symbol:scsi_device_put scsi_mod
+ + alias symbol:sdev_evt_alloc scsi_mod
+ + alias symbol:nf_ct_expect_put nf_conntrack
+ + alias symbol:xt_replace_table x_tables
+ + alias symbol:nf_conntrack_lock nf_conntrack
+ + alias symbol:cn_add_callback cn
+ + alias symbol:xt_find_table_lock x_tables
+ + alias symbol:xt_unregister_table x_tables
+ + alias symbol:scsi_adjust_queue_depth scsi_mod
+ + alias symbol:usb_serial_generic_read_bulk_callback usbserial
+ + alias symbol:nf_ct_get_tuplepr nf_conntrack
+ + alias symbol:nf_conntrack_find_get nf_conntrack
+ + alias symbol:scsi_remove_device scsi_mod
+ + alias symbol:scsi_free_host_dev scsi_mod
+ + alias symbol:scsi_complete_async_scans scsi_mod
+ + alias symbol:ipt_unregister_table ip_tables
+ + alias symbol:xt_unregister_target x_tables
+ + alias symbol:nf_conntrack_unregister_notifier nf_conntrack
+ + alias symbol:nf_nat_ftp_hook nf_conntrack_ftp
+ + alias symbol:scsi_dma_map scsi_mod
+ + alias symbol:scsi_unblock_requests scsi_mod
+ + alias symbol:nf_ct_deliver_cached_events nf_conntrack
+ + alias symbol:nf_ct_expect_find_get nf_conntrack
+ + alias symbol:xt_find_revision x_tables
+ + alias symbol:nf_conntrack_flush nf_conntrack
+ + alias symbol:nf_conntrack_l3proto_generic nf_conntrack
+ + alias symbol:scsi_prep_return scsi_mod
+ + alias symbol:scsi_print_command scsi_mod
+ + alias symbol:nf_ct_expect_unregister_notifier nf_conntrack
+ + alias symbol:__scsi_print_command scsi_mod
+ + alias symbol:__scsi_get_command scsi_mod
+ + alias symbol:__scsi_put_command scsi_mod
+ + alias symbol:xt_check_target x_tables
+ + alias symbol:__nf_ct_try_assign_helper nf_conntrack
+ + alias symbol:scsi_command_normalize_sense scsi_mod
+ + alias symbol:seq_print_acct nf_conntrack
+ + alias symbol:ipt_register_table ip_tables
+ + alias symbol:nf_conntrack_hash_insert nf_conntrack
+ + alias symbol:nf_conntrack_helper_register nf_conntrack
+ + alias symbol:usb_serial_probe usbserial
+ + alias symbol:nf_conntrack_l4proto_udp4 nf_conntrack
+ + alias symbol:nf_conntrack_free nf_conntrack
+ + alias symbol:scsi_queue_work scsi_mod
+ + alias symbol:nf_ct_expect_related nf_conntrack
+ + alias symbol:nf_ct_l4proto_find_get nf_conntrack
+ + alias symbol:nf_ct_l3proto_find_get nf_conntrack
+ + alias symbol:usb_serial_port_softint usbserial
+ + alias symbol:xt_request_find_target x_tables
+ + alias symbol:scsi_bus_type scsi_mod
+ + alias symbol:xt_free_table_info x_tables
+ + alias symbol:cn_netlink_send cn
+ + alias symbol:nf_ct_extend_register nf_conntrack
+ + alias symbol:scsi_report_bus_reset scsi_mod
+ + alias symbol:__nf_ct_kill_acct nf_conntrack
+ + alias symbol:scsi_bios_ptable scsi_mod
+ + alias symbol:xt_alloc_table_info x_tables
+ + alias symbol:scsi_execute_req scsi_mod
+ + alias symbol:scsi_add_host scsi_mod
+ + alias symbol:scsi_schedule_eh scsi_mod
+ + alias symbol:scsi_print_sense_hdr scsi_mod
+ + alias symbol:scsi_host_lookup scsi_mod
+ + alias symbol:nf_conntrack_max nf_conntrack
+ + alias symbol:scsi_device_lookup scsi_mod
+ + alias symbol:scsi_get_host_dev scsi_mod
+ + alias symbol:scsi_add_device scsi_mod
+ + alias symbol:scsi_kmap_atomic_sg scsi_mod
+ + alias symbol:starget_for_each_device scsi_mod
+ + alias symbol:scsi_allocate_command scsi_mod
+ + alias symbol:scsi_get_sense_info_fld scsi_mod
+ + alias symbol:scsi_kunmap_atomic_sg scsi_mod
+ + alias symbol:scsi_block_when_processing_errors scsi_mod
+ + alias symbol:scsi_register_interface scsi_mod
+ + alias symbol:__nf_conntrack_helper_find_byname nf_conntrack
+ + alias symbol:release_firmware firmware_class
+ + alias symbol:scsi_register scsi_mod
+ + alias symbol:nf_ct_extend_unregister nf_conntrack
+ + alias symbol:xt_unregister_targets x_tables
+ + alias symbol:nf_ct_expect_hsize nf_conntrack
+ + alias symbol:nf_ct_alloc_hashtable nf_conntrack
+ + alias symbol:scsi_eh_finish_cmd scsi_mod
+ + alias symbol:__scsi_add_device scsi_mod
+ + alias symbol:__scsi_print_sense scsi_mod
+ + alias symbol:nf_conntrack_l4proto_udp6 nf_conntrack
+ + alias symbol:nf_conntrack_l3proto_register nf_conntrack
+ + alias symbol:nf_conntrack_l4proto_register nf_conntrack
+ + alias symbol:usb_serial_resume usbserial
+ + alias symbol:nf_ct_iterate_cleanup nf_conntrack
+ + alias symbol:scsi_print_result scsi_mod
+ + alias symbol:nf_ct_free_hashtable nf_conntrack
+ + alias symbol:int_to_scsilun scsi_mod
+ + alias symbol:__scsi_alloc_queue scsi_mod
+ + alias symbol:scsi_finish_command scsi_mod
+ + alias symbol:usb_serial_generic_open usbserial
+ + alias symbol:__nf_ct_l4proto_find nf_conntrack
+ + alias symbol:scsi_device_type scsi_mod
+ + alias symbol:__nf_ct_event_cache_init nf_conntrack
+ + alias symbol:scsi_dma_unmap scsi_mod
+ + alias symbol:nf_conntrack_register_notifier nf_conntrack
+ + alias symbol:need_conntrack nf_conntrack
+ + alias symbol:scsi_nonblockable_ioctl scsi_mod
+ + alias symbol:scsi_partsize scsi_mod
+ + alias symbol:scsi_host_put scsi_mod
+ + alias symbol:scsi_eh_get_sense scsi_mod
+ + alias symbol:xt_register_match x_tables
+ + alias symbol:scsi_cmd_print_sense_hdr scsi_mod
+ + alias symbol:scsi_eh_ready_devs scsi_mod
+ + alias symbol:__nf_ct_ext_destroy nf_conntrack
+ + alias symbol:scsi_is_target_device scsi_mod
+ + alias symbol:scsi_internal_device_block scsi_mod
+ + alias symbol:__nf_ct_refresh_acct nf_conntrack
+ + alias symbol:scsi_target_resume scsi_mod
+ + alias symbol:nf_ct_expect_register_notifier nf_conntrack
+ + alias symbol:nf_conntrack_untracked nf_conntrack
+ + alias symbol:scsi_target_unblock scsi_mod
+ + alias symbol:xt_unregister_match x_tables
+ + alias symbol:__nf_conntrack_find nf_conntrack
+ + alias symbol:scsi_free_command scsi_mod
+ + alias symbol:scsi_execute_async scsi_mod
+ + alias symbol:nf_ct_helper_ext_add nf_conntrack
+ + alias symbol:nf_conntrack_helper_unregister nf_conntrack
+ + alias symbol:scsi_print_status scsi_mod
+ + alias symbol:scsi_put_command scsi_mod
+ + alias symbol:sdev_evt_send_simple scsi_mod
+ + alias symbol:nf_conntrack_tuple_taken nf_conntrack
+ + alias symbol:scsi_build_sense_buffer scsi_mod
+ + alias symbol:xt_register_matches x_tables
+ + alias symbol:nf_ct_expect_related_report nf_conntrack
+ + alias symbol:nf_conntrack_alloc nf_conntrack
+ + alias symbol:__scsi_iterate_devices scsi_mod
+ + alias symbol:scsi_sense_desc_find scsi_mod
+ + alias symbol:nf_conntrack_htable_size nf_conntrack
+ + alias symbol:scsi_show_extd_sense scsi_mod
+ + alias symbol:xt_register_target x_tables
+ + alias symbol:nf_ct_expect_alloc nf_conntrack
+ + alias symbol:__nf_ct_expect_find nf_conntrack
+ + alias symbol:scsi_device_resume scsi_mod
+ + alias symbol:ipt_do_table ip_tables
+ + alias symbol:scsi_calculate_bounce_limit scsi_mod
+ + alias symbol:xt_find_target x_tables
+ + alias symbol:usb_serial_disconnect usbserial
+ + alias symbol:scsi_eh_prep_cmnd scsi_mod
+ + alias symbol:xt_register_targets x_tables
+ + alias symbol:scsi_register_driver scsi_mod
+ + alias symbol:scsi_host_set_state scsi_mod
+ Binary files linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.symbols.bin and liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.symbols.bin differ
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.usbmap liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.usbmap
+ *** linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.usbmap	1970-01-01 01:00:00.000000000 +0100
+ --- liab-linux-2.6.29.4/disksrc/liabarmdist_base/lib/modules/2.6.29.4/lib/modules/2.6.29.4/modules.usbmap	2009-07-31 11:36:16.000000000 +0200
+ ***************
+ *** 0 ****
+ --- 1,310 ----
+ + # usb module         match_flags idVendor idProduct bcdDevice_lo bcdDevice_hi bDeviceClass bDeviceSubClass bDeviceProtocol bInterfaceClass bInterfaceSubClass bInterfaceProtocol driver_info
+ + usb-storage          0x000f      0x03eb   0x2002    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x03ee   0x6901    0x0000       0x0200       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x03ee   0x6906    0x0003       0x0003       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x03f0   0x0107    0x0200       0x0200       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x03f0   0x070c    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x03f0   0x4002    0x0001       0x0001       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0409   0x0040    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x040d   0x6205    0x0003       0x0003       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0411   0x001c    0x0113       0x0113       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0419   0x0100    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0419   0xaace    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0419   0xaaf5    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0419   0xaaf6    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0420   0x0001    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0421   0x0019    0x0592       0x0592       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0421   0x042e    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0421   0x0433    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0421   0x0434    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0421   0x0444    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0421   0x0446    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0421   0x044e    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0421   0x047c    0x0370       0x0610       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0421   0x0492    0x0452       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0421   0x0495    0x0370       0x0370       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0424   0x0fdc    0x0210       0x0210       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0436   0x0005    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0451   0x5416    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0457   0x0150    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0457   0x0151    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x045e   0xffff    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x046b   0xff40    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0482   0x0100    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0482   0x0101    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0482   0x0103    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0482   0x0107    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x04a4   0x0004    0x0001       0x0001       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x04a5   0x3010    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x04b0   0x0301    0x0010       0x0010       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x04b3   0x4001    0x0110       0x0110       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x04b8   0x0601    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x04b8   0x0602    0x0110       0x0110       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x04cb   0x0100    0x0000       0x2210       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x04ce   0x0002    0x0074       0x0074       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x04da   0x0901    0x0100       0x0200       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x04da   0x0d05    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x04da   0x2372    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x04da   0x2373    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x04e6   0x0001    0x0200       0x0200       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x04e6   0x0002    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x04e6   0x0005    0x0100       0x0208       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x04e6   0x0006    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x04e6   0x0006    0x0205       0x0205       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x04e6   0x0007    0x0100       0x0200       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x04e6   0x0009    0x0200       0x0200       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x04e6   0x000a    0x0200       0x0200       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x04e6   0x000b    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x04e6   0x000c    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x04e6   0x0101    0x0200       0x0200       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x04e8   0x507c    0x0220       0x0220       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x04fc   0x80c2    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x050d   0x0115    0x0133       0x0133       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0525   0xa140    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0525   0xa4a5    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x052b   0x1801    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x052b   0x1804    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x052b   0x1807    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x052b   0x1905    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x052b   0x1911    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x054c   0x0010    0x0106       0x0450       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x054c   0x0010    0x0500       0x0610       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x054c   0x0025    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x054c   0x002c    0x0501       0x2000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x054c   0x002d    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x054c   0x002e    0x0106       0x0310       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x054c   0x002e    0x0500       0x0500       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x054c   0x0032    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x054c   0x0058    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x054c   0x0069    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x054c   0x006d    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x054c   0x0099    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x054c   0x016a    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x055d   0x2020    0x0000       0x0210       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x057b   0x0000    0x0000       0x0299       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x057b   0x0000    0x0300       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x057b   0x0022    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x058f   0x6387    0x0141       0x0141       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0595   0x4343    0x0000       0x2210       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x059b   0x0001    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x059f   0x0643    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x05ab   0x0060    0x1104       0x1110       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x05ac   0x1202    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x05ac   0x1203    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x05ac   0x1204    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x05ac   0x1205    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x05ac   0x120a    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x05c6   0x1000    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x05dc   0xb002    0x0000       0x0113       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x05e3   0x0701    0x0000       0xffff       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x05e3   0x0702    0x0000       0xffff       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x05e3   0x0723    0x9451       0x9451       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0636   0x0003    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0644   0x0000    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x066f   0x8000    0x0001       0x0001       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x067b   0x2507    0x0001       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x067b   0x3507    0x0001       0x0101       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0686   0x4011    0x0001       0x0001       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0686   0x4017    0x0001       0x0001       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0693   0x0005    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x069b   0x3004    0x0001       0x0001       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x071b   0x3203    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x071b   0x32bb    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x071b   0x3203    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0727   0x0306    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0781   0x0001    0x0200       0x0200       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0781   0x0002    0x0009       0x0009       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0781   0x0100    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x07ab   0xfccd    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x07af   0x0004    0x0100       0x0133       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x07af   0x0005    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x07af   0x0006    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x07c4   0xa400    0x0000       0xffff       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x07c4   0xa4a5    0x0000       0xffff       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x07cf   0x1001    0x1000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0839   0x000a    0x0001       0x0001       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0840   0x0082    0x0001       0x0001       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0840   0x0084    0x0001       0x0001       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0840   0x0085    0x0001       0x0001       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x084d   0x0011    0x0110       0x0110       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0851   0x1543    0x0200       0x0200       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x08bd   0x1100    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x08ca   0x3103    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x090a   0x1001    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x090a   0x1050    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x090a   0x1200    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x090c   0x1132    0x0000       0xffff       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0a17   0x0004    0x1000       0x1000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0ace   0x2011    0x0101       0x0101       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0ace   0x20ff    0x0101       0x0101       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0af0   0x6971    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0af0   0x7401    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0af0   0x7501    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0bc2   0x3010    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0d49   0x7310    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0c45   0x1060    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0d96   0x410a    0x0001       0xffff       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0d96   0x5200    0x0001       0x0200       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0dc4   0x0073    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0dd8   0x1060    0x0000       0xffff       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0dd8   0xd202    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0dda   0x0001    0x0012       0x0012       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0dda   0x0301    0x0012       0x0012       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0e21   0x0520    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0ed1   0x6660    0x0100       0x0300       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0ea0   0x2168    0x0110       0x0110       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0ea0   0x6828    0x0110       0x0110       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0ed1   0x7636    0x0103       0x0103       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0f19   0x0103    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0f19   0x0105    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0fce   0xd008    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0fce   0xd0e1    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0fce   0xe030    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0fce   0xe031    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x0fce   0xe092    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x1019   0x0c55    0x0000       0x0110       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x1058   0x0704    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x10d6   0x2200    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x1199   0x0fff    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x1210   0x0003    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1001    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1003    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1004    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1401    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1402    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1403    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1404    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1405    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1406    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1407    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1408    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1409    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x140a    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x140b    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x140c    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x140d    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x140e    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x140f    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1410    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1411    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1412    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1413    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1414    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1415    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1416    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1417    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1418    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1419    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x141a    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x141b    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x141c    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x141d    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x141e    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x141f    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1420    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1421    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1422    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1423    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1424    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1425    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1426    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1427    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1428    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1429    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x142a    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x142b    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x142c    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x142d    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x142e    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x142f    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1430    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1431    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1432    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1433    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1434    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1435    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1436    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1437    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1438    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x1439    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x143a    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x143b    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x143c    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x143d    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x143e    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x12d1   0x143f    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x132b   0x000b    0x0001       0x0001       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x1370   0x6828    0x0110       0x0110       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x14cd   0x6600    0x0201       0x0201       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x152d   0x2329    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x1652   0x6600    0x0201       0x0201       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x2116   0x0320    0x0001       0x0001       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x22b8   0x3010    0x0001       0x0001       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x22b8   0x6426    0x0101       0x0101       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x2735   0x100b    0x0000       0x9999       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x2770   0x915d    0x0010       0x0010       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x3340   0xffff    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x4102   0x1020    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0x4146   0xba01    0x0100       0x0100       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0xed06   0x4500    0x0001       0x0001       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x000f      0xed10   0x7636    0x0001       0x0001       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x01               0x01               0x0
+ + usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x02               0x01               0x0
+ + usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x03               0x01               0x0
+ + usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x04               0x01               0x0
+ + usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x05               0x01               0x0
+ + usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x06               0x01               0x0
+ + usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x01               0x00               0x0
+ + usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x02               0x00               0x0
+ + usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x03               0x00               0x0
+ + usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x04               0x00               0x0
+ + usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x05               0x00               0x0
+ + usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x06               0x00               0x0
+ + usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x01               0x50               0x0
+ + usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x02               0x50               0x0
+ + usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x03               0x50               0x0
+ + usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x04               0x50               0x0
+ + usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x05               0x50               0x0
+ + usb-storage          0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x08            0x06               0x50               0x0
+ + pl2303               0x0003      0x067b   0x2303    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x067b   0x04bb    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x067b   0x1234    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x067b   0xaaa2    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x067b   0xaaa0    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x067b   0x0611    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x067b   0x0612    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x067b   0x0609    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x04bb   0x0a03    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x04bb   0x0a0e    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x0557   0x2008    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x0547   0x2008    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x056e   0x5003    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x056e   0x5004    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x0eba   0x1080    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x0eba   0x2080    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x0df7   0x0620    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x0584   0xb000    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x2478   0x2008    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x1453   0x4026    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x0731   0x0528    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x6189   0x2068    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x11f7   0x02df    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x04e8   0x8001    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x11f5   0x0001    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x11f5   0x0003    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x11f5   0x0004    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x11f5   0x0005    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x0745   0x0001    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x078b   0x1234    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x10b5   0xac70    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x079b   0x0027    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x0413   0x2101    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x0e55   0x110b    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x0731   0x2003    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x050d   0x0257    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x058f   0x9720    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x11f6   0x2001    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x07aa   0x002a    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x05ad   0x0fba    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x5372   0x2303    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ + pl2303               0x0003      0x03f0   0x3524    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/drivers/i2c/chips/pca9539.c liab-linux-2.6.29.4/drivers/i2c/chips/pca9539.c
+ *** linux-2.6.29.4/drivers/i2c/chips/pca9539.c	2009-05-19 01:52:34.000000000 +0200
+ --- liab-linux-2.6.29.4/drivers/i2c/chips/pca9539.c	2010-05-28 13:21:50.193678101 +0200
+ ***************
+ *** 15,21 ****
+   #include <linux/hwmon-sysfs.h>
+   
+   /* Addresses to scan: none, device is not autodetected */
+ ! static const unsigned short normal_i2c[] = { I2C_CLIENT_END };
+   
+   /* Insmod parameters */
+   I2C_CLIENT_INSMOD_1(pca9539);
+ --- 15,22 ----
+   #include <linux/hwmon-sysfs.h>
+   
+   /* Addresses to scan: none, device is not autodetected */
+ ! //static const unsigned short normal_i2c[] = { I2C_CLIENT_END };
+ ! static unsigned short normal_i2c[] = {0x20, 0x21, I2C_CLIENT_END};
+   
+   /* Insmod parameters */
+   I2C_CLIENT_INSMOD_1(pca9539);
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/drivers/leds/Kconfig liab-linux-2.6.29.4/drivers/leds/Kconfig
+ *** linux-2.6.29.4/drivers/leds/Kconfig	2009-05-19 01:52:34.000000000 +0200
+ --- liab-linux-2.6.29.4/drivers/leds/Kconfig	2009-08-04 15:38:20.000000000 +0200
+ ***************
+ *** 19,29 ****
+   
+   config LEDS_ATMEL_PWM
+   	tristate "LED Support using Atmel PWM outputs"
+ ! 	depends on LEDS_CLASS && ATMEL_PWM
+   	help
+   	  This option enables support for LEDs driven using outputs
+   	  of the dedicated PWM controller found on newer Atmel SOCs.
+   
+   config LEDS_LOCOMO
+   	tristate "LED Support for Locomo device"
+   	depends on LEDS_CLASS && SHARP_LOCOMO
+ --- 19,37 ----
+   
+   config LEDS_ATMEL_PWM
+   	tristate "LED Support using Atmel PWM outputs"
+ ! 	depends on LEDS_CLASS && (ATMEL_PWM || AT91_PWM)
+   	help
+   	  This option enables support for LEDs driven using outputs
+   	  of the dedicated PWM controller found on newer Atmel SOCs.
+   
+ + config LEDS_LIABDIN_ADDON
+ + 	tristate "LED on the LIABDIN addon"
+ + 	depends on LEDS_CLASS
+ + 	help
+ + 	  This option enables support for LEDs driven using outputs
+ + 	  of the dedicated PWM controller found on newer Atmel SOCs.
+ + 
+ + 
+   config LEDS_LOCOMO
+   	tristate "LED Support for Locomo device"
+   	depends on LEDS_CLASS && SHARP_LOCOMO
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/drivers/leds/leds-atmel-pwm.c liab-linux-2.6.29.4/drivers/leds/leds-atmel-pwm.c
+ *** linux-2.6.29.4/drivers/leds/leds-atmel-pwm.c	2009-05-19 01:52:34.000000000 +0200
+ --- liab-linux-2.6.29.4/drivers/leds/leds-atmel-pwm.c	2009-09-15 09:34:29.000000000 +0200
+ ***************
+ *** 2,8 ****
+   #include <linux/platform_device.h>
+   #include <linux/leds.h>
+   #include <linux/io.h>
+ ! #include <linux/atmel_pwm.h>
+   
+   
+   struct pwmled {
+ --- 2,8 ----
+   #include <linux/platform_device.h>
+   #include <linux/leds.h>
+   #include <linux/io.h>
+ ! #include <linux/at91_pwm.h>
+   
+   
+   struct pwmled {
+ ***************
+ *** 43,49 ****
+   	pdata = pdev->dev.platform_data;
+   	if (!pdata || pdata->num_leds < 1)
+   		return -ENODEV;
+ - 
+   	leds = kcalloc(pdata->num_leds, sizeof(*leds), GFP_KERNEL);
+   	if (!leds)
+   		return -ENOMEM;
+ --- 43,48 ----
+ ***************
+ *** 64,69 ****
+ --- 63,70 ----
+   		if (status < 0)
+   			goto err;
+   
+ +                 printk("%04d : %s() - pwm channel alloc ok\n",__LINE__, __FUNCTION__);
+ + 
+   		/*
+   		 * Prescale clock by 2^x, so PWM counts in low MHz.
+   		 * Start each cycle with the LED active, so increasing
+ ***************
+ *** 94,99 ****
+ --- 95,103 ----
+   			pwm_channel_free(&led->pwmc);
+   			goto err;
+   		}
+ + 
+ +               printk("%04d : %s() - handover ok\n",__LINE__, __FUNCTION__);
+ + 
+   	}
+   
+   	platform_set_drvdata(pdev, leds);
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/drivers/leds/leds-liabdin-addon.c liab-linux-2.6.29.4/drivers/leds/leds-liabdin-addon.c
+ *** linux-2.6.29.4/drivers/leds/leds-liabdin-addon.c	1970-01-01 01:00:00.000000000 +0100
+ --- liab-linux-2.6.29.4/drivers/leds/leds-liabdin-addon.c	2009-08-06 13:53:31.000000000 +0200
+ ***************
+ *** 0 ****
+ --- 1,212 ----
+ + /*
+ +  * LEDs driver for GPIOs
+ +  *
+ +  * Copyright (C) 2007 8D Technologies inc.
+ +  * Raphael Assenat <raph@8d.com>
+ +  *
+ +  * This program is free software; you can redistribute it and/or modify
+ +  * it under the terms of the GNU General Public License version 2 as
+ +  * published by the Free Software Foundation.
+ +  *
+ +  */
+ + #include <linux/kernel.h>
+ + #include <linux/init.h>
+ + #include <linux/platform_device.h>
+ + #include <linux/leds.h>
+ + #include <linux/workqueue.h>
+ + #include <linux/delay.h>
+ + 
+ + #include <asm/gpio.h>
+ + 
+ + #define NO_LED 15
+ + 
+ + struct liabdin_led_data {
+ +   struct led_classdev cdev;
+ +   struct work_struct work;
+ +   u8 level;
+ +   u8 pos;
+ + };
+ + 
+ + #define STROBE 0
+ + #define DATA 1
+ + #define CLOCK 2
+ + #define RESET 3
+ + #define NO_PINS 4
+ + 
+ + struct addon_ctrl {
+ +   unsigned gpio;
+ +   char *name;
+ +   u8 level;
+ + };
+ + 
+ + struct addon_ctrl gpio_pins[NO_PINS] = {
+ +   {AT91_PIN_PB2, "addon-strobe"},
+ +   {AT91_PIN_PD19, "addon-data"},
+ +   {AT91_PIN_PD20, "addon-clock"},
+ +   {AT91_PIN_PC12, "addon-reset"},
+ + };
+ + 
+ + static ulong led_val=0;
+ + spinlock_t lock;
+ + 
+ + void inline __set_strobe(int state)
+ + {
+ +   if(state)
+ +     at91_set_gpio_value(gpio_pins[STROBE].gpio, 0);
+ +   else
+ +     at91_set_gpio_value(gpio_pins[STROBE].gpio, 1);
+ + }
+ + 
+ + void inline __shift_value(int state)
+ + {
+ +   at91_set_gpio_value(gpio_pins[CLOCK].gpio, 0);
+ +   if(state)
+ +     at91_set_gpio_value(gpio_pins[DATA].gpio, 0);
+ +   else
+ +     at91_set_gpio_value(gpio_pins[DATA].gpio, 1);
+ +   at91_set_gpio_value(gpio_pins[CLOCK].gpio, 1);
+ + }
+ + 
+ + void inline __reset(void)
+ + {
+ +   at91_set_gpio_value(gpio_pins[RESET].gpio, 0);
+ +   udelay(100);
+ +   at91_set_gpio_value(gpio_pins[RESET].gpio, 1);
+ + }
+ + 
+ + 
+ + 
+ + static void addon_led_set(struct led_classdev *led_cdev,
+ + 	enum led_brightness value)
+ + {
+ +   ulong led;
+ +   int i;
+ + 	struct liabdin_led_data *led_dat =
+ + 		container_of(led_cdev, struct liabdin_led_data, cdev);
+ + 
+ +   led = led_val;
+ + 
+ + 	if (value == LED_OFF)
+ +     led = ~(~led | (1 << (led_dat->pos > 7 ? led_dat->pos+1 : led_dat->pos) ));
+ +   else
+ +     led = led | (1 << (led_dat->pos > 7 ? led_dat->pos+1 : led_dat->pos) );
+ + 
+ +   /* Make this uninterrruptible */
+ +   spin_lock_irq(&lock); 
+ +   /* Blank leds */
+ +   __set_strobe(0);
+ +   /* Shift out bits */
+ +   for(i=0; i<NO_LED+2; i++) {
+ +     __shift_value((~led >> i)&0x1 ? 1 : 0);
+ +   }
+ +   __set_strobe(1);
+ +   spin_unlock_irq(&lock); 
+ + 
+ +   led_val = led;
+ + }
+ + 
+ + static int liabdin_led_probe(struct platform_device *pdev)
+ + {
+ + 	int i, ret = 0;
+ +   struct liabdin_led_data *led_data;
+ +   struct gpio_led_platform_data *pdata = pdev->dev.platform_data;
+ + 
+ + 
+ +   if(!pdata)
+ +     return -EBUSY;
+ + 
+ +   led_data = kzalloc(sizeof(struct liabdin_led_data)*pdata->num_leds, GFP_KERNEL); 
+ + 	if (!led_data)
+ + 		return -ENOMEM;
+ + 
+ +   spin_lock_init(&lock);
+ +   
+ +   for(i=0; i<pdata->num_leds; i++) {
+ +     /* LED name */
+ +     led_data[i].cdev.name = pdata->leds[i].name;
+ +     /* Set callback */
+ +     led_data[i].cdev.brightness_set = addon_led_set;
+ + 		led_data[i].cdev.brightness = LED_OFF;
+ + 		led_data[i].cdev.flags |= LED_CORE_SUSPENDRESUME;
+ +     led_data[i].cdev.default_trigger = pdata->leds[i].default_trigger;
+ +     led_data[i].pos = i;
+ +     /* Add the led device */
+ +     ret = led_classdev_register(&pdev->dev, &led_data[i].cdev);
+ + 		if (ret < 0) {
+ + 			goto err_cdev;
+ + 		}
+ +   }
+ + 
+ +   /* Set up gpio */
+ +   for(i=0; i<NO_PINS; i++) {
+ +     ret = gpio_request(gpio_pins[i].gpio, gpio_pins[i].name);
+ + 		if (ret < 0)
+ + 			goto err_pins;
+ +     at91_set_gpio_output(gpio_pins[i].gpio, 1);
+ +   }
+ + 
+ + 	platform_set_drvdata(pdev, led_data);
+ + 
+ + 	return 0;
+ + 
+ +  err_pins:
+ +   for(i=0; i<NO_PINS; i++) {
+ +     gpio_free(gpio_pins[i].gpio);
+ +   }
+ + err_cdev:
+ +   for(i=0; i<pdata->num_leds; i++) {
+ +     led_classdev_unregister(&led_data[i].cdev);
+ +   }
+ + 
+ +   kfree(led_data);
+ + 
+ + 	return ret;
+ + }
+ + 
+ + static int __devexit liabdin_led_remove(struct platform_device *pdev)
+ + {
+ + 	int i;
+ +   struct liabdin_led_data *led_data;
+ +   struct gpio_led_platform_data *pdata = pdev->dev.platform_data;
+ + 
+ +   led_data = platform_get_drvdata(pdev);
+ + 
+ +   for(i=0; i<pdata->num_leds; i++) {
+ +     led_classdev_unregister(&led_data[i].cdev);
+ +   }
+ + 
+ +   for(i=0; i<NO_PINS; i++) {
+ +     gpio_free(gpio_pins[i].gpio);
+ +   }
+ + 
+ +   kfree(led_data);
+ + 
+ + 	return 0;
+ + }
+ + 
+ + static struct platform_driver liabdin_led_driver = {
+ + 	.probe		= liabdin_led_probe,
+ + 	.remove		= __devexit_p(liabdin_led_remove),
+ + 	.driver		= {
+ + 		.name	= "leds-liabdin-addon",
+ + 		.owner	= THIS_MODULE,
+ + 	},
+ + };
+ + 
+ + static int __init liabdin_led_init(void)
+ + {
+ + 	return platform_driver_register(&liabdin_led_driver);
+ + }
+ + 
+ + static void __exit liabdin_led_exit(void)
+ + {
+ + 	platform_driver_unregister(&liabdin_led_driver);
+ + }
+ + 
+ + module_init(liabdin_led_init);
+ + module_exit(liabdin_led_exit);
+ + 
+ + MODULE_AUTHOR("Raphael Assenat <raph@8d.com>");
+ + MODULE_DESCRIPTION("GPIO LED driver");
+ + MODULE_LICENSE("GPL");
+ + MODULE_ALIAS("platform:leds-gpio");
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/drivers/leds/Makefile liab-linux-2.6.29.4/drivers/leds/Makefile
+ *** linux-2.6.29.4/drivers/leds/Makefile	2009-05-19 01:52:34.000000000 +0200
+ --- liab-linux-2.6.29.4/drivers/leds/Makefile	2009-08-04 15:37:46.000000000 +0200
+ ***************
+ *** 24,29 ****
+ --- 24,30 ----
+   obj-$(CONFIG_LEDS_PCA955X)		+= leds-pca955x.o
+   obj-$(CONFIG_LEDS_DA903X)		+= leds-da903x.o
+   obj-$(CONFIG_LEDS_WM8350)		+= leds-wm8350.o
+ + obj-$(CONFIG_LEDS_LIABDIN_ADDON)		+= leds-liabdin-addon.o
+   
+   # LED Triggers
+   obj-$(CONFIG_LEDS_TRIGGER_TIMER)	+= ledtrig-timer.o
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/drivers/misc/at91_pwm.c liab-linux-2.6.29.4/drivers/misc/at91_pwm.c
+ *** linux-2.6.29.4/drivers/misc/at91_pwm.c	1970-01-01 01:00:00.000000000 +0100
+ --- liab-linux-2.6.29.4/drivers/misc/at91_pwm.c	2009-09-15 15:07:02.000000000 +0200
+ ***************
+ *** 0 ****
+ --- 1,550 ----
+ + #include <linux/module.h>
+ + #include <linux/clk.h>
+ + #include <linux/err.h>
+ + #include <linux/io.h>
+ + #include <linux/interrupt.h>
+ + #include <linux/platform_device.h>
+ + #include <linux/at91_pwm.h>
+ + #include <mach/at91_tc.h>
+ + #include <mach/gpio.h>
+ + 
+ + 
+ + /*
+ +  * This is a simple driver for generating PWM signals, using the
+ +  * timer/counter registers on the Atmel AT91 series processors.
+ +  *
+ +  * The timers are mapped pair wise. For example, on the at91sam9260,
+ +  * there are TIOA0-2 TIOB0-2, i.e. 6 pins that can beused to
+ +  * genererate PWM output. Since they at mapped pair-wise, e.g. TIOA0
+ +  * and TIOB0 uses the same period time but can have individual
+ +  * duty-cycles.
+ +  *
+ +  * LIAB ApS 2008 (msa)
+ +  *
+ +  */
+ + 
+ + #define PWM_NCHAN 6
+ + 
+ + struct pwm {
+ +   spinlock_t		lock;
+ +   struct platform_device	*pdev;
+ +   u32			mask;
+ +   int			irq;
+ +   void __iomem		*base[3];
+ +   struct clk		*clk[3];
+ +   struct pwm_channel	*channel[PWM_NCHAN];
+ +   void			(*handler[PWM_NCHAN])(struct pwm_channel *);
+ + };
+ + 
+ + struct pin_mapping {
+ +   u8     timer;
+ +   u32    gpio;
+ +   u8     flags;
+ +   u8     is_active_low;
+ + };
+ + 
+ + #ifdef CONFIG_ARCH_AT91RM9200
+ + static struct pin_mapping channel_map[PWM_NCHAN] = 
+ +   {
+ +     { /* TIOA0*/
+ +       .timer         = 0,
+ +       .gpio          = AT91_PIN_PA17,
+ +       .flags         = AT91_TC_RA,
+ +       .is_active_low = 1,
+ +     },
+ +     { /* TIOA1*/
+ +       .timer         = 1,
+ +       .gpio          = AT91_PIN_PA19,
+ +       .flags         = AT91_TC_RA,
+ +       .is_active_low = 1,
+ +     },
+ +     { /* TIOA2*/
+ +       .timer         = 2,
+ +       .gpio          = AT91_PIN_PA21,
+ +       .flags         = AT91_TC_RA,
+ +       .is_active_low = 1,
+ +     },
+ +     { /* TIOB0*/
+ +       .timer         = 0,
+ +       .gpio          = AT91_PIN_PA18,
+ +       .flags         = AT91_TC_RB,
+ +       .is_active_low = 1,
+ +     },
+ +     { /* TIOB1*/
+ +       .timer         = 1,
+ +       .gpio          = AT91_PIN_PA20,
+ +       .flags         = AT91_TC_RB,
+ +       .is_active_low = 1,
+ +     },
+ +     { /* TIOB2*/
+ +       .timer         = 2,
+ +       .gpio          = AT91_PIN_PA22,
+ +       .flags         = AT91_TC_RB,
+ +       .is_active_low = 1,
+ +     },
+ +   };
+ + #else
+ + static struct pin_mapping channel_map[PWM_NCHAN] = 
+ +   {
+ +     { /* TIOA0*/
+ +       .timer         = 0,
+ +       .gpio          = AT91_PIN_PA26,
+ +       .flags         = AT91_TC_RA,
+ +       .is_active_low = 1,
+ +     },
+ +     { /* TIOA1*/
+ +       .timer         = 1,
+ +       .gpio          = AT91_PIN_PA27,
+ +       .flags         = AT91_TC_RA,
+ +       .is_active_low = 1,
+ +     },
+ +     { /* TIOA2*/
+ +       .timer         = 2,
+ +       .gpio          = AT91_PIN_PA28,
+ +       .flags         = AT91_TC_RA,
+ +       .is_active_low = 1,
+ +     },
+ +     { /* TIOB0*/
+ +       .timer         = 0,
+ +       .gpio          = AT91_PIN_PC9,
+ +       .flags         = AT91_TC_RB,
+ +       .is_active_low = 1,
+ +     },
+ +     { /* TIOB1*/
+ +       .timer         = 1,
+ +       .gpio          = AT91_PIN_PC7,
+ +       .flags         = AT91_TC_RB,
+ +       .is_active_low = 1,
+ +     },
+ +     { /* TIOB2*/
+ +       .timer         = 2,
+ +       .gpio          = AT91_PIN_PC6,
+ +       .flags         = AT91_TC_RB,
+ +       .is_active_low = 1,
+ +     },
+ +   };
+ + #endif
+ + 
+ + int get_channel_from_gpio(u32 gpio) 
+ + {
+ +   int i;
+ +   for(i=0; i<PWM_NCHAN; i++) {
+ +     if(channel_map[i].gpio == gpio) {
+ +       //printk("%04d : %s() - returning %d\n", __LINE__, __FUNCTION__, i);
+ +       return i;      
+ +     }
+ +   }
+ +   //  printk("%04d : %s() - returning %d\n", __LINE__, __FUNCTION__, -1);
+ +   return -1;
+ + }
+ + 
+ + /* global PWM controller registers */
+ + #define PWM_MR		0x00
+ + #define PWM_ENA		0x04
+ + #define PWM_DIS		0x08
+ + #define PWM_SR		0x0c
+ + #define PWM_IER		0x10
+ + #define PWM_IDR		0x14
+ + #define PWM_IMR		0x18
+ + #define PWM_ISR		0x1c
+ + 
+ + static inline void pwm_writel(const struct pwm *p, unsigned offset, u32 val)
+ + {
+ +   //	__raw_writel(val, p->base + offset);
+ + }
+ + 
+ + static inline u32 pwm_readl(const struct pwm *p, unsigned offset)
+ + {
+ +   //	return __raw_readl(p->base + offset);
+ +   return 0;
+ + }
+ + 
+ + static inline void __iomem *pwmc_regs(const struct pwm *p, int index)
+ + {
+ +   //  return p->base + 0x200 + index * 0x20;
+ +   return NULL;
+ + }
+ + 
+ + static inline void timer_writel(const struct pwm *p, u8 timer, unsigned offset, u32 val)
+ + {
+ +   __raw_writel(val, p->base[timer] + offset);
+ + }
+ + 
+ + static inline u32 timer_readl(const struct pwm *p, u8 timer,  unsigned offset)
+ + {
+ +   return __raw_readl(p->base[timer] + offset);
+ + }
+ + 
+ + 
+ + static char *clocks[3] = {"tc0_clk", "tc1_clk", "tc2_clk"};
+ + 
+ + static struct pwm *pwm = NULL;
+ + 
+ + 
+ + static void pwm_dumpregs(struct pwm_channel *ch, char *tag)
+ + {
+ +   struct device	*dev = &pwm->pdev->dev;
+ + 
+ +   dev_dbg(dev, "%s: mr %08x, sr %08x, imr %08x\n",
+ +           tag,
+ +           pwm_readl(pwm, PWM_MR),
+ +           pwm_readl(pwm, PWM_SR),
+ +           pwm_readl(pwm, PWM_IMR));
+ +   dev_dbg(dev,
+ +           "pwm ch%d - mr %08x, dty %u, prd %u, cnt %u\n",
+ +           ch->index,
+ +           pwm_channel_readl(ch, PWM_CMR),
+ +           pwm_channel_readl(ch, PWM_CDTY),
+ +           pwm_channel_readl(ch, PWM_CPRD),
+ +           pwm_channel_readl(ch, PWM_CCNT));
+ + }
+ + 
+ + void
+ + pwm_channel_writel(struct pwm_channel *pwmc, unsigned offset, u32 val)
+ + {
+ +   int idx;
+ + 
+ +   if((idx = get_channel_from_gpio(pwmc->index)) < 0)
+ +     return;
+ + 
+ +   if(offset == PWM_CUPD) {
+ +     if(channel_map[idx].is_active_low) {
+ +       timer_writel(pwm, channel_map[idx].timer, channel_map[idx].flags, 255-val);
+ +     } else {
+ +       timer_writel(pwm, channel_map[idx].timer, channel_map[idx].flags, val);
+ +     }
+ +     /*
+ +     printk("%s() - TIO%c%d %d   %d\n", __FUNCTION__, 
+ +            channel_map[idx].flags&AT91_TC_RA ? 'A' : 'B',
+ +            channel_map[idx].timer,
+ +            timer_readl(pwm, channel_map[idx].timer, channel_map[idx].flags),
+ +            timer_readl(pwm, channel_map[idx].timer, AT91_TC_RC));
+ +     */
+ +   } 
+ + }
+ + EXPORT_SYMBOL(pwm_channel_writel);
+ + 
+ + u32 pwm_channel_readl(struct pwm_channel *pwmc, unsigned offset)
+ + {
+ +   int idx;
+ + 
+ +   if((idx = get_channel_from_gpio(pwmc->index)) < 0)
+ +     return -1;
+ + 
+ +   if(offset == PWM_CUPD) {
+ +     return timer_readl(pwm, channel_map[idx].timer, channel_map[idx].flags);
+ +   } else {
+ +     return 0;
+ +   }
+ + }
+ + 
+ + 
+ + /**
+ +  * pwm_channel_alloc - allocate an unused PWM channel
+ +  * @index: identifies the channel
+ +  * @ch: structure to be initialized
+ +  *
+ +  * Drivers allocate PWM channels according to the board's wiring, and
+ +  * matching board-specific setup code.  Returns zero or negative errno.
+ +  */
+ + int pwm_channel_alloc(int index, struct pwm_channel *ch)
+ + {
+ +   unsigned long	flags;
+ +   int		status = 0;
+ +   u32 tcval;
+ +   int idx;
+ + 
+ +   /* insist on PWM init, with this signal pinned out */
+ +   //  if (!pwm || !(pwm->mask & 1 << index)) {
+ +   if (!pwm) {
+ +     //printk("at91_pwm - %s(): pwm is NULL\n", __FUNCTION__);
+ +     return -ENODEV;
+ +   }
+ + 
+ +   if((idx = get_channel_from_gpio(index)) < 0)
+ +     return -EINVAL;
+ + 
+ +   memset(ch, 0, sizeof *ch);
+ + 
+ +   spin_lock_irqsave(&pwm->lock, flags);
+ +   // if (pwm->channel[index])
+ +   //  status = -EBUSY;
+ +   //else {
+ +     
+ +   /*
+ +     printk("at91_pwm - allocating PWM timer TIO%c%d on PIO 0x%08x\n", 
+ +            (channel_map[idx].flags == AT91_TC_RA) ? 'A' : 'B',
+ +            channel_map[idx].timer,
+ +            index);
+ +   */
+ +     ch->index = index;
+ + 
+ +     clk_enable(pwm->clk[channel_map[idx].timer]);
+ + 
+ +     pwm->channel[index] = ch;
+ +     pwm->handler[index] = NULL;
+ + 
+ +     tcval = 
+ +       AT91_TC_BCPC_SET | AT91_TC_BCPB_CLEAR | 
+ +       AT91_TC_ACPC_SET | AT91_TC_ACPA_CLEAR | 
+ +       AT91_TC_WAVE | AT91_TC_WAVESEL_UP_AUTO | 
+ +       AT91_TC_ABETRG | (channel_map[idx].timer << 0);
+ +     /*
+ +     printk("%s() - CMR%d: 0x%08x\n", __FUNCTION__, 
+ +            channel_map[idx].timer, tcval);
+ +     */
+ +     /* Setup tio */
+ +     timer_writel(pwm, channel_map[idx].timer, AT91_TC_CMR, tcval);
+ +     timer_writel(pwm, channel_map[idx].timer, channel_map[idx].flags, 155);
+ + 
+ +     /* Fixed 255 period time */
+ +     timer_writel(pwm, channel_map[idx].timer, AT91_TC_RC, 255); 
+ +     timer_writel(pwm, channel_map[idx].timer, AT91_TC_CCR, 
+ +                  (AT91_TC_CLKEN | AT91_TC_SWTRG));
+ +     //}
+ +   spin_unlock_irqrestore(&pwm->lock, flags);
+ +   return status;
+ + }
+ + EXPORT_SYMBOL(pwm_channel_alloc);
+ + 
+ + static int pwmcheck(struct pwm_channel *ch)
+ + {
+ +   int		index;
+ + 
+ +   //  printk("at91_pwm - %s()\n", __FUNCTION__);
+ + 
+ +   if (!pwm)
+ +     return -ENODEV;
+ +   if (!ch)
+ +     return -EINVAL;
+ +   index = ch->index;
+ +   if (index < 0 || index >= PWM_NCHAN || pwm->channel[index] != ch)
+ +     return -EINVAL;
+ + 
+ +   return index;
+ + }
+ + 
+ + /**
+ +  * pwm_channel_free - release a previously allocated channel
+ +  * @ch: the channel being released
+ +  *
+ +  * The channel is completely shut down (counter and IRQ disabled),
+ +  * and made available for re-use.  Returns zero, or negative errno.
+ +  */
+ + int pwm_channel_free(struct pwm_channel *ch)
+ + {
+ +   unsigned long	flags;
+ +   int		t;
+ + 
+ +   //  printk("at91_pwm - %s()\n", __FUNCTION__);
+ + 
+ +   spin_lock_irqsave(&pwm->lock, flags);
+ +   t = pwmcheck(ch);
+ +   if (t >= 0) {
+ +     pwm->channel[t] = NULL;
+ +     pwm->handler[t] = NULL;
+ + 
+ +     /* channel and irq are always disabled when we return */
+ +     pwm_writel(pwm, PWM_DIS, 1 << t);
+ +     pwm_writel(pwm, PWM_IDR, 1 << t);
+ + 
+ +     /*
+ +     clk_disable(pwm->clk0);
+ +     clk_disable(pwm->clk1);
+ +     clk_disable(pwm->clk2);
+ +     */
+ +     t = 0;
+ +   }
+ +   spin_unlock_irqrestore(&pwm->lock, flags);
+ +   return t;
+ + }
+ + EXPORT_SYMBOL(pwm_channel_free);
+ + 
+ + int __pwm_channel_onoff(struct pwm_channel *ch, int enabled)
+ + {
+ +   unsigned long	flags;
+ +   int		t;
+ + 
+ +   /* OMITTED FUNCTIONALITY:  starting several channels in synch */
+ + 
+ +   //printk("at91_pwm - %s()\n", __FUNCTION__);
+ + 
+ +   spin_lock_irqsave(&pwm->lock, flags);
+ +   t = pwmcheck(ch);
+ +   if (t >= 0) {
+ +     pwm_writel(pwm, enabled ? PWM_ENA : PWM_DIS, 1 << t);
+ +     t = 0;
+ + 
+ +   }
+ +   spin_unlock_irqrestore(&pwm->lock, flags);
+ + 
+ +   return t;
+ + }
+ + EXPORT_SYMBOL(__pwm_channel_onoff);
+ + 
+ + /**
+ +  * pwm_clk_alloc - allocate and configure CLKA or CLKB
+ +  * @prescale: from 0..10, the power of two used to divide MCK
+ +  * @div: from 1..255, the linear divisor to use
+ +  *
+ +  * Returns PWM_CPR_CLKA, PWM_CPR_CLKB, or negative errno.  The allocated
+ +  * clock will run with a period of (2^prescale * div) / MCK, or twice as
+ +  * long if center aligned PWM output is used.  The clock must later be
+ +  * deconfigured using pwm_clk_free().
+ +  */
+ + int pwm_clk_alloc(unsigned prescale, unsigned div)
+ + {
+ +   //  printk("at91_pwm - %s()\n", __FUNCTION__);
+ +   return 1;
+ + }
+ + EXPORT_SYMBOL(pwm_clk_alloc);
+ + 
+ + /**
+ +  * pwm_clk_free - deconfigure and release CLKA or CLKB
+ +  *
+ +  * Reverses the effect of pwm_clk_alloc().
+ +  */
+ + void pwm_clk_free(unsigned clk)
+ + {
+ +   //printk("at91_pwm - %s()\n", __FUNCTION__);
+ +   return;
+ + }
+ + EXPORT_SYMBOL(pwm_clk_free);
+ + 
+ + /**
+ +  * pwm_channel_handler - manage channel's IRQ handler
+ +  * @ch: the channel
+ +  * @handler: the handler to use, possibly NULL
+ +  *
+ +  * If the handler is non-null, the handler will be called after every
+ +  * period of this PWM channel.  If the handler is null, this channel
+ +  * won't generate an IRQ.
+ +  */
+ + int pwm_channel_handler(struct pwm_channel *ch,
+ +                         void (*handler)(struct pwm_channel *ch))
+ + {
+ +   //  printk("at91_pwm - %s()\n", __FUNCTION__);
+ +   return 0;
+ + }
+ + EXPORT_SYMBOL(pwm_channel_handler);
+ + 
+ + 
+ + static int __init pwm_probe(struct platform_device *pdev)
+ + {
+ +   int i;
+ +   struct resource *r;
+ +   u32 *mp = pdev->dev.platform_data;
+ +   struct pwm *p;
+ +   int status = -EIO;
+ + 
+ +   //  printk("%04d : %s()\n",__LINE__, __FUNCTION__);
+ +   if (pwm)
+ +     return -EBUSY;
+ +   if (!mp || !*mp)
+ +     return -ENODEV;
+ +   /*
+ +   if (*mp & ~((1<<PWM_NCHAN)-1)) {
+ +     dev_warn(&pdev->dev, "mask 0x%x ... more than %d channels\n",
+ +              *mp, PWM_NCHAN);
+ +     return -EINVAL;
+ +   }
+ +   */
+ + 
+ +   //  printk("%04d : %s()\n",__LINE__, __FUNCTION__);
+ +   
+ +   p = kzalloc(sizeof(*p), GFP_KERNEL);
+ +   if (!p)
+ +     return -ENOMEM;
+ + 
+ +   spin_lock_init(&p->lock);
+ +   p->pdev = pdev;
+ +   p->mask = *mp;
+ + 
+ +   for(i=0; i<3; i++) {
+ +     r = platform_get_resource(pdev, IORESOURCE_MEM, i);
+ +     if(!r) {
+ +       //      printk("at91_pwm - %s(): resource fail\n", __FUNCTION__);
+ +       goto fail;
+ +     }
+ +     p->base[i] = ioremap(r->start, r->end - r->start + 1);
+ +     if (!p->base[i])
+ +       goto fail;
+ +   }
+ +   //printk("%04d : %s() - ressource ok\n",__LINE__, __FUNCTION__);
+ +   for(i=0; i<3; i++) {
+ +     p->clk[i] = clk_get(&pdev->dev, clocks[i]);
+ +     if (IS_ERR(p->clk[i])) {
+ +       status = PTR_ERR(p->clk[i]);
+ +       p->clk[i] = NULL;
+ +       //printk("at91_pwm - %s(): %s fail\n", __FUNCTION__, clocks[i]);
+ +       goto fail;
+ +     }
+ +   }
+ + 
+ +   //printk("%04d : %s() - clk ok\n",__LINE__, __FUNCTION__);
+ +   pwm = p;
+ + 
+ +   platform_set_drvdata(pdev, p);
+ + 
+ +   return 0;
+ + 
+ +  fail:
+ +   for(i=0; i<3; i++) {
+ +     if (p->clk[i])
+ +     clk_put(p->clk[i]);
+ +   }
+ +   if (p->base)
+ +     iounmap(p->base);
+ + 
+ +   kfree(p);
+ +   return status;
+ + }
+ + 
+ + static int __exit pwm_remove(struct platform_device *pdev)
+ + {
+ +   int i;
+ +   struct pwm *p = platform_get_drvdata(pdev);
+ + 
+ +   //printk("at91_pwm - %s()\n", __FUNCTION__);
+ + 
+ +   if (p != pwm)
+ +     return -EINVAL;
+ + 
+ +   for(i=0; i<3; i++) {
+ +     if (p->clk[i])
+ +       clk_put(p->clk[i]);
+ +   }
+ +   
+ +   pwm = NULL;
+ + 
+ +   iounmap(p->base);
+ +   kfree(p);
+ + 
+ +   return 0;
+ + }
+ + 
+ + static struct platform_driver at91_pwm_driver = {
+ +   .driver = {
+ +     .name = "at91_pwm",
+ +     .owner = THIS_MODULE,
+ +   },
+ +   .remove = __exit_p(pwm_remove),
+ + };
+ + 
+ + static int __init pwm_init(void)
+ + {
+ +   printk("at91_pwm - %s()\n", __FUNCTION__);
+ +   return platform_driver_probe(&at91_pwm_driver, pwm_probe);
+ + }
+ + module_init(pwm_init);
+ + 
+ + static void __exit pwm_exit(void)
+ + {
+ +   printk("at91_pwm - %s()\n", __FUNCTION__);
+ +   platform_driver_unregister(&at91_pwm_driver);
+ + }
+ + module_exit(pwm_exit);
+ + 
+ + MODULE_DESCRIPTION("Driver for AT91 PWM module");
+ + MODULE_LICENSE("GPL");
+ + MODULE_ALIAS("platform:at91_pwm");
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/drivers/misc/Kconfig liab-linux-2.6.29.4/drivers/misc/Kconfig
+ *** linux-2.6.29.4/drivers/misc/Kconfig	2009-05-19 01:52:34.000000000 +0200
+ --- liab-linux-2.6.29.4/drivers/misc/Kconfig	2009-07-31 11:41:29.000000000 +0200
+ ***************
+ *** 55,60 ****
+ --- 55,67 ----
+   	  TC can be used for other purposes, such as PWM generation and
+   	  interval timing.
+   
+ + config AT91_PWM
+ + 	tristate "Atmel AT91 PWM support"
+ + 	depends on ARCH_AT91
+ + 	help
+ + 	  This option enables device driver support for the PWM channels
+ + 	  on certain Atmel processors by using the TIOA/B timer banks.
+ + 
+   config IBM_ASM
+   	tristate "Device driver for IBM RSA service processor"
+   	depends on X86 && PCI && INPUT && EXPERIMENTAL
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/drivers/misc/Makefile liab-linux-2.6.29.4/drivers/misc/Makefile
+ *** linux-2.6.29.4/drivers/misc/Makefile	2009-05-19 01:52:34.000000000 +0200
+ --- liab-linux-2.6.29.4/drivers/misc/Makefile	2009-07-31 11:41:29.000000000 +0200
+ ***************
+ *** 5,10 ****
+ --- 5,11 ----
+   obj-$(CONFIG_IBM_ASM)		+= ibmasm/
+   obj-$(CONFIG_HDPU_FEATURES)	+= hdpuftrs/
+   obj-$(CONFIG_ATMEL_PWM)		+= atmel_pwm.o
+ + obj-$(CONFIG_AT91_PWM)		+= at91_pwm.o
+   obj-$(CONFIG_ATMEL_SSC)		+= atmel-ssc.o
+   obj-$(CONFIG_ATMEL_TCLIB)	+= atmel_tclib.o
+   obj-$(CONFIG_ICS932S401)	+= ics932s401.o
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/drivers/misc/mikkelsysfs.c liab-linux-2.6.29.4/drivers/misc/mikkelsysfs.c
+ *** linux-2.6.29.4/drivers/misc/mikkelsysfs.c	1970-01-01 01:00:00.000000000 +0100
+ --- liab-linux-2.6.29.4/drivers/misc/mikkelsysfs.c	2009-08-19 15:22:30.000000000 +0200
+ ***************
+ *** 0 ****
+ --- 1,143 ----
+ + /*
+ +     pca9539.c - 16-bit I/O port with interrupt and reset
+ + 
+ +     Copyright (C) 2005 Ben Gardner <bgardner@wabtec.com>
+ + 
+ +     This program is free software; you can redistribute it and/or modify
+ +     it under the terms of the GNU General Public License as published by
+ +     the Free Software Foundation; version 2 of the License.
+ + */
+ + 
+ + #include <linux/module.h>
+ + #include <linux/init.h>
+ + #include <linux/slab.h>
+ + #include <linux/hwmon-sysfs.h>
+ + 
+ + 
+ + /*
+ +  * Feature listing:
+ +  * Set GPIO to I/O. Readable through sysfs interface.
+ +  * 
+ +  *
+ +  *
+ +  */
+ + 
+ + enum liabio_cmd
+ + {
+ + 	LIABIO_INPUT_0		= 0,
+ + 	LIABIO_INPUT_1		= 1,
+ + 	LIABIO_OUTPUT_0	= 2,
+ + 	LIABIO_OUTPUT_1	= 3,
+ + 	LIABIO_INVERT_0	= 4,
+ + 	LIABIO_INVERT_1	= 5,
+ + 	LIABIO_DIRECTION_0	= 6,
+ + 	LIABIO_DIRECTION_1	= 7,
+ + };
+ + 
+ + /* following are the sysfs callback functions */
+ + static ssize_t liabio_show(struct device *dev, struct device_attribute *attr,
+ + 			    char *buf)
+ + {
+ +   int count = 0;
+ + 	struct sensor_device_attribute *psa = to_sensor_dev_attr(attr);
+ +   /* Write back the current value... */
+ +   return count;
+ + }
+ + 
+ + static ssize_t liabio_store(struct device *dev, struct device_attribute *attr,
+ + 			     const char *buf, size_t count)
+ + {
+ + 	struct sensor_device_attribute *psa = to_sensor_dev_attr(attr);
+ + 	unsigned long val = simple_strtoul(buf, NULL, 0);
+ + 	if (val > 0xff)
+ + 		return -EINVAL;
+ + 
+ +   /* Write the value to register */
+ + 	return count;
+ + }
+ + 
+ + /* Define the device attributes */
+ + 
+ + #define LIABIO_ENTRY_RO(name, cmd_idx) \
+ + 	static SENSOR_DEVICE_ATTR(name, S_IRUGO, liabio_show, NULL, cmd_idx)
+ + 
+ + #define LIABIO_ENTRY_RW(name, cmd_idx) \
+ + 	static SENSOR_DEVICE_ATTR(name, S_IRUGO | S_IWUSR, liabio_show, \
+ + 				  liabio_store, cmd_idx)
+ + 
+ + LIABIO_ENTRY_RO(input0, LIABIO_INPUT_0);
+ + LIABIO_ENTRY_RO(input1, LIABIO_INPUT_1);
+ + LIABIO_ENTRY_RW(output0, LIABIO_OUTPUT_0);
+ + LIABIO_ENTRY_RW(output1, LIABIO_OUTPUT_1);
+ + LIABIO_ENTRY_RW(invert0, LIABIO_INVERT_0);
+ + LIABIO_ENTRY_RW(invert1, LIABIO_INVERT_1);
+ + LIABIO_ENTRY_RW(direction0, LIABIO_DIRECTION_0);
+ + LIABIO_ENTRY_RW(direction1, LIABIO_DIRECTION_1);
+ + 
+ + static struct attribute *liabio_attributes[] = {
+ + 	&sensor_dev_attr_input0.dev_attr.attr,
+ + 	&sensor_dev_attr_input1.dev_attr.attr,
+ + 	&sensor_dev_attr_output0.dev_attr.attr,
+ + 	&sensor_dev_attr_output1.dev_attr.attr,
+ + 	&sensor_dev_attr_invert0.dev_attr.attr,
+ + 	&sensor_dev_attr_invert1.dev_attr.attr,
+ + 	&sensor_dev_attr_direction0.dev_attr.attr,
+ + 	&sensor_dev_attr_direction1.dev_attr.attr,
+ + 	NULL
+ + };
+ + 
+ + static struct attribute_group liabio_defattr_group = {
+ + 	.attrs = liabio_attributes,
+ + };
+ + 
+ + /* Return 0 if detection is successful, -ENODEV otherwise */
+ + static int liabio_detect(struct i2c_client *client, int kind,
+ + 			  struct i2c_board_info *info)
+ + {
+ +   /* TODO: */
+ + 
+ + 	return 0;
+ + }
+ + 
+ + static int liabio_probe(struct i2c_client *client,
+ + 			 const struct i2c_device_id *id)
+ + {
+ + 	/* Register sysfs hooks */
+ + 	return sysfs_create_group(&client->dev.kobj,
+ + 				  &liabio_defattr_group);
+ + }
+ + 
+ + static int liabio_remove(struct i2c_client *client)
+ + {
+ + 	sysfs_remove_group(&client->dev.kobj, &liabio_defattr_group);
+ + 	return 0;
+ + }
+ + 
+ + 
+ + static struct i2c_driver liabio_driver = {
+ + 	.driver = {
+ + 		.name	= "liabio",
+ + 	},
+ + 	.probe		= liabio_probe,
+ + 	.remove		= liabio_remove,
+ + 	.detect		= liabio_detect,
+ + 	.address_data	= &addr_data,
+ + };
+ + 
+ + static int __init liabio_init(void)
+ + {
+ + 
+ + }
+ + 
+ + static void __exit liabio_exit(void)
+ + {
+ + 
+ + }
+ + 
+ + MODULE_AUTHOR("Ben Gardner <bgardner@wabtec.com>");
+ + MODULE_DESCRIPTION("LIABIO driver");
+ + MODULE_LICENSE("GPL");
+ + 
+ + module_init(liabio_init);
+ + module_exit(liabio_exit);
+ + 
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/drivers/mtd/maps/Kconfig liab-linux-2.6.29.4/drivers/mtd/maps/Kconfig
+ *** linux-2.6.29.4/drivers/mtd/maps/Kconfig	2009-05-19 01:52:34.000000000 +0200
+ --- liab-linux-2.6.29.4/drivers/mtd/maps/Kconfig	2009-07-31 11:40:42.000000000 +0200
+ ***************
+ *** 542,547 ****
+ --- 542,604 ----
+   	  Map driver for a NOR flash bank located on the Expansion Bus of the
+   	  Intel Vermilion Range chipset.
+   
+ + # -----------------------------------------------------
+ + config MTD_LIABARM
+ + 	bool "CFI Flash device mapped on a LIABARM series product"
+ + 	depends on MTD_CFI && MACH_LIABARM && MTD_PARTITIONS
+ + 	help
+ +     Use this if you have either a LIABARM9200 or a nanoLIAB board.
+ + 
+ + config MTD_LIAB_FLASH_SIZE
+ + 	int "FLASH chip size (KB)"
+ + 	depends on MTD_LIABARM
+ +   default "16384"
+ + 	help
+ +     The size of the individual FLASH chips on the board.
+ + 
+ + config MTD_LIAB_NOFLASH
+ +   int "Number of FLASH chips on the board"
+ + 	depends on MTD_LIABARM
+ + 	default "1"
+ + 	help
+ +     This would typically be 1 or 2 for LIABARM9200 and 1 for nanoLIAB.
+ + 
+ + config MTD_LIABARM_BOOTSIZE
+ + 	int "Size of bootloader partition (KB)"
+ + 	depends on MTD_LIABARM
+ + 	default "128"
+ + 	help
+ +     This is the size in kilobytes of the LIAB ApS bootloader
+ +     partition.
+ + 
+ + config MTD_LIABARM_KERNELSIZE
+ + 	int "Size of kernel partition (KB)"
+ + 	depends on MTD_LIABARM
+ + 	default "1536"
+ + 	help
+ +     This is the size in kilobytes of the kernel partition.
+ + 
+ + config MTD_LIABARM_ROOTSIZE
+ + 	int "Size of root partition (KB)"
+ + 	depends on MTD_LIABARM
+ + 	default "4480"
+ + 	help
+ +     This is the size in kilobytes of the root (initrd) partition.
+ + 
+ + config MTD_LIABARM_PARAMSIZE
+ +   int "Size of parameters partition (KB)"
+ +   depends on MTD_LIABARM
+ +   default "128"
+ +   help
+ +     This is the size in kilobytes of the parameters partition.
+ + 
+ + config MTD_LIABARM_JFFS2SIZE
+ + 	int "Size of jffs2 partition (KB)"
+ + 	depends on MTD_LIABARM
+ + 	default "10112"
+ + 	help
+ +     This is the size in kilobytes of the JFFS2 filesystem partition.
+ + 
+   config MTD_PLATRAM
+   	tristate "Map driver for platform device RAM (mtd-ram)"
+   	select MTD_RAM
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/drivers/mtd/maps/Makefile liab-linux-2.6.29.4/drivers/mtd/maps/Makefile
+ *** linux-2.6.29.4/drivers/mtd/maps/Makefile	2009-05-19 01:52:34.000000000 +0200
+ --- liab-linux-2.6.29.4/drivers/mtd/maps/Makefile	2009-07-31 11:40:42.000000000 +0200
+ ***************
+ *** 61,63 ****
+ --- 61,64 ----
+   obj-$(CONFIG_MTD_OMAP_NOR)	+= omap_nor.o
+   obj-$(CONFIG_MTD_INTEL_VR_NOR)	+= intel_vr_nor.o
+   obj-$(CONFIG_MTD_BFIN_ASYNC)	+= bfin-async-flash.o
+ + obj-$(CONFIG_MTD_LIABARM)	+= nanoliab.o
+ \ No newline at end of file
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/drivers/mtd/maps/nanoliab.c liab-linux-2.6.29.4/drivers/mtd/maps/nanoliab.c
+ *** linux-2.6.29.4/drivers/mtd/maps/nanoliab.c	1970-01-01 01:00:00.000000000 +0100
+ --- liab-linux-2.6.29.4/drivers/mtd/maps/nanoliab.c	2009-07-31 11:40:42.000000000 +0200
+ ***************
+ *** 0 ****
+ --- 1,195 ----
+ + /*
+ +  * Flash on Cirrus CDB89712
+ +  *
+ +  * $Id: cdb89712.c,v 1.10 2004/11/04 13:24:14 gleixner Exp $
+ +  */
+ + 
+ + #include <linux/module.h>
+ + #include <linux/types.h>
+ + #include <linux/kernel.h>
+ + #include <linux/ioport.h>
+ + #include <linux/init.h>
+ + #include <asm/io.h>
+ + #include <mach/hardware.h>
+ + #include <linux/mtd/mtd.h>
+ + #include <linux/mtd/map.h>
+ + #include <linux/mtd/partitions.h>
+ + 
+ + static struct mtd_info *flash0_mtd;
+ + 
+ + #define LIAB_FLASH0_START           (0x10000000)
+ + #define MEGABYTE                    (1024)
+ + #define FLASHMAXSIZE                (CONFIG_MTD_LIAB_FLASH_SIZE)
+ + #define NANOLIABBANKWIDTH           (2)
+ + 
+ + struct map_info liab_flash0_map = 
+ + {
+ + 	.name = "flash0",
+ + 	.size =      (CONFIG_MTD_LIAB_FLASH_SIZE)*1024,
+ + 	.bankwidth = NANOLIABBANKWIDTH,
+ + 	.phys =      LIAB_FLASH0_START,
+ + };
+ + 
+ + struct resource liab_flash0_resource = 
+ + {
+ + 	.name =   "Flash0",
+ + 	.start =  LIAB_FLASH0_START,
+ + 	.end =    LIAB_FLASH0_START+(CONFIG_MTD_LIAB_FLASH_SIZE)*1024-1,
+ + 	.flags =  IORESOURCE_IO | IORESOURCE_BUSY,
+ + };
+ + 
+ + #define NUM_PARTITIONS 5
+ + 
+ + /*    Physical partition order: */
+ + /*    mtdblock 1: 'FLASH Boot partition'   */
+ + /*    mtdblock 2: 'FLASH Kernel partition' */
+ + /*    mtdblock 0: 'FLASH Root partition'   */
+ + /*    mtdblock 3: 'FLASH Param partition'  */
+ + /*    mtdblock 4: 'FLASH JFFS2 partition'  */
+ + 
+ + /*    Logical partition order: */
+ + /*    mtdblock 0: 'FLASH Root partition'   */
+ + /*    mtdblock 1: 'FLASH Boot partition'   */
+ + /*    mtdblock 2: 'FLASH Kernel partition' */
+ + /*    mtdblock 3: 'FLASH Param partition'  */
+ + /*    mtdblock 4: 'FLASH JFFS2 partition'  */
+ + 
+ + #define OFFSET_BOOTSIZE   0
+ + #define OFFSET_KERNELSIZE (OFFSET_BOOTSIZE   + CONFIG_MTD_LIABARM_BOOTSIZE)
+ + #define OFFSET_ROOTSIZE   (OFFSET_KERNELSIZE + CONFIG_MTD_LIABARM_KERNELSIZE)
+ + #define OFFSET_JFFS2SIZE  (OFFSET_ROOTSIZE   + CONFIG_MTD_LIABARM_ROOTSIZE)
+ + #define OFFSET_PARAMSIZE  (OFFSET_JFFS2SIZE  + CONFIG_MTD_LIABARM_JFFS2SIZE)
+ + #define TOTALSIZE         (OFFSET_PARAMSIZE  + CONFIG_MTD_LIABARM_PARAMSIZE)
+ + 
+ + /* partition_info gives details on the logical partitions that the 
+ +  * single flash device is split into. */
+ + static struct mtd_partition flash0_partition_info[]={
+ +   {
+ +     name:   "NANOLIAB FLASH Root partition", 
+ +     offset: OFFSET_ROOTSIZE*1024,
+ +     size: CONFIG_MTD_LIABARM_ROOTSIZE*1024
+ +   },
+ +   {
+ +     name:   "NANOLIAB FLASH Boot partition", 
+ +     offset: OFFSET_BOOTSIZE*1024,
+ +     size: CONFIG_MTD_LIABARM_BOOTSIZE*1024
+ +   },
+ +   {
+ +     name:   "NANOLIAB FLASH Kernel partition", 
+ +     offset: OFFSET_KERNELSIZE*1024,
+ +     size: CONFIG_MTD_LIABARM_KERNELSIZE*1024
+ +   },
+ +   {
+ +     name:   "NANOLIAB FLASH Param partition", 
+ +     offset: OFFSET_PARAMSIZE*1024,
+ +     size: CONFIG_MTD_LIABARM_PARAMSIZE*1024
+ +   },
+ +   {
+ +     name:   "NANOLIAB FLASH JFFS2 partition", 
+ +     offset: OFFSET_JFFS2SIZE*1024,
+ +     size: CONFIG_MTD_LIABARM_JFFS2SIZE*1024
+ +   },
+ + };
+ + 
+ + #if TOTALSIZE > FLASHMAXSIZE
+ + #error NANOLIAB FLASH: Total size of all MTD FLASH partitions too large!
+ + #endif
+ + #if TOTALSIZE < FLASHMAXSIZE
+ + #error NANOLIAB FLASH: Total size of all MTD FLASH partitions too small!
+ + #endif
+ + 
+ + static int __init init_liab_flash (void)
+ + {
+ + 	int err;
+ + 	
+ + 	if (request_resource (&ioport_resource, &liab_flash0_resource))
+ +     {
+ + 		printk(KERN_NOTICE "Failed to reserve NANOLIAB FLASH0 space\n");
+ + 		err = -EBUSY;
+ + 		goto out;
+ + 	}
+ +     
+ +   /* init flash0 */	
+ + 
+ + 	liab_flash0_map.virt = ioremap(LIAB_FLASH0_START, 
+ + 																 CONFIG_MTD_LIAB_FLASH_SIZE*1024);
+ + 	if (!liab_flash0_map.virt) 
+ +     {
+ + 		printk(KERN_NOTICE "Failed to ioremap NANOLIAB FLASH0 space\n");
+ + 		err = -EIO;
+ + 		goto out_resource;
+ + 	}
+ + 
+ + 	simple_map_init(&liab_flash0_map);
+ + 
+ + 	flash0_mtd = do_map_probe("cfi_probe", &liab_flash0_map);
+ + 
+ +     printk("--> 0x%08x 0x%08x\n", liab_flash0_map.virt, flash0_mtd);
+ + 
+ + #ifdef undef
+ + 	if (!flash0_mtd) 
+ +     {
+ + 		flash0_mtd = do_map_probe("map_rom", &liab_flash0_map);
+ + 		if (flash0_mtd)
+ + 			flash0_mtd->erasesize = 0x10000;
+ + 	}
+ + #endif
+ + 
+ + 	if (!flash0_mtd) 
+ +     {
+ + 		printk("FLASH probe failed\n");
+ + 		err = -ENXIO;
+ + 		goto out_ioremap;
+ + 	}
+ + 
+ + 	flash0_mtd->owner = THIS_MODULE;
+ +     
+ +   /* Add partitions */
+ +     if (add_mtd_partitions(flash0_mtd,  flash0_partition_info, 
+ +                          ARRAY_SIZE( flash0_partition_info)))
+ +     {
+ +         printk("FLASH0 device partition addition failed\n");
+ +         err = -ENOMEM;
+ +         goto out_probe;
+ +     }
+ + 	return 0;
+ +   
+ +  out_probe:
+ + 	map_destroy(flash0_mtd);
+ + 	flash0_mtd = 0;
+ +  out_ioremap:
+ + 	iounmap((void *)liab_flash0_map.virt);
+ +  out_resource:
+ + 	release_resource (&liab_flash0_resource);
+ +  out:
+ + 	return err;
+ + }
+ + 
+ + 
+ + static int __init init_nanoliab_maps(void)
+ + {
+ +     printk(KERN_INFO "NANOLIAB MTD FLASH device %d "
+ +                      "KB at physical offset 0x%x\n", 
+ + 					 CONFIG_MTD_LIAB_FLASH_SIZE, LIAB_FLASH0_START);
+ + 	init_liab_flash();
+ + 	return 0;
+ + }
+ + 	
+ + 
+ + static void __exit cleanup_nanoliab_maps(void)
+ + {
+ + 	if (flash0_mtd) 
+ +     {
+ +       del_mtd_device(flash0_mtd);
+ +       map_destroy(flash0_mtd);
+ +       iounmap((void *)liab_flash0_map.virt);
+ +       release_resource (&liab_flash0_resource);
+ +     }
+ + }
+ + 
+ + module_init(init_nanoliab_maps);
+ + module_exit(cleanup_nanoliab_maps);
+ + 
+ + MODULE_AUTHOR("LIAB ApS <www.liab.dk>");
+ + MODULE_DESCRIPTION("NANOLIAB mtdmap driver");
+ + MODULE_LICENSE("GPL");
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/drivers/net/dm9000.c liab-linux-2.6.29.4/drivers/net/dm9000.c
+ *** linux-2.6.29.4/drivers/net/dm9000.c	2009-05-19 01:52:34.000000000 +0200
+ --- liab-linux-2.6.29.4/drivers/net/dm9000.c	2009-09-10 15:36:51.000000000 +0200
+ ***************
+ *** 76,81 ****
+ --- 76,82 ----
+    * devices, DM9000A and DM9000B.
+    */
+   
+ + 
+   enum dm9000_type {
+   	TYPE_DM9000E,	/* original DM9000 */
+   	TYPE_DM9000A,
+ ***************
+ *** 128,133 ****
+ --- 129,136 ----
+   
+   /* debug code */
+   
+ + u8 mac_addr[6] = {0x00, 0x15, 0x8c, 0x00, 0x18, 0x01};
+ + 
+   #define dm9000_dbg(db, lev, msg...) do {		\
+   	if ((lev) < CONFIG_DM9000_DEBUGLEVEL &&		\
+   	    (lev) < db->debug_level) {			\
+ ***************
+ *** 1000,1032 ****
+   {
+   	board_info_t *db = netdev_priv(dev);
+   	unsigned long irqflags = db->irq_res->flags & IRQF_TRIGGER_MASK;
+ ! 
+   	if (netif_msg_ifup(db))
+   		dev_dbg(db->dev, "enabling %s\n", dev->name);
+   
+   	/* If there is no IRQ type specified, default to something that
+   	 * may work, and tell the user that this is a problem */
+   
+   	if (irqflags == IRQF_TRIGGER_NONE)
+   		dev_warn(db->dev, "WARNING: no IRQ resource flags set.\n");
+ ! 
+   	irqflags |= IRQF_SHARED;
+ ! 
+   	if (request_irq(dev->irq, &dm9000_interrupt, irqflags, dev->name, dev))
+   		return -EAGAIN;
+ ! 
+   	/* Initialize DM9000 board */
+   	dm9000_reset(db);
+   	dm9000_init_dm9000(dev);
+   
+   	/* Init driver variable */
+   	db->dbug_cnt = 0;
+   
+   	mii_check_media(&db->mii, netif_msg_link(db), 1);
+   	netif_start_queue(dev);
+   	
+   	dm9000_schedule_poll(db);
+   
+   	return 0;
+   }
+   
+ --- 1003,1040 ----
+   {
+   	board_info_t *db = netdev_priv(dev);
+   	unsigned long irqflags = db->irq_res->flags & IRQF_TRIGGER_MASK;
+ !   printk("%s():%d - here\n", __FUNCTION__, __LINE__);
+   	if (netif_msg_ifup(db))
+   		dev_dbg(db->dev, "enabling %s\n", dev->name);
+   
+ +   printk("%s():%d - here\n", __FUNCTION__, __LINE__);
+   	/* If there is no IRQ type specified, default to something that
+   	 * may work, and tell the user that this is a problem */
+   
+   	if (irqflags == IRQF_TRIGGER_NONE)
+   		dev_warn(db->dev, "WARNING: no IRQ resource flags set.\n");
+ !   printk("%s():%d - here\n", __FUNCTION__, __LINE__);
+   	irqflags |= IRQF_SHARED;
+ !   printk("%s():%d - here\n", __FUNCTION__, __LINE__);
+   	if (request_irq(dev->irq, &dm9000_interrupt, irqflags, dev->name, dev))
+   		return -EAGAIN;
+ !   printk("%s():%d - here\n", __FUNCTION__, __LINE__);
+   	/* Initialize DM9000 board */
+   	dm9000_reset(db);
+   	dm9000_init_dm9000(dev);
+   
+ +   printk("%s():%d - here\n", __FUNCTION__, __LINE__);
+   	/* Init driver variable */
+   	db->dbug_cnt = 0;
+   
+ +   printk("%s():%d - here\n", __FUNCTION__, __LINE__);
+   	mii_check_media(&db->mii, netif_msg_link(db), 1);
+   	netif_start_queue(dev);
+   	
+ +   printk("%s():%d - here\n", __FUNCTION__, __LINE__);
+   	dm9000_schedule_poll(db);
+   
+ +   printk("%s():%d - here\n", __FUNCTION__, __LINE__);
+   	return 0;
+   }
+   
+ ***************
+ *** 1380,1385 ****
+ --- 1388,1398 ----
+   			ndev->dev_addr[i] = ior(db, i+DM9000_PAR);
+   	}
+   
+ +   /* msawh*/
+ +   for (i = 0; i < 6; i++)
+ +     ndev->dev_addr[i] = mac_addr[i];
+ + 
+ + 
+   	if (!is_valid_ether_addr(ndev->dev_addr))
+   		dev_warn(db->dev, "%s: Invalid ethernet MAC address. Please "
+   			 "set using ifconfig\n", ndev->name);
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/drivers/rtc/rtc-ds1307.c liab-linux-2.6.29.4/drivers/rtc/rtc-ds1307.c
+ *** linux-2.6.29.4/drivers/rtc/rtc-ds1307.c	2009-05-19 01:52:34.000000000 +0200
+ --- liab-linux-2.6.29.4/drivers/rtc/rtc-ds1307.c	2009-07-31 11:41:48.000000000 +0200
+ ***************
+ *** 18,24 ****
+   #include <linux/bcd.h>
+   
+   
+ - 
+   /* We can't determine type by probing, but if we expect pre-Linux code
+    * to have set the chip up as a clock (turning on the oscillator and
+    * setting the date and time), Linux can ignore the non-clock features.
+ --- 18,23 ----
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/drivers/serial/atmel_serial.c liab-linux-2.6.29.4/drivers/serial/atmel_serial.c
+ *** linux-2.6.29.4/drivers/serial/atmel_serial.c	2009-05-19 01:52:34.000000000 +0200
+ --- liab-linux-2.6.29.4/drivers/serial/atmel_serial.c	2009-10-09 13:36:39.000000000 +0200
+ ***************
+ *** 1065,1070 ****
+ --- 1065,1078 ----
+   	} else
+   		mode |= ATMEL_US_PAR_NONE;
+   
+ + #ifdef CONFIG_MACH_LIABDIN
+ +   /* msawh */
+ +   if(port->line == 4) {
+ +     //printk("msawh - /dev/ttyS%d is RS485 mode\n", port->line);
+ +     mode |= ATMEL_US_USMODE_RS485;
+ +   }
+ + #endif
+ + 
+   	spin_lock_irqsave(&port->lock, flags);
+   
+   	port->read_status_mask = ATMEL_US_OVRE;
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/drivers/usb/serial/pl2303.h liab-linux-2.6.29.4/drivers/usb/serial/pl2303.h
+ *** linux-2.6.29.4/drivers/usb/serial/pl2303.h	2009-05-19 01:52:34.000000000 +0200
+ --- liab-linux-2.6.29.4/drivers/usb/serial/pl2303.h	2009-07-31 11:43:23.000000000 +0200
+ ***************
+ *** 60,65 ****
+ --- 60,67 ----
+   #define SAMSUNG_PRODUCT_ID	0x8001
+   
+   #define SIEMENS_VENDOR_ID	0x11f5
+ + #define SIEMENS2_VENDOR_ID	0x0681
+ + #define SIEMENS_PRODUCT_ID_HC25	0x0041
+   #define SIEMENS_PRODUCT_ID_SX1	0x0001
+   #define SIEMENS_PRODUCT_ID_X65	0x0003
+   #define SIEMENS_PRODUCT_ID_X75	0x0004
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/drivers/video/Kconfig liab-linux-2.6.29.4/drivers/video/Kconfig
+ *** linux-2.6.29.4/drivers/video/Kconfig	2009-05-19 01:52:34.000000000 +0200
+ --- liab-linux-2.6.29.4/drivers/video/Kconfig	2009-07-31 11:41:17.000000000 +0200
+ ***************
+ *** 940,945 ****
+ --- 940,951 ----
+   	help
+   	  This enables support for the AT91/AT32 LCD Controller.
+   
+ + config FB_MIKKEL
+ +        depends on FB
+ + 	tristate "Mikkel LCD Controller support"
+ + 	help
+ + 	  This enables support for the AT91/AT32 LCD Controller.
+ + 
+   config FB_INTSRAM
+   	bool "Frame Buffer in internal SRAM"
+   	depends on FB_ATMEL && ARCH_AT91SAM9261
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/drivers/watchdog/at91rm9200_wdt.c liab-linux-2.6.29.4/drivers/watchdog/at91rm9200_wdt.c
+ *** linux-2.6.29.4/drivers/watchdog/at91rm9200_wdt.c	2009-05-19 01:52:34.000000000 +0200
+ --- liab-linux-2.6.29.4/drivers/watchdog/at91rm9200_wdt.c	2009-07-31 11:41:03.000000000 +0200
+ ***************
+ *** 24,30 ****
+   #include <linux/uaccess.h>
+   #include <mach/at91_st.h>
+   
+ ! #define WDT_DEFAULT_TIME	5	/* seconds */
+   #define WDT_MAX_TIME		256	/* seconds */
+   
+   static int wdt_time = WDT_DEFAULT_TIME;
+ --- 24,30 ----
+   #include <linux/uaccess.h>
+   #include <mach/at91_st.h>
+   
+ ! #define WDT_DEFAULT_TIME 60	/* seconds */
+   #define WDT_MAX_TIME		256	/* seconds */
+   
+   static int wdt_time = WDT_DEFAULT_TIME;
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/gpiolib.patch liab-linux-2.6.29.4/gpiolib.patch
+ *** linux-2.6.29.4/gpiolib.patch	1970-01-01 01:00:00.000000000 +0100
+ --- liab-linux-2.6.29.4/gpiolib.patch	2010-05-28 13:41:40.665651985 +0200
+ ***************
+ *** 0 ****
+ --- 1,463 ----
+ + diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
+ + index dbfdf87..5e0c5ab 100644
+ + --- a/arch/arm/Kconfig
+ + +++ b/arch/arm/Kconfig
+ + @@ -241,6 +241,7 @@ config ARCH_VERSATILE
+ +  config ARCH_AT91
+ +  	bool "Atmel AT91"
+ +  	select GENERIC_GPIO
+ + +	select ARCH_REQUIRE_GPIOLIB
+ +  	select HAVE_CLK
+ +  	help
+ +  	  This enables support for systems based on the Atmel AT91RM9200,
+ + diff --git a/arch/arm/mach-at91/generic.h b/arch/arm/mach-at91/generic.h
+ + index 7b9ce7a..b5daf7f 100644
+ + --- a/arch/arm/mach-at91/generic.h
+ + +++ b/arch/arm/mach-at91/generic.h
+ + @@ -47,9 +47,6 @@ extern void at91_irq_resume(void);
+ +  #define AT91RM9200_BGA		4	/* AT91RM9200 BGA package has 4 banks */
+ +  
+ +  struct at91_gpio_bank {
+ + -	unsigned chipbase;		/* bank's first GPIO number */
+ + -	void __iomem *regbase;		/* base of register bank */
+ + -	struct at91_gpio_bank *next;	/* bank sharing same IRQ/clock/... */
+ +  	unsigned short id;		/* peripheral ID */
+ +  	unsigned long offset;		/* offset from system peripheral base */
+ +  	struct clk *clock;		/* associated clock */
+ + diff --git a/arch/arm/mach-at91/gpio.c b/arch/arm/mach-at91/gpio.c
+ + index 9b0447c..2b1232f 100644
+ + --- a/arch/arm/mach-at91/gpio.c
+ + +++ b/arch/arm/mach-at91/gpio.c
+ + @@ -24,19 +24,59 @@
+ +  #include <mach/at91_pio.h>
+ +  #include <mach/gpio.h>
+ +  
+ + +#include <asm/gpio.h>
+ + +
+ +  #include "generic.h"
+ +  
+ + +struct at91_gpio_chip {
+ + +	struct gpio_chip	chip;
+ + +	struct at91_gpio_chip	*next;		/* Bank sharing same clock */
+ + +	struct at91_gpio_bank	*bank;		/* Bank definition */
+ + +	void __iomem		*regbase;	/* Base of register bank */
+ + +};
+ +  
+ + -static struct at91_gpio_bank *gpio;
+ + -static int gpio_banks;
+ + +#define to_at91_gpio_chip(c) container_of(c, struct at91_gpio_chip, chip)
+ + +
+ + +static void at91_gpiolib_dbg_show(struct seq_file *s, struct gpio_chip *chip);
+ + +static void at91_gpiolib_set(struct gpio_chip *chip, unsigned offset, int val);
+ + +static int at91_gpiolib_get(struct gpio_chip *chip, unsigned offset);
+ + +static int at91_gpiolib_direction_output(struct gpio_chip *chip,
+ + +					 unsigned offset, int val);
+ + +static int at91_gpiolib_direction_input(struct gpio_chip *chip,
+ + +					unsigned offset);
+ + +static int at91_gpiolib_request(struct gpio_chip *chip, unsigned offset);
+ + +
+ + +#define AT91_GPIO_CHIP(name, base_gpio, nr_gpio)			\
+ + +	{								\
+ + +		.chip = {						\
+ + +			.label		  = name,			\
+ + +			.request	  = at91_gpiolib_request,	\
+ + +			.direction_input  = at91_gpiolib_direction_input, \
+ + +			.direction_output = at91_gpiolib_direction_output, \
+ + +			.get		  = at91_gpiolib_get,		\
+ + +			.set		  = at91_gpiolib_set,		\
+ + +			.dbg_show	  = at91_gpiolib_dbg_show,	\
+ + +			.base		  = base_gpio,			\
+ + +			.ngpio		  = nr_gpio,			\
+ + +		},							\
+ + +	}
+ + +
+ + +static struct at91_gpio_chip gpio_chip[] = {
+ + +	AT91_GPIO_CHIP("A", 0x00 + PIN_BASE, 32),
+ + +	AT91_GPIO_CHIP("B", 0x20 + PIN_BASE, 32),
+ + +	AT91_GPIO_CHIP("C", 0x40 + PIN_BASE, 32),
+ + +	AT91_GPIO_CHIP("D", 0x60 + PIN_BASE, 32),
+ + +	AT91_GPIO_CHIP("E", 0x80 + PIN_BASE, 32),
+ + +};
+ +  
+ + +static int gpio_banks;
+ +  
+ +  static inline void __iomem *pin_to_controller(unsigned pin)
+ +  {
+ +  	pin -= PIN_BASE;
+ +  	pin /= 32;
+ +  	if (likely(pin < gpio_banks))
+ + -		return gpio[pin].regbase;
+ + +		return gpio_chip[pin].regbase;
+ +  
+ +  	return NULL;
+ +  }
+ + @@ -197,39 +237,6 @@ int __init_or_module at91_set_multi_drive(unsigned pin, int is_on)
+ +  }
+ +  EXPORT_SYMBOL(at91_set_multi_drive);
+ +  
+ + -/*--------------------------------------------------------------------------*/
+ + -
+ + -/* new-style GPIO calls; these expect at91_set_GPIO_periph to have been
+ + - * called, and maybe at91_set_multi_drive() for putout pins.
+ + - */
+ + -
+ + -int gpio_direction_input(unsigned pin)
+ + -{
+ + -	void __iomem	*pio = pin_to_controller(pin);
+ + -	unsigned	mask = pin_to_mask(pin);
+ + -
+ + -	if (!pio || !(__raw_readl(pio + PIO_PSR) & mask))
+ + -		return -EINVAL;
+ + -	__raw_writel(mask, pio + PIO_ODR);
+ + -	return 0;
+ + -}
+ + -EXPORT_SYMBOL(gpio_direction_input);
+ + -
+ + -int gpio_direction_output(unsigned pin, int value)
+ + -{
+ + -	void __iomem	*pio = pin_to_controller(pin);
+ + -	unsigned	mask = pin_to_mask(pin);
+ + -
+ + -	if (!pio || !(__raw_readl(pio + PIO_PSR) & mask))
+ + -		return -EINVAL;
+ + -	__raw_writel(mask, pio + (value ? PIO_SODR : PIO_CODR));
+ + -	__raw_writel(mask, pio + PIO_OER);
+ + -	return 0;
+ + -}
+ + -EXPORT_SYMBOL(gpio_direction_output);
+ + -
+ + -/*--------------------------------------------------------------------------*/
+ + -
+ +  /*
+ +   * assuming the pin is muxed as a gpio output, set its value.
+ +   */
+ + @@ -282,7 +289,7 @@ static int gpio_irq_set_wake(unsigned pin, unsigned state)
+ +  	else
+ +  		wakeups[bank] &= ~mask;
+ +  
+ + -	set_irq_wake(gpio[bank].id, state);
+ + +	set_irq_wake(gpio_chip[bank].bank->id, state);
+ +  
+ +  	return 0;
+ +  }
+ + @@ -292,14 +299,14 @@ void at91_gpio_suspend(void)
+ +  	int i;
+ +  
+ +  	for (i = 0; i < gpio_banks; i++) {
+ + -		void __iomem	*pio = gpio[i].regbase;
+ + +		void __iomem	*pio = gpio_chip[i].regbase;
+ +  
+ +  		backups[i] = __raw_readl(pio + PIO_IMR);
+ +  		__raw_writel(backups[i], pio + PIO_IDR);
+ +  		__raw_writel(wakeups[i], pio + PIO_IER);
+ +  
+ +  		if (!wakeups[i])
+ + -			clk_disable(gpio[i].clock);
+ + +			clk_disable(gpio_chip[i].bank->clock);
+ +  		else {
+ +  #ifdef CONFIG_PM_DEBUG
+ +  			printk(KERN_DEBUG "GPIO-%c may wake for %08x\n", 'A'+i, wakeups[i]);
+ + @@ -313,10 +320,10 @@ void at91_gpio_resume(void)
+ +  	int i;
+ +  
+ +  	for (i = 0; i < gpio_banks; i++) {
+ + -		void __iomem	*pio = gpio[i].regbase;
+ + +		void __iomem	*pio = gpio_chip[i].regbase;
+ +  
+ +  		if (!wakeups[i])
+ + -			clk_enable(gpio[i].clock);
+ + +			clk_enable(gpio_chip[i].bank->clock);
+ +  
+ +  		__raw_writel(wakeups[i], pio + PIO_IDR);
+ +  		__raw_writel(backups[i], pio + PIO_IER);
+ + @@ -380,12 +387,12 @@ static void gpio_irq_handler(unsigned irq, struct irq_desc *desc)
+ +  {
+ +  	unsigned	pin;
+ +  	struct irq_desc	*gpio;
+ + -	struct at91_gpio_bank *bank;
+ + +	struct at91_gpio_chip *at91_gpio;
+ +  	void __iomem	*pio;
+ +  	u32		isr;
+ +  
+ + -	bank = get_irq_chip_data(irq);
+ + -	pio = bank->regbase;
+ + +	at91_gpio = get_irq_chip_data(irq);
+ + +	pio = at91_gpio->regbase;
+ +  
+ +  	/* temporarily mask (level sensitive) parent IRQ */
+ +  	desc->chip->ack(irq);
+ + @@ -396,14 +403,14 @@ static void gpio_irq_handler(unsigned irq, struct irq_desc *desc)
+ +  		 */
+ +  		isr = __raw_readl(pio + PIO_ISR) & __raw_readl(pio + PIO_IMR);
+ +  		if (!isr) {
+ + -			if (!bank->next)
+ + +			if (!at91_gpio->next)
+ +  				break;
+ + -			bank = bank->next;
+ + -			pio = bank->regbase;
+ + +			at91_gpio = at91_gpio->next;
+ + +			pio = at91_gpio->regbase;
+ +  			continue;
+ +  		}
+ +  
+ + -		pin = bank->chipbase;
+ + +		pin = at91_gpio->chip.base;
+ +  		gpio = &irq_desc[pin];
+ +  
+ +  		while (isr) {
+ + @@ -430,66 +437,6 @@ static void gpio_irq_handler(unsigned irq, struct irq_desc *desc)
+ +  
+ +  /*--------------------------------------------------------------------------*/
+ +  
+ + -#ifdef CONFIG_DEBUG_FS
+ + -
+ + -static int at91_gpio_show(struct seq_file *s, void *unused)
+ + -{
+ + -	int bank, j;
+ + -
+ + -	/* print heading */
+ + -	seq_printf(s, "Pin\t");
+ + -	for (bank = 0; bank < gpio_banks; bank++) {
+ + -		seq_printf(s, "PIO%c\t", 'A' + bank);
+ + -	};
+ + -	seq_printf(s, "\n\n");
+ + -
+ + -	/* print pin status */
+ + -	for (j = 0; j < 32; j++) {
+ + -		seq_printf(s, "%i:\t", j);
+ + -
+ + -		for (bank = 0; bank < gpio_banks; bank++) {
+ + -			unsigned	pin  = PIN_BASE + (32 * bank) + j;
+ + -			void __iomem	*pio = pin_to_controller(pin);
+ + -			unsigned	mask = pin_to_mask(pin);
+ + -
+ + -			if (__raw_readl(pio + PIO_PSR) & mask)
+ + -				seq_printf(s, "GPIO:%s", __raw_readl(pio + PIO_PDSR) & mask ? "1" : "0");
+ + -			else
+ + -				seq_printf(s, "%s", __raw_readl(pio + PIO_ABSR) & mask ? "B" : "A");
+ + -
+ + -			seq_printf(s, "\t");
+ + -		}
+ + -
+ + -		seq_printf(s, "\n");
+ + -	}
+ + -
+ + -	return 0;
+ + -}
+ + -
+ + -static int at91_gpio_open(struct inode *inode, struct file *file)
+ + -{
+ + -	return single_open(file, at91_gpio_show, NULL);
+ + -}
+ + -
+ + -static const struct file_operations at91_gpio_operations = {
+ + -	.open		= at91_gpio_open,
+ + -	.read		= seq_read,
+ + -	.llseek		= seq_lseek,
+ + -	.release	= single_release,
+ + -};
+ + -
+ + -static int __init at91_gpio_debugfs_init(void)
+ + -{
+ + -	/* /sys/kernel/debug/at91_gpio */
+ + -	(void) debugfs_create_file("at91_gpio", S_IFREG | S_IRUGO, NULL, NULL, &at91_gpio_operations);
+ + -	return 0;
+ + -}
+ + -postcore_initcall(at91_gpio_debugfs_init);
+ + -
+ + -#endif
+ + -
+ + -/*--------------------------------------------------------------------------*/
+ + -
+ +  /* This lock class tells lockdep that GPIO irqs are in a different
+ +   * category than their parents, so it won't report false recursion.
+ +   */
+ + @@ -501,20 +448,20 @@ static struct lock_class_key gpio_lock_class;
+ +  void __init at91_gpio_irq_setup(void)
+ +  {
+ +  	unsigned		pioc, pin;
+ + -	struct at91_gpio_bank	*this, *prev;
+ + +	struct at91_gpio_chip	*this, *prev;
+ +  
+ + -	for (pioc = 0, pin = PIN_BASE, this = gpio, prev = NULL;
+ + +	for (pioc = 0, pin = PIN_BASE, this = gpio_chip, prev = NULL;
+ +  			pioc++ < gpio_banks;
+ +  			prev = this, this++) {
+ + -		unsigned	id = this->id;
+ + +		unsigned	id = this->bank->id;
+ +  		unsigned	i;
+ +  
+ +  		/* enable PIO controller's clock */
+ + -		clk_enable(this->clock);
+ + +		clk_enable(this->bank->clock);
+ +  
+ +  		__raw_writel(~0, this->regbase + PIO_IDR);
+ +  
+ + -		for (i = 0, pin = this->chipbase; i < 32; i++, pin++) {
+ + +		for (i = 0, pin = this->chip.base; i < 32; i++, pin++) {
+ +  			lockdep_set_class(&irq_desc[pin].lock, &gpio_lock_class);
+ +  
+ +  			/*
+ + @@ -539,25 +486,114 @@ void __init at91_gpio_irq_setup(void)
+ +  	pr_info("AT91: %d gpio irqs in %d banks\n", pin - PIN_BASE, gpio_banks);
+ +  }
+ +  
+ + +/* gpiolib support */
+ + +static int at91_gpiolib_direction_input(struct gpio_chip *chip,
+ + +					unsigned offset)
+ + +{
+ + +	struct at91_gpio_chip *at91_gpio = to_at91_gpio_chip(chip);
+ + +	void __iomem *pio = at91_gpio->regbase;
+ + +	unsigned mask = 1 << offset;
+ + +	
+ + +	__raw_writel(mask, pio + PIO_ODR);
+ + +	return 0;
+ + +}
+ + +
+ + +static int at91_gpiolib_direction_output(struct gpio_chip *chip,
+ + +					 unsigned offset, int val)
+ + +{
+ + +	struct at91_gpio_chip *at91_gpio = to_at91_gpio_chip(chip);
+ + +	void __iomem *pio = at91_gpio->regbase;
+ + +	unsigned mask = 1 << offset;
+ + +
+ + +	__raw_writel(mask, pio + (val ? PIO_SODR : PIO_CODR));
+ + +	__raw_writel(mask, pio + PIO_OER);
+ + +	return 0;
+ + +}
+ + +
+ + +static int at91_gpiolib_get(struct gpio_chip *chip, unsigned offset)
+ + +{
+ + +	struct at91_gpio_chip *at91_gpio = to_at91_gpio_chip(chip);
+ + +	void __iomem *pio = at91_gpio->regbase;
+ + +	unsigned mask = 1 << offset;
+ + +	u32 pdsr;
+ + +
+ + +	pdsr = __raw_readl(pio + PIO_PDSR);
+ + +	return (pdsr & mask) != 0;
+ + +}
+ + +
+ + +static void at91_gpiolib_set(struct gpio_chip *chip, unsigned offset, int val)
+ + +{	
+ + +	struct at91_gpio_chip *at91_gpio = to_at91_gpio_chip(chip);
+ + +	void __iomem *pio = at91_gpio->regbase;
+ + +	unsigned mask = 1 << offset;
+ + +	
+ + +	__raw_writel(mask, pio + (val ? PIO_SODR : PIO_CODR));
+ + +}
+ + +
+ + +static int at91_gpiolib_request(struct gpio_chip *chip, unsigned offset)
+ + +{
+ + +	unsigned pin = chip->base + offset;
+ + +	void __iomem *pio = pin_to_controller(pin);
+ + +	unsigned mask = pin_to_mask(pin);
+ + +	
+ + +	/* Cannot request GPIOs that are in alternate function mode */
+ + +	if (!(__raw_readl(pio + PIO_PSR) & mask))
+ + +		return -EPERM;
+ + +	
+ + +	return 0;
+ + +}
+ + +
+ + +static void at91_gpiolib_dbg_show(struct seq_file *s, struct gpio_chip *chip)
+ + +{
+ + +	int i;
+ + +
+ + +	for (i = 0; i < chip->ngpio; i++) {
+ + +		unsigned pin = chip->base + i;
+ + +		void __iomem *pio = pin_to_controller(pin);
+ + +		unsigned mask = pin_to_mask(pin);
+ + +		const char *gpio_label;
+ + +
+ + +		gpio_label = gpiochip_is_requested(chip, i);
+ + +		if (gpio_label) {
+ + +			seq_printf(s, "[%s] GPIO%s%d: ",
+ + +				   gpio_label, chip->label, i);
+ + +			if (__raw_readl(pio + PIO_PSR) & mask)
+ + +				seq_printf(s, "[gpio] %s\n",
+ + +					   at91_get_gpio_value(pin) ?
+ + +					   "set" : "clear");
+ + +			else
+ + +				seq_printf(s, "[periph %s]\n",
+ + +					   __raw_readl(pio + PIO_ABSR) &
+ + +					   mask ? "B" : "A");
+ + +		}
+ + +	}
+ + +}
+ + +
+ +  /*
+ +   * Called from the processor-specific init to enable GPIO pin support.
+ +   */
+ +  void __init at91_gpio_init(struct at91_gpio_bank *data, int nr_banks)
+ +  {
+ +  	unsigned		i;
+ + -	struct at91_gpio_bank	*last;
+ + +	struct at91_gpio_chip *at91_gpio, *last = NULL;
+ +  
+ +  	BUG_ON(nr_banks > MAX_GPIO_BANKS);
+ +  
+ + -	gpio = data;
+ +  	gpio_banks = nr_banks;
+ +  
+ + -	for (i = 0, last = NULL; i < nr_banks; i++, last = data, data++) {
+ + -		data->chipbase = PIN_BASE + i * 32;
+ + -		data->regbase = data->offset + (void __iomem *)AT91_VA_BASE_SYS;
+ + +	for (i = 0; i < nr_banks; i++) {
+ + +		at91_gpio = &gpio_chip[i];
+ + +
+ + +		at91_gpio->bank = data;
+ + +		at91_gpio->chip.base = PIN_BASE + i * 32;
+ + +		at91_gpio->regbase = at91_gpio->bank->offset + 
+ + +			(void __iomem *)AT91_VA_BASE_SYS;
+ +  
+ +  		/* AT91SAM9263_ID_PIOCDE groups PIOC, PIOD, PIOE */
+ + -		if (last && last->id == data->id)
+ + -			last->next = data;
+ + +		if (last && last->bank->id == at91_gpio->bank->id)
+ + +			last->next = at91_gpio;
+ + +		last = at91_gpio;
+ + +
+ + +		gpiochip_add(&at91_gpio->chip);
+ +  	}
+ +  }
+ + diff --git a/arch/arm/mach-at91/include/mach/gpio.h b/arch/arm/mach-at91/include/mach/gpio.h
+ + index bffa674..04c91e3 100644
+ + --- a/arch/arm/mach-at91/include/mach/gpio.h
+ + +++ b/arch/arm/mach-at91/include/mach/gpio.h
+ + @@ -213,32 +213,12 @@ extern void at91_gpio_resume(void);
+ +   */
+ +  
+ +  #include <asm/errno.h>
+ + -
+ + -static inline int gpio_request(unsigned gpio, const char *label)
+ + -{
+ + -	return 0;
+ + -}
+ + -
+ + -static inline void gpio_free(unsigned gpio)
+ + -{
+ + -	might_sleep();
+ + -}
+ + -
+ + -extern int gpio_direction_input(unsigned gpio);
+ + -extern int gpio_direction_output(unsigned gpio, int value);
+ + -
+ + -static inline int gpio_get_value(unsigned gpio)
+ + -{
+ + -	return at91_get_gpio_value(gpio);
+ + -}
+ + -
+ + -static inline void gpio_set_value(unsigned gpio, int value)
+ + -{
+ + -	at91_set_gpio_value(gpio, value);
+ + -}
+ + -
+ +  #include <asm-generic/gpio.h>		/* cansleep wrappers */
+ +  
+ + +#define gpio_get_value	__gpio_get_value
+ + +#define gpio_set_value	__gpio_set_value
+ + +#define gpio_cansleep	__gpio_cansleep
+ + +
+ +  static inline int gpio_to_irq(unsigned gpio)
+ +  {
+ +  	return gpio;
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/include/linux/at91_pwm.h liab-linux-2.6.29.4/include/linux/at91_pwm.h
+ *** linux-2.6.29.4/include/linux/at91_pwm.h	1970-01-01 01:00:00.000000000 +0100
+ --- liab-linux-2.6.29.4/include/linux/at91_pwm.h	2009-09-14 11:44:51.000000000 +0200
+ ***************
+ *** 0 ****
+ --- 1,74 ----
+ + #ifndef __LINUX_ATMEL_PWM_H
+ + #define __LINUX_ATMEL_PWM_H
+ + 
+ + /**
+ +  * struct pwm_channel - driver handle to a PWM channel
+ +  * @regs: base of this channel's registers
+ +  * @index: number of this channel (0..31)
+ +  * @mck: base clock rate, which can be prescaled and maybe subdivided
+ +  *
+ +  * Drivers initialize a pwm_channel structure using pwm_channel_alloc().
+ +  * Then they configure its clock rate (derived from MCK), alignment,
+ +  * polarity, and duty cycle by writing directly to the channel registers,
+ +  * before enabling the channel by calling pwm_channel_enable().
+ +  *
+ +  * After emitting a PWM signal for the desired length of time, drivers
+ +  * may then pwm_channel_disable() or pwm_channel_free().  Both of these
+ +  * disable the channel, but when it's freed the IRQ is deconfigured and
+ +  * the channel must later be re-allocated and reconfigured.
+ +  *
+ +  * Note that if the period or duty cycle need to be changed while the
+ +  * PWM channel is operating, drivers must use the PWM_CUPD double buffer
+ +  * mechanism, either polling until they change or getting implicitly
+ +  * notified through a once-per-period interrupt handler.
+ +  */
+ + struct pwm_channel {
+ + 	void __iomem	*regs;
+ + 	unsigned	index;
+ + 	unsigned long	mck;
+ + };
+ + 
+ + extern int pwm_channel_alloc(int index, struct pwm_channel *ch);
+ + extern int pwm_channel_free(struct pwm_channel *ch);
+ + 
+ + extern int pwm_clk_alloc(unsigned prescale, unsigned div);
+ + extern void pwm_clk_free(unsigned clk);
+ + 
+ + extern int __pwm_channel_onoff(struct pwm_channel *ch, int enabled);
+ + 
+ + #define pwm_channel_enable(ch)	__pwm_channel_onoff((ch), 1)
+ + #define pwm_channel_disable(ch)	__pwm_channel_onoff((ch), 0)
+ + 
+ + /* periodic interrupts, mostly for CUPD changes to period or cycle */
+ + extern int pwm_channel_handler(struct pwm_channel *ch,
+ + 		void (*handler)(struct pwm_channel *ch));
+ + 
+ + /* per-channel registers (banked at pwm_channel->regs) */
+ + #define PWM_CMR		0x00		/* mode register */
+ + #define		PWM_CPR_CPD	(1 << 10)	/* set: CUPD modifies period */
+ + #define		PWM_CPR_CPOL	(1 << 9)	/* set: idle high */
+ + #define		PWM_CPR_CALG	(1 << 8)	/* set: center align */
+ + #define		PWM_CPR_CPRE	(0xf << 0)	/* mask: rate is mck/(2^pre) */
+ + #define		PWM_CPR_CLKA	(0xb << 0)	/* rate CLKA */
+ + #define		PWM_CPR_CLKB	(0xc << 0)	/* rate CLKB */
+ + #define PWM_CDTY	0x04		/* duty cycle (max of CPRD) */
+ + #define PWM_CPRD	0x08		/* period (count up from zero) */
+ + #define PWM_CCNT	0x0c		/* counter (20 bits?) */
+ + #define PWM_CUPD	0x10		/* update CPRD (or CDTY) next period */
+ + 
+ + extern void
+ + pwm_channel_writel(struct pwm_channel *pwmc, unsigned offset, u32 val);
+ + extern u32 pwm_channel_readl(struct pwm_channel *pwmc, unsigned offset);
+ + 
+ + /* static inline void */
+ + /* pwm_channel_writel(struct pwm_channel *pwmc, unsigned offset, u32 val) */
+ + /* { */
+ + /*   __raw_writel(val, pwmc->regs + offset); */
+ + /* } */
+ + 
+ + /* static inline u32 pwm_channel_readl(struct pwm_channel *pwmc, unsigned offset) */
+ + /* { */
+ + /* 	return __raw_readl(pwmc->regs + offset); */
+ + /* } */
+ + 
+ + #endif /* __LINUX_ATMEL_PWM_H */
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/include/linux/tty.h liab-linux-2.6.29.4/include/linux/tty.h
+ *** linux-2.6.29.4/include/linux/tty.h	2009-05-19 01:52:34.000000000 +0200
+ --- liab-linux-2.6.29.4/include/linux/tty.h	2009-11-13 10:37:17.000000000 +0100
+ ***************
+ *** 23,29 ****
+    */
+   #define NR_UNIX98_PTY_DEFAULT	4096      /* Default maximum for Unix98 ptys */
+   #define NR_UNIX98_PTY_MAX	(1 << MINORBITS) /* Absolute limit */
+ ! #define NR_LDISCS		19
+   
+   /* line disciplines */
+   #define N_TTY		0
+ --- 23,29 ----
+    */
+   #define NR_UNIX98_PTY_DEFAULT	4096      /* Default maximum for Unix98 ptys */
+   #define NR_UNIX98_PTY_MAX	(1 << MINORBITS) /* Absolute limit */
+ ! #define NR_LDISCS		20
+   
+   /* line disciplines */
+   #define N_TTY		0
+ ***************
+ *** 46,51 ****
+ --- 46,52 ----
+   #define N_GIGASET_M101	16	/* Siemens Gigaset M101 serial DECT adapter */
+   #define N_SLCAN		17	/* Serial / USB serial CAN Adaptors */
+   #define N_PPS		18	/* Pulse per Second */
+ + #define N_LIAB		19	/* LIAB line discipline hook */
+   
+   /*
+    * This character is the same as _POSIX_VDISABLE: it cannot be used as
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/init/do_mounts_rd.c liab-linux-2.6.29.4/init/do_mounts_rd.c
+ *** linux-2.6.29.4/init/do_mounts_rd.c	2009-05-19 01:52:34.000000000 +0200
+ --- liab-linux-2.6.29.4/init/do_mounts_rd.c	2009-07-31 11:36:16.000000000 +0200
+ ***************
+ *** 323,328 ****
+ --- 323,337 ----
+   
+   #include "../lib/inflate.c"
+   
+ + #ifdef    CONFIG_MACH_LIABARM
+ +  static int fill_inbuf_counter = 0;
+ +  #define KILOBYTESPERDOT      64
+ +  #define DOTDIVISOR         ((KILOBYTESPERDOT*1024)/INBUFSIZ)
+ +  #define DOTDIVISOR2         (KILOBYTESPERDOT*1024)
+ +  #define MEGABYTEDIVISOR    ((1024*1024)/INBUFSIZ)
+ +  #define MEGABYTEDIVISOR2    (1024*1024)
+ + #endif /* CONFIG_MACH_LIABARM */
+ + 
+   /* ===========================================================================
+    * Fill the input buffer. This is called only when the buffer is empty
+    * and at least one byte is really needed.
+ ***************
+ *** 340,345 ****
+ --- 349,365 ----
+   
+   	inptr = 1;
+   
+ + #ifdef    CONFIG_MACH_LIABARM
+ +   fill_inbuf_counter++;
+ +   if (fill_inbuf_counter % DOTDIVISOR == 0)
+ +     {
+ +       if (fill_inbuf_counter % MEGABYTEDIVISOR == 0)
+ +         printk("M");
+ +       else
+ +         printk(".");
+ +     }
+ + #endif /* CONFIG_MACH_LIABARM */
+ + 
+   	return inbuf[0];
+   }
+   
+ ***************
+ *** 402,407 ****
+ --- 422,430 ----
+   	}
+   	makecrc();
+   	result = gunzip();
+ + #ifdef    CONFIG_MACH_LIABARM
+ +   printk("\n");
+ + #endif /* CONFIG_MACH_LIABARM */
+   	if (unzip_error)
+   		result = 1;
+   	kfree(inbuf);
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/init/initramfs.c liab-linux-2.6.29.4/init/initramfs.c
+ *** linux-2.6.29.4/init/initramfs.c	2009-05-19 01:52:34.000000000 +0200
+ --- liab-linux-2.6.29.4/init/initramfs.c	2009-07-31 11:36:16.000000000 +0200
+ ***************
+ *** 583,588 ****
+ --- 583,589 ----
+   	if (initrd_start) {
+   #ifdef CONFIG_BLK_DEV_RAM
+   		int fd;
+ + #ifndef   CONFIG_MACH_LIABARM
+   		printk(KERN_INFO "checking if image is initramfs...");
+   		err = unpack_to_rootfs((char *)initrd_start,
+   			initrd_end - initrd_start, 1);
+ ***************
+ *** 594,599 ****
+ --- 595,604 ----
+   			return 0;
+   		}
+   		printk("it isn't (%s); looks like an initrd\n", err);
+ + #else /* CONFIG_MACH_LIABARM */
+ +     printk("Using initrd at 0x%lx length 0x%lx\n",
+ + 					 initrd_start, initrd_end-initrd_start);
+ + #endif /* CONFIG_MACH_LIABARM */
+   		fd = sys_open("/initrd.image", O_WRONLY|O_CREAT, 0700);
+   		if (fd >= 0) {
+   			sys_write(fd, (char *)initrd_start,
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/liabdin-2.6.29.4.config liab-linux-2.6.29.4/liabdin-2.6.29.4.config
+ *** linux-2.6.29.4/liabdin-2.6.29.4.config	1970-01-01 01:00:00.000000000 +0100
+ --- liab-linux-2.6.29.4/liabdin-2.6.29.4.config	2010-01-22 15:29:08.000000000 +0100
+ ***************
+ *** 0 ****
+ --- 1,1462 ----
+ + #
+ + # Automatically generated make config: don't edit
+ + # Linux kernel version: 2.6.29.4
+ + # Fri Jan 22 15:28:53 2010
+ + #
+ + CONFIG_ARM=y
+ + CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+ + CONFIG_GENERIC_GPIO=y
+ + CONFIG_GENERIC_TIME=y
+ + CONFIG_GENERIC_CLOCKEVENTS=y
+ + CONFIG_MMU=y
+ + # CONFIG_NO_IOPORT is not set
+ + CONFIG_GENERIC_HARDIRQS=y
+ + CONFIG_STACKTRACE_SUPPORT=y
+ + CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+ + CONFIG_LOCKDEP_SUPPORT=y
+ + CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+ + CONFIG_HARDIRQS_SW_RESEND=y
+ + CONFIG_GENERIC_IRQ_PROBE=y
+ + CONFIG_RWSEM_GENERIC_SPINLOCK=y
+ + # CONFIG_ARCH_HAS_ILOG2_U32 is not set
+ + # CONFIG_ARCH_HAS_ILOG2_U64 is not set
+ + CONFIG_GENERIC_HWEIGHT=y
+ + CONFIG_GENERIC_CALIBRATE_DELAY=y
+ + CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+ + CONFIG_VECTORS_BASE=0xffff0000
+ + CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+ + 
+ + #
+ + # General setup
+ + #
+ + CONFIG_EXPERIMENTAL=y
+ + CONFIG_BROKEN_ON_SMP=y
+ + CONFIG_LOCK_KERNEL=y
+ + CONFIG_INIT_ENV_ARG_LIMIT=32
+ + CONFIG_LOCALVERSION=""
+ + # CONFIG_LOCALVERSION_AUTO is not set
+ + CONFIG_SWAP=y
+ + CONFIG_SYSVIPC=y
+ + CONFIG_SYSVIPC_SYSCTL=y
+ + CONFIG_POSIX_MQUEUE=y
+ + # CONFIG_BSD_PROCESS_ACCT is not set
+ + # CONFIG_TASKSTATS is not set
+ + # CONFIG_AUDIT is not set
+ + 
+ + #
+ + # RCU Subsystem
+ + #
+ + # CONFIG_CLASSIC_RCU is not set
+ + # CONFIG_TREE_RCU is not set
+ + CONFIG_PREEMPT_RCU=y
+ + # CONFIG_RCU_TRACE is not set
+ + # CONFIG_TREE_RCU_TRACE is not set
+ + # CONFIG_PREEMPT_RCU_TRACE is not set
+ + CONFIG_IKCONFIG=y
+ + CONFIG_IKCONFIG_PROC=y
+ + CONFIG_LOG_BUF_SHIFT=14
+ + CONFIG_GROUP_SCHED=y
+ + CONFIG_FAIR_GROUP_SCHED=y
+ + # CONFIG_RT_GROUP_SCHED is not set
+ + CONFIG_USER_SCHED=y
+ + # CONFIG_CGROUP_SCHED is not set
+ + # CONFIG_CGROUPS is not set
+ + CONFIG_SYSFS_DEPRECATED=y
+ + CONFIG_SYSFS_DEPRECATED_V2=y
+ + # CONFIG_RELAY is not set
+ + # CONFIG_NAMESPACES is not set
+ + CONFIG_BLK_DEV_INITRD=y
+ + CONFIG_INITRAMFS_SOURCE=""
+ + CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+ + CONFIG_SYSCTL=y
+ + CONFIG_ANON_INODES=y
+ + CONFIG_EMBEDDED=y
+ + CONFIG_UID16=y
+ + CONFIG_SYSCTL_SYSCALL=y
+ + # CONFIG_KALLSYMS is not set
+ + CONFIG_HOTPLUG=y
+ + CONFIG_PRINTK=y
+ + CONFIG_BUG=y
+ + # CONFIG_ELF_CORE is not set
+ + CONFIG_BASE_FULL=y
+ + CONFIG_FUTEX=y
+ + CONFIG_EPOLL=y
+ + CONFIG_SIGNALFD=y
+ + CONFIG_TIMERFD=y
+ + CONFIG_EVENTFD=y
+ + CONFIG_SHMEM=y
+ + CONFIG_AIO=y
+ + CONFIG_VM_EVENT_COUNTERS=y
+ + CONFIG_COMPAT_BRK=y
+ + CONFIG_SLAB=y
+ + # CONFIG_SLUB is not set
+ + # CONFIG_SLOB is not set
+ + # CONFIG_PROFILING is not set
+ + CONFIG_HAVE_OPROFILE=y
+ + CONFIG_HAVE_KPROBES=y
+ + CONFIG_HAVE_KRETPROBES=y
+ + CONFIG_HAVE_CLK=y
+ + CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+ + CONFIG_SLABINFO=y
+ + CONFIG_RT_MUTEXES=y
+ + CONFIG_BASE_SMALL=0
+ + CONFIG_MODULES=y
+ + # CONFIG_MODULE_FORCE_LOAD is not set
+ + CONFIG_MODULE_UNLOAD=y
+ + CONFIG_MODULE_FORCE_UNLOAD=y
+ + # CONFIG_MODVERSIONS is not set
+ + # CONFIG_MODULE_SRCVERSION_ALL is not set
+ + CONFIG_BLOCK=y
+ + # CONFIG_LBD is not set
+ + # CONFIG_BLK_DEV_IO_TRACE is not set
+ + # CONFIG_BLK_DEV_BSG is not set
+ + # CONFIG_BLK_DEV_INTEGRITY is not set
+ + 
+ + #
+ + # IO Schedulers
+ + #
+ + CONFIG_IOSCHED_NOOP=y
+ + # CONFIG_IOSCHED_AS is not set
+ + # CONFIG_IOSCHED_DEADLINE is not set
+ + CONFIG_IOSCHED_CFQ=y
+ + # CONFIG_DEFAULT_AS is not set
+ + # CONFIG_DEFAULT_DEADLINE is not set
+ + CONFIG_DEFAULT_CFQ=y
+ + # CONFIG_DEFAULT_NOOP is not set
+ + CONFIG_DEFAULT_IOSCHED="cfq"
+ + # CONFIG_FREEZER is not set
+ + 
+ + #
+ + # System Type
+ + #
+ + # CONFIG_ARCH_AAEC2000 is not set
+ + # CONFIG_ARCH_INTEGRATOR is not set
+ + # CONFIG_ARCH_REALVIEW is not set
+ + # CONFIG_ARCH_VERSATILE is not set
+ + CONFIG_ARCH_AT91=y
+ + # CONFIG_ARCH_CLPS711X is not set
+ + # CONFIG_ARCH_EBSA110 is not set
+ + # CONFIG_ARCH_EP93XX is not set
+ + # CONFIG_ARCH_FOOTBRIDGE is not set
+ + # CONFIG_ARCH_NETX is not set
+ + # CONFIG_ARCH_H720X is not set
+ + # CONFIG_ARCH_IMX is not set
+ + # CONFIG_ARCH_IOP13XX is not set
+ + # CONFIG_ARCH_IOP32X is not set
+ + # CONFIG_ARCH_IOP33X is not set
+ + # CONFIG_ARCH_IXP23XX is not set
+ + # CONFIG_ARCH_IXP2000 is not set
+ + # CONFIG_ARCH_IXP4XX is not set
+ + # CONFIG_ARCH_L7200 is not set
+ + # CONFIG_ARCH_KIRKWOOD is not set
+ + # CONFIG_ARCH_KS8695 is not set
+ + # CONFIG_ARCH_NS9XXX is not set
+ + # CONFIG_ARCH_LOKI is not set
+ + # CONFIG_ARCH_MV78XX0 is not set
+ + # CONFIG_ARCH_MXC is not set
+ + # CONFIG_ARCH_ORION5X is not set
+ + # CONFIG_ARCH_PNX4008 is not set
+ + # CONFIG_ARCH_PXA is not set
+ + # CONFIG_ARCH_RPC is not set
+ + # CONFIG_ARCH_SA1100 is not set
+ + # CONFIG_ARCH_S3C2410 is not set
+ + # CONFIG_ARCH_S3C64XX is not set
+ + # CONFIG_ARCH_SHARK is not set
+ + # CONFIG_ARCH_LH7A40X is not set
+ + # CONFIG_ARCH_DAVINCI is not set
+ + # CONFIG_ARCH_OMAP is not set
+ + # CONFIG_ARCH_MSM is not set
+ + # CONFIG_ARCH_W90X900 is not set
+ + 
+ + #
+ + # Atmel AT91 System-on-Chip
+ + #
+ + CONFIG_ARCH_AT91RM9200=y
+ + # CONFIG_ARCH_AT91SAM9260 is not set
+ + # CONFIG_ARCH_AT91SAM9261 is not set
+ + # CONFIG_ARCH_AT91SAM9263 is not set
+ + # CONFIG_ARCH_AT91SAM9RL is not set
+ + # CONFIG_ARCH_AT91SAM9G20 is not set
+ + # CONFIG_ARCH_AT91CAP9 is not set
+ + # CONFIG_ARCH_AT91X40 is not set
+ + CONFIG_AT91_PMC_UNIT=y
+ + 
+ + #
+ + # AT91RM9200 Board Type
+ + #
+ + # CONFIG_MACH_ONEARM is not set
+ + # CONFIG_ARCH_AT91RM9200DK is not set
+ + CONFIG_MACH_LIABARM=y
+ + # CONFIG_MACH_LIABARM9200 is not set
+ + # CONFIG_MACH_NANOLIAB is not set
+ + CONFIG_MACH_LIABDIN=y
+ + # CONFIG_LIAB_TDC_LIABDIN_ADDON is not set
+ + CONFIG_LIAB_LIABDIN_ADDON=y
+ + CONFIG_LIAB_ENABLE_UART0=y
+ + CONFIG_LIAB_ENABLE_UART1=y
+ + CONFIG_LIAB_ENABLE_UART2=y
+ + CONFIG_LIAB_ENABLE_UART3=y
+ + # CONFIG_MACH_AT91RM9200EK is not set
+ + # CONFIG_MACH_CSB337 is not set
+ + # CONFIG_MACH_CSB637 is not set
+ + # CONFIG_MACH_CARMEVA is not set
+ + # CONFIG_MACH_ATEB9200 is not set
+ + # CONFIG_MACH_KB9200 is not set
+ + # CONFIG_MACH_PICOTUX2XX is not set
+ + # CONFIG_MACH_KAFA is not set
+ + # CONFIG_MACH_ECBAT91 is not set
+ + # CONFIG_MACH_YL9200 is not set
+ + 
+ + #
+ + # AT91 Board Options
+ + #
+ + CONFIG_ARCH_LIABAT91RM9200_HASMII=y
+ + CONFIG_ARCH_LIABAT91RM9200_SELECTDBGUANDUART0=y
+ + CONFIG_I2C_AT91_GPIO=y
+ + 
+ + #
+ + # AT91 Feature Selections
+ + #
+ + # CONFIG_AT91_PROGRAMMABLE_CLOCKS is not set
+ + CONFIG_AT91_TIMER_HZ=128
+ + CONFIG_AT91_EARLY_DBGU=y
+ + # CONFIG_AT91_EARLY_USART0 is not set
+ + # CONFIG_AT91_EARLY_USART1 is not set
+ + # CONFIG_AT91_EARLY_USART2 is not set
+ + # CONFIG_AT91_EARLY_USART3 is not set
+ + # CONFIG_AT91_EARLY_USART4 is not set
+ + # CONFIG_AT91_EARLY_USART5 is not set
+ + 
+ + #
+ + # Processor Type
+ + #
+ + CONFIG_CPU_32=y
+ + CONFIG_CPU_ARM920T=y
+ + CONFIG_CPU_32v4T=y
+ + CONFIG_CPU_ABRT_EV4T=y
+ + CONFIG_CPU_PABRT_NOIFAR=y
+ + CONFIG_CPU_CACHE_V4WT=y
+ + CONFIG_CPU_CACHE_VIVT=y
+ + CONFIG_CPU_COPY_V4WB=y
+ + CONFIG_CPU_TLB_V4WBI=y
+ + CONFIG_CPU_CP15=y
+ + CONFIG_CPU_CP15_MMU=y
+ + 
+ + #
+ + # Processor Features
+ + #
+ + CONFIG_ARM_THUMB=y
+ + # CONFIG_CPU_ICACHE_DISABLE is not set
+ + # CONFIG_CPU_DCACHE_DISABLE is not set
+ + # CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+ + # CONFIG_OUTER_CACHE is not set
+ + 
+ + #
+ + # Bus support
+ + #
+ + # CONFIG_PCI_SYSCALL is not set
+ + # CONFIG_ARCH_SUPPORTS_MSI is not set
+ + # CONFIG_PCCARD is not set
+ + 
+ + #
+ + # Kernel Features
+ + #
+ + # CONFIG_NO_HZ is not set
+ + # CONFIG_HIGH_RES_TIMERS is not set
+ + CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+ + CONFIG_VMSPLIT_3G=y
+ + # CONFIG_VMSPLIT_2G is not set
+ + # CONFIG_VMSPLIT_1G is not set
+ + CONFIG_PAGE_OFFSET=0xC0000000
+ + CONFIG_PREEMPT=y
+ + CONFIG_HZ=128
+ + # CONFIG_AEABI is not set
+ + CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+ + # CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+ + # CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+ + CONFIG_SELECT_MEMORY_MODEL=y
+ + CONFIG_FLATMEM_MANUAL=y
+ + # CONFIG_DISCONTIGMEM_MANUAL is not set
+ + # CONFIG_SPARSEMEM_MANUAL is not set
+ + CONFIG_FLATMEM=y
+ + CONFIG_FLAT_NODE_MEM_MAP=y
+ + CONFIG_PAGEFLAGS_EXTENDED=y
+ + CONFIG_SPLIT_PTLOCK_CPUS=4096
+ + # CONFIG_PHYS_ADDR_T_64BIT is not set
+ + CONFIG_ZONE_DMA_FLAG=0
+ + CONFIG_VIRT_TO_BUS=y
+ + CONFIG_UNEVICTABLE_LRU=y
+ + CONFIG_LEDS=y
+ + CONFIG_LEDS_CPU=y
+ + CONFIG_ALIGNMENT_TRAP=y
+ + 
+ + #
+ + # Boot options
+ + #
+ + CONFIG_ZBOOT_ROM_TEXT=0x0
+ + CONFIG_ZBOOT_ROM_BSS=0x0
+ + CONFIG_CMDLINE=""
+ + # CONFIG_XIP_KERNEL is not set
+ + # CONFIG_KEXEC is not set
+ + 
+ + #
+ + # CPU Power Management
+ + #
+ + # CONFIG_CPU_IDLE is not set
+ + 
+ + #
+ + # Floating point emulation
+ + #
+ + 
+ + #
+ + # At least one emulation must be selected
+ + #
+ + CONFIG_FPE_NWFPE=y
+ + # CONFIG_FPE_NWFPE_XP is not set
+ + # CONFIG_FPE_FASTFPE is not set
+ + 
+ + #
+ + # Userspace binary formats
+ + #
+ + CONFIG_BINFMT_ELF=y
+ + CONFIG_HAVE_AOUT=y
+ + # CONFIG_BINFMT_AOUT is not set
+ + # CONFIG_BINFMT_MISC is not set
+ + # CONFIG_ARTHUR is not set
+ + 
+ + #
+ + # Power management options
+ + #
+ + # CONFIG_PM is not set
+ + CONFIG_ARCH_SUSPEND_POSSIBLE=y
+ + CONFIG_NET=y
+ + 
+ + #
+ + # Networking options
+ + #
+ + CONFIG_COMPAT_NET_DEV_OPS=y
+ + CONFIG_PACKET=y
+ + CONFIG_PACKET_MMAP=y
+ + CONFIG_UNIX=y
+ + # CONFIG_NET_KEY is not set
+ + CONFIG_INET=y
+ + CONFIG_IP_MULTICAST=y
+ + CONFIG_IP_ADVANCED_ROUTER=y
+ + CONFIG_ASK_IP_FIB_HASH=y
+ + # CONFIG_IP_FIB_TRIE is not set
+ + CONFIG_IP_FIB_HASH=y
+ + CONFIG_IP_MULTIPLE_TABLES=y
+ + CONFIG_IP_ROUTE_MULTIPATH=y
+ + CONFIG_IP_ROUTE_VERBOSE=y
+ + CONFIG_IP_PNP=y
+ + CONFIG_IP_PNP_DHCP=y
+ + CONFIG_IP_PNP_BOOTP=y
+ + CONFIG_IP_PNP_RARP=y
+ + # CONFIG_NET_IPIP is not set
+ + # CONFIG_NET_IPGRE is not set
+ + CONFIG_IP_MROUTE=y
+ + CONFIG_IP_PIMSM_V1=y
+ + # CONFIG_IP_PIMSM_V2 is not set
+ + # CONFIG_ARPD is not set
+ + CONFIG_SYN_COOKIES=y
+ + # CONFIG_INET_AH is not set
+ + # CONFIG_INET_ESP is not set
+ + # CONFIG_INET_IPCOMP is not set
+ + # CONFIG_INET_XFRM_TUNNEL is not set
+ + # CONFIG_INET_TUNNEL is not set
+ + # CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+ + # CONFIG_INET_XFRM_MODE_TUNNEL is not set
+ + # CONFIG_INET_XFRM_MODE_BEET is not set
+ + # CONFIG_INET_LRO is not set
+ + # CONFIG_INET_DIAG is not set
+ + # CONFIG_TCP_CONG_ADVANCED is not set
+ + CONFIG_TCP_CONG_CUBIC=y
+ + CONFIG_DEFAULT_TCP_CONG="cubic"
+ + # CONFIG_TCP_MD5SIG is not set
+ + # CONFIG_IPV6 is not set
+ + # CONFIG_NETWORK_SECMARK is not set
+ + # CONFIG_NETFILTER is not set
+ + # CONFIG_IP_DCCP is not set
+ + # CONFIG_IP_SCTP is not set
+ + # CONFIG_TIPC is not set
+ + # CONFIG_ATM is not set
+ + # CONFIG_BRIDGE is not set
+ + # CONFIG_NET_DSA is not set
+ + # CONFIG_VLAN_8021Q is not set
+ + # CONFIG_DECNET is not set
+ + # CONFIG_LLC2 is not set
+ + # CONFIG_IPX is not set
+ + # CONFIG_ATALK is not set
+ + # CONFIG_X25 is not set
+ + # CONFIG_LAPB is not set
+ + # CONFIG_ECONET is not set
+ + # CONFIG_WAN_ROUTER is not set
+ + # CONFIG_NET_SCHED is not set
+ + # CONFIG_DCB is not set
+ + 
+ + #
+ + # Network testing
+ + #
+ + # CONFIG_NET_PKTGEN is not set
+ + # CONFIG_HAMRADIO is not set
+ + # CONFIG_CAN is not set
+ + # CONFIG_IRDA is not set
+ + # CONFIG_BT is not set
+ + # CONFIG_AF_RXRPC is not set
+ + # CONFIG_PHONET is not set
+ + CONFIG_FIB_RULES=y
+ + # CONFIG_WIRELESS is not set
+ + # CONFIG_WIMAX is not set
+ + # CONFIG_RFKILL is not set
+ + # CONFIG_NET_9P is not set
+ + 
+ + #
+ + # Device Drivers
+ + #
+ + 
+ + #
+ + # Generic Driver Options
+ + #
+ + CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+ + CONFIG_STANDALONE=y
+ + CONFIG_PREVENT_FIRMWARE_BUILD=y
+ + CONFIG_FW_LOADER=y
+ + # CONFIG_FIRMWARE_IN_KERNEL is not set
+ + CONFIG_EXTRA_FIRMWARE=""
+ + # CONFIG_DEBUG_DRIVER is not set
+ + # CONFIG_DEBUG_DEVRES is not set
+ + # CONFIG_SYS_HYPERVISOR is not set
+ + # CONFIG_CONNECTOR is not set
+ + CONFIG_MTD=y
+ + # CONFIG_MTD_DEBUG is not set
+ + # CONFIG_MTD_CONCAT is not set
+ + CONFIG_MTD_PARTITIONS=y
+ + # CONFIG_MTD_TESTS is not set
+ + # CONFIG_MTD_REDBOOT_PARTS is not set
+ + # CONFIG_MTD_CMDLINE_PARTS is not set
+ + # CONFIG_MTD_AFS_PARTS is not set
+ + # CONFIG_MTD_AR7_PARTS is not set
+ + 
+ + #
+ + # User Modules And Translation Layers
+ + #
+ + CONFIG_MTD_CHAR=y
+ + CONFIG_MTD_BLKDEVS=y
+ + CONFIG_MTD_BLOCK=y
+ + # CONFIG_FTL is not set
+ + # CONFIG_NFTL is not set
+ + # CONFIG_INFTL is not set
+ + # CONFIG_RFD_FTL is not set
+ + # CONFIG_SSFDC is not set
+ + # CONFIG_MTD_OOPS is not set
+ + 
+ + #
+ + # RAM/ROM/Flash chip drivers
+ + #
+ + CONFIG_MTD_CFI=y
+ + # CONFIG_MTD_JEDECPROBE is not set
+ + CONFIG_MTD_GEN_PROBE=y
+ + # CONFIG_MTD_CFI_ADV_OPTIONS is not set
+ + CONFIG_MTD_MAP_BANK_WIDTH_1=y
+ + CONFIG_MTD_MAP_BANK_WIDTH_2=y
+ + CONFIG_MTD_MAP_BANK_WIDTH_4=y
+ + # CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+ + # CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+ + # CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+ + CONFIG_MTD_CFI_I1=y
+ + CONFIG_MTD_CFI_I2=y
+ + # CONFIG_MTD_CFI_I4 is not set
+ + # CONFIG_MTD_CFI_I8 is not set
+ + CONFIG_MTD_CFI_INTELEXT=y
+ + CONFIG_MTD_CFI_AMDSTD=y
+ + # CONFIG_MTD_CFI_STAA is not set
+ + CONFIG_MTD_CFI_UTIL=y
+ + # CONFIG_MTD_RAM is not set
+ + # CONFIG_MTD_ROM is not set
+ + # CONFIG_MTD_ABSENT is not set
+ + 
+ + #
+ + # Mapping drivers for chip access
+ + #
+ + # CONFIG_MTD_COMPLEX_MAPPINGS is not set
+ + # CONFIG_MTD_PHYSMAP is not set
+ + # CONFIG_MTD_ARM_INTEGRATOR is not set
+ + CONFIG_MTD_LIABARM=y
+ + CONFIG_MTD_LIAB_FLASH_SIZE=16384
+ + CONFIG_MTD_LIAB_NOFLASH=1
+ + CONFIG_MTD_LIABARM_BOOTSIZE=128
+ + CONFIG_MTD_LIABARM_KERNELSIZE=1536
+ + CONFIG_MTD_LIABARM_ROOTSIZE=6144
+ + CONFIG_MTD_LIABARM_PARAMSIZE=128
+ + CONFIG_MTD_LIABARM_JFFS2SIZE=8448
+ + # CONFIG_MTD_PLATRAM is not set
+ + 
+ + #
+ + # Self-contained MTD device drivers
+ + #
+ + # CONFIG_MTD_DATAFLASH is not set
+ + # CONFIG_MTD_M25P80 is not set
+ + # CONFIG_MTD_SLRAM is not set
+ + # CONFIG_MTD_PHRAM is not set
+ + # CONFIG_MTD_MTDRAM is not set
+ + # CONFIG_MTD_BLOCK2MTD is not set
+ + 
+ + #
+ + # Disk-On-Chip Device Drivers
+ + #
+ + # CONFIG_MTD_DOC2000 is not set
+ + # CONFIG_MTD_DOC2001 is not set
+ + # CONFIG_MTD_DOC2001PLUS is not set
+ + # CONFIG_MTD_NAND is not set
+ + # CONFIG_MTD_ONENAND is not set
+ + 
+ + #
+ + # LPDDR flash memory drivers
+ + #
+ + # CONFIG_MTD_LPDDR is not set
+ + 
+ + #
+ + # UBI - Unsorted block images
+ + #
+ + # CONFIG_MTD_UBI is not set
+ + # CONFIG_PARPORT is not set
+ + CONFIG_BLK_DEV=y
+ + # CONFIG_BLK_DEV_COW_COMMON is not set
+ + # CONFIG_BLK_DEV_LOOP is not set
+ + # CONFIG_BLK_DEV_NBD is not set
+ + # CONFIG_BLK_DEV_UB is not set
+ + CONFIG_BLK_DEV_RAM=y
+ + CONFIG_BLK_DEV_RAM_COUNT=16
+ + CONFIG_BLK_DEV_RAM_SIZE=32768
+ + # CONFIG_BLK_DEV_XIP is not set
+ + # CONFIG_CDROM_PKTCDVD is not set
+ + # CONFIG_ATA_OVER_ETH is not set
+ + CONFIG_MISC_DEVICES=y
+ + # CONFIG_ATMEL_TCLIB is not set
+ + CONFIG_AT91_PWM=y
+ + # CONFIG_ICS932S401 is not set
+ + # CONFIG_ATMEL_SSC is not set
+ + # CONFIG_ENCLOSURE_SERVICES is not set
+ + # CONFIG_C2PORT is not set
+ + 
+ + #
+ + # EEPROM support
+ + #
+ + # CONFIG_EEPROM_AT24 is not set
+ + # CONFIG_EEPROM_AT25 is not set
+ + # CONFIG_EEPROM_LEGACY is not set
+ + # CONFIG_EEPROM_93CX6 is not set
+ + CONFIG_HAVE_IDE=y
+ + # CONFIG_IDE is not set
+ + 
+ + #
+ + # SCSI device support
+ + #
+ + # CONFIG_RAID_ATTRS is not set
+ + CONFIG_SCSI=m
+ + CONFIG_SCSI_DMA=y
+ + # CONFIG_SCSI_TGT is not set
+ + # CONFIG_SCSI_NETLINK is not set
+ + CONFIG_SCSI_PROC_FS=y
+ + 
+ + #
+ + # SCSI support type (disk, tape, CD-ROM)
+ + #
+ + CONFIG_BLK_DEV_SD=m
+ + # CONFIG_CHR_DEV_ST is not set
+ + # CONFIG_CHR_DEV_OSST is not set
+ + # CONFIG_BLK_DEV_SR is not set
+ + # CONFIG_CHR_DEV_SG is not set
+ + # CONFIG_CHR_DEV_SCH is not set
+ + 
+ + #
+ + # Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+ + #
+ + CONFIG_SCSI_MULTI_LUN=y
+ + # CONFIG_SCSI_CONSTANTS is not set
+ + CONFIG_SCSI_LOGGING=y
+ + # CONFIG_SCSI_SCAN_ASYNC is not set
+ + CONFIG_SCSI_WAIT_SCAN=m
+ + 
+ + #
+ + # SCSI Transports
+ + #
+ + # CONFIG_SCSI_SPI_ATTRS is not set
+ + # CONFIG_SCSI_FC_ATTRS is not set
+ + # CONFIG_SCSI_ISCSI_ATTRS is not set
+ + # CONFIG_SCSI_SAS_LIBSAS is not set
+ + # CONFIG_SCSI_SRP_ATTRS is not set
+ + CONFIG_SCSI_LOWLEVEL=y
+ + # CONFIG_ISCSI_TCP is not set
+ + # CONFIG_LIBFC is not set
+ + # CONFIG_SCSI_DEBUG is not set
+ + # CONFIG_SCSI_DH is not set
+ + # CONFIG_ATA is not set
+ + # CONFIG_MD is not set
+ + CONFIG_NETDEVICES=y
+ + # CONFIG_DUMMY is not set
+ + # CONFIG_BONDING is not set
+ + # CONFIG_MACVLAN is not set
+ + # CONFIG_EQUALIZER is not set
+ + CONFIG_TUN=y
+ + # CONFIG_VETH is not set
+ + # CONFIG_PHYLIB is not set
+ + CONFIG_NET_ETHERNET=y
+ + CONFIG_MII=y
+ + CONFIG_ARM_AT91_ETHER=y
+ + # CONFIG_AX88796 is not set
+ + # CONFIG_SMC91X is not set
+ + # CONFIG_DM9000 is not set
+ + # CONFIG_ENC28J60 is not set
+ + # CONFIG_SMC911X is not set
+ + # CONFIG_SMSC911X is not set
+ + # CONFIG_DNET is not set
+ + # CONFIG_IBM_NEW_EMAC_ZMII is not set
+ + # CONFIG_IBM_NEW_EMAC_RGMII is not set
+ + # CONFIG_IBM_NEW_EMAC_TAH is not set
+ + # CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+ + # CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+ + # CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+ + # CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+ + # CONFIG_B44 is not set
+ + # CONFIG_NETDEV_1000 is not set
+ + # CONFIG_NETDEV_10000 is not set
+ + 
+ + #
+ + # Wireless LAN
+ + #
+ + # CONFIG_WLAN_PRE80211 is not set
+ + # CONFIG_WLAN_80211 is not set
+ + # CONFIG_IWLWIFI_LEDS is not set
+ + 
+ + #
+ + # Enable WiMAX (Networking options) to see the WiMAX drivers
+ + #
+ + 
+ + #
+ + # USB Network Adapters
+ + #
+ + # CONFIG_USB_CATC is not set
+ + # CONFIG_USB_KAWETH is not set
+ + # CONFIG_USB_PEGASUS is not set
+ + # CONFIG_USB_RTL8150 is not set
+ + # CONFIG_USB_USBNET is not set
+ + # CONFIG_WAN is not set
+ + CONFIG_PPP=y
+ + # CONFIG_PPP_MULTILINK is not set
+ + CONFIG_PPP_FILTER=y
+ + CONFIG_PPP_ASYNC=y
+ + # CONFIG_PPP_SYNC_TTY is not set
+ + CONFIG_PPP_DEFLATE=y
+ + CONFIG_PPP_BSDCOMP=y
+ + CONFIG_PPP_MPPE=y
+ + CONFIG_PPPOE=y
+ + # CONFIG_PPPOL2TP is not set
+ + # CONFIG_SLIP is not set
+ + CONFIG_SLHC=y
+ + # CONFIG_NETCONSOLE is not set
+ + # CONFIG_NETPOLL is not set
+ + # CONFIG_NET_POLL_CONTROLLER is not set
+ + # CONFIG_ISDN is not set
+ + 
+ + #
+ + # Input device support
+ + #
+ + CONFIG_INPUT=y
+ + # CONFIG_INPUT_FF_MEMLESS is not set
+ + # CONFIG_INPUT_POLLDEV is not set
+ + 
+ + #
+ + # Userland interfaces
+ + #
+ + # CONFIG_INPUT_MOUSEDEV is not set
+ + # CONFIG_INPUT_JOYDEV is not set
+ + CONFIG_INPUT_EVDEV=y
+ + # CONFIG_INPUT_EVBUG is not set
+ + 
+ + #
+ + # Input Device Drivers
+ + #
+ + CONFIG_INPUT_KEYBOARD=y
+ + # CONFIG_KEYBOARD_ATKBD is not set
+ + # CONFIG_KEYBOARD_SUNKBD is not set
+ + # CONFIG_KEYBOARD_LKKBD is not set
+ + # CONFIG_KEYBOARD_XTKBD is not set
+ + # CONFIG_KEYBOARD_NEWTON is not set
+ + # CONFIG_KEYBOARD_STOWAWAY is not set
+ + CONFIG_KEYBOARD_GPIO=y
+ + # CONFIG_INPUT_MOUSE is not set
+ + # CONFIG_INPUT_JOYSTICK is not set
+ + # CONFIG_INPUT_TABLET is not set
+ + # CONFIG_INPUT_TOUCHSCREEN is not set
+ + # CONFIG_INPUT_MISC is not set
+ + 
+ + #
+ + # Hardware I/O ports
+ + #
+ + # CONFIG_SERIO is not set
+ + # CONFIG_GAMEPORT is not set
+ + 
+ + #
+ + # Character devices
+ + #
+ + # CONFIG_VT is not set
+ + CONFIG_DEVKMEM=y
+ + # CONFIG_SERIAL_NONSTANDARD is not set
+ + 
+ + #
+ + # Serial drivers
+ + #
+ + # CONFIG_SERIAL_8250 is not set
+ + 
+ + #
+ + # Non-8250 serial port support
+ + #
+ + CONFIG_SERIAL_ATMEL=y
+ + CONFIG_SERIAL_ATMEL_CONSOLE=y
+ + CONFIG_SERIAL_ATMEL_PDC=y
+ + # CONFIG_SERIAL_ATMEL_TTYAT is not set
+ + CONFIG_SERIAL_CORE=y
+ + CONFIG_SERIAL_CORE_CONSOLE=y
+ + CONFIG_UNIX98_PTYS=y
+ + # CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+ + CONFIG_LEGACY_PTYS=y
+ + CONFIG_LEGACY_PTY_COUNT=256
+ + # CONFIG_IPMI_HANDLER is not set
+ + CONFIG_HW_RANDOM=y
+ + # CONFIG_R3964 is not set
+ + # CONFIG_RAW_DRIVER is not set
+ + # CONFIG_TCG_TPM is not set
+ + CONFIG_I2C=y
+ + CONFIG_I2C_BOARDINFO=y
+ + CONFIG_I2C_CHARDEV=y
+ + CONFIG_I2C_HELPER_AUTO=y
+ + CONFIG_I2C_ALGOBIT=y
+ + 
+ + #
+ + # I2C Hardware Bus support
+ + #
+ + 
+ + #
+ + # I2C system bus drivers (mostly embedded / system-on-chip)
+ + #
+ + CONFIG_I2C_GPIO=y
+ + # CONFIG_I2C_OCORES is not set
+ + # CONFIG_I2C_SIMTEC is not set
+ + 
+ + #
+ + # External I2C/SMBus adapter drivers
+ + #
+ + # CONFIG_I2C_PARPORT_LIGHT is not set
+ + # CONFIG_I2C_TAOS_EVM is not set
+ + # CONFIG_I2C_TINY_USB is not set
+ + 
+ + #
+ + # Other I2C/SMBus bus drivers
+ + #
+ + # CONFIG_I2C_PCA_PLATFORM is not set
+ + # CONFIG_I2C_STUB is not set
+ + 
+ + #
+ + # Miscellaneous I2C Chip support
+ + #
+ + # CONFIG_DS1682 is not set
+ + # CONFIG_SENSORS_PCF8574 is not set
+ + # CONFIG_PCF8575 is not set
+ + # CONFIG_SENSORS_PCA9539 is not set
+ + # CONFIG_SENSORS_PCF8591 is not set
+ + # CONFIG_SENSORS_MAX6875 is not set
+ + # CONFIG_SENSORS_TSL2550 is not set
+ + # CONFIG_I2C_DEBUG_CORE is not set
+ + # CONFIG_I2C_DEBUG_ALGO is not set
+ + # CONFIG_I2C_DEBUG_BUS is not set
+ + # CONFIG_I2C_DEBUG_CHIP is not set
+ + CONFIG_SPI=y
+ + # CONFIG_SPI_DEBUG is not set
+ + CONFIG_SPI_MASTER=y
+ + 
+ + #
+ + # SPI Master Controller Drivers
+ + #
+ + CONFIG_SPI_ATMEL=y
+ + # CONFIG_SPI_BITBANG is not set
+ + # CONFIG_SPI_GPIO is not set
+ + 
+ + #
+ + # SPI Protocol Masters
+ + #
+ + # CONFIG_SPI_SPIDEV is not set
+ + # CONFIG_SPI_TLE62X0 is not set
+ + # CONFIG_W1 is not set
+ + # CONFIG_POWER_SUPPLY is not set
+ + # CONFIG_HWMON is not set
+ + # CONFIG_THERMAL is not set
+ + # CONFIG_THERMAL_HWMON is not set
+ + CONFIG_WATCHDOG=y
+ + # CONFIG_WATCHDOG_NOWAYOUT is not set
+ + 
+ + #
+ + # Watchdog Device Drivers
+ + #
+ + # CONFIG_SOFT_WATCHDOG is not set
+ + CONFIG_AT91RM9200_WATCHDOG=m
+ + 
+ + #
+ + # USB-based Watchdog Cards
+ + #
+ + # CONFIG_USBPCWATCHDOG is not set
+ + CONFIG_SSB_POSSIBLE=y
+ + 
+ + #
+ + # Sonics Silicon Backplane
+ + #
+ + # CONFIG_SSB is not set
+ + 
+ + #
+ + # Multifunction device drivers
+ + #
+ + # CONFIG_MFD_CORE is not set
+ + # CONFIG_MFD_SM501 is not set
+ + # CONFIG_HTC_PASIC3 is not set
+ + # CONFIG_TWL4030_CORE is not set
+ + # CONFIG_MFD_TMIO is not set
+ + # CONFIG_MFD_T7L66XB is not set
+ + # CONFIG_MFD_TC6387XB is not set
+ + # CONFIG_PMIC_DA903X is not set
+ + # CONFIG_MFD_WM8400 is not set
+ + # CONFIG_MFD_WM8350_I2C is not set
+ + # CONFIG_MFD_PCF50633 is not set
+ + 
+ + #
+ + # Multimedia devices
+ + #
+ + 
+ + #
+ + # Multimedia core support
+ + #
+ + # CONFIG_VIDEO_DEV is not set
+ + # CONFIG_DVB_CORE is not set
+ + # CONFIG_VIDEO_MEDIA is not set
+ + 
+ + #
+ + # Multimedia drivers
+ + #
+ + # CONFIG_DAB is not set
+ + 
+ + #
+ + # Graphics support
+ + #
+ + # CONFIG_VGASTATE is not set
+ + # CONFIG_VIDEO_OUTPUT_CONTROL is not set
+ + # CONFIG_FB is not set
+ + # CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+ + 
+ + #
+ + # Display device support
+ + #
+ + # CONFIG_DISPLAY_SUPPORT is not set
+ + # CONFIG_SOUND is not set
+ + CONFIG_HID_SUPPORT=y
+ + CONFIG_HID=y
+ + # CONFIG_HID_DEBUG is not set
+ + # CONFIG_HIDRAW is not set
+ + 
+ + #
+ + # USB Input Devices
+ + #
+ + # CONFIG_USB_HID is not set
+ + # CONFIG_HID_PID is not set
+ + 
+ + #
+ + # USB HID Boot Protocol drivers
+ + #
+ + # CONFIG_USB_KBD is not set
+ + # CONFIG_USB_MOUSE is not set
+ + 
+ + #
+ + # Special HID drivers
+ + #
+ + CONFIG_HID_COMPAT=y
+ + CONFIG_USB_SUPPORT=y
+ + CONFIG_USB_ARCH_HAS_HCD=y
+ + CONFIG_USB_ARCH_HAS_OHCI=y
+ + # CONFIG_USB_ARCH_HAS_EHCI is not set
+ + CONFIG_USB=y
+ + # CONFIG_USB_DEBUG is not set
+ + # CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+ + 
+ + #
+ + # Miscellaneous USB options
+ + #
+ + CONFIG_USB_DEVICEFS=y
+ + CONFIG_USB_DEVICE_CLASS=y
+ + # CONFIG_USB_DYNAMIC_MINORS is not set
+ + # CONFIG_USB_OTG is not set
+ + # CONFIG_USB_OTG_WHITELIST is not set
+ + # CONFIG_USB_OTG_BLACKLIST_HUB is not set
+ + CONFIG_USB_MON=y
+ + # CONFIG_USB_WUSB is not set
+ + # CONFIG_USB_WUSB_CBAF is not set
+ + 
+ + #
+ + # USB Host Controller Drivers
+ + #
+ + # CONFIG_USB_C67X00_HCD is not set
+ + # CONFIG_USB_OXU210HP_HCD is not set
+ + # CONFIG_USB_ISP116X_HCD is not set
+ + CONFIG_USB_OHCI_HCD=y
+ + # CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+ + # CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+ + CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+ + # CONFIG_USB_SL811_HCD is not set
+ + # CONFIG_USB_R8A66597_HCD is not set
+ + # CONFIG_USB_HWA_HCD is not set
+ + # CONFIG_USB_MUSB_HDRC is not set
+ + 
+ + #
+ + # USB Device Class drivers
+ + #
+ + CONFIG_USB_ACM=m
+ + # CONFIG_USB_PRINTER is not set
+ + # CONFIG_USB_WDM is not set
+ + # CONFIG_USB_TMC is not set
+ + 
+ + #
+ + # NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
+ + #
+ + 
+ + #
+ + # see USB_STORAGE Help for more information
+ + #
+ + CONFIG_USB_STORAGE=m
+ + # CONFIG_USB_STORAGE_DEBUG is not set
+ + # CONFIG_USB_STORAGE_DATAFAB is not set
+ + # CONFIG_USB_STORAGE_FREECOM is not set
+ + # CONFIG_USB_STORAGE_ISD200 is not set
+ + # CONFIG_USB_STORAGE_USBAT is not set
+ + # CONFIG_USB_STORAGE_SDDR09 is not set
+ + # CONFIG_USB_STORAGE_SDDR55 is not set
+ + # CONFIG_USB_STORAGE_JUMPSHOT is not set
+ + # CONFIG_USB_STORAGE_ALAUDA is not set
+ + # CONFIG_USB_STORAGE_ONETOUCH is not set
+ + # CONFIG_USB_STORAGE_KARMA is not set
+ + # CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+ + # CONFIG_USB_LIBUSUAL is not set
+ + 
+ + #
+ + # USB Imaging devices
+ + #
+ + # CONFIG_USB_MDC800 is not set
+ + # CONFIG_USB_MICROTEK is not set
+ + 
+ + #
+ + # USB port drivers
+ + #
+ + CONFIG_USB_SERIAL=m
+ + # CONFIG_USB_EZUSB is not set
+ + CONFIG_USB_SERIAL_GENERIC=y
+ + # CONFIG_USB_SERIAL_AIRCABLE is not set
+ + # CONFIG_USB_SERIAL_ARK3116 is not set
+ + # CONFIG_USB_SERIAL_BELKIN is not set
+ + # CONFIG_USB_SERIAL_CH341 is not set
+ + # CONFIG_USB_SERIAL_WHITEHEAT is not set
+ + # CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+ + # CONFIG_USB_SERIAL_CP2101 is not set
+ + # CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+ + # CONFIG_USB_SERIAL_EMPEG is not set
+ + # CONFIG_USB_SERIAL_FTDI_SIO is not set
+ + # CONFIG_USB_SERIAL_FUNSOFT is not set
+ + # CONFIG_USB_SERIAL_VISOR is not set
+ + # CONFIG_USB_SERIAL_IPAQ is not set
+ + # CONFIG_USB_SERIAL_IR is not set
+ + # CONFIG_USB_SERIAL_EDGEPORT is not set
+ + # CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+ + # CONFIG_USB_SERIAL_GARMIN is not set
+ + # CONFIG_USB_SERIAL_IPW is not set
+ + # CONFIG_USB_SERIAL_IUU is not set
+ + # CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+ + # CONFIG_USB_SERIAL_KEYSPAN is not set
+ + # CONFIG_USB_SERIAL_KLSI is not set
+ + # CONFIG_USB_SERIAL_KOBIL_SCT is not set
+ + # CONFIG_USB_SERIAL_MCT_U232 is not set
+ + # CONFIG_USB_SERIAL_MOS7720 is not set
+ + # CONFIG_USB_SERIAL_MOS7840 is not set
+ + # CONFIG_USB_SERIAL_MOTOROLA is not set
+ + # CONFIG_USB_SERIAL_NAVMAN is not set
+ + CONFIG_USB_SERIAL_PL2303=m
+ + # CONFIG_USB_SERIAL_OTI6858 is not set
+ + # CONFIG_USB_SERIAL_SPCP8X5 is not set
+ + # CONFIG_USB_SERIAL_HP4X is not set
+ + # CONFIG_USB_SERIAL_SAFE is not set
+ + # CONFIG_USB_SERIAL_SIEMENS_MPI is not set
+ + # CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+ + # CONFIG_USB_SERIAL_TI is not set
+ + # CONFIG_USB_SERIAL_CYBERJACK is not set
+ + # CONFIG_USB_SERIAL_XIRCOM is not set
+ + # CONFIG_USB_SERIAL_OPTION is not set
+ + # CONFIG_USB_SERIAL_OMNINET is not set
+ + # CONFIG_USB_SERIAL_OPTICON is not set
+ + # CONFIG_USB_SERIAL_DEBUG is not set
+ + 
+ + #
+ + # USB Miscellaneous drivers
+ + #
+ + # CONFIG_USB_EMI62 is not set
+ + # CONFIG_USB_EMI26 is not set
+ + # CONFIG_USB_ADUTUX is not set
+ + # CONFIG_USB_SEVSEG is not set
+ + # CONFIG_USB_RIO500 is not set
+ + # CONFIG_USB_LEGOTOWER is not set
+ + # CONFIG_USB_LCD is not set
+ + # CONFIG_USB_BERRY_CHARGE is not set
+ + # CONFIG_USB_LED is not set
+ + # CONFIG_USB_CYPRESS_CY7C63 is not set
+ + # CONFIG_USB_CYTHERM is not set
+ + # CONFIG_USB_PHIDGET is not set
+ + # CONFIG_USB_IDMOUSE is not set
+ + # CONFIG_USB_FTDI_ELAN is not set
+ + # CONFIG_USB_APPLEDISPLAY is not set
+ + # CONFIG_USB_LD is not set
+ + # CONFIG_USB_TRANCEVIBRATOR is not set
+ + # CONFIG_USB_IOWARRIOR is not set
+ + # CONFIG_USB_TEST is not set
+ + # CONFIG_USB_ISIGHTFW is not set
+ + # CONFIG_USB_VST is not set
+ + # CONFIG_USB_GADGET is not set
+ + 
+ + #
+ + # OTG and related infrastructure
+ + #
+ + # CONFIG_USB_GPIO_VBUS is not set
+ + # CONFIG_MMC is not set
+ + # CONFIG_MEMSTICK is not set
+ + # CONFIG_ACCESSIBILITY is not set
+ + CONFIG_NEW_LEDS=y
+ + CONFIG_LEDS_CLASS=y
+ + 
+ + #
+ + # LED drivers
+ + #
+ + # CONFIG_LEDS_ATMEL_PWM is not set
+ + CONFIG_LEDS_LIABDIN_ADDON=y
+ + # CONFIG_LEDS_PCA9532 is not set
+ + CONFIG_LEDS_GPIO=y
+ + # CONFIG_LEDS_PCA955X is not set
+ + 
+ + #
+ + # LED Triggers
+ + #
+ + CONFIG_LEDS_TRIGGERS=y
+ + CONFIG_LEDS_TRIGGER_TIMER=y
+ + CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+ + # CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+ + # CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+ + CONFIG_RTC_LIB=y
+ + CONFIG_RTC_CLASS=y
+ + CONFIG_RTC_HCTOSYS=y
+ + CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+ + # CONFIG_RTC_DEBUG is not set
+ + 
+ + #
+ + # RTC interfaces
+ + #
+ + CONFIG_RTC_INTF_SYSFS=y
+ + CONFIG_RTC_INTF_PROC=y
+ + CONFIG_RTC_INTF_DEV=y
+ + CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+ + # CONFIG_RTC_DRV_TEST is not set
+ + 
+ + #
+ + # I2C RTC drivers
+ + #
+ + CONFIG_RTC_DRV_DS1307=y
+ + # CONFIG_RTC_DRV_DS1374 is not set
+ + # CONFIG_RTC_DRV_DS1672 is not set
+ + # CONFIG_RTC_DRV_MAX6900 is not set
+ + # CONFIG_RTC_DRV_RS5C372 is not set
+ + # CONFIG_RTC_DRV_ISL1208 is not set
+ + # CONFIG_RTC_DRV_X1205 is not set
+ + # CONFIG_RTC_DRV_PCF8563 is not set
+ + # CONFIG_RTC_DRV_PCF8583 is not set
+ + # CONFIG_RTC_DRV_M41T80 is not set
+ + # CONFIG_RTC_DRV_S35390A is not set
+ + # CONFIG_RTC_DRV_FM3130 is not set
+ + # CONFIG_RTC_DRV_RX8581 is not set
+ + 
+ + #
+ + # SPI RTC drivers
+ + #
+ + # CONFIG_RTC_DRV_M41T94 is not set
+ + # CONFIG_RTC_DRV_DS1305 is not set
+ + # CONFIG_RTC_DRV_DS1390 is not set
+ + # CONFIG_RTC_DRV_MAX6902 is not set
+ + # CONFIG_RTC_DRV_R9701 is not set
+ + # CONFIG_RTC_DRV_RS5C348 is not set
+ + # CONFIG_RTC_DRV_DS3234 is not set
+ + 
+ + #
+ + # Platform RTC drivers
+ + #
+ + # CONFIG_RTC_DRV_CMOS is not set
+ + # CONFIG_RTC_DRV_DS1286 is not set
+ + # CONFIG_RTC_DRV_DS1511 is not set
+ + # CONFIG_RTC_DRV_DS1553 is not set
+ + # CONFIG_RTC_DRV_DS1742 is not set
+ + # CONFIG_RTC_DRV_STK17TA8 is not set
+ + # CONFIG_RTC_DRV_M48T86 is not set
+ + # CONFIG_RTC_DRV_M48T35 is not set
+ + # CONFIG_RTC_DRV_M48T59 is not set
+ + # CONFIG_RTC_DRV_BQ4802 is not set
+ + # CONFIG_RTC_DRV_V3020 is not set
+ + 
+ + #
+ + # on-CPU RTC drivers
+ + #
+ + # CONFIG_RTC_DRV_AT91RM9200 is not set
+ + # CONFIG_DMADEVICES is not set
+ + # CONFIG_REGULATOR is not set
+ + # CONFIG_UIO is not set
+ + # CONFIG_STAGING is not set
+ + 
+ + #
+ + # File systems
+ + #
+ + CONFIG_EXT2_FS=y
+ + CONFIG_EXT2_FS_XATTR=y
+ + CONFIG_EXT2_FS_POSIX_ACL=y
+ + CONFIG_EXT2_FS_SECURITY=y
+ + # CONFIG_EXT2_FS_XIP is not set
+ + CONFIG_EXT3_FS=y
+ + CONFIG_EXT3_FS_XATTR=y
+ + CONFIG_EXT3_FS_POSIX_ACL=y
+ + CONFIG_EXT3_FS_SECURITY=y
+ + # CONFIG_EXT4_FS is not set
+ + CONFIG_JBD=y
+ + CONFIG_FS_MBCACHE=y
+ + # CONFIG_REISERFS_FS is not set
+ + # CONFIG_JFS_FS is not set
+ + CONFIG_FS_POSIX_ACL=y
+ + CONFIG_FILE_LOCKING=y
+ + # CONFIG_XFS_FS is not set
+ + # CONFIG_OCFS2_FS is not set
+ + # CONFIG_BTRFS_FS is not set
+ + # CONFIG_DNOTIFY is not set
+ + # CONFIG_INOTIFY is not set
+ + # CONFIG_QUOTA is not set
+ + # CONFIG_AUTOFS_FS is not set
+ + # CONFIG_AUTOFS4_FS is not set
+ + # CONFIG_FUSE_FS is not set
+ + 
+ + #
+ + # CD-ROM/DVD Filesystems
+ + #
+ + # CONFIG_ISO9660_FS is not set
+ + # CONFIG_UDF_FS is not set
+ + 
+ + #
+ + # DOS/FAT/NT Filesystems
+ + #
+ + CONFIG_FAT_FS=y
+ + CONFIG_MSDOS_FS=y
+ + CONFIG_VFAT_FS=y
+ + CONFIG_FAT_DEFAULT_CODEPAGE=850
+ + CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+ + # CONFIG_NTFS_FS is not set
+ + 
+ + #
+ + # Pseudo filesystems
+ + #
+ + CONFIG_PROC_FS=y
+ + CONFIG_PROC_SYSCTL=y
+ + CONFIG_PROC_PAGE_MONITOR=y
+ + CONFIG_SYSFS=y
+ + CONFIG_TMPFS=y
+ + # CONFIG_TMPFS_POSIX_ACL is not set
+ + # CONFIG_HUGETLB_PAGE is not set
+ + # CONFIG_CONFIGFS_FS is not set
+ + CONFIG_MISC_FILESYSTEMS=y
+ + # CONFIG_ADFS_FS is not set
+ + # CONFIG_AFFS_FS is not set
+ + # CONFIG_HFS_FS is not set
+ + # CONFIG_HFSPLUS_FS is not set
+ + # CONFIG_BEFS_FS is not set
+ + # CONFIG_BFS_FS is not set
+ + # CONFIG_EFS_FS is not set
+ + CONFIG_JFFS2_FS=y
+ + CONFIG_JFFS2_FS_DEBUG=0
+ + CONFIG_JFFS2_FS_WRITEBUFFER=y
+ + # CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+ + # CONFIG_JFFS2_SUMMARY is not set
+ + # CONFIG_JFFS2_FS_XATTR is not set
+ + # CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+ + CONFIG_JFFS2_ZLIB=y
+ + # CONFIG_JFFS2_LZO is not set
+ + CONFIG_JFFS2_RTIME=y
+ + # CONFIG_JFFS2_RUBIN is not set
+ + # CONFIG_CRAMFS is not set
+ + # CONFIG_SQUASHFS is not set
+ + # CONFIG_VXFS_FS is not set
+ + # CONFIG_MINIX_FS is not set
+ + # CONFIG_OMFS_FS is not set
+ + # CONFIG_HPFS_FS is not set
+ + # CONFIG_QNX4FS_FS is not set
+ + # CONFIG_ROMFS_FS is not set
+ + # CONFIG_SYSV_FS is not set
+ + # CONFIG_UFS_FS is not set
+ + CONFIG_NETWORK_FILESYSTEMS=y
+ + CONFIG_NFS_FS=y
+ + CONFIG_NFS_V3=y
+ + # CONFIG_NFS_V3_ACL is not set
+ + # CONFIG_NFS_V4 is not set
+ + CONFIG_ROOT_NFS=y
+ + # CONFIG_NFSD is not set
+ + CONFIG_LOCKD=y
+ + CONFIG_LOCKD_V4=y
+ + CONFIG_NFS_COMMON=y
+ + CONFIG_SUNRPC=y
+ + # CONFIG_SUNRPC_REGISTER_V4 is not set
+ + # CONFIG_RPCSEC_GSS_KRB5 is not set
+ + # CONFIG_RPCSEC_GSS_SPKM3 is not set
+ + # CONFIG_SMB_FS is not set
+ + # CONFIG_CIFS is not set
+ + # CONFIG_NCP_FS is not set
+ + # CONFIG_CODA_FS is not set
+ + # CONFIG_AFS_FS is not set
+ + 
+ + #
+ + # Partition Types
+ + #
+ + # CONFIG_PARTITION_ADVANCED is not set
+ + CONFIG_MSDOS_PARTITION=y
+ + CONFIG_NLS=y
+ + CONFIG_NLS_DEFAULT="iso8859-1"
+ + # CONFIG_NLS_CODEPAGE_437 is not set
+ + # CONFIG_NLS_CODEPAGE_737 is not set
+ + # CONFIG_NLS_CODEPAGE_775 is not set
+ + CONFIG_NLS_CODEPAGE_850=y
+ + # CONFIG_NLS_CODEPAGE_852 is not set
+ + # CONFIG_NLS_CODEPAGE_855 is not set
+ + # CONFIG_NLS_CODEPAGE_857 is not set
+ + # CONFIG_NLS_CODEPAGE_860 is not set
+ + # CONFIG_NLS_CODEPAGE_861 is not set
+ + # CONFIG_NLS_CODEPAGE_862 is not set
+ + # CONFIG_NLS_CODEPAGE_863 is not set
+ + # CONFIG_NLS_CODEPAGE_864 is not set
+ + # CONFIG_NLS_CODEPAGE_865 is not set
+ + # CONFIG_NLS_CODEPAGE_866 is not set
+ + # CONFIG_NLS_CODEPAGE_869 is not set
+ + # CONFIG_NLS_CODEPAGE_936 is not set
+ + # CONFIG_NLS_CODEPAGE_950 is not set
+ + # CONFIG_NLS_CODEPAGE_932 is not set
+ + # CONFIG_NLS_CODEPAGE_949 is not set
+ + # CONFIG_NLS_CODEPAGE_874 is not set
+ + # CONFIG_NLS_ISO8859_8 is not set
+ + # CONFIG_NLS_CODEPAGE_1250 is not set
+ + # CONFIG_NLS_CODEPAGE_1251 is not set
+ + # CONFIG_NLS_ASCII is not set
+ + CONFIG_NLS_ISO8859_1=y
+ + # CONFIG_NLS_ISO8859_2 is not set
+ + # CONFIG_NLS_ISO8859_3 is not set
+ + # CONFIG_NLS_ISO8859_4 is not set
+ + # CONFIG_NLS_ISO8859_5 is not set
+ + # CONFIG_NLS_ISO8859_6 is not set
+ + # CONFIG_NLS_ISO8859_7 is not set
+ + # CONFIG_NLS_ISO8859_9 is not set
+ + # CONFIG_NLS_ISO8859_13 is not set
+ + # CONFIG_NLS_ISO8859_14 is not set
+ + # CONFIG_NLS_ISO8859_15 is not set
+ + # CONFIG_NLS_KOI8_R is not set
+ + # CONFIG_NLS_KOI8_U is not set
+ + # CONFIG_NLS_UTF8 is not set
+ + # CONFIG_DLM is not set
+ + 
+ + #
+ + # Kernel hacking
+ + #
+ + # CONFIG_PRINTK_TIME is not set
+ + CONFIG_ENABLE_WARN_DEPRECATED=y
+ + CONFIG_ENABLE_MUST_CHECK=y
+ + CONFIG_FRAME_WARN=1024
+ + # CONFIG_MAGIC_SYSRQ is not set
+ + # CONFIG_UNUSED_SYMBOLS is not set
+ + # CONFIG_DEBUG_FS is not set
+ + # CONFIG_HEADERS_CHECK is not set
+ + CONFIG_DEBUG_KERNEL=y
+ + # CONFIG_DEBUG_SHIRQ is not set
+ + CONFIG_DETECT_SOFTLOCKUP=y
+ + # CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+ + CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+ + CONFIG_SCHED_DEBUG=y
+ + # CONFIG_SCHEDSTATS is not set
+ + # CONFIG_TIMER_STATS is not set
+ + # CONFIG_DEBUG_OBJECTS is not set
+ + # CONFIG_DEBUG_SLAB is not set
+ + CONFIG_DEBUG_PREEMPT=y
+ + # CONFIG_DEBUG_RT_MUTEXES is not set
+ + # CONFIG_RT_MUTEX_TESTER is not set
+ + # CONFIG_DEBUG_SPINLOCK is not set
+ + CONFIG_DEBUG_MUTEXES=y
+ + # CONFIG_DEBUG_LOCK_ALLOC is not set
+ + # CONFIG_PROVE_LOCKING is not set
+ + # CONFIG_LOCK_STAT is not set
+ + # CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+ + # CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+ + # CONFIG_DEBUG_KOBJECT is not set
+ + # CONFIG_DEBUG_BUGVERBOSE is not set
+ + # CONFIG_DEBUG_INFO is not set
+ + # CONFIG_DEBUG_VM is not set
+ + # CONFIG_DEBUG_WRITECOUNT is not set
+ + # CONFIG_DEBUG_MEMORY_INIT is not set
+ + # CONFIG_DEBUG_LIST is not set
+ + # CONFIG_DEBUG_SG is not set
+ + # CONFIG_DEBUG_NOTIFIERS is not set
+ + CONFIG_FRAME_POINTER=y
+ + # CONFIG_BOOT_PRINTK_DELAY is not set
+ + # CONFIG_RCU_TORTURE_TEST is not set
+ + # CONFIG_BACKTRACE_SELF_TEST is not set
+ + # CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+ + # CONFIG_FAULT_INJECTION is not set
+ + # CONFIG_LATENCYTOP is not set
+ + # CONFIG_SYSCTL_SYSCALL_CHECK is not set
+ + CONFIG_HAVE_FUNCTION_TRACER=y
+ + 
+ + #
+ + # Tracers
+ + #
+ + # CONFIG_FUNCTION_TRACER is not set
+ + # CONFIG_IRQSOFF_TRACER is not set
+ + # CONFIG_PREEMPT_TRACER is not set
+ + # CONFIG_SCHED_TRACER is not set
+ + # CONFIG_CONTEXT_SWITCH_TRACER is not set
+ + # CONFIG_BOOT_TRACER is not set
+ + # CONFIG_TRACE_BRANCH_PROFILING is not set
+ + # CONFIG_STACK_TRACER is not set
+ + # CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+ + # CONFIG_SAMPLES is not set
+ + CONFIG_HAVE_ARCH_KGDB=y
+ + # CONFIG_KGDB is not set
+ + # CONFIG_DEBUG_USER is not set
+ + # CONFIG_DEBUG_ERRORS is not set
+ + # CONFIG_DEBUG_STACK_USAGE is not set
+ + CONFIG_DEBUG_LL=y
+ + # CONFIG_DEBUG_ICEDCC is not set
+ + 
+ + #
+ + # Security options
+ + #
+ + # CONFIG_KEYS is not set
+ + # CONFIG_SECURITY is not set
+ + # CONFIG_SECURITYFS is not set
+ + # CONFIG_SECURITY_FILE_CAPABILITIES is not set
+ + CONFIG_CRYPTO=y
+ + 
+ + #
+ + # Crypto core or helper
+ + #
+ + # CONFIG_CRYPTO_FIPS is not set
+ + CONFIG_CRYPTO_ALGAPI=y
+ + CONFIG_CRYPTO_ALGAPI2=y
+ + CONFIG_CRYPTO_AEAD2=y
+ + CONFIG_CRYPTO_BLKCIPHER=y
+ + CONFIG_CRYPTO_BLKCIPHER2=y
+ + CONFIG_CRYPTO_HASH=y
+ + CONFIG_CRYPTO_HASH2=y
+ + CONFIG_CRYPTO_RNG2=y
+ + CONFIG_CRYPTO_MANAGER=y
+ + CONFIG_CRYPTO_MANAGER2=y
+ + # CONFIG_CRYPTO_GF128MUL is not set
+ + # CONFIG_CRYPTO_NULL is not set
+ + # CONFIG_CRYPTO_CRYPTD is not set
+ + # CONFIG_CRYPTO_AUTHENC is not set
+ + # CONFIG_CRYPTO_TEST is not set
+ + 
+ + #
+ + # Authenticated Encryption with Associated Data
+ + #
+ + # CONFIG_CRYPTO_CCM is not set
+ + # CONFIG_CRYPTO_GCM is not set
+ + # CONFIG_CRYPTO_SEQIV is not set
+ + 
+ + #
+ + # Block modes
+ + #
+ + # CONFIG_CRYPTO_CBC is not set
+ + # CONFIG_CRYPTO_CTR is not set
+ + # CONFIG_CRYPTO_CTS is not set
+ + CONFIG_CRYPTO_ECB=y
+ + # CONFIG_CRYPTO_LRW is not set
+ + # CONFIG_CRYPTO_PCBC is not set
+ + # CONFIG_CRYPTO_XTS is not set
+ + 
+ + #
+ + # Hash modes
+ + #
+ + # CONFIG_CRYPTO_HMAC is not set
+ + # CONFIG_CRYPTO_XCBC is not set
+ + 
+ + #
+ + # Digest
+ + #
+ + CONFIG_CRYPTO_CRC32C=y
+ + # CONFIG_CRYPTO_MD4 is not set
+ + # CONFIG_CRYPTO_MD5 is not set
+ + # CONFIG_CRYPTO_MICHAEL_MIC is not set
+ + # CONFIG_CRYPTO_RMD128 is not set
+ + # CONFIG_CRYPTO_RMD160 is not set
+ + # CONFIG_CRYPTO_RMD256 is not set
+ + # CONFIG_CRYPTO_RMD320 is not set
+ + CONFIG_CRYPTO_SHA1=y
+ + # CONFIG_CRYPTO_SHA256 is not set
+ + # CONFIG_CRYPTO_SHA512 is not set
+ + # CONFIG_CRYPTO_TGR192 is not set
+ + # CONFIG_CRYPTO_WP512 is not set
+ + 
+ + #
+ + # Ciphers
+ + #
+ + CONFIG_CRYPTO_AES=y
+ + # CONFIG_CRYPTO_ANUBIS is not set
+ + CONFIG_CRYPTO_ARC4=y
+ + # CONFIG_CRYPTO_BLOWFISH is not set
+ + # CONFIG_CRYPTO_CAMELLIA is not set
+ + # CONFIG_CRYPTO_CAST5 is not set
+ + # CONFIG_CRYPTO_CAST6 is not set
+ + # CONFIG_CRYPTO_DES is not set
+ + # CONFIG_CRYPTO_FCRYPT is not set
+ + # CONFIG_CRYPTO_KHAZAD is not set
+ + # CONFIG_CRYPTO_SALSA20 is not set
+ + # CONFIG_CRYPTO_SEED is not set
+ + # CONFIG_CRYPTO_SERPENT is not set
+ + # CONFIG_CRYPTO_TEA is not set
+ + # CONFIG_CRYPTO_TWOFISH is not set
+ + 
+ + #
+ + # Compression
+ + #
+ + # CONFIG_CRYPTO_DEFLATE is not set
+ + # CONFIG_CRYPTO_LZO is not set
+ + 
+ + #
+ + # Random Number Generation
+ + #
+ + # CONFIG_CRYPTO_ANSI_CPRNG is not set
+ + CONFIG_CRYPTO_HW=y
+ + 
+ + #
+ + # Library routines
+ + #
+ + CONFIG_BITREVERSE=y
+ + CONFIG_GENERIC_FIND_LAST_BIT=y
+ + CONFIG_CRC_CCITT=y
+ + CONFIG_CRC16=y
+ + # CONFIG_CRC_T10DIF is not set
+ + CONFIG_CRC_ITU_T=y
+ + CONFIG_CRC32=y
+ + # CONFIG_CRC7 is not set
+ + CONFIG_LIBCRC32C=y
+ + CONFIG_ZLIB_INFLATE=y
+ + CONFIG_ZLIB_DEFLATE=y
+ + CONFIG_PLIST=y
+ + CONFIG_HAS_IOMEM=y
+ + CONFIG_HAS_IOPORT=y
+ + CONFIG_HAS_DMA=y
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/liabsg-2.6.29.4.config liab-linux-2.6.29.4/liabsg-2.6.29.4.config
+ *** linux-2.6.29.4/liabsg-2.6.29.4.config	1970-01-01 01:00:00.000000000 +0100
+ --- liab-linux-2.6.29.4/liabsg-2.6.29.4.config	2010-05-31 11:07:23.632795277 +0200
+ ***************
+ *** 0 ****
+ --- 1,1514 ----
+ + #
+ + # Automatically generated make config: don't edit
+ + # Linux kernel version: 2.6.29.4
+ + # Fri May 28 14:05:55 2010
+ + #
+ + CONFIG_ARM=y
+ + CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+ + CONFIG_GENERIC_GPIO=y
+ + CONFIG_GENERIC_TIME=y
+ + CONFIG_GENERIC_CLOCKEVENTS=y
+ + CONFIG_MMU=y
+ + # CONFIG_NO_IOPORT is not set
+ + CONFIG_GENERIC_HARDIRQS=y
+ + CONFIG_STACKTRACE_SUPPORT=y
+ + CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+ + CONFIG_LOCKDEP_SUPPORT=y
+ + CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+ + CONFIG_HARDIRQS_SW_RESEND=y
+ + CONFIG_GENERIC_IRQ_PROBE=y
+ + CONFIG_RWSEM_GENERIC_SPINLOCK=y
+ + # CONFIG_ARCH_HAS_ILOG2_U32 is not set
+ + # CONFIG_ARCH_HAS_ILOG2_U64 is not set
+ + CONFIG_GENERIC_HWEIGHT=y
+ + CONFIG_GENERIC_CALIBRATE_DELAY=y
+ + CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+ + CONFIG_VECTORS_BASE=0xffff0000
+ + CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+ + 
+ + #
+ + # General setup
+ + #
+ + CONFIG_EXPERIMENTAL=y
+ + CONFIG_BROKEN_ON_SMP=y
+ + CONFIG_LOCK_KERNEL=y
+ + CONFIG_INIT_ENV_ARG_LIMIT=32
+ + CONFIG_LOCALVERSION=""
+ + # CONFIG_LOCALVERSION_AUTO is not set
+ + CONFIG_SWAP=y
+ + CONFIG_SYSVIPC=y
+ + CONFIG_SYSVIPC_SYSCTL=y
+ + CONFIG_POSIX_MQUEUE=y
+ + # CONFIG_BSD_PROCESS_ACCT is not set
+ + # CONFIG_TASKSTATS is not set
+ + # CONFIG_AUDIT is not set
+ + 
+ + #
+ + # RCU Subsystem
+ + #
+ + # CONFIG_CLASSIC_RCU is not set
+ + # CONFIG_TREE_RCU is not set
+ + CONFIG_PREEMPT_RCU=y
+ + # CONFIG_RCU_TRACE is not set
+ + # CONFIG_TREE_RCU_TRACE is not set
+ + # CONFIG_PREEMPT_RCU_TRACE is not set
+ + CONFIG_IKCONFIG=y
+ + CONFIG_IKCONFIG_PROC=y
+ + CONFIG_LOG_BUF_SHIFT=14
+ + CONFIG_GROUP_SCHED=y
+ + CONFIG_FAIR_GROUP_SCHED=y
+ + # CONFIG_RT_GROUP_SCHED is not set
+ + CONFIG_USER_SCHED=y
+ + # CONFIG_CGROUP_SCHED is not set
+ + # CONFIG_CGROUPS is not set
+ + CONFIG_SYSFS_DEPRECATED=y
+ + CONFIG_SYSFS_DEPRECATED_V2=y
+ + # CONFIG_RELAY is not set
+ + # CONFIG_NAMESPACES is not set
+ + CONFIG_BLK_DEV_INITRD=y
+ + CONFIG_INITRAMFS_SOURCE=""
+ + CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+ + CONFIG_SYSCTL=y
+ + CONFIG_ANON_INODES=y
+ + CONFIG_EMBEDDED=y
+ + CONFIG_UID16=y
+ + CONFIG_SYSCTL_SYSCALL=y
+ + # CONFIG_KALLSYMS is not set
+ + CONFIG_HOTPLUG=y
+ + CONFIG_PRINTK=y
+ + CONFIG_BUG=y
+ + # CONFIG_ELF_CORE is not set
+ + CONFIG_BASE_FULL=y
+ + CONFIG_FUTEX=y
+ + CONFIG_EPOLL=y
+ + CONFIG_SIGNALFD=y
+ + CONFIG_TIMERFD=y
+ + CONFIG_EVENTFD=y
+ + CONFIG_SHMEM=y
+ + CONFIG_AIO=y
+ + CONFIG_VM_EVENT_COUNTERS=y
+ + CONFIG_COMPAT_BRK=y
+ + CONFIG_SLAB=y
+ + # CONFIG_SLUB is not set
+ + # CONFIG_SLOB is not set
+ + # CONFIG_PROFILING is not set
+ + CONFIG_HAVE_OPROFILE=y
+ + CONFIG_HAVE_KPROBES=y
+ + CONFIG_HAVE_KRETPROBES=y
+ + CONFIG_HAVE_CLK=y
+ + CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+ + CONFIG_SLABINFO=y
+ + CONFIG_RT_MUTEXES=y
+ + CONFIG_BASE_SMALL=0
+ + CONFIG_MODULES=y
+ + # CONFIG_MODULE_FORCE_LOAD is not set
+ + CONFIG_MODULE_UNLOAD=y
+ + CONFIG_MODULE_FORCE_UNLOAD=y
+ + # CONFIG_MODVERSIONS is not set
+ + # CONFIG_MODULE_SRCVERSION_ALL is not set
+ + CONFIG_BLOCK=y
+ + # CONFIG_LBD is not set
+ + # CONFIG_BLK_DEV_IO_TRACE is not set
+ + # CONFIG_BLK_DEV_BSG is not set
+ + # CONFIG_BLK_DEV_INTEGRITY is not set
+ + 
+ + #
+ + # IO Schedulers
+ + #
+ + CONFIG_IOSCHED_NOOP=y
+ + # CONFIG_IOSCHED_AS is not set
+ + # CONFIG_IOSCHED_DEADLINE is not set
+ + CONFIG_IOSCHED_CFQ=y
+ + # CONFIG_DEFAULT_AS is not set
+ + # CONFIG_DEFAULT_DEADLINE is not set
+ + CONFIG_DEFAULT_CFQ=y
+ + # CONFIG_DEFAULT_NOOP is not set
+ + CONFIG_DEFAULT_IOSCHED="cfq"
+ + # CONFIG_FREEZER is not set
+ + 
+ + #
+ + # System Type
+ + #
+ + # CONFIG_ARCH_AAEC2000 is not set
+ + # CONFIG_ARCH_INTEGRATOR is not set
+ + # CONFIG_ARCH_REALVIEW is not set
+ + # CONFIG_ARCH_VERSATILE is not set
+ + CONFIG_ARCH_AT91=y
+ + # CONFIG_ARCH_CLPS711X is not set
+ + # CONFIG_ARCH_EBSA110 is not set
+ + # CONFIG_ARCH_EP93XX is not set
+ + # CONFIG_ARCH_FOOTBRIDGE is not set
+ + # CONFIG_ARCH_NETX is not set
+ + # CONFIG_ARCH_H720X is not set
+ + # CONFIG_ARCH_IMX is not set
+ + # CONFIG_ARCH_IOP13XX is not set
+ + # CONFIG_ARCH_IOP32X is not set
+ + # CONFIG_ARCH_IOP33X is not set
+ + # CONFIG_ARCH_IXP23XX is not set
+ + # CONFIG_ARCH_IXP2000 is not set
+ + # CONFIG_ARCH_IXP4XX is not set
+ + # CONFIG_ARCH_L7200 is not set
+ + # CONFIG_ARCH_KIRKWOOD is not set
+ + # CONFIG_ARCH_KS8695 is not set
+ + # CONFIG_ARCH_NS9XXX is not set
+ + # CONFIG_ARCH_LOKI is not set
+ + # CONFIG_ARCH_MV78XX0 is not set
+ + # CONFIG_ARCH_MXC is not set
+ + # CONFIG_ARCH_ORION5X is not set
+ + # CONFIG_ARCH_PNX4008 is not set
+ + # CONFIG_ARCH_PXA is not set
+ + # CONFIG_ARCH_RPC is not set
+ + # CONFIG_ARCH_SA1100 is not set
+ + # CONFIG_ARCH_S3C2410 is not set
+ + # CONFIG_ARCH_S3C64XX is not set
+ + # CONFIG_ARCH_SHARK is not set
+ + # CONFIG_ARCH_LH7A40X is not set
+ + # CONFIG_ARCH_DAVINCI is not set
+ + # CONFIG_ARCH_OMAP is not set
+ + # CONFIG_ARCH_MSM is not set
+ + # CONFIG_ARCH_W90X900 is not set
+ + 
+ + #
+ + # Atmel AT91 System-on-Chip
+ + #
+ + # CONFIG_ARCH_AT91RM9200 is not set
+ + CONFIG_ARCH_AT91SAM9260=y
+ + # CONFIG_ARCH_AT91SAM9261 is not set
+ + # CONFIG_ARCH_AT91SAM9263 is not set
+ + # CONFIG_ARCH_AT91SAM9RL is not set
+ + # CONFIG_ARCH_AT91SAM9G20 is not set
+ + # CONFIG_ARCH_AT91CAP9 is not set
+ + # CONFIG_ARCH_AT91X40 is not set
+ + CONFIG_AT91_PMC_UNIT=y
+ + CONFIG_MACH_LIABARM=y
+ + 
+ + #
+ + # AT91SAM9260 Variants
+ + #
+ + # CONFIG_ARCH_AT91SAM9260_SAM9XE is not set
+ + 
+ + #
+ + # AT91SAM9260 / AT91SAM9XE Board Type
+ + #
+ + CONFIG_MACH_AT91SAM9260EK=y
+ + # CONFIG_MACH_LIABSG is not set
+ + # CONFIG_MACH_CAM60 is not set
+ + # CONFIG_MACH_SAM9_L9260 is not set
+ + # CONFIG_MACH_AFEB9260 is not set
+ + # CONFIG_MACH_USB_A9260 is not set
+ + # CONFIG_MACH_QIL_A9260 is not set
+ + 
+ + #
+ + # AT91 Board Options
+ + #
+ + # CONFIG_MTD_AT91_DATAFLASH_CARD is not set
+ + # CONFIG_MTD_NAND_ATMEL_BUSWIDTH_16 is not set
+ + 
+ + #
+ + # AT91 Feature Selections
+ + #
+ + # CONFIG_AT91_PROGRAMMABLE_CLOCKS is not set
+ + CONFIG_AT91_TIMER_HZ=128
+ + CONFIG_AT91_EARLY_DBGU=y
+ + # CONFIG_AT91_EARLY_USART0 is not set
+ + # CONFIG_AT91_EARLY_USART1 is not set
+ + # CONFIG_AT91_EARLY_USART2 is not set
+ + # CONFIG_AT91_EARLY_USART3 is not set
+ + # CONFIG_AT91_EARLY_USART4 is not set
+ + # CONFIG_AT91_EARLY_USART5 is not set
+ + 
+ + #
+ + # Processor Type
+ + #
+ + CONFIG_CPU_32=y
+ + CONFIG_CPU_ARM926T=y
+ + CONFIG_CPU_32v5=y
+ + CONFIG_CPU_ABRT_EV5TJ=y
+ + CONFIG_CPU_PABRT_NOIFAR=y
+ + CONFIG_CPU_CACHE_VIVT=y
+ + CONFIG_CPU_COPY_V4WB=y
+ + CONFIG_CPU_TLB_V4WBI=y
+ + CONFIG_CPU_CP15=y
+ + CONFIG_CPU_CP15_MMU=y
+ + 
+ + #
+ + # Processor Features
+ + #
+ + CONFIG_ARM_THUMB=y
+ + # CONFIG_CPU_ICACHE_DISABLE is not set
+ + # CONFIG_CPU_DCACHE_DISABLE is not set
+ + # CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+ + # CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+ + # CONFIG_OUTER_CACHE is not set
+ + 
+ + #
+ + # Bus support
+ + #
+ + # CONFIG_PCI_SYSCALL is not set
+ + # CONFIG_ARCH_SUPPORTS_MSI is not set
+ + # CONFIG_PCCARD is not set
+ + 
+ + #
+ + # Kernel Features
+ + #
+ + # CONFIG_NO_HZ is not set
+ + # CONFIG_HIGH_RES_TIMERS is not set
+ + CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+ + CONFIG_VMSPLIT_3G=y
+ + # CONFIG_VMSPLIT_2G is not set
+ + # CONFIG_VMSPLIT_1G is not set
+ + CONFIG_PAGE_OFFSET=0xC0000000
+ + CONFIG_PREEMPT=y
+ + CONFIG_HZ=128
+ + # CONFIG_AEABI is not set
+ + CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+ + # CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+ + # CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+ + CONFIG_SELECT_MEMORY_MODEL=y
+ + CONFIG_FLATMEM_MANUAL=y
+ + # CONFIG_DISCONTIGMEM_MANUAL is not set
+ + # CONFIG_SPARSEMEM_MANUAL is not set
+ + CONFIG_FLATMEM=y
+ + CONFIG_FLAT_NODE_MEM_MAP=y
+ + CONFIG_PAGEFLAGS_EXTENDED=y
+ + CONFIG_SPLIT_PTLOCK_CPUS=4096
+ + # CONFIG_PHYS_ADDR_T_64BIT is not set
+ + CONFIG_ZONE_DMA_FLAG=0
+ + CONFIG_VIRT_TO_BUS=y
+ + CONFIG_UNEVICTABLE_LRU=y
+ + CONFIG_LEDS=y
+ + CONFIG_LEDS_CPU=y
+ + CONFIG_ALIGNMENT_TRAP=y
+ + 
+ + #
+ + # Boot options
+ + #
+ + CONFIG_ZBOOT_ROM_TEXT=0x0
+ + CONFIG_ZBOOT_ROM_BSS=0x0
+ + CONFIG_CMDLINE=""
+ + # CONFIG_XIP_KERNEL is not set
+ + # CONFIG_KEXEC is not set
+ + 
+ + #
+ + # CPU Power Management
+ + #
+ + # CONFIG_CPU_IDLE is not set
+ + 
+ + #
+ + # Floating point emulation
+ + #
+ + 
+ + #
+ + # At least one emulation must be selected
+ + #
+ + CONFIG_FPE_NWFPE=y
+ + # CONFIG_FPE_NWFPE_XP is not set
+ + # CONFIG_FPE_FASTFPE is not set
+ + # CONFIG_VFP is not set
+ + 
+ + #
+ + # Userspace binary formats
+ + #
+ + CONFIG_BINFMT_ELF=y
+ + CONFIG_HAVE_AOUT=y
+ + # CONFIG_BINFMT_AOUT is not set
+ + # CONFIG_BINFMT_MISC is not set
+ + # CONFIG_ARTHUR is not set
+ + 
+ + #
+ + # Power management options
+ + #
+ + # CONFIG_PM is not set
+ + CONFIG_ARCH_SUSPEND_POSSIBLE=y
+ + CONFIG_NET=y
+ + 
+ + #
+ + # Networking options
+ + #
+ + CONFIG_COMPAT_NET_DEV_OPS=y
+ + CONFIG_PACKET=y
+ + CONFIG_PACKET_MMAP=y
+ + CONFIG_UNIX=y
+ + # CONFIG_NET_KEY is not set
+ + CONFIG_INET=y
+ + CONFIG_IP_MULTICAST=y
+ + CONFIG_IP_ADVANCED_ROUTER=y
+ + CONFIG_ASK_IP_FIB_HASH=y
+ + # CONFIG_IP_FIB_TRIE is not set
+ + CONFIG_IP_FIB_HASH=y
+ + CONFIG_IP_MULTIPLE_TABLES=y
+ + CONFIG_IP_ROUTE_MULTIPATH=y
+ + CONFIG_IP_ROUTE_VERBOSE=y
+ + CONFIG_IP_PNP=y
+ + CONFIG_IP_PNP_DHCP=y
+ + CONFIG_IP_PNP_BOOTP=y
+ + CONFIG_IP_PNP_RARP=y
+ + # CONFIG_NET_IPIP is not set
+ + # CONFIG_NET_IPGRE is not set
+ + CONFIG_IP_MROUTE=y
+ + CONFIG_IP_PIMSM_V1=y
+ + # CONFIG_IP_PIMSM_V2 is not set
+ + # CONFIG_ARPD is not set
+ + CONFIG_SYN_COOKIES=y
+ + # CONFIG_INET_AH is not set
+ + # CONFIG_INET_ESP is not set
+ + # CONFIG_INET_IPCOMP is not set
+ + # CONFIG_INET_XFRM_TUNNEL is not set
+ + # CONFIG_INET_TUNNEL is not set
+ + # CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+ + # CONFIG_INET_XFRM_MODE_TUNNEL is not set
+ + # CONFIG_INET_XFRM_MODE_BEET is not set
+ + # CONFIG_INET_LRO is not set
+ + # CONFIG_INET_DIAG is not set
+ + # CONFIG_TCP_CONG_ADVANCED is not set
+ + CONFIG_TCP_CONG_CUBIC=y
+ + CONFIG_DEFAULT_TCP_CONG="cubic"
+ + # CONFIG_TCP_MD5SIG is not set
+ + # CONFIG_IPV6 is not set
+ + # CONFIG_NETWORK_SECMARK is not set
+ + # CONFIG_NETFILTER is not set
+ + # CONFIG_IP_DCCP is not set
+ + # CONFIG_IP_SCTP is not set
+ + # CONFIG_TIPC is not set
+ + # CONFIG_ATM is not set
+ + # CONFIG_BRIDGE is not set
+ + # CONFIG_NET_DSA is not set
+ + # CONFIG_VLAN_8021Q is not set
+ + # CONFIG_DECNET is not set
+ + # CONFIG_LLC2 is not set
+ + # CONFIG_IPX is not set
+ + # CONFIG_ATALK is not set
+ + # CONFIG_X25 is not set
+ + # CONFIG_LAPB is not set
+ + # CONFIG_ECONET is not set
+ + # CONFIG_WAN_ROUTER is not set
+ + # CONFIG_NET_SCHED is not set
+ + # CONFIG_DCB is not set
+ + 
+ + #
+ + # Network testing
+ + #
+ + # CONFIG_NET_PKTGEN is not set
+ + # CONFIG_HAMRADIO is not set
+ + # CONFIG_CAN is not set
+ + # CONFIG_IRDA is not set
+ + # CONFIG_BT is not set
+ + # CONFIG_AF_RXRPC is not set
+ + # CONFIG_PHONET is not set
+ + CONFIG_FIB_RULES=y
+ + # CONFIG_WIRELESS is not set
+ + # CONFIG_WIMAX is not set
+ + # CONFIG_RFKILL is not set
+ + # CONFIG_NET_9P is not set
+ + 
+ + #
+ + # Device Drivers
+ + #
+ + 
+ + #
+ + # Generic Driver Options
+ + #
+ + CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+ + CONFIG_STANDALONE=y
+ + CONFIG_PREVENT_FIRMWARE_BUILD=y
+ + CONFIG_FW_LOADER=y
+ + # CONFIG_FIRMWARE_IN_KERNEL is not set
+ + CONFIG_EXTRA_FIRMWARE=""
+ + # CONFIG_DEBUG_DRIVER is not set
+ + # CONFIG_DEBUG_DEVRES is not set
+ + # CONFIG_SYS_HYPERVISOR is not set
+ + # CONFIG_CONNECTOR is not set
+ + CONFIG_MTD=y
+ + # CONFIG_MTD_DEBUG is not set
+ + # CONFIG_MTD_CONCAT is not set
+ + CONFIG_MTD_PARTITIONS=y
+ + # CONFIG_MTD_TESTS is not set
+ + # CONFIG_MTD_REDBOOT_PARTS is not set
+ + # CONFIG_MTD_CMDLINE_PARTS is not set
+ + # CONFIG_MTD_AFS_PARTS is not set
+ + # CONFIG_MTD_AR7_PARTS is not set
+ + 
+ + #
+ + # User Modules And Translation Layers
+ + #
+ + CONFIG_MTD_CHAR=y
+ + CONFIG_MTD_BLKDEVS=y
+ + CONFIG_MTD_BLOCK=y
+ + # CONFIG_FTL is not set
+ + # CONFIG_NFTL is not set
+ + # CONFIG_INFTL is not set
+ + # CONFIG_RFD_FTL is not set
+ + # CONFIG_SSFDC is not set
+ + # CONFIG_MTD_OOPS is not set
+ + 
+ + #
+ + # RAM/ROM/Flash chip drivers
+ + #
+ + CONFIG_MTD_CFI=y
+ + # CONFIG_MTD_JEDECPROBE is not set
+ + CONFIG_MTD_GEN_PROBE=y
+ + # CONFIG_MTD_CFI_ADV_OPTIONS is not set
+ + CONFIG_MTD_MAP_BANK_WIDTH_1=y
+ + CONFIG_MTD_MAP_BANK_WIDTH_2=y
+ + CONFIG_MTD_MAP_BANK_WIDTH_4=y
+ + # CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+ + # CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+ + # CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+ + CONFIG_MTD_CFI_I1=y
+ + CONFIG_MTD_CFI_I2=y
+ + # CONFIG_MTD_CFI_I4 is not set
+ + # CONFIG_MTD_CFI_I8 is not set
+ + CONFIG_MTD_CFI_INTELEXT=y
+ + CONFIG_MTD_CFI_AMDSTD=y
+ + # CONFIG_MTD_CFI_STAA is not set
+ + CONFIG_MTD_CFI_UTIL=y
+ + # CONFIG_MTD_RAM is not set
+ + # CONFIG_MTD_ROM is not set
+ + # CONFIG_MTD_ABSENT is not set
+ + 
+ + #
+ + # Mapping drivers for chip access
+ + #
+ + # CONFIG_MTD_COMPLEX_MAPPINGS is not set
+ + # CONFIG_MTD_PHYSMAP is not set
+ + # CONFIG_MTD_ARM_INTEGRATOR is not set
+ + CONFIG_MTD_LIABARM=y
+ + CONFIG_MTD_LIAB_FLASH_SIZE=16384
+ + CONFIG_MTD_LIAB_NOFLASH=1
+ + CONFIG_MTD_LIABARM_BOOTSIZE=128
+ + CONFIG_MTD_LIABARM_KERNELSIZE=1536
+ + CONFIG_MTD_LIABARM_ROOTSIZE=6144
+ + CONFIG_MTD_LIABARM_PARAMSIZE=128
+ + CONFIG_MTD_LIABARM_JFFS2SIZE=8448
+ + # CONFIG_MTD_PLATRAM is not set
+ + 
+ + #
+ + # Self-contained MTD device drivers
+ + #
+ + # CONFIG_MTD_DATAFLASH is not set
+ + # CONFIG_MTD_M25P80 is not set
+ + # CONFIG_MTD_SLRAM is not set
+ + # CONFIG_MTD_PHRAM is not set
+ + # CONFIG_MTD_MTDRAM is not set
+ + # CONFIG_MTD_BLOCK2MTD is not set
+ + 
+ + #
+ + # Disk-On-Chip Device Drivers
+ + #
+ + # CONFIG_MTD_DOC2000 is not set
+ + # CONFIG_MTD_DOC2001 is not set
+ + # CONFIG_MTD_DOC2001PLUS is not set
+ + CONFIG_MTD_NAND=y
+ + # CONFIG_MTD_NAND_VERIFY_WRITE is not set
+ + # CONFIG_MTD_NAND_ECC_SMC is not set
+ + # CONFIG_MTD_NAND_MUSEUM_IDS is not set
+ + # CONFIG_MTD_NAND_GPIO is not set
+ + CONFIG_MTD_NAND_IDS=y
+ + # CONFIG_MTD_NAND_DISKONCHIP is not set
+ + CONFIG_MTD_NAND_ATMEL=y
+ + # CONFIG_MTD_NAND_ATMEL_ECC_HW is not set
+ + CONFIG_MTD_NAND_ATMEL_ECC_SOFT=y
+ + # CONFIG_MTD_NAND_ATMEL_ECC_NONE is not set
+ + # CONFIG_MTD_NAND_NANDSIM is not set
+ + # CONFIG_MTD_NAND_PLATFORM is not set
+ + # CONFIG_MTD_ALAUDA is not set
+ + # CONFIG_MTD_ONENAND is not set
+ + 
+ + #
+ + # LPDDR flash memory drivers
+ + #
+ + # CONFIG_MTD_LPDDR is not set
+ + 
+ + #
+ + # UBI - Unsorted block images
+ + #
+ + # CONFIG_MTD_UBI is not set
+ + # CONFIG_PARPORT is not set
+ + CONFIG_BLK_DEV=y
+ + # CONFIG_BLK_DEV_COW_COMMON is not set
+ + # CONFIG_BLK_DEV_LOOP is not set
+ + # CONFIG_BLK_DEV_NBD is not set
+ + # CONFIG_BLK_DEV_UB is not set
+ + CONFIG_BLK_DEV_RAM=y
+ + CONFIG_BLK_DEV_RAM_COUNT=16
+ + CONFIG_BLK_DEV_RAM_SIZE=32768
+ + # CONFIG_BLK_DEV_XIP is not set
+ + # CONFIG_CDROM_PKTCDVD is not set
+ + # CONFIG_ATA_OVER_ETH is not set
+ + CONFIG_MISC_DEVICES=y
+ + # CONFIG_ATMEL_TCLIB is not set
+ + CONFIG_AT91_PWM=y
+ + # CONFIG_ICS932S401 is not set
+ + # CONFIG_ATMEL_SSC is not set
+ + # CONFIG_ENCLOSURE_SERVICES is not set
+ + # CONFIG_C2PORT is not set
+ + 
+ + #
+ + # EEPROM support
+ + #
+ + # CONFIG_EEPROM_AT24 is not set
+ + # CONFIG_EEPROM_AT25 is not set
+ + # CONFIG_EEPROM_LEGACY is not set
+ + # CONFIG_EEPROM_93CX6 is not set
+ + CONFIG_HAVE_IDE=y
+ + # CONFIG_IDE is not set
+ + 
+ + #
+ + # SCSI device support
+ + #
+ + # CONFIG_RAID_ATTRS is not set
+ + CONFIG_SCSI=m
+ + CONFIG_SCSI_DMA=y
+ + # CONFIG_SCSI_TGT is not set
+ + # CONFIG_SCSI_NETLINK is not set
+ + CONFIG_SCSI_PROC_FS=y
+ + 
+ + #
+ + # SCSI support type (disk, tape, CD-ROM)
+ + #
+ + CONFIG_BLK_DEV_SD=m
+ + # CONFIG_CHR_DEV_ST is not set
+ + # CONFIG_CHR_DEV_OSST is not set
+ + # CONFIG_BLK_DEV_SR is not set
+ + # CONFIG_CHR_DEV_SG is not set
+ + # CONFIG_CHR_DEV_SCH is not set
+ + 
+ + #
+ + # Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+ + #
+ + CONFIG_SCSI_MULTI_LUN=y
+ + # CONFIG_SCSI_CONSTANTS is not set
+ + CONFIG_SCSI_LOGGING=y
+ + # CONFIG_SCSI_SCAN_ASYNC is not set
+ + CONFIG_SCSI_WAIT_SCAN=m
+ + 
+ + #
+ + # SCSI Transports
+ + #
+ + # CONFIG_SCSI_SPI_ATTRS is not set
+ + # CONFIG_SCSI_FC_ATTRS is not set
+ + # CONFIG_SCSI_ISCSI_ATTRS is not set
+ + # CONFIG_SCSI_SAS_LIBSAS is not set
+ + # CONFIG_SCSI_SRP_ATTRS is not set
+ + CONFIG_SCSI_LOWLEVEL=y
+ + # CONFIG_ISCSI_TCP is not set
+ + # CONFIG_LIBFC is not set
+ + # CONFIG_SCSI_DEBUG is not set
+ + # CONFIG_SCSI_DH is not set
+ + # CONFIG_ATA is not set
+ + # CONFIG_MD is not set
+ + CONFIG_NETDEVICES=y
+ + # CONFIG_DUMMY is not set
+ + # CONFIG_BONDING is not set
+ + # CONFIG_MACVLAN is not set
+ + # CONFIG_EQUALIZER is not set
+ + CONFIG_TUN=y
+ + # CONFIG_VETH is not set
+ + CONFIG_PHYLIB=y
+ + 
+ + #
+ + # MII PHY device drivers
+ + #
+ + # CONFIG_MARVELL_PHY is not set
+ + CONFIG_DAVICOM_PHY=y
+ + # CONFIG_QSEMI_PHY is not set
+ + # CONFIG_LXT_PHY is not set
+ + # CONFIG_CICADA_PHY is not set
+ + # CONFIG_VITESSE_PHY is not set
+ + # CONFIG_SMSC_PHY is not set
+ + # CONFIG_BROADCOM_PHY is not set
+ + # CONFIG_ICPLUS_PHY is not set
+ + # CONFIG_REALTEK_PHY is not set
+ + # CONFIG_NATIONAL_PHY is not set
+ + # CONFIG_STE10XP is not set
+ + # CONFIG_LSI_ET1011C_PHY is not set
+ + # CONFIG_FIXED_PHY is not set
+ + # CONFIG_MDIO_BITBANG is not set
+ + CONFIG_NET_ETHERNET=y
+ + CONFIG_MII=y
+ + CONFIG_MACB=y
+ + # CONFIG_AX88796 is not set
+ + # CONFIG_SMC91X is not set
+ + # CONFIG_DM9000 is not set
+ + # CONFIG_ENC28J60 is not set
+ + # CONFIG_SMC911X is not set
+ + # CONFIG_SMSC911X is not set
+ + # CONFIG_DNET is not set
+ + # CONFIG_IBM_NEW_EMAC_ZMII is not set
+ + # CONFIG_IBM_NEW_EMAC_RGMII is not set
+ + # CONFIG_IBM_NEW_EMAC_TAH is not set
+ + # CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+ + # CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+ + # CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+ + # CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+ + # CONFIG_B44 is not set
+ + # CONFIG_NETDEV_1000 is not set
+ + # CONFIG_NETDEV_10000 is not set
+ + 
+ + #
+ + # Wireless LAN
+ + #
+ + # CONFIG_WLAN_PRE80211 is not set
+ + # CONFIG_WLAN_80211 is not set
+ + # CONFIG_IWLWIFI_LEDS is not set
+ + 
+ + #
+ + # Enable WiMAX (Networking options) to see the WiMAX drivers
+ + #
+ + 
+ + #
+ + # USB Network Adapters
+ + #
+ + # CONFIG_USB_CATC is not set
+ + # CONFIG_USB_KAWETH is not set
+ + # CONFIG_USB_PEGASUS is not set
+ + # CONFIG_USB_RTL8150 is not set
+ + # CONFIG_USB_USBNET is not set
+ + # CONFIG_WAN is not set
+ + CONFIG_PPP=y
+ + # CONFIG_PPP_MULTILINK is not set
+ + CONFIG_PPP_FILTER=y
+ + CONFIG_PPP_ASYNC=y
+ + # CONFIG_PPP_SYNC_TTY is not set
+ + CONFIG_PPP_DEFLATE=y
+ + CONFIG_PPP_BSDCOMP=y
+ + CONFIG_PPP_MPPE=y
+ + CONFIG_PPPOE=y
+ + # CONFIG_PPPOL2TP is not set
+ + # CONFIG_SLIP is not set
+ + CONFIG_SLHC=y
+ + # CONFIG_NETCONSOLE is not set
+ + # CONFIG_NETPOLL is not set
+ + # CONFIG_NET_POLL_CONTROLLER is not set
+ + # CONFIG_ISDN is not set
+ + 
+ + #
+ + # Input device support
+ + #
+ + CONFIG_INPUT=y
+ + # CONFIG_INPUT_FF_MEMLESS is not set
+ + # CONFIG_INPUT_POLLDEV is not set
+ + 
+ + #
+ + # Userland interfaces
+ + #
+ + # CONFIG_INPUT_MOUSEDEV is not set
+ + # CONFIG_INPUT_JOYDEV is not set
+ + CONFIG_INPUT_EVDEV=y
+ + # CONFIG_INPUT_EVBUG is not set
+ + 
+ + #
+ + # Input Device Drivers
+ + #
+ + CONFIG_INPUT_KEYBOARD=y
+ + # CONFIG_KEYBOARD_ATKBD is not set
+ + # CONFIG_KEYBOARD_SUNKBD is not set
+ + # CONFIG_KEYBOARD_LKKBD is not set
+ + # CONFIG_KEYBOARD_XTKBD is not set
+ + # CONFIG_KEYBOARD_NEWTON is not set
+ + # CONFIG_KEYBOARD_STOWAWAY is not set
+ + CONFIG_KEYBOARD_GPIO=y
+ + # CONFIG_INPUT_MOUSE is not set
+ + # CONFIG_INPUT_JOYSTICK is not set
+ + # CONFIG_INPUT_TABLET is not set
+ + # CONFIG_INPUT_TOUCHSCREEN is not set
+ + # CONFIG_INPUT_MISC is not set
+ + 
+ + #
+ + # Hardware I/O ports
+ + #
+ + # CONFIG_SERIO is not set
+ + # CONFIG_GAMEPORT is not set
+ + 
+ + #
+ + # Character devices
+ + #
+ + # CONFIG_VT is not set
+ + CONFIG_DEVKMEM=y
+ + # CONFIG_SERIAL_NONSTANDARD is not set
+ + 
+ + #
+ + # Serial drivers
+ + #
+ + # CONFIG_SERIAL_8250 is not set
+ + 
+ + #
+ + # Non-8250 serial port support
+ + #
+ + CONFIG_SERIAL_ATMEL=y
+ + CONFIG_SERIAL_ATMEL_CONSOLE=y
+ + CONFIG_SERIAL_ATMEL_PDC=y
+ + # CONFIG_SERIAL_ATMEL_TTYAT is not set
+ + CONFIG_SERIAL_CORE=y
+ + CONFIG_SERIAL_CORE_CONSOLE=y
+ + CONFIG_UNIX98_PTYS=y
+ + # CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+ + CONFIG_LEGACY_PTYS=y
+ + CONFIG_LEGACY_PTY_COUNT=256
+ + # CONFIG_IPMI_HANDLER is not set
+ + CONFIG_HW_RANDOM=y
+ + # CONFIG_R3964 is not set
+ + # CONFIG_RAW_DRIVER is not set
+ + # CONFIG_TCG_TPM is not set
+ + CONFIG_I2C=y
+ + CONFIG_I2C_BOARDINFO=y
+ + CONFIG_I2C_CHARDEV=y
+ + CONFIG_I2C_HELPER_AUTO=y
+ + CONFIG_I2C_ALGOBIT=y
+ + 
+ + #
+ + # I2C Hardware Bus support
+ + #
+ + 
+ + #
+ + # I2C system bus drivers (mostly embedded / system-on-chip)
+ + #
+ + CONFIG_I2C_GPIO=y
+ + # CONFIG_I2C_OCORES is not set
+ + # CONFIG_I2C_SIMTEC is not set
+ + 
+ + #
+ + # External I2C/SMBus adapter drivers
+ + #
+ + # CONFIG_I2C_PARPORT_LIGHT is not set
+ + # CONFIG_I2C_TAOS_EVM is not set
+ + # CONFIG_I2C_TINY_USB is not set
+ + 
+ + #
+ + # Other I2C/SMBus bus drivers
+ + #
+ + # CONFIG_I2C_PCA_PLATFORM is not set
+ + # CONFIG_I2C_STUB is not set
+ + 
+ + #
+ + # Miscellaneous I2C Chip support
+ + #
+ + # CONFIG_DS1682 is not set
+ + # CONFIG_SENSORS_PCF8574 is not set
+ + # CONFIG_PCF8575 is not set
+ + # CONFIG_SENSORS_PCF8591 is not set
+ + # CONFIG_SENSORS_MAX6875 is not set
+ + # CONFIG_SENSORS_TSL2550 is not set
+ + # CONFIG_I2C_DEBUG_CORE is not set
+ + # CONFIG_I2C_DEBUG_ALGO is not set
+ + # CONFIG_I2C_DEBUG_BUS is not set
+ + # CONFIG_I2C_DEBUG_CHIP is not set
+ + CONFIG_SPI=y
+ + # CONFIG_SPI_DEBUG is not set
+ + CONFIG_SPI_MASTER=y
+ + 
+ + #
+ + # SPI Master Controller Drivers
+ + #
+ + CONFIG_SPI_ATMEL=y
+ + # CONFIG_SPI_BITBANG is not set
+ + # CONFIG_SPI_GPIO is not set
+ + 
+ + #
+ + # SPI Protocol Masters
+ + #
+ + # CONFIG_SPI_SPIDEV is not set
+ + # CONFIG_SPI_TLE62X0 is not set
+ + CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+ + CONFIG_ARCH_REQUIRE_GPIOLIB=y
+ + CONFIG_GPIOLIB=y
+ + CONFIG_DEBUG_GPIO=y
+ + CONFIG_GPIO_SYSFS=y
+ + 
+ + #
+ + # Memory mapped GPIO expanders:
+ + #
+ + 
+ + #
+ + # I2C GPIO expanders:
+ + #
+ + # CONFIG_GPIO_MAX732X is not set
+ + CONFIG_GPIO_PCA953X=y
+ + # CONFIG_GPIO_PCF857X is not set
+ + 
+ + #
+ + # PCI GPIO expanders:
+ + #
+ + 
+ + #
+ + # SPI GPIO expanders:
+ + #
+ + # CONFIG_GPIO_MAX7301 is not set
+ + # CONFIG_GPIO_MCP23S08 is not set
+ + # CONFIG_W1 is not set
+ + # CONFIG_POWER_SUPPLY is not set
+ + # CONFIG_HWMON is not set
+ + # CONFIG_THERMAL is not set
+ + # CONFIG_THERMAL_HWMON is not set
+ + CONFIG_WATCHDOG=y
+ + # CONFIG_WATCHDOG_NOWAYOUT is not set
+ + 
+ + #
+ + # Watchdog Device Drivers
+ + #
+ + # CONFIG_SOFT_WATCHDOG is not set
+ + # CONFIG_AT91SAM9X_WATCHDOG is not set
+ + 
+ + #
+ + # USB-based Watchdog Cards
+ + #
+ + # CONFIG_USBPCWATCHDOG is not set
+ + CONFIG_SSB_POSSIBLE=y
+ + 
+ + #
+ + # Sonics Silicon Backplane
+ + #
+ + # CONFIG_SSB is not set
+ + 
+ + #
+ + # Multifunction device drivers
+ + #
+ + # CONFIG_MFD_CORE is not set
+ + # CONFIG_MFD_SM501 is not set
+ + # CONFIG_MFD_ASIC3 is not set
+ + # CONFIG_HTC_EGPIO is not set
+ + # CONFIG_HTC_PASIC3 is not set
+ + # CONFIG_TPS65010 is not set
+ + # CONFIG_TWL4030_CORE is not set
+ + # CONFIG_MFD_TMIO is not set
+ + # CONFIG_MFD_T7L66XB is not set
+ + # CONFIG_MFD_TC6387XB is not set
+ + # CONFIG_MFD_TC6393XB is not set
+ + # CONFIG_PMIC_DA903X is not set
+ + # CONFIG_MFD_WM8400 is not set
+ + # CONFIG_MFD_WM8350_I2C is not set
+ + # CONFIG_MFD_PCF50633 is not set
+ + 
+ + #
+ + # Multimedia devices
+ + #
+ + 
+ + #
+ + # Multimedia core support
+ + #
+ + # CONFIG_VIDEO_DEV is not set
+ + # CONFIG_DVB_CORE is not set
+ + # CONFIG_VIDEO_MEDIA is not set
+ + 
+ + #
+ + # Multimedia drivers
+ + #
+ + # CONFIG_DAB is not set
+ + 
+ + #
+ + # Graphics support
+ + #
+ + # CONFIG_VGASTATE is not set
+ + # CONFIG_VIDEO_OUTPUT_CONTROL is not set
+ + # CONFIG_FB is not set
+ + # CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+ + 
+ + #
+ + # Display device support
+ + #
+ + # CONFIG_DISPLAY_SUPPORT is not set
+ + # CONFIG_SOUND is not set
+ + CONFIG_HID_SUPPORT=y
+ + CONFIG_HID=y
+ + # CONFIG_HID_DEBUG is not set
+ + # CONFIG_HIDRAW is not set
+ + 
+ + #
+ + # USB Input Devices
+ + #
+ + # CONFIG_USB_HID is not set
+ + # CONFIG_HID_PID is not set
+ + 
+ + #
+ + # USB HID Boot Protocol drivers
+ + #
+ + # CONFIG_USB_KBD is not set
+ + # CONFIG_USB_MOUSE is not set
+ + 
+ + #
+ + # Special HID drivers
+ + #
+ + CONFIG_HID_COMPAT=y
+ + CONFIG_USB_SUPPORT=y
+ + CONFIG_USB_ARCH_HAS_HCD=y
+ + CONFIG_USB_ARCH_HAS_OHCI=y
+ + # CONFIG_USB_ARCH_HAS_EHCI is not set
+ + CONFIG_USB=y
+ + # CONFIG_USB_DEBUG is not set
+ + # CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+ + 
+ + #
+ + # Miscellaneous USB options
+ + #
+ + CONFIG_USB_DEVICEFS=y
+ + CONFIG_USB_DEVICE_CLASS=y
+ + # CONFIG_USB_DYNAMIC_MINORS is not set
+ + # CONFIG_USB_OTG is not set
+ + # CONFIG_USB_OTG_WHITELIST is not set
+ + # CONFIG_USB_OTG_BLACKLIST_HUB is not set
+ + CONFIG_USB_MON=y
+ + # CONFIG_USB_WUSB is not set
+ + # CONFIG_USB_WUSB_CBAF is not set
+ + 
+ + #
+ + # USB Host Controller Drivers
+ + #
+ + # CONFIG_USB_C67X00_HCD is not set
+ + # CONFIG_USB_OXU210HP_HCD is not set
+ + # CONFIG_USB_ISP116X_HCD is not set
+ + CONFIG_USB_OHCI_HCD=y
+ + # CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+ + # CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+ + CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+ + # CONFIG_USB_SL811_HCD is not set
+ + # CONFIG_USB_R8A66597_HCD is not set
+ + # CONFIG_USB_HWA_HCD is not set
+ + # CONFIG_USB_MUSB_HDRC is not set
+ + 
+ + #
+ + # USB Device Class drivers
+ + #
+ + CONFIG_USB_ACM=m
+ + # CONFIG_USB_PRINTER is not set
+ + # CONFIG_USB_WDM is not set
+ + # CONFIG_USB_TMC is not set
+ + 
+ + #
+ + # NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
+ + #
+ + 
+ + #
+ + # see USB_STORAGE Help for more information
+ + #
+ + CONFIG_USB_STORAGE=m
+ + # CONFIG_USB_STORAGE_DEBUG is not set
+ + # CONFIG_USB_STORAGE_DATAFAB is not set
+ + # CONFIG_USB_STORAGE_FREECOM is not set
+ + # CONFIG_USB_STORAGE_ISD200 is not set
+ + # CONFIG_USB_STORAGE_USBAT is not set
+ + # CONFIG_USB_STORAGE_SDDR09 is not set
+ + # CONFIG_USB_STORAGE_SDDR55 is not set
+ + # CONFIG_USB_STORAGE_JUMPSHOT is not set
+ + # CONFIG_USB_STORAGE_ALAUDA is not set
+ + # CONFIG_USB_STORAGE_ONETOUCH is not set
+ + # CONFIG_USB_STORAGE_KARMA is not set
+ + # CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+ + # CONFIG_USB_LIBUSUAL is not set
+ + 
+ + #
+ + # USB Imaging devices
+ + #
+ + # CONFIG_USB_MDC800 is not set
+ + # CONFIG_USB_MICROTEK is not set
+ + 
+ + #
+ + # USB port drivers
+ + #
+ + CONFIG_USB_SERIAL=m
+ + # CONFIG_USB_EZUSB is not set
+ + CONFIG_USB_SERIAL_GENERIC=y
+ + # CONFIG_USB_SERIAL_AIRCABLE is not set
+ + # CONFIG_USB_SERIAL_ARK3116 is not set
+ + # CONFIG_USB_SERIAL_BELKIN is not set
+ + # CONFIG_USB_SERIAL_CH341 is not set
+ + # CONFIG_USB_SERIAL_WHITEHEAT is not set
+ + # CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+ + # CONFIG_USB_SERIAL_CP2101 is not set
+ + # CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+ + # CONFIG_USB_SERIAL_EMPEG is not set
+ + # CONFIG_USB_SERIAL_FTDI_SIO is not set
+ + # CONFIG_USB_SERIAL_FUNSOFT is not set
+ + # CONFIG_USB_SERIAL_VISOR is not set
+ + # CONFIG_USB_SERIAL_IPAQ is not set
+ + # CONFIG_USB_SERIAL_IR is not set
+ + # CONFIG_USB_SERIAL_EDGEPORT is not set
+ + # CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+ + # CONFIG_USB_SERIAL_GARMIN is not set
+ + # CONFIG_USB_SERIAL_IPW is not set
+ + # CONFIG_USB_SERIAL_IUU is not set
+ + # CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+ + # CONFIG_USB_SERIAL_KEYSPAN is not set
+ + # CONFIG_USB_SERIAL_KLSI is not set
+ + # CONFIG_USB_SERIAL_KOBIL_SCT is not set
+ + # CONFIG_USB_SERIAL_MCT_U232 is not set
+ + # CONFIG_USB_SERIAL_MOS7720 is not set
+ + # CONFIG_USB_SERIAL_MOS7840 is not set
+ + # CONFIG_USB_SERIAL_MOTOROLA is not set
+ + # CONFIG_USB_SERIAL_NAVMAN is not set
+ + CONFIG_USB_SERIAL_PL2303=m
+ + # CONFIG_USB_SERIAL_OTI6858 is not set
+ + # CONFIG_USB_SERIAL_SPCP8X5 is not set
+ + # CONFIG_USB_SERIAL_HP4X is not set
+ + # CONFIG_USB_SERIAL_SAFE is not set
+ + # CONFIG_USB_SERIAL_SIEMENS_MPI is not set
+ + # CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+ + # CONFIG_USB_SERIAL_TI is not set
+ + # CONFIG_USB_SERIAL_CYBERJACK is not set
+ + # CONFIG_USB_SERIAL_XIRCOM is not set
+ + # CONFIG_USB_SERIAL_OPTION is not set
+ + # CONFIG_USB_SERIAL_OMNINET is not set
+ + # CONFIG_USB_SERIAL_OPTICON is not set
+ + # CONFIG_USB_SERIAL_DEBUG is not set
+ + 
+ + #
+ + # USB Miscellaneous drivers
+ + #
+ + # CONFIG_USB_EMI62 is not set
+ + # CONFIG_USB_EMI26 is not set
+ + # CONFIG_USB_ADUTUX is not set
+ + # CONFIG_USB_SEVSEG is not set
+ + # CONFIG_USB_RIO500 is not set
+ + # CONFIG_USB_LEGOTOWER is not set
+ + # CONFIG_USB_LCD is not set
+ + # CONFIG_USB_BERRY_CHARGE is not set
+ + # CONFIG_USB_LED is not set
+ + # CONFIG_USB_CYPRESS_CY7C63 is not set
+ + # CONFIG_USB_CYTHERM is not set
+ + # CONFIG_USB_PHIDGET is not set
+ + # CONFIG_USB_IDMOUSE is not set
+ + # CONFIG_USB_FTDI_ELAN is not set
+ + # CONFIG_USB_APPLEDISPLAY is not set
+ + # CONFIG_USB_LD is not set
+ + # CONFIG_USB_TRANCEVIBRATOR is not set
+ + # CONFIG_USB_IOWARRIOR is not set
+ + # CONFIG_USB_TEST is not set
+ + # CONFIG_USB_ISIGHTFW is not set
+ + # CONFIG_USB_VST is not set
+ + # CONFIG_USB_GADGET is not set
+ + 
+ + #
+ + # OTG and related infrastructure
+ + #
+ + # CONFIG_USB_GPIO_VBUS is not set
+ + # CONFIG_MMC is not set
+ + # CONFIG_MEMSTICK is not set
+ + # CONFIG_ACCESSIBILITY is not set
+ + CONFIG_NEW_LEDS=y
+ + CONFIG_LEDS_CLASS=y
+ + 
+ + #
+ + # LED drivers
+ + #
+ + # CONFIG_LEDS_ATMEL_PWM is not set
+ + CONFIG_LEDS_LIABDIN_ADDON=y
+ + # CONFIG_LEDS_PCA9532 is not set
+ + CONFIG_LEDS_GPIO=y
+ + # CONFIG_LEDS_PCA955X is not set
+ + 
+ + #
+ + # LED Triggers
+ + #
+ + CONFIG_LEDS_TRIGGERS=y
+ + CONFIG_LEDS_TRIGGER_TIMER=y
+ + CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+ + # CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+ + # CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+ + CONFIG_RTC_LIB=y
+ + CONFIG_RTC_CLASS=y
+ + CONFIG_RTC_HCTOSYS=y
+ + CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+ + # CONFIG_RTC_DEBUG is not set
+ + 
+ + #
+ + # RTC interfaces
+ + #
+ + CONFIG_RTC_INTF_SYSFS=y
+ + CONFIG_RTC_INTF_PROC=y
+ + CONFIG_RTC_INTF_DEV=y
+ + CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+ + # CONFIG_RTC_DRV_TEST is not set
+ + 
+ + #
+ + # I2C RTC drivers
+ + #
+ + CONFIG_RTC_DRV_DS1307=y
+ + # CONFIG_RTC_DRV_DS1374 is not set
+ + # CONFIG_RTC_DRV_DS1672 is not set
+ + # CONFIG_RTC_DRV_MAX6900 is not set
+ + # CONFIG_RTC_DRV_RS5C372 is not set
+ + # CONFIG_RTC_DRV_ISL1208 is not set
+ + # CONFIG_RTC_DRV_X1205 is not set
+ + # CONFIG_RTC_DRV_PCF8563 is not set
+ + # CONFIG_RTC_DRV_PCF8583 is not set
+ + # CONFIG_RTC_DRV_M41T80 is not set
+ + # CONFIG_RTC_DRV_S35390A is not set
+ + # CONFIG_RTC_DRV_FM3130 is not set
+ + # CONFIG_RTC_DRV_RX8581 is not set
+ + 
+ + #
+ + # SPI RTC drivers
+ + #
+ + # CONFIG_RTC_DRV_M41T94 is not set
+ + # CONFIG_RTC_DRV_DS1305 is not set
+ + # CONFIG_RTC_DRV_DS1390 is not set
+ + # CONFIG_RTC_DRV_MAX6902 is not set
+ + # CONFIG_RTC_DRV_R9701 is not set
+ + # CONFIG_RTC_DRV_RS5C348 is not set
+ + # CONFIG_RTC_DRV_DS3234 is not set
+ + 
+ + #
+ + # Platform RTC drivers
+ + #
+ + # CONFIG_RTC_DRV_CMOS is not set
+ + # CONFIG_RTC_DRV_DS1286 is not set
+ + # CONFIG_RTC_DRV_DS1511 is not set
+ + # CONFIG_RTC_DRV_DS1553 is not set
+ + # CONFIG_RTC_DRV_DS1742 is not set
+ + # CONFIG_RTC_DRV_STK17TA8 is not set
+ + # CONFIG_RTC_DRV_M48T86 is not set
+ + # CONFIG_RTC_DRV_M48T35 is not set
+ + # CONFIG_RTC_DRV_M48T59 is not set
+ + # CONFIG_RTC_DRV_BQ4802 is not set
+ + # CONFIG_RTC_DRV_V3020 is not set
+ + 
+ + #
+ + # on-CPU RTC drivers
+ + #
+ + # CONFIG_RTC_DRV_AT91SAM9 is not set
+ + # CONFIG_DMADEVICES is not set
+ + # CONFIG_REGULATOR is not set
+ + # CONFIG_UIO is not set
+ + # CONFIG_STAGING is not set
+ + 
+ + #
+ + # File systems
+ + #
+ + CONFIG_EXT2_FS=y
+ + CONFIG_EXT2_FS_XATTR=y
+ + CONFIG_EXT2_FS_POSIX_ACL=y
+ + CONFIG_EXT2_FS_SECURITY=y
+ + # CONFIG_EXT2_FS_XIP is not set
+ + CONFIG_EXT3_FS=y
+ + CONFIG_EXT3_FS_XATTR=y
+ + CONFIG_EXT3_FS_POSIX_ACL=y
+ + CONFIG_EXT3_FS_SECURITY=y
+ + # CONFIG_EXT4_FS is not set
+ + CONFIG_JBD=y
+ + CONFIG_FS_MBCACHE=y
+ + # CONFIG_REISERFS_FS is not set
+ + # CONFIG_JFS_FS is not set
+ + CONFIG_FS_POSIX_ACL=y
+ + CONFIG_FILE_LOCKING=y
+ + # CONFIG_XFS_FS is not set
+ + # CONFIG_OCFS2_FS is not set
+ + # CONFIG_BTRFS_FS is not set
+ + # CONFIG_DNOTIFY is not set
+ + # CONFIG_INOTIFY is not set
+ + # CONFIG_QUOTA is not set
+ + # CONFIG_AUTOFS_FS is not set
+ + # CONFIG_AUTOFS4_FS is not set
+ + # CONFIG_FUSE_FS is not set
+ + 
+ + #
+ + # CD-ROM/DVD Filesystems
+ + #
+ + # CONFIG_ISO9660_FS is not set
+ + # CONFIG_UDF_FS is not set
+ + 
+ + #
+ + # DOS/FAT/NT Filesystems
+ + #
+ + CONFIG_FAT_FS=y
+ + CONFIG_MSDOS_FS=y
+ + CONFIG_VFAT_FS=y
+ + CONFIG_FAT_DEFAULT_CODEPAGE=850
+ + CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+ + # CONFIG_NTFS_FS is not set
+ + 
+ + #
+ + # Pseudo filesystems
+ + #
+ + CONFIG_PROC_FS=y
+ + CONFIG_PROC_SYSCTL=y
+ + CONFIG_PROC_PAGE_MONITOR=y
+ + CONFIG_SYSFS=y
+ + CONFIG_TMPFS=y
+ + # CONFIG_TMPFS_POSIX_ACL is not set
+ + # CONFIG_HUGETLB_PAGE is not set
+ + # CONFIG_CONFIGFS_FS is not set
+ + CONFIG_MISC_FILESYSTEMS=y
+ + # CONFIG_ADFS_FS is not set
+ + # CONFIG_AFFS_FS is not set
+ + # CONFIG_HFS_FS is not set
+ + # CONFIG_HFSPLUS_FS is not set
+ + # CONFIG_BEFS_FS is not set
+ + # CONFIG_BFS_FS is not set
+ + # CONFIG_EFS_FS is not set
+ + CONFIG_JFFS2_FS=y
+ + CONFIG_JFFS2_FS_DEBUG=0
+ + CONFIG_JFFS2_FS_WRITEBUFFER=y
+ + # CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+ + # CONFIG_JFFS2_SUMMARY is not set
+ + # CONFIG_JFFS2_FS_XATTR is not set
+ + # CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+ + CONFIG_JFFS2_ZLIB=y
+ + # CONFIG_JFFS2_LZO is not set
+ + CONFIG_JFFS2_RTIME=y
+ + # CONFIG_JFFS2_RUBIN is not set
+ + # CONFIG_CRAMFS is not set
+ + # CONFIG_SQUASHFS is not set
+ + # CONFIG_VXFS_FS is not set
+ + # CONFIG_MINIX_FS is not set
+ + # CONFIG_OMFS_FS is not set
+ + # CONFIG_HPFS_FS is not set
+ + # CONFIG_QNX4FS_FS is not set
+ + # CONFIG_ROMFS_FS is not set
+ + # CONFIG_SYSV_FS is not set
+ + # CONFIG_UFS_FS is not set
+ + CONFIG_NETWORK_FILESYSTEMS=y
+ + CONFIG_NFS_FS=y
+ + CONFIG_NFS_V3=y
+ + # CONFIG_NFS_V3_ACL is not set
+ + # CONFIG_NFS_V4 is not set
+ + CONFIG_ROOT_NFS=y
+ + # CONFIG_NFSD is not set
+ + CONFIG_LOCKD=y
+ + CONFIG_LOCKD_V4=y
+ + CONFIG_NFS_COMMON=y
+ + CONFIG_SUNRPC=y
+ + # CONFIG_SUNRPC_REGISTER_V4 is not set
+ + # CONFIG_RPCSEC_GSS_KRB5 is not set
+ + # CONFIG_RPCSEC_GSS_SPKM3 is not set
+ + # CONFIG_SMB_FS is not set
+ + # CONFIG_CIFS is not set
+ + # CONFIG_NCP_FS is not set
+ + # CONFIG_CODA_FS is not set
+ + # CONFIG_AFS_FS is not set
+ + 
+ + #
+ + # Partition Types
+ + #
+ + # CONFIG_PARTITION_ADVANCED is not set
+ + CONFIG_MSDOS_PARTITION=y
+ + CONFIG_NLS=y
+ + CONFIG_NLS_DEFAULT="iso8859-1"
+ + # CONFIG_NLS_CODEPAGE_437 is not set
+ + # CONFIG_NLS_CODEPAGE_737 is not set
+ + # CONFIG_NLS_CODEPAGE_775 is not set
+ + CONFIG_NLS_CODEPAGE_850=y
+ + # CONFIG_NLS_CODEPAGE_852 is not set
+ + # CONFIG_NLS_CODEPAGE_855 is not set
+ + # CONFIG_NLS_CODEPAGE_857 is not set
+ + # CONFIG_NLS_CODEPAGE_860 is not set
+ + # CONFIG_NLS_CODEPAGE_861 is not set
+ + # CONFIG_NLS_CODEPAGE_862 is not set
+ + # CONFIG_NLS_CODEPAGE_863 is not set
+ + # CONFIG_NLS_CODEPAGE_864 is not set
+ + # CONFIG_NLS_CODEPAGE_865 is not set
+ + # CONFIG_NLS_CODEPAGE_866 is not set
+ + # CONFIG_NLS_CODEPAGE_869 is not set
+ + # CONFIG_NLS_CODEPAGE_936 is not set
+ + # CONFIG_NLS_CODEPAGE_950 is not set
+ + # CONFIG_NLS_CODEPAGE_932 is not set
+ + # CONFIG_NLS_CODEPAGE_949 is not set
+ + # CONFIG_NLS_CODEPAGE_874 is not set
+ + # CONFIG_NLS_ISO8859_8 is not set
+ + # CONFIG_NLS_CODEPAGE_1250 is not set
+ + # CONFIG_NLS_CODEPAGE_1251 is not set
+ + # CONFIG_NLS_ASCII is not set
+ + CONFIG_NLS_ISO8859_1=y
+ + # CONFIG_NLS_ISO8859_2 is not set
+ + # CONFIG_NLS_ISO8859_3 is not set
+ + # CONFIG_NLS_ISO8859_4 is not set
+ + # CONFIG_NLS_ISO8859_5 is not set
+ + # CONFIG_NLS_ISO8859_6 is not set
+ + # CONFIG_NLS_ISO8859_7 is not set
+ + # CONFIG_NLS_ISO8859_9 is not set
+ + # CONFIG_NLS_ISO8859_13 is not set
+ + # CONFIG_NLS_ISO8859_14 is not set
+ + # CONFIG_NLS_ISO8859_15 is not set
+ + # CONFIG_NLS_KOI8_R is not set
+ + # CONFIG_NLS_KOI8_U is not set
+ + # CONFIG_NLS_UTF8 is not set
+ + # CONFIG_DLM is not set
+ + 
+ + #
+ + # Kernel hacking
+ + #
+ + # CONFIG_PRINTK_TIME is not set
+ + CONFIG_ENABLE_WARN_DEPRECATED=y
+ + CONFIG_ENABLE_MUST_CHECK=y
+ + CONFIG_FRAME_WARN=1024
+ + # CONFIG_MAGIC_SYSRQ is not set
+ + # CONFIG_UNUSED_SYMBOLS is not set
+ + # CONFIG_DEBUG_FS is not set
+ + # CONFIG_HEADERS_CHECK is not set
+ + CONFIG_DEBUG_KERNEL=y
+ + # CONFIG_DEBUG_SHIRQ is not set
+ + CONFIG_DETECT_SOFTLOCKUP=y
+ + # CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+ + CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+ + CONFIG_SCHED_DEBUG=y
+ + # CONFIG_SCHEDSTATS is not set
+ + # CONFIG_TIMER_STATS is not set
+ + # CONFIG_DEBUG_OBJECTS is not set
+ + # CONFIG_DEBUG_SLAB is not set
+ + CONFIG_DEBUG_PREEMPT=y
+ + # CONFIG_DEBUG_RT_MUTEXES is not set
+ + # CONFIG_RT_MUTEX_TESTER is not set
+ + # CONFIG_DEBUG_SPINLOCK is not set
+ + CONFIG_DEBUG_MUTEXES=y
+ + # CONFIG_DEBUG_LOCK_ALLOC is not set
+ + # CONFIG_PROVE_LOCKING is not set
+ + # CONFIG_LOCK_STAT is not set
+ + # CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+ + # CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+ + # CONFIG_DEBUG_KOBJECT is not set
+ + # CONFIG_DEBUG_BUGVERBOSE is not set
+ + # CONFIG_DEBUG_INFO is not set
+ + # CONFIG_DEBUG_VM is not set
+ + # CONFIG_DEBUG_WRITECOUNT is not set
+ + # CONFIG_DEBUG_MEMORY_INIT is not set
+ + # CONFIG_DEBUG_LIST is not set
+ + # CONFIG_DEBUG_SG is not set
+ + # CONFIG_DEBUG_NOTIFIERS is not set
+ + CONFIG_FRAME_POINTER=y
+ + # CONFIG_BOOT_PRINTK_DELAY is not set
+ + # CONFIG_RCU_TORTURE_TEST is not set
+ + # CONFIG_BACKTRACE_SELF_TEST is not set
+ + # CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+ + # CONFIG_FAULT_INJECTION is not set
+ + # CONFIG_LATENCYTOP is not set
+ + # CONFIG_SYSCTL_SYSCALL_CHECK is not set
+ + CONFIG_HAVE_FUNCTION_TRACER=y
+ + 
+ + #
+ + # Tracers
+ + #
+ + # CONFIG_FUNCTION_TRACER is not set
+ + # CONFIG_IRQSOFF_TRACER is not set
+ + # CONFIG_PREEMPT_TRACER is not set
+ + # CONFIG_SCHED_TRACER is not set
+ + # CONFIG_CONTEXT_SWITCH_TRACER is not set
+ + # CONFIG_BOOT_TRACER is not set
+ + # CONFIG_TRACE_BRANCH_PROFILING is not set
+ + # CONFIG_STACK_TRACER is not set
+ + # CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+ + # CONFIG_SAMPLES is not set
+ + CONFIG_HAVE_ARCH_KGDB=y
+ + # CONFIG_KGDB is not set
+ + # CONFIG_DEBUG_USER is not set
+ + # CONFIG_DEBUG_ERRORS is not set
+ + # CONFIG_DEBUG_STACK_USAGE is not set
+ + CONFIG_DEBUG_LL=y
+ + # CONFIG_DEBUG_ICEDCC is not set
+ + 
+ + #
+ + # Security options
+ + #
+ + # CONFIG_KEYS is not set
+ + # CONFIG_SECURITY is not set
+ + # CONFIG_SECURITYFS is not set
+ + # CONFIG_SECURITY_FILE_CAPABILITIES is not set
+ + CONFIG_CRYPTO=y
+ + 
+ + #
+ + # Crypto core or helper
+ + #
+ + # CONFIG_CRYPTO_FIPS is not set
+ + CONFIG_CRYPTO_ALGAPI=y
+ + CONFIG_CRYPTO_ALGAPI2=y
+ + CONFIG_CRYPTO_AEAD2=y
+ + CONFIG_CRYPTO_BLKCIPHER=y
+ + CONFIG_CRYPTO_BLKCIPHER2=y
+ + CONFIG_CRYPTO_HASH=y
+ + CONFIG_CRYPTO_HASH2=y
+ + CONFIG_CRYPTO_RNG2=y
+ + CONFIG_CRYPTO_MANAGER=y
+ + CONFIG_CRYPTO_MANAGER2=y
+ + # CONFIG_CRYPTO_GF128MUL is not set
+ + # CONFIG_CRYPTO_NULL is not set
+ + # CONFIG_CRYPTO_CRYPTD is not set
+ + # CONFIG_CRYPTO_AUTHENC is not set
+ + # CONFIG_CRYPTO_TEST is not set
+ + 
+ + #
+ + # Authenticated Encryption with Associated Data
+ + #
+ + # CONFIG_CRYPTO_CCM is not set
+ + # CONFIG_CRYPTO_GCM is not set
+ + # CONFIG_CRYPTO_SEQIV is not set
+ + 
+ + #
+ + # Block modes
+ + #
+ + # CONFIG_CRYPTO_CBC is not set
+ + # CONFIG_CRYPTO_CTR is not set
+ + # CONFIG_CRYPTO_CTS is not set
+ + CONFIG_CRYPTO_ECB=y
+ + # CONFIG_CRYPTO_LRW is not set
+ + # CONFIG_CRYPTO_PCBC is not set
+ + # CONFIG_CRYPTO_XTS is not set
+ + 
+ + #
+ + # Hash modes
+ + #
+ + # CONFIG_CRYPTO_HMAC is not set
+ + # CONFIG_CRYPTO_XCBC is not set
+ + 
+ + #
+ + # Digest
+ + #
+ + CONFIG_CRYPTO_CRC32C=y
+ + # CONFIG_CRYPTO_MD4 is not set
+ + # CONFIG_CRYPTO_MD5 is not set
+ + # CONFIG_CRYPTO_MICHAEL_MIC is not set
+ + # CONFIG_CRYPTO_RMD128 is not set
+ + # CONFIG_CRYPTO_RMD160 is not set
+ + # CONFIG_CRYPTO_RMD256 is not set
+ + # CONFIG_CRYPTO_RMD320 is not set
+ + CONFIG_CRYPTO_SHA1=y
+ + # CONFIG_CRYPTO_SHA256 is not set
+ + # CONFIG_CRYPTO_SHA512 is not set
+ + # CONFIG_CRYPTO_TGR192 is not set
+ + # CONFIG_CRYPTO_WP512 is not set
+ + 
+ + #
+ + # Ciphers
+ + #
+ + CONFIG_CRYPTO_AES=y
+ + # CONFIG_CRYPTO_ANUBIS is not set
+ + CONFIG_CRYPTO_ARC4=y
+ + # CONFIG_CRYPTO_BLOWFISH is not set
+ + # CONFIG_CRYPTO_CAMELLIA is not set
+ + # CONFIG_CRYPTO_CAST5 is not set
+ + # CONFIG_CRYPTO_CAST6 is not set
+ + # CONFIG_CRYPTO_DES is not set
+ + # CONFIG_CRYPTO_FCRYPT is not set
+ + # CONFIG_CRYPTO_KHAZAD is not set
+ + # CONFIG_CRYPTO_SALSA20 is not set
+ + # CONFIG_CRYPTO_SEED is not set
+ + # CONFIG_CRYPTO_SERPENT is not set
+ + # CONFIG_CRYPTO_TEA is not set
+ + # CONFIG_CRYPTO_TWOFISH is not set
+ + 
+ + #
+ + # Compression
+ + #
+ + # CONFIG_CRYPTO_DEFLATE is not set
+ + # CONFIG_CRYPTO_LZO is not set
+ + 
+ + #
+ + # Random Number Generation
+ + #
+ + # CONFIG_CRYPTO_ANSI_CPRNG is not set
+ + CONFIG_CRYPTO_HW=y
+ + 
+ + #
+ + # Library routines
+ + #
+ + CONFIG_BITREVERSE=y
+ + CONFIG_GENERIC_FIND_LAST_BIT=y
+ + CONFIG_CRC_CCITT=y
+ + CONFIG_CRC16=y
+ + # CONFIG_CRC_T10DIF is not set
+ + CONFIG_CRC_ITU_T=y
+ + CONFIG_CRC32=y
+ + # CONFIG_CRC7 is not set
+ + CONFIG_LIBCRC32C=y
+ + CONFIG_ZLIB_INFLATE=y
+ + CONFIG_ZLIB_DEFLATE=y
+ + CONFIG_PLIST=y
+ + CONFIG_HAS_IOMEM=y
+ + CONFIG_HAS_IOPORT=y
+ + CONFIG_HAS_DMA=y
+ diff --exclude=.svn -r -C3 -P linux-2.6.29.4/Makefile liab-linux-2.6.29.4/Makefile
+ *** linux-2.6.29.4/Makefile	2009-05-19 01:52:34.000000000 +0200
+ --- liab-linux-2.6.29.4/Makefile	2009-07-31 11:44:04.000000000 +0200
+ ***************
+ *** 190,197 ****
+   # Default value for CROSS_COMPILE is not to prefix executables
+   # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
+   export KBUILD_BUILDHOST := $(SUBARCH)
+ ! ARCH		?= $(SUBARCH)
+ ! CROSS_COMPILE	?=
+   
+   # Architecture as present in compile.h
+   UTS_MACHINE 	:= $(ARCH)
+ --- 190,198 ----
+   # Default value for CROSS_COMPILE is not to prefix executables
+   # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
+   export KBUILD_BUILDHOST := $(SUBARCH)
+ ! #ARCH		?= $(SUBARCH)
+ ! ARCH		?= arm
+ ! CROSS_COMPILE	?= arm-unknown-linux-gnu-
+   
+   # Architecture as present in compile.h
+   UTS_MACHINE 	:= $(ARCH)
diff -r -C3 -P linux-2.6.29.4/Makefile liab-linux-2.6.29.4/Makefile
*** linux-2.6.29.4/Makefile	2009-05-19 01:52:34.000000000 +0200
--- liab-linux-2.6.29.4/Makefile	2012-01-20 14:49:42.829307094 +0100
***************
*** 1,3 ****
--- 1,7 ----
+ 
+ # LED Core
+ obj-$(CONFIG_LIAB)			+= liab.o
+ 
  VERSION = 2
  PATCHLEVEL = 6
  SUBLEVEL = 29
***************
*** 190,197 ****
  # Default value for CROSS_COMPILE is not to prefix executables
  # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
  export KBUILD_BUILDHOST := $(SUBARCH)
! ARCH		?= $(SUBARCH)
! CROSS_COMPILE	?=
  
  # Architecture as present in compile.h
  UTS_MACHINE 	:= $(ARCH)
--- 194,202 ----
  # Default value for CROSS_COMPILE is not to prefix executables
  # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
  export KBUILD_BUILDHOST := $(SUBARCH)
! #ARCH		?= $(SUBARCH)
! ARCH		?= arm
! CROSS_COMPILE	?= arm-unknown-linux-gnu-
  
  # Architecture as present in compile.h
  UTS_MACHINE 	:= $(ARCH)
Binary files linux-2.6.29.4/scripts/basic/docproc and liab-linux-2.6.29.4/scripts/basic/docproc differ
diff -r -C3 -P linux-2.6.29.4/scripts/basic/.docproc.cmd liab-linux-2.6.29.4/scripts/basic/.docproc.cmd
*** linux-2.6.29.4/scripts/basic/.docproc.cmd	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/scripts/basic/.docproc.cmd	2012-04-03 14:03:06.592517062 +0200
***************
*** 0 ****
--- 1,72 ----
+ cmd_scripts/basic/docproc := gcc -Wp,-MD,scripts/basic/.docproc.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer     -o scripts/basic/docproc scripts/basic/docproc.c  
+ 
+ deps_scripts/basic/docproc := \
+   scripts/basic/docproc.c \
+   /usr/include/stdio.h \
+   /usr/include/features.h \
+   /usr/include/x86_64-linux-gnu/bits/predefs.h \
+   /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+   /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+   /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+   /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+   /usr/lib/gcc/x86_64-linux-gnu/4.6.1/include/stddef.h \
+   /usr/include/x86_64-linux-gnu/bits/types.h \
+   /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+   /usr/include/libio.h \
+   /usr/include/_G_config.h \
+   /usr/include/wchar.h \
+   /usr/lib/gcc/x86_64-linux-gnu/4.6.1/include/stdarg.h \
+   /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+   /usr/include/x86_64-linux-gnu/bits/sys_errlist.h \
+   /usr/include/x86_64-linux-gnu/bits/stdio.h \
+   /usr/include/x86_64-linux-gnu/bits/stdio2.h \
+   /usr/include/stdlib.h \
+   /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+   /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+   /usr/include/endian.h \
+   /usr/include/x86_64-linux-gnu/bits/endian.h \
+   /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+   /usr/include/x86_64-linux-gnu/sys/types.h \
+   /usr/include/time.h \
+   /usr/include/x86_64-linux-gnu/sys/select.h \
+   /usr/include/x86_64-linux-gnu/bits/select.h \
+   /usr/include/x86_64-linux-gnu/bits/sigset.h \
+   /usr/include/x86_64-linux-gnu/bits/time.h \
+   /usr/include/x86_64-linux-gnu/sys/sysmacros.h \
+   /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+   /usr/include/alloca.h \
+   /usr/include/x86_64-linux-gnu/bits/stdlib.h \
+   /usr/include/string.h \
+   /usr/include/xlocale.h \
+   /usr/include/x86_64-linux-gnu/bits/string.h \
+   /usr/include/x86_64-linux-gnu/bits/string2.h \
+   /usr/include/x86_64-linux-gnu/bits/string3.h \
+   /usr/include/ctype.h \
+   /usr/include/unistd.h \
+   /usr/include/x86_64-linux-gnu/bits/posix_opt.h \
+   /usr/include/x86_64-linux-gnu/bits/environments.h \
+   /usr/include/x86_64-linux-gnu/bits/confname.h \
+   /usr/include/getopt.h \
+   /usr/include/x86_64-linux-gnu/bits/unistd.h \
+   /usr/lib/gcc/x86_64-linux-gnu/4.6.1/include-fixed/limits.h \
+   /usr/lib/gcc/x86_64-linux-gnu/4.6.1/include-fixed/syslimits.h \
+   /usr/include/limits.h \
+   /usr/include/x86_64-linux-gnu/bits/posix1_lim.h \
+   /usr/include/x86_64-linux-gnu/bits/local_lim.h \
+   /usr/include/linux/limits.h \
+   /usr/include/x86_64-linux-gnu/bits/posix2_lim.h \
+   /usr/include/x86_64-linux-gnu/sys/wait.h \
+   /usr/include/signal.h \
+   /usr/include/x86_64-linux-gnu/bits/signum.h \
+   /usr/include/x86_64-linux-gnu/bits/siginfo.h \
+   /usr/include/x86_64-linux-gnu/bits/sigaction.h \
+   /usr/include/x86_64-linux-gnu/bits/sigcontext.h \
+   /usr/include/x86_64-linux-gnu/bits/sigstack.h \
+   /usr/include/x86_64-linux-gnu/sys/ucontext.h \
+   /usr/include/x86_64-linux-gnu/bits/sigthread.h \
+   /usr/include/x86_64-linux-gnu/sys/resource.h \
+   /usr/include/x86_64-linux-gnu/bits/resource.h \
+ 
+ scripts/basic/docproc: $(deps_scripts/basic/docproc)
+ 
+ $(deps_scripts/basic/docproc):
Binary files linux-2.6.29.4/scripts/basic/fixdep and liab-linux-2.6.29.4/scripts/basic/fixdep differ
diff -r -C3 -P linux-2.6.29.4/scripts/basic/.fixdep.cmd liab-linux-2.6.29.4/scripts/basic/.fixdep.cmd
*** linux-2.6.29.4/scripts/basic/.fixdep.cmd	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/scripts/basic/.fixdep.cmd	2012-04-03 14:03:06.444517066 +0200
***************
*** 0 ****
--- 1,89 ----
+ cmd_scripts/basic/fixdep := gcc -Wp,-MD,scripts/basic/.fixdep.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer     -o scripts/basic/fixdep scripts/basic/fixdep.c  
+ 
+ deps_scripts/basic/fixdep := \
+   scripts/basic/fixdep.c \
+     $(wildcard include/config/his/driver.h) \
+     $(wildcard include/config/my/option.h) \
+     $(wildcard include/config/.h) \
+     $(wildcard include/config/foo.h) \
+     $(wildcard include/config/boom.h) \
+   /usr/include/x86_64-linux-gnu/sys/types.h \
+   /usr/include/features.h \
+   /usr/include/x86_64-linux-gnu/bits/predefs.h \
+   /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+   /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+   /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+   /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+   /usr/include/x86_64-linux-gnu/bits/types.h \
+   /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+   /usr/include/time.h \
+   /usr/lib/gcc/x86_64-linux-gnu/4.6.1/include/stddef.h \
+   /usr/include/endian.h \
+   /usr/include/x86_64-linux-gnu/bits/endian.h \
+   /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+   /usr/include/x86_64-linux-gnu/sys/select.h \
+   /usr/include/x86_64-linux-gnu/bits/select.h \
+   /usr/include/x86_64-linux-gnu/bits/sigset.h \
+   /usr/include/x86_64-linux-gnu/bits/time.h \
+   /usr/include/x86_64-linux-gnu/sys/sysmacros.h \
+   /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+   /usr/include/x86_64-linux-gnu/sys/stat.h \
+   /usr/include/x86_64-linux-gnu/bits/stat.h \
+   /usr/include/x86_64-linux-gnu/sys/mman.h \
+   /usr/include/x86_64-linux-gnu/bits/mman.h \
+   /usr/include/unistd.h \
+   /usr/include/x86_64-linux-gnu/bits/posix_opt.h \
+   /usr/include/x86_64-linux-gnu/bits/environments.h \
+   /usr/include/x86_64-linux-gnu/bits/confname.h \
+   /usr/include/getopt.h \
+   /usr/include/x86_64-linux-gnu/bits/unistd.h \
+   /usr/include/fcntl.h \
+   /usr/include/x86_64-linux-gnu/bits/fcntl.h \
+   /usr/include/x86_64-linux-gnu/bits/fcntl2.h \
+   /usr/include/string.h \
+   /usr/include/xlocale.h \
+   /usr/include/x86_64-linux-gnu/bits/string.h \
+   /usr/include/x86_64-linux-gnu/bits/string2.h \
+   /usr/include/stdlib.h \
+   /usr/include/x86_64-linux-gnu/bits/string3.h \
+   /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+   /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+   /usr/include/alloca.h \
+   /usr/include/x86_64-linux-gnu/bits/stdlib.h \
+   /usr/include/stdio.h \
+   /usr/include/libio.h \
+   /usr/include/_G_config.h \
+   /usr/include/wchar.h \
+   /usr/lib/gcc/x86_64-linux-gnu/4.6.1/include/stdarg.h \
+   /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+   /usr/include/x86_64-linux-gnu/bits/sys_errlist.h \
+   /usr/include/x86_64-linux-gnu/bits/stdio.h \
+   /usr/include/x86_64-linux-gnu/bits/stdio2.h \
+   /usr/lib/gcc/x86_64-linux-gnu/4.6.1/include-fixed/limits.h \
+   /usr/lib/gcc/x86_64-linux-gnu/4.6.1/include-fixed/syslimits.h \
+   /usr/include/limits.h \
+   /usr/include/x86_64-linux-gnu/bits/posix1_lim.h \
+   /usr/include/x86_64-linux-gnu/bits/local_lim.h \
+   /usr/include/linux/limits.h \
+   /usr/include/x86_64-linux-gnu/bits/posix2_lim.h \
+   /usr/include/ctype.h \
+   /usr/include/arpa/inet.h \
+   /usr/include/netinet/in.h \
+   /usr/lib/gcc/x86_64-linux-gnu/4.6.1/include/stdint.h \
+   /usr/include/stdint.h \
+   /usr/include/x86_64-linux-gnu/bits/wchar.h \
+   /usr/include/x86_64-linux-gnu/sys/socket.h \
+   /usr/include/x86_64-linux-gnu/sys/uio.h \
+   /usr/include/x86_64-linux-gnu/bits/uio.h \
+   /usr/include/x86_64-linux-gnu/bits/socket.h \
+   /usr/include/x86_64-linux-gnu/bits/sockaddr.h \
+   /usr/include/x86_64-linux-gnu/asm/socket.h \
+   /usr/include/asm-generic/socket.h \
+   /usr/include/x86_64-linux-gnu/asm/sockios.h \
+   /usr/include/asm-generic/sockios.h \
+   /usr/include/x86_64-linux-gnu/bits/socket2.h \
+   /usr/include/x86_64-linux-gnu/bits/in.h \
+ 
+ scripts/basic/fixdep: $(deps_scripts/basic/fixdep)
+ 
+ $(deps_scripts/basic/fixdep):
Binary files linux-2.6.29.4/scripts/basic/hash and liab-linux-2.6.29.4/scripts/basic/hash differ
diff -r -C3 -P linux-2.6.29.4/scripts/basic/.hash.cmd liab-linux-2.6.29.4/scripts/basic/.hash.cmd
*** linux-2.6.29.4/scripts/basic/.hash.cmd	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/scripts/basic/.hash.cmd	2012-04-03 14:03:06.664517060 +0200
***************
*** 0 ****
--- 1,47 ----
+ cmd_scripts/basic/hash := gcc -Wp,-MD,scripts/basic/.hash.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer     -o scripts/basic/hash scripts/basic/hash.c  
+ 
+ deps_scripts/basic/hash := \
+   scripts/basic/hash.c \
+   /usr/include/stdio.h \
+   /usr/include/features.h \
+   /usr/include/x86_64-linux-gnu/bits/predefs.h \
+   /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+   /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+   /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+   /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+   /usr/lib/gcc/x86_64-linux-gnu/4.6.1/include/stddef.h \
+   /usr/include/x86_64-linux-gnu/bits/types.h \
+   /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+   /usr/include/libio.h \
+   /usr/include/_G_config.h \
+   /usr/include/wchar.h \
+   /usr/lib/gcc/x86_64-linux-gnu/4.6.1/include/stdarg.h \
+   /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+   /usr/include/x86_64-linux-gnu/bits/sys_errlist.h \
+   /usr/include/x86_64-linux-gnu/bits/stdio.h \
+   /usr/include/x86_64-linux-gnu/bits/stdio2.h \
+   /usr/include/stdlib.h \
+   /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+   /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+   /usr/include/endian.h \
+   /usr/include/x86_64-linux-gnu/bits/endian.h \
+   /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+   /usr/include/x86_64-linux-gnu/sys/types.h \
+   /usr/include/time.h \
+   /usr/include/x86_64-linux-gnu/sys/select.h \
+   /usr/include/x86_64-linux-gnu/bits/select.h \
+   /usr/include/x86_64-linux-gnu/bits/sigset.h \
+   /usr/include/x86_64-linux-gnu/bits/time.h \
+   /usr/include/x86_64-linux-gnu/sys/sysmacros.h \
+   /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+   /usr/include/alloca.h \
+   /usr/include/x86_64-linux-gnu/bits/stdlib.h \
+   /usr/include/string.h \
+   /usr/include/xlocale.h \
+   /usr/include/x86_64-linux-gnu/bits/string.h \
+   /usr/include/x86_64-linux-gnu/bits/string2.h \
+   /usr/include/x86_64-linux-gnu/bits/string3.h \
+ 
+ scripts/basic/hash: $(deps_scripts/basic/hash)
+ 
+ $(deps_scripts/basic/hash):
Binary files linux-2.6.29.4/scripts/kconfig/conf and liab-linux-2.6.29.4/scripts/kconfig/conf differ
diff -r -C3 -P linux-2.6.29.4/scripts/kconfig/.conf.cmd liab-linux-2.6.29.4/scripts/kconfig/.conf.cmd
*** linux-2.6.29.4/scripts/kconfig/.conf.cmd	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/scripts/kconfig/.conf.cmd	2012-04-03 14:03:08.300517016 +0200
***************
*** 0 ****
--- 1 ----
+ cmd_scripts/kconfig/conf := gcc  -o scripts/kconfig/conf scripts/kconfig/conf.o scripts/kconfig/zconf.tab.o -lncurses 
Binary files linux-2.6.29.4/scripts/kconfig/conf.o and liab-linux-2.6.29.4/scripts/kconfig/conf.o differ
diff -r -C3 -P linux-2.6.29.4/scripts/kconfig/.conf.o.cmd liab-linux-2.6.29.4/scripts/kconfig/.conf.o.cmd
*** linux-2.6.29.4/scripts/kconfig/.conf.o.cmd	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/scripts/kconfig/.conf.o.cmd	2012-04-03 14:03:06.964517052 +0200
***************
*** 0 ****
--- 1,67 ----
+ cmd_scripts/kconfig/conf.o := gcc -Wp,-MD,scripts/kconfig/.conf.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -DCURSES_LOC="<ncurses.h>" -DLOCALE   -c -o scripts/kconfig/conf.o scripts/kconfig/conf.c
+ 
+ deps_scripts/kconfig/conf.o := \
+   scripts/kconfig/conf.c \
+     $(wildcard include/config/allconfig.h) \
+     $(wildcard include/config/nosilentupdate.h) \
+   /usr/include/locale.h \
+   /usr/include/features.h \
+   /usr/include/x86_64-linux-gnu/bits/predefs.h \
+   /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+   /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+   /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+   /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+   /usr/lib/gcc/x86_64-linux-gnu/4.6.1/include/stddef.h \
+   /usr/include/x86_64-linux-gnu/bits/locale.h \
+   /usr/include/xlocale.h \
+   /usr/include/ctype.h \
+   /usr/include/x86_64-linux-gnu/bits/types.h \
+   /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+   /usr/include/endian.h \
+   /usr/include/x86_64-linux-gnu/bits/endian.h \
+   /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+   /usr/include/stdio.h \
+   /usr/include/libio.h \
+   /usr/include/_G_config.h \
+   /usr/include/wchar.h \
+   /usr/lib/gcc/x86_64-linux-gnu/4.6.1/include/stdarg.h \
+   /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+   /usr/include/x86_64-linux-gnu/bits/sys_errlist.h \
+   /usr/include/x86_64-linux-gnu/bits/stdio.h \
+   /usr/include/x86_64-linux-gnu/bits/stdio2.h \
+   /usr/include/stdlib.h \
+   /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+   /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+   /usr/include/x86_64-linux-gnu/sys/types.h \
+   /usr/include/time.h \
+   /usr/include/x86_64-linux-gnu/sys/select.h \
+   /usr/include/x86_64-linux-gnu/bits/select.h \
+   /usr/include/x86_64-linux-gnu/bits/sigset.h \
+   /usr/include/x86_64-linux-gnu/bits/time.h \
+   /usr/include/x86_64-linux-gnu/sys/sysmacros.h \
+   /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+   /usr/include/alloca.h \
+   /usr/include/x86_64-linux-gnu/bits/stdlib.h \
+   /usr/include/string.h \
+   /usr/include/x86_64-linux-gnu/bits/string.h \
+   /usr/include/x86_64-linux-gnu/bits/string2.h \
+   /usr/include/x86_64-linux-gnu/bits/string3.h \
+   /usr/include/unistd.h \
+   /usr/include/x86_64-linux-gnu/bits/posix_opt.h \
+   /usr/include/x86_64-linux-gnu/bits/environments.h \
+   /usr/include/x86_64-linux-gnu/bits/confname.h \
+   /usr/include/getopt.h \
+   /usr/include/x86_64-linux-gnu/bits/unistd.h \
+   /usr/include/x86_64-linux-gnu/sys/stat.h \
+   /usr/include/x86_64-linux-gnu/bits/stat.h \
+   /usr/include/x86_64-linux-gnu/sys/time.h \
+   scripts/kconfig/lkc.h \
+     $(wildcard include/config/list.h) \
+   scripts/kconfig/expr.h \
+   /usr/lib/gcc/x86_64-linux-gnu/4.6.1/include/stdbool.h \
+   /usr/include/libintl.h \
+   scripts/kconfig/lkc_proto.h \
+ 
+ scripts/kconfig/conf.o: $(deps_scripts/kconfig/conf.o)
+ 
+ $(deps_scripts/kconfig/conf.o):
Binary files linux-2.6.29.4/scripts/kconfig/kxgettext.o and liab-linux-2.6.29.4/scripts/kconfig/kxgettext.o differ
diff -r -C3 -P linux-2.6.29.4/scripts/kconfig/.kxgettext.o.cmd liab-linux-2.6.29.4/scripts/kconfig/.kxgettext.o.cmd
*** linux-2.6.29.4/scripts/kconfig/.kxgettext.o.cmd	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/scripts/kconfig/.kxgettext.o.cmd	2012-04-03 14:03:07.172517046 +0200
***************
*** 0 ****
--- 1,55 ----
+ cmd_scripts/kconfig/kxgettext.o := gcc -Wp,-MD,scripts/kconfig/.kxgettext.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -DCURSES_LOC="<ncurses.h>" -DLOCALE   -c -o scripts/kconfig/kxgettext.o scripts/kconfig/kxgettext.c
+ 
+ deps_scripts/kconfig/kxgettext.o := \
+   scripts/kconfig/kxgettext.c \
+   /usr/include/stdlib.h \
+   /usr/include/features.h \
+   /usr/include/x86_64-linux-gnu/bits/predefs.h \
+   /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+   /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+   /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+   /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+   /usr/lib/gcc/x86_64-linux-gnu/4.6.1/include/stddef.h \
+   /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+   /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+   /usr/include/endian.h \
+   /usr/include/x86_64-linux-gnu/bits/endian.h \
+   /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+   /usr/include/x86_64-linux-gnu/sys/types.h \
+   /usr/include/x86_64-linux-gnu/bits/types.h \
+   /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+   /usr/include/time.h \
+   /usr/include/x86_64-linux-gnu/sys/select.h \
+   /usr/include/x86_64-linux-gnu/bits/select.h \
+   /usr/include/x86_64-linux-gnu/bits/sigset.h \
+   /usr/include/x86_64-linux-gnu/bits/time.h \
+   /usr/include/x86_64-linux-gnu/sys/sysmacros.h \
+   /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+   /usr/include/alloca.h \
+   /usr/include/x86_64-linux-gnu/bits/stdlib.h \
+   /usr/include/string.h \
+   /usr/include/xlocale.h \
+   /usr/include/x86_64-linux-gnu/bits/string.h \
+   /usr/include/x86_64-linux-gnu/bits/string2.h \
+   /usr/include/x86_64-linux-gnu/bits/string3.h \
+   scripts/kconfig/lkc.h \
+     $(wildcard include/config/list.h) \
+   scripts/kconfig/expr.h \
+   /usr/include/stdio.h \
+   /usr/include/libio.h \
+   /usr/include/_G_config.h \
+   /usr/include/wchar.h \
+   /usr/lib/gcc/x86_64-linux-gnu/4.6.1/include/stdarg.h \
+   /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+   /usr/include/x86_64-linux-gnu/bits/sys_errlist.h \
+   /usr/include/x86_64-linux-gnu/bits/stdio.h \
+   /usr/include/x86_64-linux-gnu/bits/stdio2.h \
+   /usr/lib/gcc/x86_64-linux-gnu/4.6.1/include/stdbool.h \
+   /usr/include/libintl.h \
+   /usr/include/locale.h \
+   /usr/include/x86_64-linux-gnu/bits/locale.h \
+   scripts/kconfig/lkc_proto.h \
+ 
+ scripts/kconfig/kxgettext.o: $(deps_scripts/kconfig/kxgettext.o)
+ 
+ $(deps_scripts/kconfig/kxgettext.o):
diff -r -C3 -P linux-2.6.29.4/scripts/kconfig/lex.zconf.c liab-linux-2.6.29.4/scripts/kconfig/lex.zconf.c
*** linux-2.6.29.4/scripts/kconfig/lex.zconf.c	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/scripts/kconfig/lex.zconf.c	2012-04-03 14:03:07.176517046 +0200
***************
*** 0 ****
--- 1,2416 ----
+ 
+ #line 3 "scripts/kconfig/lex.zconf.c"
+ 
+ #define  YY_INT_ALIGNED short int
+ 
+ /* A lexical scanner generated by flex */
+ 
+ #define yy_create_buffer zconf_create_buffer
+ #define yy_delete_buffer zconf_delete_buffer
+ #define yy_flex_debug zconf_flex_debug
+ #define yy_init_buffer zconf_init_buffer
+ #define yy_flush_buffer zconf_flush_buffer
+ #define yy_load_buffer_state zconf_load_buffer_state
+ #define yy_switch_to_buffer zconf_switch_to_buffer
+ #define yyin zconfin
+ #define yyleng zconfleng
+ #define yylex zconflex
+ #define yylineno zconflineno
+ #define yyout zconfout
+ #define yyrestart zconfrestart
+ #define yytext zconftext
+ #define yywrap zconfwrap
+ #define yyalloc zconfalloc
+ #define yyrealloc zconfrealloc
+ #define yyfree zconffree
+ 
+ #define FLEX_SCANNER
+ #define YY_FLEX_MAJOR_VERSION 2
+ #define YY_FLEX_MINOR_VERSION 5
+ #define YY_FLEX_SUBMINOR_VERSION 35
+ #if YY_FLEX_SUBMINOR_VERSION > 0
+ #define FLEX_BETA
+ #endif
+ 
+ /* First, we deal with  platform-specific or compiler-specific issues. */
+ 
+ /* begin standard C headers. */
+ #include <stdio.h>
+ #include <string.h>
+ #include <errno.h>
+ #include <stdlib.h>
+ 
+ /* end standard C headers. */
+ 
+ /* flex integer type definitions */
+ 
+ #ifndef FLEXINT_H
+ #define FLEXINT_H
+ 
+ /* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+ 
+ #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+ 
+ /* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+  * if you want the limit (max/min) macros for int types. 
+  */
+ #ifndef __STDC_LIMIT_MACROS
+ #define __STDC_LIMIT_MACROS 1
+ #endif
+ 
+ #include <inttypes.h>
+ typedef int8_t flex_int8_t;
+ typedef uint8_t flex_uint8_t;
+ typedef int16_t flex_int16_t;
+ typedef uint16_t flex_uint16_t;
+ typedef int32_t flex_int32_t;
+ typedef uint32_t flex_uint32_t;
+ #else
+ typedef signed char flex_int8_t;
+ typedef short int flex_int16_t;
+ typedef int flex_int32_t;
+ typedef unsigned char flex_uint8_t; 
+ typedef unsigned short int flex_uint16_t;
+ typedef unsigned int flex_uint32_t;
+ 
+ /* Limits of integral types. */
+ #ifndef INT8_MIN
+ #define INT8_MIN               (-128)
+ #endif
+ #ifndef INT16_MIN
+ #define INT16_MIN              (-32767-1)
+ #endif
+ #ifndef INT32_MIN
+ #define INT32_MIN              (-2147483647-1)
+ #endif
+ #ifndef INT8_MAX
+ #define INT8_MAX               (127)
+ #endif
+ #ifndef INT16_MAX
+ #define INT16_MAX              (32767)
+ #endif
+ #ifndef INT32_MAX
+ #define INT32_MAX              (2147483647)
+ #endif
+ #ifndef UINT8_MAX
+ #define UINT8_MAX              (255U)
+ #endif
+ #ifndef UINT16_MAX
+ #define UINT16_MAX             (65535U)
+ #endif
+ #ifndef UINT32_MAX
+ #define UINT32_MAX             (4294967295U)
+ #endif
+ 
+ #endif /* ! C99 */
+ 
+ #endif /* ! FLEXINT_H */
+ 
+ #ifdef __cplusplus
+ 
+ /* The "const" storage-class-modifier is valid. */
+ #define YY_USE_CONST
+ 
+ #else	/* ! __cplusplus */
+ 
+ /* C99 requires __STDC__ to be defined as 1. */
+ #if defined (__STDC__)
+ 
+ #define YY_USE_CONST
+ 
+ #endif	/* defined (__STDC__) */
+ #endif	/* ! __cplusplus */
+ 
+ #ifdef YY_USE_CONST
+ #define yyconst const
+ #else
+ #define yyconst
+ #endif
+ 
+ /* Returned upon end-of-file. */
+ #define YY_NULL 0
+ 
+ /* Promotes a possibly negative, possibly signed char to an unsigned
+  * integer for use as an array index.  If the signed char is negative,
+  * we want to instead treat it as an 8-bit unsigned char, hence the
+  * double cast.
+  */
+ #define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+ 
+ /* Enter a start condition.  This macro really ought to take a parameter,
+  * but we do it the disgusting crufty way forced on us by the ()-less
+  * definition of BEGIN.
+  */
+ #define BEGIN (yy_start) = 1 + 2 *
+ 
+ /* Translate the current start state into a value that can be later handed
+  * to BEGIN to return to the state.  The YYSTATE alias is for lex
+  * compatibility.
+  */
+ #define YY_START (((yy_start) - 1) / 2)
+ #define YYSTATE YY_START
+ 
+ /* Action number for EOF rule of a given start state. */
+ #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+ 
+ /* Special action meaning "start processing a new file". */
+ #define YY_NEW_FILE zconfrestart(zconfin  )
+ 
+ #define YY_END_OF_BUFFER_CHAR 0
+ 
+ /* Size of default input buffer. */
+ #ifndef YY_BUF_SIZE
+ #define YY_BUF_SIZE 16384
+ #endif
+ 
+ /* The state buf must be large enough to hold one state per character in the main buffer.
+  */
+ #define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+ 
+ #ifndef YY_TYPEDEF_YY_BUFFER_STATE
+ #define YY_TYPEDEF_YY_BUFFER_STATE
+ typedef struct yy_buffer_state *YY_BUFFER_STATE;
+ #endif
+ 
+ extern int zconfleng;
+ 
+ extern FILE *zconfin, *zconfout;
+ 
+ #define EOB_ACT_CONTINUE_SCAN 0
+ #define EOB_ACT_END_OF_FILE 1
+ #define EOB_ACT_LAST_MATCH 2
+ 
+     #define YY_LESS_LINENO(n)
+     
+ /* Return all but the first "n" matched characters back to the input stream. */
+ #define yyless(n) \
+ 	do \
+ 		{ \
+ 		/* Undo effects of setting up zconftext. */ \
+         int yyless_macro_arg = (n); \
+         YY_LESS_LINENO(yyless_macro_arg);\
+ 		*yy_cp = (yy_hold_char); \
+ 		YY_RESTORE_YY_MORE_OFFSET \
+ 		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+ 		YY_DO_BEFORE_ACTION; /* set up zconftext again */ \
+ 		} \
+ 	while ( 0 )
+ 
+ #define unput(c) yyunput( c, (yytext_ptr)  )
+ 
+ #ifndef YY_TYPEDEF_YY_SIZE_T
+ #define YY_TYPEDEF_YY_SIZE_T
+ typedef size_t yy_size_t;
+ #endif
+ 
+ #ifndef YY_STRUCT_YY_BUFFER_STATE
+ #define YY_STRUCT_YY_BUFFER_STATE
+ struct yy_buffer_state
+ 	{
+ 	FILE *yy_input_file;
+ 
+ 	char *yy_ch_buf;		/* input buffer */
+ 	char *yy_buf_pos;		/* current position in input buffer */
+ 
+ 	/* Size of input buffer in bytes, not including room for EOB
+ 	 * characters.
+ 	 */
+ 	yy_size_t yy_buf_size;
+ 
+ 	/* Number of characters read into yy_ch_buf, not including EOB
+ 	 * characters.
+ 	 */
+ 	int yy_n_chars;
+ 
+ 	/* Whether we "own" the buffer - i.e., we know we created it,
+ 	 * and can realloc() it to grow it, and should free() it to
+ 	 * delete it.
+ 	 */
+ 	int yy_is_our_buffer;
+ 
+ 	/* Whether this is an "interactive" input source; if so, and
+ 	 * if we're using stdio for input, then we want to use getc()
+ 	 * instead of fread(), to make sure we stop fetching input after
+ 	 * each newline.
+ 	 */
+ 	int yy_is_interactive;
+ 
+ 	/* Whether we're considered to be at the beginning of a line.
+ 	 * If so, '^' rules will be active on the next match, otherwise
+ 	 * not.
+ 	 */
+ 	int yy_at_bol;
+ 
+     int yy_bs_lineno; /**< The line count. */
+     int yy_bs_column; /**< The column count. */
+     
+ 	/* Whether to try to fill the input buffer when we reach the
+ 	 * end of it.
+ 	 */
+ 	int yy_fill_buffer;
+ 
+ 	int yy_buffer_status;
+ 
+ #define YY_BUFFER_NEW 0
+ #define YY_BUFFER_NORMAL 1
+ 	/* When an EOF's been seen but there's still some text to process
+ 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+ 	 * shouldn't try reading from the input source any more.  We might
+ 	 * still have a bunch of tokens to match, though, because of
+ 	 * possible backing-up.
+ 	 *
+ 	 * When we actually see the EOF, we change the status to "new"
+ 	 * (via zconfrestart()), so that the user can continue scanning by
+ 	 * just pointing zconfin at a new input file.
+ 	 */
+ #define YY_BUFFER_EOF_PENDING 2
+ 
+ 	};
+ #endif /* !YY_STRUCT_YY_BUFFER_STATE */
+ 
+ /* Stack of input buffers. */
+ static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+ static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+ static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+ 
+ /* We provide macros for accessing buffer states in case in the
+  * future we want to put the buffer states in a more general
+  * "scanner state".
+  *
+  * Returns the top of the stack, or NULL.
+  */
+ #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                           : NULL)
+ 
+ /* Same as previous macro, but useful when we know that the buffer stack is not
+  * NULL or when we need an lvalue. For internal use only.
+  */
+ #define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+ 
+ /* yy_hold_char holds the character lost when zconftext is formed. */
+ static char yy_hold_char;
+ static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+ int zconfleng;
+ 
+ /* Points to current character in buffer. */
+ static char *yy_c_buf_p = (char *) 0;
+ static int yy_init = 0;		/* whether we need to initialize */
+ static int yy_start = 0;	/* start state number */
+ 
+ /* Flag which is used to allow zconfwrap()'s to do buffer switches
+  * instead of setting up a fresh zconfin.  A bit of a hack ...
+  */
+ static int yy_did_buffer_switch_on_eof;
+ 
+ void zconfrestart (FILE *input_file  );
+ void zconf_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+ YY_BUFFER_STATE zconf_create_buffer (FILE *file,int size  );
+ void zconf_delete_buffer (YY_BUFFER_STATE b  );
+ void zconf_flush_buffer (YY_BUFFER_STATE b  );
+ void zconfpush_buffer_state (YY_BUFFER_STATE new_buffer  );
+ void zconfpop_buffer_state (void );
+ 
+ static void zconfensure_buffer_stack (void );
+ static void zconf_load_buffer_state (void );
+ static void zconf_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+ 
+ #define YY_FLUSH_BUFFER zconf_flush_buffer(YY_CURRENT_BUFFER )
+ 
+ YY_BUFFER_STATE zconf_scan_buffer (char *base,yy_size_t size  );
+ YY_BUFFER_STATE zconf_scan_string (yyconst char *yy_str  );
+ YY_BUFFER_STATE zconf_scan_bytes (yyconst char *bytes,int len  );
+ 
+ void *zconfalloc (yy_size_t  );
+ void *zconfrealloc (void *,yy_size_t  );
+ void zconffree (void *  );
+ 
+ #define yy_new_buffer zconf_create_buffer
+ 
+ #define yy_set_interactive(is_interactive) \
+ 	{ \
+ 	if ( ! YY_CURRENT_BUFFER ){ \
+         zconfensure_buffer_stack (); \
+ 		YY_CURRENT_BUFFER_LVALUE =    \
+             zconf_create_buffer(zconfin,YY_BUF_SIZE ); \
+ 	} \
+ 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+ 	}
+ 
+ #define yy_set_bol(at_bol) \
+ 	{ \
+ 	if ( ! YY_CURRENT_BUFFER ){\
+         zconfensure_buffer_stack (); \
+ 		YY_CURRENT_BUFFER_LVALUE =    \
+             zconf_create_buffer(zconfin,YY_BUF_SIZE ); \
+ 	} \
+ 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+ 	}
+ 
+ #define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+ 
+ /* Begin user sect3 */
+ 
+ #define zconfwrap(n) 1
+ #define YY_SKIP_YYWRAP
+ 
+ typedef unsigned char YY_CHAR;
+ 
+ FILE *zconfin = (FILE *) 0, *zconfout = (FILE *) 0;
+ 
+ typedef int yy_state_type;
+ 
+ extern int zconflineno;
+ 
+ int zconflineno = 1;
+ 
+ extern char *zconftext;
+ #define yytext_ptr zconftext
+ static yyconst flex_int16_t yy_nxt[][17] =
+     {
+     {
+         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+         0,    0,    0,    0,    0,    0,    0
+     },
+ 
+     {
+        11,   12,   13,   14,   12,   12,   15,   12,   12,   12,
+        12,   12,   12,   12,   12,   12,   12
+     },
+ 
+     {
+        11,   12,   13,   14,   12,   12,   15,   12,   12,   12,
+        12,   12,   12,   12,   12,   12,   12
+     },
+ 
+     {
+        11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
+        16,   16,   16,   18,   16,   16,   16
+     },
+ 
+     {
+        11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
+        16,   16,   16,   18,   16,   16,   16
+ 
+     },
+ 
+     {
+        11,   19,   20,   21,   19,   19,   19,   19,   19,   19,
+        19,   19,   19,   19,   19,   19,   19
+     },
+ 
+     {
+        11,   19,   20,   21,   19,   19,   19,   19,   19,   19,
+        19,   19,   19,   19,   19,   19,   19
+     },
+ 
+     {
+        11,   22,   22,   23,   22,   24,   22,   22,   24,   22,
+        22,   22,   22,   22,   22,   25,   22
+     },
+ 
+     {
+        11,   22,   22,   23,   22,   24,   22,   22,   24,   22,
+        22,   22,   22,   22,   22,   25,   22
+     },
+ 
+     {
+        11,   26,   26,   27,   28,   29,   30,   31,   29,   32,
+        33,   34,   35,   35,   36,   37,   38
+ 
+     },
+ 
+     {
+        11,   26,   26,   27,   28,   29,   30,   31,   29,   32,
+        33,   34,   35,   35,   36,   37,   38
+     },
+ 
+     {
+       -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+       -11,  -11,  -11,  -11,  -11,  -11,  -11
+     },
+ 
+     {
+        11,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+       -12,  -12,  -12,  -12,  -12,  -12,  -12
+     },
+ 
+     {
+        11,  -13,   39,   40,  -13,  -13,   41,  -13,  -13,  -13,
+       -13,  -13,  -13,  -13,  -13,  -13,  -13
+     },
+ 
+     {
+        11,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+       -14,  -14,  -14,  -14,  -14,  -14,  -14
+ 
+     },
+ 
+     {
+        11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+        42,   42,   42,   42,   42,   42,   42
+     },
+ 
+     {
+        11,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+       -16,  -16,  -16,  -16,  -16,  -16,  -16
+     },
+ 
+     {
+        11,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+       -17,  -17,  -17,  -17,  -17,  -17,  -17
+     },
+ 
+     {
+        11,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+       -18,  -18,  -18,   44,  -18,  -18,  -18
+     },
+ 
+     {
+        11,   45,   45,  -19,   45,   45,   45,   45,   45,   45,
+        45,   45,   45,   45,   45,   45,   45
+ 
+     },
+ 
+     {
+        11,  -20,   46,   47,  -20,  -20,  -20,  -20,  -20,  -20,
+       -20,  -20,  -20,  -20,  -20,  -20,  -20
+     },
+ 
+     {
+        11,   48,  -21,  -21,   48,   48,   48,   48,   48,   48,
+        48,   48,   48,   48,   48,   48,   48
+     },
+ 
+     {
+        11,   49,   49,   50,   49,  -22,   49,   49,  -22,   49,
+        49,   49,   49,   49,   49,  -22,   49
+     },
+ 
+     {
+        11,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+       -23,  -23,  -23,  -23,  -23,  -23,  -23
+     },
+ 
+     {
+        11,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+       -24,  -24,  -24,  -24,  -24,  -24,  -24
+ 
+     },
+ 
+     {
+        11,   51,   51,   52,   51,   51,   51,   51,   51,   51,
+        51,   51,   51,   51,   51,   51,   51
+     },
+ 
+     {
+        11,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+       -26,  -26,  -26,  -26,  -26,  -26,  -26
+     },
+ 
+     {
+        11,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+       -27,  -27,  -27,  -27,  -27,  -27,  -27
+     },
+ 
+     {
+        11,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+       -28,  -28,  -28,  -28,   53,  -28,  -28
+     },
+ 
+     {
+        11,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+       -29,  -29,  -29,  -29,  -29,  -29,  -29
+ 
+     },
+ 
+     {
+        11,   54,   54,  -30,   54,   54,   54,   54,   54,   54,
+        54,   54,   54,   54,   54,   54,   54
+     },
+ 
+     {
+        11,  -31,  -31,  -31,  -31,  -31,  -31,   55,  -31,  -31,
+       -31,  -31,  -31,  -31,  -31,  -31,  -31
+     },
+ 
+     {
+        11,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+       -32,  -32,  -32,  -32,  -32,  -32,  -32
+     },
+ 
+     {
+        11,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,
+       -33,  -33,  -33,  -33,  -33,  -33,  -33
+     },
+ 
+     {
+        11,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,
+       -34,   56,   57,   57,  -34,  -34,  -34
+ 
+     },
+ 
+     {
+        11,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+       -35,   57,   57,   57,  -35,  -35,  -35
+     },
+ 
+     {
+        11,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+       -36,  -36,  -36,  -36,  -36,  -36,  -36
+     },
+ 
+     {
+        11,  -37,  -37,   58,  -37,  -37,  -37,  -37,  -37,  -37,
+       -37,  -37,  -37,  -37,  -37,  -37,  -37
+     },
+ 
+     {
+        11,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+       -38,  -38,  -38,  -38,  -38,  -38,   59
+     },
+ 
+     {
+        11,  -39,   39,   40,  -39,  -39,   41,  -39,  -39,  -39,
+       -39,  -39,  -39,  -39,  -39,  -39,  -39
+ 
+     },
+ 
+     {
+        11,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+       -40,  -40,  -40,  -40,  -40,  -40,  -40
+     },
+ 
+     {
+        11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+        42,   42,   42,   42,   42,   42,   42
+     },
+ 
+     {
+        11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+        42,   42,   42,   42,   42,   42,   42
+     },
+ 
+     {
+        11,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+       -43,  -43,  -43,  -43,  -43,  -43,  -43
+     },
+ 
+     {
+        11,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+       -44,  -44,  -44,   44,  -44,  -44,  -44
+ 
+     },
+ 
+     {
+        11,   45,   45,  -45,   45,   45,   45,   45,   45,   45,
+        45,   45,   45,   45,   45,   45,   45
+     },
+ 
+     {
+        11,  -46,   46,   47,  -46,  -46,  -46,  -46,  -46,  -46,
+       -46,  -46,  -46,  -46,  -46,  -46,  -46
+     },
+ 
+     {
+        11,   48,  -47,  -47,   48,   48,   48,   48,   48,   48,
+        48,   48,   48,   48,   48,   48,   48
+     },
+ 
+     {
+        11,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+       -48,  -48,  -48,  -48,  -48,  -48,  -48
+     },
+ 
+     {
+        11,   49,   49,   50,   49,  -49,   49,   49,  -49,   49,
+        49,   49,   49,   49,   49,  -49,   49
+ 
+     },
+ 
+     {
+        11,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+       -50,  -50,  -50,  -50,  -50,  -50,  -50
+     },
+ 
+     {
+        11,  -51,  -51,   52,  -51,  -51,  -51,  -51,  -51,  -51,
+       -51,  -51,  -51,  -51,  -51,  -51,  -51
+     },
+ 
+     {
+        11,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+       -52,  -52,  -52,  -52,  -52,  -52,  -52
+     },
+ 
+     {
+        11,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+       -53,  -53,  -53,  -53,  -53,  -53,  -53
+     },
+ 
+     {
+        11,   54,   54,  -54,   54,   54,   54,   54,   54,   54,
+        54,   54,   54,   54,   54,   54,   54
+ 
+     },
+ 
+     {
+        11,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,
+       -55,  -55,  -55,  -55,  -55,  -55,  -55
+     },
+ 
+     {
+        11,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,
+       -56,   60,   57,   57,  -56,  -56,  -56
+     },
+ 
+     {
+        11,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,
+       -57,   57,   57,   57,  -57,  -57,  -57
+     },
+ 
+     {
+        11,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,
+       -58,  -58,  -58,  -58,  -58,  -58,  -58
+     },
+ 
+     {
+        11,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,
+       -59,  -59,  -59,  -59,  -59,  -59,  -59
+ 
+     },
+ 
+     {
+        11,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,
+       -60,   57,   57,   57,  -60,  -60,  -60
+     },
+ 
+     } ;
+ 
+ static yy_state_type yy_get_previous_state (void );
+ static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+ static int yy_get_next_buffer (void );
+ static void yy_fatal_error (yyconst char msg[]  );
+ 
+ /* Done after the current pattern has been matched and before the
+  * corresponding action - sets up zconftext.
+  */
+ #define YY_DO_BEFORE_ACTION \
+ 	(yytext_ptr) = yy_bp; \
+ 	zconfleng = (size_t) (yy_cp - yy_bp); \
+ 	(yy_hold_char) = *yy_cp; \
+ 	*yy_cp = '\0'; \
+ 	(yy_c_buf_p) = yy_cp;
+ 
+ #define YY_NUM_RULES 33
+ #define YY_END_OF_BUFFER 34
+ /* This struct is not used in this scanner,
+    but its presence is necessary. */
+ struct yy_trans_info
+ 	{
+ 	flex_int32_t yy_verify;
+ 	flex_int32_t yy_nxt;
+ 	};
+ static yyconst flex_int16_t yy_accept[61] =
+     {   0,
+         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        34,    5,    4,    2,    3,    7,    8,    6,   32,   29,
+        31,   24,   28,   27,   26,   22,   17,   13,   16,   20,
+        22,   11,   12,   19,   19,   14,   22,   22,    4,    2,
+         3,    3,    1,    6,   32,   29,   31,   30,   24,   23,
+        26,   25,   15,   20,    9,   19,   19,   21,   10,   18
+     } ;
+ 
+ static yyconst flex_int32_t yy_ec[256] =
+     {   0,
+         1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+         1,    2,    4,    5,    6,    1,    1,    7,    8,    9,
+        10,    1,    1,    1,   11,   12,   12,   13,   13,   13,
+        13,   13,   13,   13,   13,   13,   13,    1,    1,    1,
+        14,    1,    1,    1,   13,   13,   13,   13,   13,   13,
+        13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+        13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+         1,   15,    1,    1,   13,    1,   13,   13,   13,   13,
+ 
+        13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+        13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+        13,   13,    1,   16,    1,    1,    1,    1,    1,    1,
+         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+ 
+         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+         1,    1,    1,    1,    1
+     } ;
+ 
+ extern int zconf_flex_debug;
+ int zconf_flex_debug = 0;
+ 
+ /* The intent behind this definition is that it'll catch
+  * any uses of REJECT which flex missed.
+  */
+ #define REJECT reject_used_but_not_detected
+ #define yymore() yymore_used_but_not_detected
+ #define YY_MORE_ADJ 0
+ #define YY_RESTORE_YY_MORE_OFFSET
+ char *zconftext;
+ #define YY_NO_INPUT 1
+ 
+ /*
+  * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+  * Released under the terms of the GNU GPL v2.0.
+  */
+ 
+ #include <limits.h>
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <string.h>
+ #include <unistd.h>
+ 
+ #define LKC_DIRECT_LINK
+ #include "lkc.h"
+ 
+ #define START_STRSIZE	16
+ 
+ static struct {
+ 	struct file *file;
+ 	int lineno;
+ } current_pos;
+ 
+ static char *text;
+ static int text_size, text_asize;
+ 
+ struct buffer {
+         struct buffer *parent;
+         YY_BUFFER_STATE state;
+ };
+ 
+ struct buffer *current_buf;
+ 
+ static int last_ts, first_ts;
+ 
+ static void zconf_endhelp(void);
+ static void zconf_endfile(void);
+ 
+ void new_string(void)
+ {
+ 	text = malloc(START_STRSIZE);
+ 	text_asize = START_STRSIZE;
+ 	text_size = 0;
+ 	*text = 0;
+ }
+ 
+ void append_string(const char *str, int size)
+ {
+ 	int new_size = text_size + size + 1;
+ 	if (new_size > text_asize) {
+ 		new_size += START_STRSIZE - 1;
+ 		new_size &= -START_STRSIZE;
+ 		text = realloc(text, new_size);
+ 		text_asize = new_size;
+ 	}
+ 	memcpy(text + text_size, str, size);
+ 	text_size += size;
+ 	text[text_size] = 0;
+ }
+ 
+ void alloc_string(const char *str, int size)
+ {
+ 	text = malloc(size + 1);
+ 	memcpy(text, str, size);
+ 	text[size] = 0;
+ }
+ 
+ #define INITIAL 0
+ #define COMMAND 1
+ #define HELP 2
+ #define STRING 3
+ #define PARAM 4
+ 
+ #ifndef YY_NO_UNISTD_H
+ /* Special case for "unistd.h", since it is non-ANSI. We include it way
+  * down here because we want the user's section 1 to have been scanned first.
+  * The user has a chance to override it with an option.
+  */
+ #include <unistd.h>
+ #endif
+ 
+ #ifndef YY_EXTRA_TYPE
+ #define YY_EXTRA_TYPE void *
+ #endif
+ 
+ static int yy_init_globals (void );
+ 
+ /* Accessor methods to globals.
+    These are made visible to non-reentrant scanners for convenience. */
+ 
+ int zconflex_destroy (void );
+ 
+ int zconfget_debug (void );
+ 
+ void zconfset_debug (int debug_flag  );
+ 
+ YY_EXTRA_TYPE zconfget_extra (void );
+ 
+ void zconfset_extra (YY_EXTRA_TYPE user_defined  );
+ 
+ FILE *zconfget_in (void );
+ 
+ void zconfset_in  (FILE * in_str  );
+ 
+ FILE *zconfget_out (void );
+ 
+ void zconfset_out  (FILE * out_str  );
+ 
+ int zconfget_leng (void );
+ 
+ char *zconfget_text (void );
+ 
+ int zconfget_lineno (void );
+ 
+ void zconfset_lineno (int line_number  );
+ 
+ /* Macros after this point can all be overridden by user definitions in
+  * section 1.
+  */
+ 
+ #ifndef YY_SKIP_YYWRAP
+ #ifdef __cplusplus
+ extern "C" int zconfwrap (void );
+ #else
+ extern int zconfwrap (void );
+ #endif
+ #endif
+ 
+     static void yyunput (int c,char *buf_ptr  );
+     
+ #ifndef yytext_ptr
+ static void yy_flex_strncpy (char *,yyconst char *,int );
+ #endif
+ 
+ #ifdef YY_NEED_STRLEN
+ static int yy_flex_strlen (yyconst char * );
+ #endif
+ 
+ #ifndef YY_NO_INPUT
+ 
+ #ifdef __cplusplus
+ static int yyinput (void );
+ #else
+ static int input (void );
+ #endif
+ 
+ #endif
+ 
+ /* Amount of stuff to slurp up with each read. */
+ #ifndef YY_READ_BUF_SIZE
+ #define YY_READ_BUF_SIZE 8192
+ #endif
+ 
+ /* Copy whatever the last rule matched to the standard output. */
+ #ifndef ECHO
+ /* This used to be an fputs(), but since the string might contain NUL's,
+  * we now use fwrite().
+  */
+ #define ECHO fwrite( zconftext, zconfleng, 1, zconfout )
+ #endif
+ 
+ /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+  * is returned in "result".
+  */
+ #ifndef YY_INPUT
+ #define YY_INPUT(buf,result,max_size) \
+ 	errno=0; \
+ 	while ( (result = read( fileno(zconfin), (char *) buf, max_size )) < 0 ) \
+ 	{ \
+ 		if( errno != EINTR) \
+ 		{ \
+ 			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+ 			break; \
+ 		} \
+ 		errno=0; \
+ 		clearerr(zconfin); \
+ 	}\
+ \
+ 
+ #endif
+ 
+ /* No semi-colon after return; correct usage is to write "yyterminate();" -
+  * we don't want an extra ';' after the "return" because that will cause
+  * some compilers to complain about unreachable statements.
+  */
+ #ifndef yyterminate
+ #define yyterminate() return YY_NULL
+ #endif
+ 
+ /* Number of entries by which start-condition stack grows. */
+ #ifndef YY_START_STACK_INCR
+ #define YY_START_STACK_INCR 25
+ #endif
+ 
+ /* Report a fatal error. */
+ #ifndef YY_FATAL_ERROR
+ #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+ #endif
+ 
+ /* end tables serialization structures and prototypes */
+ 
+ /* Default declaration of generated scanner - a define so the user can
+  * easily add parameters.
+  */
+ #ifndef YY_DECL
+ #define YY_DECL_IS_OURS 1
+ 
+ extern int zconflex (void);
+ 
+ #define YY_DECL int zconflex (void)
+ #endif /* !YY_DECL */
+ 
+ /* Code executed at the beginning of each rule, after zconftext and zconfleng
+  * have been set up.
+  */
+ #ifndef YY_USER_ACTION
+ #define YY_USER_ACTION
+ #endif
+ 
+ /* Code executed at the end of each rule. */
+ #ifndef YY_BREAK
+ #define YY_BREAK break;
+ #endif
+ 
+ #define YY_RULE_SETUP \
+ 	YY_USER_ACTION
+ 
+ /** The main scanner function which does all the work.
+  */
+ YY_DECL
+ {
+ 	register yy_state_type yy_current_state;
+ 	register char *yy_cp, *yy_bp;
+ 	register int yy_act;
+     
+ 	int str = 0;
+ 	int ts, i;
+ 
+ 	if ( !(yy_init) )
+ 		{
+ 		(yy_init) = 1;
+ 
+ #ifdef YY_USER_INIT
+ 		YY_USER_INIT;
+ #endif
+ 
+ 		if ( ! (yy_start) )
+ 			(yy_start) = 1;	/* first start state */
+ 
+ 		if ( ! zconfin )
+ 			zconfin = stdin;
+ 
+ 		if ( ! zconfout )
+ 			zconfout = stdout;
+ 
+ 		if ( ! YY_CURRENT_BUFFER ) {
+ 			zconfensure_buffer_stack ();
+ 			YY_CURRENT_BUFFER_LVALUE =
+ 				zconf_create_buffer(zconfin,YY_BUF_SIZE );
+ 		}
+ 
+ 		zconf_load_buffer_state( );
+ 		}
+ 
+ 	while ( 1 )		/* loops until end-of-file is reached */
+ 		{
+ 		yy_cp = (yy_c_buf_p);
+ 
+ 		/* Support of zconftext. */
+ 		*yy_cp = (yy_hold_char);
+ 
+ 		/* yy_bp points to the position in yy_ch_buf of the start of
+ 		 * the current run.
+ 		 */
+ 		yy_bp = yy_cp;
+ 
+ 		yy_current_state = (yy_start);
+ yy_match:
+ 		while ( (yy_current_state = yy_nxt[yy_current_state][ yy_ec[YY_SC_TO_UI(*yy_cp)]  ]) > 0 )
+ 			++yy_cp;
+ 
+ 		yy_current_state = -yy_current_state;
+ 
+ yy_find_action:
+ 		yy_act = yy_accept[yy_current_state];
+ 
+ 		YY_DO_BEFORE_ACTION;
+ 
+ do_action:	/* This label is used only to access EOF actions. */
+ 
+ 		switch ( yy_act )
+ 	{ /* beginning of action switch */
+ case 1:
+ /* rule 1 can match eol */
+ case 2:
+ /* rule 2 can match eol */
+ YY_RULE_SETUP
+ {
+ 	current_file->lineno++;
+ 	return T_EOL;
+ }
+ 	YY_BREAK
+ case 3:
+ YY_RULE_SETUP
+ 
+ 	YY_BREAK
+ case 4:
+ YY_RULE_SETUP
+ {
+ 	BEGIN(COMMAND);
+ }
+ 	YY_BREAK
+ case 5:
+ YY_RULE_SETUP
+ {
+ 	unput(zconftext[0]);
+ 	BEGIN(COMMAND);
+ }
+ 	YY_BREAK
+ 
+ case 6:
+ YY_RULE_SETUP
+ {
+ 		struct kconf_id *id = kconf_id_lookup(zconftext, zconfleng);
+ 		BEGIN(PARAM);
+ 		current_pos.file = current_file;
+ 		current_pos.lineno = current_file->lineno;
+ 		if (id && id->flags & TF_COMMAND) {
+ 			zconflval.id = id;
+ 			return id->token;
+ 		}
+ 		alloc_string(zconftext, zconfleng);
+ 		zconflval.string = text;
+ 		return T_WORD;
+ 	}
+ 	YY_BREAK
+ case 7:
+ YY_RULE_SETUP
+ 
+ 	YY_BREAK
+ case 8:
+ /* rule 8 can match eol */
+ YY_RULE_SETUP
+ {
+ 		BEGIN(INITIAL);
+ 		current_file->lineno++;
+ 		return T_EOL;
+ 	}
+ 	YY_BREAK
+ 
+ case 9:
+ YY_RULE_SETUP
+ return T_AND;
+ 	YY_BREAK
+ case 10:
+ YY_RULE_SETUP
+ return T_OR;
+ 	YY_BREAK
+ case 11:
+ YY_RULE_SETUP
+ return T_OPEN_PAREN;
+ 	YY_BREAK
+ case 12:
+ YY_RULE_SETUP
+ return T_CLOSE_PAREN;
+ 	YY_BREAK
+ case 13:
+ YY_RULE_SETUP
+ return T_NOT;
+ 	YY_BREAK
+ case 14:
+ YY_RULE_SETUP
+ return T_EQUAL;
+ 	YY_BREAK
+ case 15:
+ YY_RULE_SETUP
+ return T_UNEQUAL;
+ 	YY_BREAK
+ case 16:
+ YY_RULE_SETUP
+ {
+ 		str = zconftext[0];
+ 		new_string();
+ 		BEGIN(STRING);
+ 	}
+ 	YY_BREAK
+ case 17:
+ /* rule 17 can match eol */
+ YY_RULE_SETUP
+ BEGIN(INITIAL); current_file->lineno++; return T_EOL;
+ 	YY_BREAK
+ case 18:
+ YY_RULE_SETUP
+ /* ignore */
+ 	YY_BREAK
+ case 19:
+ YY_RULE_SETUP
+ {
+ 		struct kconf_id *id = kconf_id_lookup(zconftext, zconfleng);
+ 		if (id && id->flags & TF_PARAM) {
+ 			zconflval.id = id;
+ 			return id->token;
+ 		}
+ 		alloc_string(zconftext, zconfleng);
+ 		zconflval.string = text;
+ 		return T_WORD;
+ 	}
+ 	YY_BREAK
+ case 20:
+ YY_RULE_SETUP
+ /* comment */
+ 	YY_BREAK
+ case 21:
+ /* rule 21 can match eol */
+ YY_RULE_SETUP
+ current_file->lineno++;
+ 	YY_BREAK
+ case 22:
+ YY_RULE_SETUP
+ 
+ 	YY_BREAK
+ case YY_STATE_EOF(PARAM):
+ {
+ 		BEGIN(INITIAL);
+ 	}
+ 	YY_BREAK
+ 
+ case 23:
+ /* rule 23 can match eol */
+ *yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+ (yy_c_buf_p) = yy_cp -= 1;
+ YY_DO_BEFORE_ACTION; /* set up zconftext again */
+ YY_RULE_SETUP
+ {
+ 		append_string(zconftext, zconfleng);
+ 		zconflval.string = text;
+ 		return T_WORD_QUOTE;
+ 	}
+ 	YY_BREAK
+ case 24:
+ YY_RULE_SETUP
+ {
+ 		append_string(zconftext, zconfleng);
+ 	}
+ 	YY_BREAK
+ case 25:
+ /* rule 25 can match eol */
+ *yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+ (yy_c_buf_p) = yy_cp -= 1;
+ YY_DO_BEFORE_ACTION; /* set up zconftext again */
+ YY_RULE_SETUP
+ {
+ 		append_string(zconftext + 1, zconfleng - 1);
+ 		zconflval.string = text;
+ 		return T_WORD_QUOTE;
+ 	}
+ 	YY_BREAK
+ case 26:
+ YY_RULE_SETUP
+ {
+ 		append_string(zconftext + 1, zconfleng - 1);
+ 	}
+ 	YY_BREAK
+ case 27:
+ YY_RULE_SETUP
+ {
+ 		if (str == zconftext[0]) {
+ 			BEGIN(PARAM);
+ 			zconflval.string = text;
+ 			return T_WORD_QUOTE;
+ 		} else
+ 			append_string(zconftext, 1);
+ 	}
+ 	YY_BREAK
+ case 28:
+ /* rule 28 can match eol */
+ YY_RULE_SETUP
+ {
+ 		printf("%s:%d:warning: multi-line strings not supported\n", zconf_curname(), zconf_lineno());
+ 		current_file->lineno++;
+ 		BEGIN(INITIAL);
+ 		return T_EOL;
+ 	}
+ 	YY_BREAK
+ case YY_STATE_EOF(STRING):
+ {
+ 		BEGIN(INITIAL);
+ 	}
+ 	YY_BREAK
+ 
+ case 29:
+ YY_RULE_SETUP
+ {
+ 		ts = 0;
+ 		for (i = 0; i < zconfleng; i++) {
+ 			if (zconftext[i] == '\t')
+ 				ts = (ts & ~7) + 8;
+ 			else
+ 				ts++;
+ 		}
+ 		last_ts = ts;
+ 		if (first_ts) {
+ 			if (ts < first_ts) {
+ 				zconf_endhelp();
+ 				return T_HELPTEXT;
+ 			}
+ 			ts -= first_ts;
+ 			while (ts > 8) {
+ 				append_string("        ", 8);
+ 				ts -= 8;
+ 			}
+ 			append_string("        ", ts);
+ 		}
+ 	}
+ 	YY_BREAK
+ case 30:
+ /* rule 30 can match eol */
+ *yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+ (yy_c_buf_p) = yy_cp -= 1;
+ YY_DO_BEFORE_ACTION; /* set up zconftext again */
+ YY_RULE_SETUP
+ {
+ 		current_file->lineno++;
+ 		zconf_endhelp();
+ 		return T_HELPTEXT;
+ 	}
+ 	YY_BREAK
+ case 31:
+ /* rule 31 can match eol */
+ YY_RULE_SETUP
+ {
+ 		current_file->lineno++;
+ 		append_string("\n", 1);
+ 	}
+ 	YY_BREAK
+ case 32:
+ YY_RULE_SETUP
+ {
+ 		while (zconfleng) {
+ 			if ((zconftext[zconfleng-1] != ' ') && (zconftext[zconfleng-1] != '\t'))
+ 				break;
+ 			zconfleng--;
+ 		}
+ 		append_string(zconftext, zconfleng);
+ 		if (!first_ts)
+ 			first_ts = last_ts;
+ 	}
+ 	YY_BREAK
+ case YY_STATE_EOF(HELP):
+ {
+ 		zconf_endhelp();
+ 		return T_HELPTEXT;
+ 	}
+ 	YY_BREAK
+ 
+ case YY_STATE_EOF(INITIAL):
+ case YY_STATE_EOF(COMMAND):
+ {
+ 	if (current_file) {
+ 		zconf_endfile();
+ 		return T_EOL;
+ 	}
+ 	fclose(zconfin);
+ 	yyterminate();
+ }
+ 	YY_BREAK
+ case 33:
+ YY_RULE_SETUP
+ YY_FATAL_ERROR( "flex scanner jammed" );
+ 	YY_BREAK
+ 
+ 	case YY_END_OF_BUFFER:
+ 		{
+ 		/* Amount of text matched not including the EOB char. */
+ 		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+ 
+ 		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+ 		*yy_cp = (yy_hold_char);
+ 		YY_RESTORE_YY_MORE_OFFSET
+ 
+ 		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+ 			{
+ 			/* We're scanning a new file or input source.  It's
+ 			 * possible that this happened because the user
+ 			 * just pointed zconfin at a new source and called
+ 			 * zconflex().  If so, then we have to assure
+ 			 * consistency between YY_CURRENT_BUFFER and our
+ 			 * globals.  Here is the right place to do so, because
+ 			 * this is the first action (other than possibly a
+ 			 * back-up) that will match for the new input source.
+ 			 */
+ 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+ 			YY_CURRENT_BUFFER_LVALUE->yy_input_file = zconfin;
+ 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+ 			}
+ 
+ 		/* Note that here we test for yy_c_buf_p "<=" to the position
+ 		 * of the first EOB in the buffer, since yy_c_buf_p will
+ 		 * already have been incremented past the NUL character
+ 		 * (since all states make transitions on EOB to the
+ 		 * end-of-buffer state).  Contrast this with the test
+ 		 * in input().
+ 		 */
+ 		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+ 			{ /* This was really a NUL. */
+ 			yy_state_type yy_next_state;
+ 
+ 			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+ 
+ 			yy_current_state = yy_get_previous_state(  );
+ 
+ 			/* Okay, we're now positioned to make the NUL
+ 			 * transition.  We couldn't have
+ 			 * yy_get_previous_state() go ahead and do it
+ 			 * for us because it doesn't know how to deal
+ 			 * with the possibility of jamming (and we don't
+ 			 * want to build jamming into it because then it
+ 			 * will run more slowly).
+ 			 */
+ 
+ 			yy_next_state = yy_try_NUL_trans( yy_current_state );
+ 
+ 			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+ 
+ 			if ( yy_next_state )
+ 				{
+ 				/* Consume the NUL. */
+ 				yy_cp = ++(yy_c_buf_p);
+ 				yy_current_state = yy_next_state;
+ 				goto yy_match;
+ 				}
+ 
+ 			else
+ 				{
+ 				yy_cp = (yy_c_buf_p);
+ 				goto yy_find_action;
+ 				}
+ 			}
+ 
+ 		else switch ( yy_get_next_buffer(  ) )
+ 			{
+ 			case EOB_ACT_END_OF_FILE:
+ 				{
+ 				(yy_did_buffer_switch_on_eof) = 0;
+ 
+ 				if ( zconfwrap( ) )
+ 					{
+ 					/* Note: because we've taken care in
+ 					 * yy_get_next_buffer() to have set up
+ 					 * zconftext, we can now set up
+ 					 * yy_c_buf_p so that if some total
+ 					 * hoser (like flex itself) wants to
+ 					 * call the scanner after we return the
+ 					 * YY_NULL, it'll still work - another
+ 					 * YY_NULL will get returned.
+ 					 */
+ 					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+ 
+ 					yy_act = YY_STATE_EOF(YY_START);
+ 					goto do_action;
+ 					}
+ 
+ 				else
+ 					{
+ 					if ( ! (yy_did_buffer_switch_on_eof) )
+ 						YY_NEW_FILE;
+ 					}
+ 				break;
+ 				}
+ 
+ 			case EOB_ACT_CONTINUE_SCAN:
+ 				(yy_c_buf_p) =
+ 					(yytext_ptr) + yy_amount_of_matched_text;
+ 
+ 				yy_current_state = yy_get_previous_state(  );
+ 
+ 				yy_cp = (yy_c_buf_p);
+ 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+ 				goto yy_match;
+ 
+ 			case EOB_ACT_LAST_MATCH:
+ 				(yy_c_buf_p) =
+ 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+ 
+ 				yy_current_state = yy_get_previous_state(  );
+ 
+ 				yy_cp = (yy_c_buf_p);
+ 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+ 				goto yy_find_action;
+ 			}
+ 		break;
+ 		}
+ 
+ 	default:
+ 		YY_FATAL_ERROR(
+ 			"fatal flex scanner internal error--no action found" );
+ 	} /* end of action switch */
+ 		} /* end of scanning one token */
+ } /* end of zconflex */
+ 
+ /* yy_get_next_buffer - try to read in a new buffer
+  *
+  * Returns a code representing an action:
+  *	EOB_ACT_LAST_MATCH -
+  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+  *	EOB_ACT_END_OF_FILE - end of file
+  */
+ static int yy_get_next_buffer (void)
+ {
+     	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+ 	register char *source = (yytext_ptr);
+ 	register int number_to_move, i;
+ 	int ret_val;
+ 
+ 	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+ 		YY_FATAL_ERROR(
+ 		"fatal flex scanner internal error--end of buffer missed" );
+ 
+ 	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+ 		{ /* Don't try to fill the buffer, so this is an EOF. */
+ 		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+ 			{
+ 			/* We matched a single character, the EOB, so
+ 			 * treat this as a final EOF.
+ 			 */
+ 			return EOB_ACT_END_OF_FILE;
+ 			}
+ 
+ 		else
+ 			{
+ 			/* We matched some text prior to the EOB, first
+ 			 * process it.
+ 			 */
+ 			return EOB_ACT_LAST_MATCH;
+ 			}
+ 		}
+ 
+ 	/* Try to read more data. */
+ 
+ 	/* First move last chars to start of buffer. */
+ 	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+ 
+ 	for ( i = 0; i < number_to_move; ++i )
+ 		*(dest++) = *(source++);
+ 
+ 	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+ 		/* don't do the read, it's not guaranteed to return an EOF,
+ 		 * just force an EOF
+ 		 */
+ 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+ 
+ 	else
+ 		{
+ 			int num_to_read =
+ 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+ 
+ 		while ( num_to_read <= 0 )
+ 			{ /* Not enough room in the buffer - grow it. */
+ 
+ 			/* just a shorter name for the current buffer */
+ 			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+ 
+ 			int yy_c_buf_p_offset =
+ 				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+ 
+ 			if ( b->yy_is_our_buffer )
+ 				{
+ 				int new_size = b->yy_buf_size * 2;
+ 
+ 				if ( new_size <= 0 )
+ 					b->yy_buf_size += b->yy_buf_size / 8;
+ 				else
+ 					b->yy_buf_size *= 2;
+ 
+ 				b->yy_ch_buf = (char *)
+ 					/* Include room in for 2 EOB chars. */
+ 					zconfrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+ 				}
+ 			else
+ 				/* Can't grow it, we don't own it. */
+ 				b->yy_ch_buf = 0;
+ 
+ 			if ( ! b->yy_ch_buf )
+ 				YY_FATAL_ERROR(
+ 				"fatal error - scanner input buffer overflow" );
+ 
+ 			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+ 
+ 			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+ 						number_to_move - 1;
+ 
+ 			}
+ 
+ 		if ( num_to_read > YY_READ_BUF_SIZE )
+ 			num_to_read = YY_READ_BUF_SIZE;
+ 
+ 		/* Read in more data. */
+ 		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+ 			(yy_n_chars), (size_t) num_to_read );
+ 
+ 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+ 		}
+ 
+ 	if ( (yy_n_chars) == 0 )
+ 		{
+ 		if ( number_to_move == YY_MORE_ADJ )
+ 			{
+ 			ret_val = EOB_ACT_END_OF_FILE;
+ 			zconfrestart(zconfin  );
+ 			}
+ 
+ 		else
+ 			{
+ 			ret_val = EOB_ACT_LAST_MATCH;
+ 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+ 				YY_BUFFER_EOF_PENDING;
+ 			}
+ 		}
+ 
+ 	else
+ 		ret_val = EOB_ACT_CONTINUE_SCAN;
+ 
+ 	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+ 		/* Extend the array by 50%, plus the number we really need. */
+ 		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+ 		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) zconfrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+ 		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+ 			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+ 	}
+ 
+ 	(yy_n_chars) += number_to_move;
+ 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+ 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+ 
+ 	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+ 
+ 	return ret_val;
+ }
+ 
+ /* yy_get_previous_state - get the state just before the EOB char was reached */
+ 
+     static yy_state_type yy_get_previous_state (void)
+ {
+ 	register yy_state_type yy_current_state;
+ 	register char *yy_cp;
+     
+ 	yy_current_state = (yy_start);
+ 
+ 	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+ 		{
+ 		yy_current_state = yy_nxt[yy_current_state][(*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1)];
+ 		}
+ 
+ 	return yy_current_state;
+ }
+ 
+ /* yy_try_NUL_trans - try to make a transition on the NUL character
+  *
+  * synopsis
+  *	next_state = yy_try_NUL_trans( current_state );
+  */
+     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+ {
+ 	register int yy_is_jam;
+     
+ 	yy_current_state = yy_nxt[yy_current_state][1];
+ 	yy_is_jam = (yy_current_state <= 0);
+ 
+ 	return yy_is_jam ? 0 : yy_current_state;
+ }
+ 
+     static void yyunput (int c, register char * yy_bp )
+ {
+ 	register char *yy_cp;
+     
+     yy_cp = (yy_c_buf_p);
+ 
+ 	/* undo effects of setting up zconftext */
+ 	*yy_cp = (yy_hold_char);
+ 
+ 	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+ 		{ /* need to shift things up to make room */
+ 		/* +2 for EOB chars. */
+ 		register int number_to_move = (yy_n_chars) + 2;
+ 		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+ 					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+ 		register char *source =
+ 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+ 
+ 		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+ 			*--dest = *--source;
+ 
+ 		yy_cp += (int) (dest - source);
+ 		yy_bp += (int) (dest - source);
+ 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+ 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+ 
+ 		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+ 			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+ 		}
+ 
+ 	*--yy_cp = (char) c;
+ 
+ 	(yytext_ptr) = yy_bp;
+ 	(yy_hold_char) = *yy_cp;
+ 	(yy_c_buf_p) = yy_cp;
+ }
+ 
+ #ifndef YY_NO_INPUT
+ #ifdef __cplusplus
+     static int yyinput (void)
+ #else
+     static int input  (void)
+ #endif
+ 
+ {
+ 	int c;
+     
+ 	*(yy_c_buf_p) = (yy_hold_char);
+ 
+ 	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+ 		{
+ 		/* yy_c_buf_p now points to the character we want to return.
+ 		 * If this occurs *before* the EOB characters, then it's a
+ 		 * valid NUL; if not, then we've hit the end of the buffer.
+ 		 */
+ 		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+ 			/* This was really a NUL. */
+ 			*(yy_c_buf_p) = '\0';
+ 
+ 		else
+ 			{ /* need more input */
+ 			int offset = (yy_c_buf_p) - (yytext_ptr);
+ 			++(yy_c_buf_p);
+ 
+ 			switch ( yy_get_next_buffer(  ) )
+ 				{
+ 				case EOB_ACT_LAST_MATCH:
+ 					/* This happens because yy_g_n_b()
+ 					 * sees that we've accumulated a
+ 					 * token and flags that we need to
+ 					 * try matching the token before
+ 					 * proceeding.  But for input(),
+ 					 * there's no matching to consider.
+ 					 * So convert the EOB_ACT_LAST_MATCH
+ 					 * to EOB_ACT_END_OF_FILE.
+ 					 */
+ 
+ 					/* Reset buffer status. */
+ 					zconfrestart(zconfin );
+ 
+ 					/*FALLTHROUGH*/
+ 
+ 				case EOB_ACT_END_OF_FILE:
+ 					{
+ 					if ( zconfwrap( ) )
+ 						return EOF;
+ 
+ 					if ( ! (yy_did_buffer_switch_on_eof) )
+ 						YY_NEW_FILE;
+ #ifdef __cplusplus
+ 					return yyinput();
+ #else
+ 					return input();
+ #endif
+ 					}
+ 
+ 				case EOB_ACT_CONTINUE_SCAN:
+ 					(yy_c_buf_p) = (yytext_ptr) + offset;
+ 					break;
+ 				}
+ 			}
+ 		}
+ 
+ 	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+ 	*(yy_c_buf_p) = '\0';	/* preserve zconftext */
+ 	(yy_hold_char) = *++(yy_c_buf_p);
+ 
+ 	return c;
+ }
+ #endif	/* ifndef YY_NO_INPUT */
+ 
+ /** Immediately switch to a different input stream.
+  * @param input_file A readable stream.
+  * 
+  * @note This function does not reset the start condition to @c INITIAL .
+  */
+     void zconfrestart  (FILE * input_file )
+ {
+     
+ 	if ( ! YY_CURRENT_BUFFER ){
+         zconfensure_buffer_stack ();
+ 		YY_CURRENT_BUFFER_LVALUE =
+             zconf_create_buffer(zconfin,YY_BUF_SIZE );
+ 	}
+ 
+ 	zconf_init_buffer(YY_CURRENT_BUFFER,input_file );
+ 	zconf_load_buffer_state( );
+ }
+ 
+ /** Switch to a different input buffer.
+  * @param new_buffer The new input buffer.
+  * 
+  */
+     void zconf_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+ {
+     
+ 	/* TODO. We should be able to replace this entire function body
+ 	 * with
+ 	 *		zconfpop_buffer_state();
+ 	 *		zconfpush_buffer_state(new_buffer);
+      */
+ 	zconfensure_buffer_stack ();
+ 	if ( YY_CURRENT_BUFFER == new_buffer )
+ 		return;
+ 
+ 	if ( YY_CURRENT_BUFFER )
+ 		{
+ 		/* Flush out information for old buffer. */
+ 		*(yy_c_buf_p) = (yy_hold_char);
+ 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+ 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+ 		}
+ 
+ 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+ 	zconf_load_buffer_state( );
+ 
+ 	/* We don't actually know whether we did this switch during
+ 	 * EOF (zconfwrap()) processing, but the only time this flag
+ 	 * is looked at is after zconfwrap() is called, so it's safe
+ 	 * to go ahead and always set it.
+ 	 */
+ 	(yy_did_buffer_switch_on_eof) = 1;
+ }
+ 
+ static void zconf_load_buffer_state  (void)
+ {
+     	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+ 	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+ 	zconfin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+ 	(yy_hold_char) = *(yy_c_buf_p);
+ }
+ 
+ /** Allocate and initialize an input buffer state.
+  * @param file A readable stream.
+  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+  * 
+  * @return the allocated buffer state.
+  */
+     YY_BUFFER_STATE zconf_create_buffer  (FILE * file, int  size )
+ {
+ 	YY_BUFFER_STATE b;
+     
+ 	b = (YY_BUFFER_STATE) zconfalloc(sizeof( struct yy_buffer_state )  );
+ 	if ( ! b )
+ 		YY_FATAL_ERROR( "out of dynamic memory in zconf_create_buffer()" );
+ 
+ 	b->yy_buf_size = size;
+ 
+ 	/* yy_ch_buf has to be 2 characters longer than the size given because
+ 	 * we need to put in 2 end-of-buffer characters.
+ 	 */
+ 	b->yy_ch_buf = (char *) zconfalloc(b->yy_buf_size + 2  );
+ 	if ( ! b->yy_ch_buf )
+ 		YY_FATAL_ERROR( "out of dynamic memory in zconf_create_buffer()" );
+ 
+ 	b->yy_is_our_buffer = 1;
+ 
+ 	zconf_init_buffer(b,file );
+ 
+ 	return b;
+ }
+ 
+ /** Destroy the buffer.
+  * @param b a buffer created with zconf_create_buffer()
+  * 
+  */
+     void zconf_delete_buffer (YY_BUFFER_STATE  b )
+ {
+     
+ 	if ( ! b )
+ 		return;
+ 
+ 	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+ 		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+ 
+ 	if ( b->yy_is_our_buffer )
+ 		zconffree((void *) b->yy_ch_buf  );
+ 
+ 	zconffree((void *) b  );
+ }
+ 
+ /* Initializes or reinitializes a buffer.
+  * This function is sometimes called more than once on the same buffer,
+  * such as during a zconfrestart() or at EOF.
+  */
+     static void zconf_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+ 
+ {
+ 	int oerrno = errno;
+     
+ 	zconf_flush_buffer(b );
+ 
+ 	b->yy_input_file = file;
+ 	b->yy_fill_buffer = 1;
+ 
+     /* If b is the current buffer, then zconf_init_buffer was _probably_
+      * called from zconfrestart() or through yy_get_next_buffer.
+      * In that case, we don't want to reset the lineno or column.
+      */
+     if (b != YY_CURRENT_BUFFER){
+         b->yy_bs_lineno = 1;
+         b->yy_bs_column = 0;
+     }
+ 
+         b->yy_is_interactive = 0;
+     
+ 	errno = oerrno;
+ }
+ 
+ /** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+  * 
+  */
+     void zconf_flush_buffer (YY_BUFFER_STATE  b )
+ {
+     	if ( ! b )
+ 		return;
+ 
+ 	b->yy_n_chars = 0;
+ 
+ 	/* We always need two end-of-buffer characters.  The first causes
+ 	 * a transition to the end-of-buffer state.  The second causes
+ 	 * a jam in that state.
+ 	 */
+ 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+ 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+ 
+ 	b->yy_buf_pos = &b->yy_ch_buf[0];
+ 
+ 	b->yy_at_bol = 1;
+ 	b->yy_buffer_status = YY_BUFFER_NEW;
+ 
+ 	if ( b == YY_CURRENT_BUFFER )
+ 		zconf_load_buffer_state( );
+ }
+ 
+ /** Pushes the new state onto the stack. The new state becomes
+  *  the current state. This function will allocate the stack
+  *  if necessary.
+  *  @param new_buffer The new state.
+  *  
+  */
+ void zconfpush_buffer_state (YY_BUFFER_STATE new_buffer )
+ {
+     	if (new_buffer == NULL)
+ 		return;
+ 
+ 	zconfensure_buffer_stack();
+ 
+ 	/* This block is copied from zconf_switch_to_buffer. */
+ 	if ( YY_CURRENT_BUFFER )
+ 		{
+ 		/* Flush out information for old buffer. */
+ 		*(yy_c_buf_p) = (yy_hold_char);
+ 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+ 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+ 		}
+ 
+ 	/* Only push if top exists. Otherwise, replace top. */
+ 	if (YY_CURRENT_BUFFER)
+ 		(yy_buffer_stack_top)++;
+ 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+ 
+ 	/* copied from zconf_switch_to_buffer. */
+ 	zconf_load_buffer_state( );
+ 	(yy_did_buffer_switch_on_eof) = 1;
+ }
+ 
+ /** Removes and deletes the top of the stack, if present.
+  *  The next element becomes the new top.
+  *  
+  */
+ void zconfpop_buffer_state (void)
+ {
+     	if (!YY_CURRENT_BUFFER)
+ 		return;
+ 
+ 	zconf_delete_buffer(YY_CURRENT_BUFFER );
+ 	YY_CURRENT_BUFFER_LVALUE = NULL;
+ 	if ((yy_buffer_stack_top) > 0)
+ 		--(yy_buffer_stack_top);
+ 
+ 	if (YY_CURRENT_BUFFER) {
+ 		zconf_load_buffer_state( );
+ 		(yy_did_buffer_switch_on_eof) = 1;
+ 	}
+ }
+ 
+ /* Allocates the stack if it does not exist.
+  *  Guarantees space for at least one push.
+  */
+ static void zconfensure_buffer_stack (void)
+ {
+ 	int num_to_alloc;
+     
+ 	if (!(yy_buffer_stack)) {
+ 
+ 		/* First allocation is just for 2 elements, since we don't know if this
+ 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+ 		 * immediate realloc on the next call.
+          */
+ 		num_to_alloc = 1;
+ 		(yy_buffer_stack) = (struct yy_buffer_state**)zconfalloc
+ 								(num_to_alloc * sizeof(struct yy_buffer_state*)
+ 								);
+ 		if ( ! (yy_buffer_stack) )
+ 			YY_FATAL_ERROR( "out of dynamic memory in zconfensure_buffer_stack()" );
+ 								  
+ 		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+ 				
+ 		(yy_buffer_stack_max) = num_to_alloc;
+ 		(yy_buffer_stack_top) = 0;
+ 		return;
+ 	}
+ 
+ 	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+ 
+ 		/* Increase the buffer to prepare for a possible push. */
+ 		int grow_size = 8 /* arbitrary grow size */;
+ 
+ 		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+ 		(yy_buffer_stack) = (struct yy_buffer_state**)zconfrealloc
+ 								((yy_buffer_stack),
+ 								num_to_alloc * sizeof(struct yy_buffer_state*)
+ 								);
+ 		if ( ! (yy_buffer_stack) )
+ 			YY_FATAL_ERROR( "out of dynamic memory in zconfensure_buffer_stack()" );
+ 
+ 		/* zero only the new slots.*/
+ 		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+ 		(yy_buffer_stack_max) = num_to_alloc;
+ 	}
+ }
+ 
+ /** Setup the input buffer state to scan directly from a user-specified character buffer.
+  * @param base the character buffer
+  * @param size the size in bytes of the character buffer
+  * 
+  * @return the newly allocated buffer state object. 
+  */
+ YY_BUFFER_STATE zconf_scan_buffer  (char * base, yy_size_t  size )
+ {
+ 	YY_BUFFER_STATE b;
+     
+ 	if ( size < 2 ||
+ 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+ 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+ 		/* They forgot to leave room for the EOB's. */
+ 		return 0;
+ 
+ 	b = (YY_BUFFER_STATE) zconfalloc(sizeof( struct yy_buffer_state )  );
+ 	if ( ! b )
+ 		YY_FATAL_ERROR( "out of dynamic memory in zconf_scan_buffer()" );
+ 
+ 	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+ 	b->yy_buf_pos = b->yy_ch_buf = base;
+ 	b->yy_is_our_buffer = 0;
+ 	b->yy_input_file = 0;
+ 	b->yy_n_chars = b->yy_buf_size;
+ 	b->yy_is_interactive = 0;
+ 	b->yy_at_bol = 1;
+ 	b->yy_fill_buffer = 0;
+ 	b->yy_buffer_status = YY_BUFFER_NEW;
+ 
+ 	zconf_switch_to_buffer(b  );
+ 
+ 	return b;
+ }
+ 
+ /** Setup the input buffer state to scan a string. The next call to zconflex() will
+  * scan from a @e copy of @a str.
+  * @param yystr a NUL-terminated string to scan
+  * 
+  * @return the newly allocated buffer state object.
+  * @note If you want to scan bytes that may contain NUL values, then use
+  *       zconf_scan_bytes() instead.
+  */
+ YY_BUFFER_STATE zconf_scan_string (yyconst char * yystr )
+ {
+     
+ 	return zconf_scan_bytes(yystr,strlen(yystr) );
+ }
+ 
+ /** Setup the input buffer state to scan the given bytes. The next call to zconflex() will
+  * scan from a @e copy of @a bytes.
+  * @param bytes the byte buffer to scan
+  * @param len the number of bytes in the buffer pointed to by @a bytes.
+  * 
+  * @return the newly allocated buffer state object.
+  */
+ YY_BUFFER_STATE zconf_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+ {
+ 	YY_BUFFER_STATE b;
+ 	char *buf;
+ 	yy_size_t n;
+ 	int i;
+     
+ 	/* Get memory for full buffer, including space for trailing EOB's. */
+ 	n = _yybytes_len + 2;
+ 	buf = (char *) zconfalloc(n  );
+ 	if ( ! buf )
+ 		YY_FATAL_ERROR( "out of dynamic memory in zconf_scan_bytes()" );
+ 
+ 	for ( i = 0; i < _yybytes_len; ++i )
+ 		buf[i] = yybytes[i];
+ 
+ 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+ 
+ 	b = zconf_scan_buffer(buf,n );
+ 	if ( ! b )
+ 		YY_FATAL_ERROR( "bad buffer in zconf_scan_bytes()" );
+ 
+ 	/* It's okay to grow etc. this buffer, and we should throw it
+ 	 * away when we're done.
+ 	 */
+ 	b->yy_is_our_buffer = 1;
+ 
+ 	return b;
+ }
+ 
+ #ifndef YY_EXIT_FAILURE
+ #define YY_EXIT_FAILURE 2
+ #endif
+ 
+ static void yy_fatal_error (yyconst char* msg )
+ {
+     	(void) fprintf( stderr, "%s\n", msg );
+ 	exit( YY_EXIT_FAILURE );
+ }
+ 
+ /* Redefine yyless() so it works in section 3 code. */
+ 
+ #undef yyless
+ #define yyless(n) \
+ 	do \
+ 		{ \
+ 		/* Undo effects of setting up zconftext. */ \
+         int yyless_macro_arg = (n); \
+         YY_LESS_LINENO(yyless_macro_arg);\
+ 		zconftext[zconfleng] = (yy_hold_char); \
+ 		(yy_c_buf_p) = zconftext + yyless_macro_arg; \
+ 		(yy_hold_char) = *(yy_c_buf_p); \
+ 		*(yy_c_buf_p) = '\0'; \
+ 		zconfleng = yyless_macro_arg; \
+ 		} \
+ 	while ( 0 )
+ 
+ /* Accessor  methods (get/set functions) to struct members. */
+ 
+ /** Get the current line number.
+  * 
+  */
+ int zconfget_lineno  (void)
+ {
+         
+     return zconflineno;
+ }
+ 
+ /** Get the input stream.
+  * 
+  */
+ FILE *zconfget_in  (void)
+ {
+         return zconfin;
+ }
+ 
+ /** Get the output stream.
+  * 
+  */
+ FILE *zconfget_out  (void)
+ {
+         return zconfout;
+ }
+ 
+ /** Get the length of the current token.
+  * 
+  */
+ int zconfget_leng  (void)
+ {
+         return zconfleng;
+ }
+ 
+ /** Get the current token.
+  * 
+  */
+ 
+ char *zconfget_text  (void)
+ {
+         return zconftext;
+ }
+ 
+ /** Set the current line number.
+  * @param line_number
+  * 
+  */
+ void zconfset_lineno (int  line_number )
+ {
+     
+     zconflineno = line_number;
+ }
+ 
+ /** Set the input stream. This does not discard the current
+  * input buffer.
+  * @param in_str A readable stream.
+  * 
+  * @see zconf_switch_to_buffer
+  */
+ void zconfset_in (FILE *  in_str )
+ {
+         zconfin = in_str ;
+ }
+ 
+ void zconfset_out (FILE *  out_str )
+ {
+         zconfout = out_str ;
+ }
+ 
+ int zconfget_debug  (void)
+ {
+         return zconf_flex_debug;
+ }
+ 
+ void zconfset_debug (int  bdebug )
+ {
+         zconf_flex_debug = bdebug ;
+ }
+ 
+ static int yy_init_globals (void)
+ {
+         /* Initialization is the same as for the non-reentrant scanner.
+      * This function is called from zconflex_destroy(), so don't allocate here.
+      */
+ 
+     (yy_buffer_stack) = 0;
+     (yy_buffer_stack_top) = 0;
+     (yy_buffer_stack_max) = 0;
+     (yy_c_buf_p) = (char *) 0;
+     (yy_init) = 0;
+     (yy_start) = 0;
+ 
+ /* Defined in main.c */
+ #ifdef YY_STDINIT
+     zconfin = stdin;
+     zconfout = stdout;
+ #else
+     zconfin = (FILE *) 0;
+     zconfout = (FILE *) 0;
+ #endif
+ 
+     /* For future reference: Set errno on error, since we are called by
+      * zconflex_init()
+      */
+     return 0;
+ }
+ 
+ /* zconflex_destroy is for both reentrant and non-reentrant scanners. */
+ int zconflex_destroy  (void)
+ {
+     
+     /* Pop the buffer stack, destroying each element. */
+ 	while(YY_CURRENT_BUFFER){
+ 		zconf_delete_buffer(YY_CURRENT_BUFFER  );
+ 		YY_CURRENT_BUFFER_LVALUE = NULL;
+ 		zconfpop_buffer_state();
+ 	}
+ 
+ 	/* Destroy the stack itself. */
+ 	zconffree((yy_buffer_stack) );
+ 	(yy_buffer_stack) = NULL;
+ 
+     /* Reset the globals. This is important in a non-reentrant scanner so the next time
+      * zconflex() is called, initialization will occur. */
+     yy_init_globals( );
+ 
+     return 0;
+ }
+ 
+ /*
+  * Internal utility routines.
+  */
+ 
+ #ifndef yytext_ptr
+ static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+ {
+ 	register int i;
+ 	for ( i = 0; i < n; ++i )
+ 		s1[i] = s2[i];
+ }
+ #endif
+ 
+ #ifdef YY_NEED_STRLEN
+ static int yy_flex_strlen (yyconst char * s )
+ {
+ 	register int n;
+ 	for ( n = 0; s[n]; ++n )
+ 		;
+ 
+ 	return n;
+ }
+ #endif
+ 
+ void *zconfalloc (yy_size_t  size )
+ {
+ 	return (void *) malloc( size );
+ }
+ 
+ void *zconfrealloc  (void * ptr, yy_size_t  size )
+ {
+ 	/* The cast to (char *) in the following accommodates both
+ 	 * implementations that use char* generic pointers, and those
+ 	 * that use void* generic pointers.  It works with the latter
+ 	 * because both ANSI C and C++ allow castless assignment from
+ 	 * any pointer type to void*, and deal with argument conversions
+ 	 * as though doing an assignment.
+ 	 */
+ 	return (void *) realloc( (char *) ptr, size );
+ }
+ 
+ void zconffree (void * ptr )
+ {
+ 	free( (char *) ptr );	/* see zconfrealloc() for (char *) cast */
+ }
+ 
+ #define YYTABLES_NAME "yytables"
+ 
+ void zconf_starthelp(void)
+ {
+ 	new_string();
+ 	last_ts = first_ts = 0;
+ 	BEGIN(HELP);
+ }
+ 
+ static void zconf_endhelp(void)
+ {
+ 	zconflval.string = text;
+ 	BEGIN(INITIAL);
+ }
+ 
+ /*
+  * Try to open specified file with following names:
+  * ./name
+  * $(srctree)/name
+  * The latter is used when srctree is separate from objtree
+  * when compiling the kernel.
+  * Return NULL if file is not found.
+  */
+ FILE *zconf_fopen(const char *name)
+ {
+ 	char *env, fullname[PATH_MAX+1];
+ 	FILE *f;
+ 
+ 	f = fopen(name, "r");
+ 	if (!f && name != NULL && name[0] != '/') {
+ 		env = getenv(SRCTREE);
+ 		if (env) {
+ 			sprintf(fullname, "%s/%s", env, name);
+ 			f = fopen(fullname, "r");
+ 		}
+ 	}
+ 	return f;
+ }
+ 
+ void zconf_initscan(const char *name)
+ {
+ 	zconfin = zconf_fopen(name);
+ 	if (!zconfin) {
+ 		printf("can't find file %s\n", name);
+ 		exit(1);
+ 	}
+ 
+ 	current_buf = malloc(sizeof(*current_buf));
+ 	memset(current_buf, 0, sizeof(*current_buf));
+ 
+ 	current_file = file_lookup(name);
+ 	current_file->lineno = 1;
+ 	current_file->flags = FILE_BUSY;
+ }
+ 
+ void zconf_nextfile(const char *name)
+ {
+ 	struct file *file = file_lookup(name);
+ 	struct buffer *buf = malloc(sizeof(*buf));
+ 	memset(buf, 0, sizeof(*buf));
+ 
+ 	current_buf->state = YY_CURRENT_BUFFER;
+ 	zconfin = zconf_fopen(name);
+ 	if (!zconfin) {
+ 		printf("%s:%d: can't open file \"%s\"\n", zconf_curname(), zconf_lineno(), name);
+ 		exit(1);
+ 	}
+ 	zconf_switch_to_buffer(zconf_create_buffer(zconfin,YY_BUF_SIZE));
+ 	buf->parent = current_buf;
+ 	current_buf = buf;
+ 
+ 	if (file->flags & FILE_BUSY) {
+ 		printf("%s:%d: do not source '%s' from itself\n",
+ 		       zconf_curname(), zconf_lineno(), name);
+ 		exit(1);
+ 	}
+ 	if (file->flags & FILE_SCANNED) {
+ 		printf("%s:%d: file '%s' is already sourced from '%s'\n",
+ 		       zconf_curname(), zconf_lineno(), name,
+ 		       file->parent->name);
+ 		exit(1);
+ 	}
+ 	file->flags |= FILE_BUSY;
+ 	file->lineno = 1;
+ 	file->parent = current_file;
+ 	current_file = file;
+ }
+ 
+ static void zconf_endfile(void)
+ {
+ 	struct buffer *parent;
+ 
+ 	current_file->flags |= FILE_SCANNED;
+ 	current_file->flags &= ~FILE_BUSY;
+ 	current_file = current_file->parent;
+ 
+ 	parent = current_buf->parent;
+ 	if (parent) {
+ 		fclose(zconfin);
+ 		zconf_delete_buffer(YY_CURRENT_BUFFER);
+ 		zconf_switch_to_buffer(parent->state);
+ 	}
+ 	free(current_buf);
+ 	current_buf = parent;
+ }
+ 
+ int zconf_lineno(void)
+ {
+ 	return current_pos.lineno;
+ }
+ 
+ char *zconf_curname(void)
+ {
+ 	return current_pos.file ? current_pos.file->name : "<none>";
+ }
+ 
diff -r -C3 -P linux-2.6.29.4/scripts/kconfig/zconf.hash.c liab-linux-2.6.29.4/scripts/kconfig/zconf.hash.c
*** linux-2.6.29.4/scripts/kconfig/zconf.hash.c	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/scripts/kconfig/zconf.hash.c	2012-04-03 14:03:07.180517046 +0200
***************
*** 0 ****
--- 1,237 ----
+ /* ANSI-C code produced by gperf version 3.0.3 */
+ /* Command-line: gperf  */
+ /* Computed positions: -k'1,3' */
+ 
+ #if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
+       && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
+       && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \
+       && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
+       && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \
+       && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \
+       && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \
+       && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \
+       && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \
+       && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \
+       && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \
+       && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \
+       && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \
+       && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \
+       && ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) \
+       && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \
+       && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \
+       && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \
+       && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \
+       && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \
+       && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \
+       && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \
+       && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))
+ /* The character set is not based on ISO-646.  */
+ #error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
+ #endif
+ 
+ struct kconf_id;
+ /* maximum key range = 47, duplicates = 0 */
+ 
+ #ifdef __GNUC__
+ __inline
+ #else
+ #ifdef __cplusplus
+ inline
+ #endif
+ #endif
+ static unsigned int
+ kconf_id_hash (register const char *str, register unsigned int len)
+ {
+   static unsigned char asso_values[] =
+     {
+       49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+       49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+       49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+       49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+       49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+       49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+       49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+       49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+       49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+       49, 49, 49, 49, 49, 49, 49, 49, 11,  5,
+        0,  0,  5, 49,  5, 20, 49, 49,  5, 20,
+        5,  0, 30, 49,  0, 15,  0, 10,  0, 49,
+       25, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+       49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+       49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+       49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+       49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+       49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+       49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+       49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+       49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+       49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+       49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+       49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+       49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+       49, 49, 49, 49, 49, 49
+     };
+   register int hval = len;
+ 
+   switch (hval)
+     {
+       default:
+         hval += asso_values[(unsigned char)str[2]];
+       /*FALLTHROUGH*/
+       case 2:
+       case 1:
+         hval += asso_values[(unsigned char)str[0]];
+         break;
+     }
+   return hval;
+ }
+ 
+ struct kconf_id_strings_t
+   {
+     char kconf_id_strings_str2[sizeof("on")];
+     char kconf_id_strings_str3[sizeof("env")];
+     char kconf_id_strings_str5[sizeof("endif")];
+     char kconf_id_strings_str6[sizeof("option")];
+     char kconf_id_strings_str7[sizeof("endmenu")];
+     char kconf_id_strings_str8[sizeof("optional")];
+     char kconf_id_strings_str9[sizeof("endchoice")];
+     char kconf_id_strings_str10[sizeof("range")];
+     char kconf_id_strings_str11[sizeof("choice")];
+     char kconf_id_strings_str12[sizeof("default")];
+     char kconf_id_strings_str13[sizeof("def_bool")];
+     char kconf_id_strings_str14[sizeof("help")];
+     char kconf_id_strings_str15[sizeof("bool")];
+     char kconf_id_strings_str16[sizeof("config")];
+     char kconf_id_strings_str17[sizeof("def_tristate")];
+     char kconf_id_strings_str18[sizeof("boolean")];
+     char kconf_id_strings_str19[sizeof("defconfig_list")];
+     char kconf_id_strings_str21[sizeof("string")];
+     char kconf_id_strings_str22[sizeof("if")];
+     char kconf_id_strings_str23[sizeof("int")];
+     char kconf_id_strings_str26[sizeof("select")];
+     char kconf_id_strings_str27[sizeof("modules")];
+     char kconf_id_strings_str28[sizeof("tristate")];
+     char kconf_id_strings_str29[sizeof("menu")];
+     char kconf_id_strings_str31[sizeof("source")];
+     char kconf_id_strings_str32[sizeof("comment")];
+     char kconf_id_strings_str33[sizeof("hex")];
+     char kconf_id_strings_str35[sizeof("menuconfig")];
+     char kconf_id_strings_str36[sizeof("prompt")];
+     char kconf_id_strings_str37[sizeof("depends")];
+     char kconf_id_strings_str48[sizeof("mainmenu")];
+   };
+ static struct kconf_id_strings_t kconf_id_strings_contents =
+   {
+     "on",
+     "env",
+     "endif",
+     "option",
+     "endmenu",
+     "optional",
+     "endchoice",
+     "range",
+     "choice",
+     "default",
+     "def_bool",
+     "help",
+     "bool",
+     "config",
+     "def_tristate",
+     "boolean",
+     "defconfig_list",
+     "string",
+     "if",
+     "int",
+     "select",
+     "modules",
+     "tristate",
+     "menu",
+     "source",
+     "comment",
+     "hex",
+     "menuconfig",
+     "prompt",
+     "depends",
+     "mainmenu"
+   };
+ #define kconf_id_strings ((const char *) &kconf_id_strings_contents)
+ #ifdef __GNUC__
+ __inline
+ #ifdef __GNUC_STDC_INLINE__
+ __attribute__ ((__gnu_inline__))
+ #endif
+ #endif
+ struct kconf_id *
+ kconf_id_lookup (register const char *str, register unsigned int len)
+ {
+   enum
+     {
+       TOTAL_KEYWORDS = 31,
+       MIN_WORD_LENGTH = 2,
+       MAX_WORD_LENGTH = 14,
+       MIN_HASH_VALUE = 2,
+       MAX_HASH_VALUE = 48
+     };
+ 
+   static struct kconf_id wordlist[] =
+     {
+       {-1}, {-1},
+       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str2,		T_ON,		TF_PARAM},
+       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str3,		T_OPT_ENV,	TF_OPTION},
+       {-1},
+       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str5,		T_ENDIF,	TF_COMMAND},
+       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str6,		T_OPTION,	TF_COMMAND},
+       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str7,	T_ENDMENU,	TF_COMMAND},
+       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str8,	T_OPTIONAL,	TF_COMMAND},
+       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str9,	T_ENDCHOICE,	TF_COMMAND},
+       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str10,		T_RANGE,	TF_COMMAND},
+       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str11,		T_CHOICE,	TF_COMMAND},
+       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str12,	T_DEFAULT,	TF_COMMAND, S_UNKNOWN},
+       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str13,	T_DEFAULT,	TF_COMMAND, S_BOOLEAN},
+       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str14,		T_HELP,		TF_COMMAND},
+       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str15,		T_TYPE,		TF_COMMAND, S_BOOLEAN},
+       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str16,		T_CONFIG,	TF_COMMAND},
+       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str17,	T_DEFAULT,	TF_COMMAND, S_TRISTATE},
+       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str18,	T_TYPE,		TF_COMMAND, S_BOOLEAN},
+       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str19,	T_OPT_DEFCONFIG_LIST,TF_OPTION},
+       {-1},
+       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str21,		T_TYPE,		TF_COMMAND, S_STRING},
+       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str22,		T_IF,		TF_COMMAND|TF_PARAM},
+       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str23,		T_TYPE,		TF_COMMAND, S_INT},
+       {-1}, {-1},
+       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str26,		T_SELECT,	TF_COMMAND},
+       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str27,	T_OPT_MODULES,	TF_OPTION},
+       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str28,	T_TYPE,		TF_COMMAND, S_TRISTATE},
+       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str29,		T_MENU,		TF_COMMAND},
+       {-1},
+       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str31,		T_SOURCE,	TF_COMMAND},
+       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str32,	T_COMMENT,	TF_COMMAND},
+       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str33,		T_TYPE,		TF_COMMAND, S_HEX},
+       {-1},
+       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str35,	T_MENUCONFIG,	TF_COMMAND},
+       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str36,		T_PROMPT,	TF_COMMAND},
+       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str37,	T_DEPENDS,	TF_COMMAND},
+       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
+       {-1},
+       {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str48,	T_MAINMENU,	TF_COMMAND}
+     };
+ 
+   if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
+     {
+       register int key = kconf_id_hash (str, len);
+ 
+       if (key <= MAX_HASH_VALUE && key >= 0)
+         {
+           register int o = wordlist[key].name;
+           if (o >= 0)
+             {
+               register const char *s = o + kconf_id_strings;
+ 
+               if (*str == *s && !strncmp (str + 1, s + 1, len - 1) && s[len] == '\0')
+                 return &wordlist[key];
+             }
+         }
+     }
+   return 0;
+ }
+ 
diff -r -C3 -P linux-2.6.29.4/scripts/kconfig/zconf.tab.c liab-linux-2.6.29.4/scripts/kconfig/zconf.tab.c
*** linux-2.6.29.4/scripts/kconfig/zconf.tab.c	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/scripts/kconfig/zconf.tab.c	2012-04-03 14:03:07.176517046 +0200
***************
*** 0 ****
--- 1,2490 ----
+ /* A Bison parser, made by GNU Bison 2.3.  */
+ 
+ /* Skeleton implementation for Bison's Yacc-like parsers in C
+ 
+    Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+    Free Software Foundation, Inc.
+ 
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2, or (at your option)
+    any later version.
+ 
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+ 
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.  */
+ 
+ /* As a special exception, you may create a larger work that contains
+    part or all of the Bison parser skeleton and distribute that work
+    under terms of your choice, so long as that work isn't itself a
+    parser generator using the skeleton or a modified version thereof
+    as a parser skeleton.  Alternatively, if you modify or redistribute
+    the parser skeleton itself, you may (at your option) remove this
+    special exception, which will cause the skeleton and the resulting
+    Bison output files to be licensed under the GNU General Public
+    License without this special exception.
+ 
+    This special exception was added by the Free Software Foundation in
+    version 2.2 of Bison.  */
+ 
+ /* C LALR(1) parser skeleton written by Richard Stallman, by
+    simplifying the original so-called "semantic" parser.  */
+ 
+ /* All symbols defined below should begin with yy or YY, to avoid
+    infringing on user name space.  This should be done even for local
+    variables, as they might otherwise be expanded by user macros.
+    There are some unavoidable exceptions within include files to
+    define necessary library symbols; they are noted "INFRINGES ON
+    USER NAME SPACE" below.  */
+ 
+ /* Identify Bison output.  */
+ #define YYBISON 1
+ 
+ /* Bison version.  */
+ #define YYBISON_VERSION "2.3"
+ 
+ /* Skeleton name.  */
+ #define YYSKELETON_NAME "yacc.c"
+ 
+ /* Pure parsers.  */
+ #define YYPURE 0
+ 
+ /* Using locations.  */
+ #define YYLSP_NEEDED 0
+ 
+ /* Substitute the variable and function names.  */
+ #define yyparse zconfparse
+ #define yylex   zconflex
+ #define yyerror zconferror
+ #define yylval  zconflval
+ #define yychar  zconfchar
+ #define yydebug zconfdebug
+ #define yynerrs zconfnerrs
+ 
+ 
+ /* Tokens.  */
+ #ifndef YYTOKENTYPE
+ # define YYTOKENTYPE
+    /* Put the tokens into the symbol table, so that GDB and other debuggers
+       know about them.  */
+    enum yytokentype {
+      T_MAINMENU = 258,
+      T_MENU = 259,
+      T_ENDMENU = 260,
+      T_SOURCE = 261,
+      T_CHOICE = 262,
+      T_ENDCHOICE = 263,
+      T_COMMENT = 264,
+      T_CONFIG = 265,
+      T_MENUCONFIG = 266,
+      T_HELP = 267,
+      T_HELPTEXT = 268,
+      T_IF = 269,
+      T_ENDIF = 270,
+      T_DEPENDS = 271,
+      T_OPTIONAL = 272,
+      T_PROMPT = 273,
+      T_TYPE = 274,
+      T_DEFAULT = 275,
+      T_SELECT = 276,
+      T_RANGE = 277,
+      T_OPTION = 278,
+      T_ON = 279,
+      T_WORD = 280,
+      T_WORD_QUOTE = 281,
+      T_UNEQUAL = 282,
+      T_CLOSE_PAREN = 283,
+      T_OPEN_PAREN = 284,
+      T_EOL = 285,
+      T_OR = 286,
+      T_AND = 287,
+      T_EQUAL = 288,
+      T_NOT = 289
+    };
+ #endif
+ /* Tokens.  */
+ #define T_MAINMENU 258
+ #define T_MENU 259
+ #define T_ENDMENU 260
+ #define T_SOURCE 261
+ #define T_CHOICE 262
+ #define T_ENDCHOICE 263
+ #define T_COMMENT 264
+ #define T_CONFIG 265
+ #define T_MENUCONFIG 266
+ #define T_HELP 267
+ #define T_HELPTEXT 268
+ #define T_IF 269
+ #define T_ENDIF 270
+ #define T_DEPENDS 271
+ #define T_OPTIONAL 272
+ #define T_PROMPT 273
+ #define T_TYPE 274
+ #define T_DEFAULT 275
+ #define T_SELECT 276
+ #define T_RANGE 277
+ #define T_OPTION 278
+ #define T_ON 279
+ #define T_WORD 280
+ #define T_WORD_QUOTE 281
+ #define T_UNEQUAL 282
+ #define T_CLOSE_PAREN 283
+ #define T_OPEN_PAREN 284
+ #define T_EOL 285
+ #define T_OR 286
+ #define T_AND 287
+ #define T_EQUAL 288
+ #define T_NOT 289
+ 
+ 
+ 
+ 
+ /* Copy the first part of user declarations.  */
+ 
+ 
+ /*
+  * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+  * Released under the terms of the GNU GPL v2.0.
+  */
+ 
+ #include <ctype.h>
+ #include <stdarg.h>
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <string.h>
+ #include <stdbool.h>
+ 
+ #define LKC_DIRECT_LINK
+ #include "lkc.h"
+ 
+ #include "zconf.hash.c"
+ 
+ #define printd(mask, fmt...) if (cdebug & (mask)) printf(fmt)
+ 
+ #define PRINTD		0x0001
+ #define DEBUG_PARSE	0x0002
+ 
+ int cdebug = PRINTD;
+ 
+ extern int zconflex(void);
+ static void zconfprint(const char *err, ...);
+ static void zconf_error(const char *err, ...);
+ static void zconferror(const char *err);
+ static bool zconf_endtoken(struct kconf_id *id, int starttoken, int endtoken);
+ 
+ struct symbol *symbol_hash[257];
+ 
+ static struct menu *current_menu, *current_entry;
+ 
+ #define YYDEBUG 0
+ #if YYDEBUG
+ #define YYERROR_VERBOSE
+ #endif
+ 
+ 
+ /* Enabling traces.  */
+ #ifndef YYDEBUG
+ # define YYDEBUG 0
+ #endif
+ 
+ /* Enabling verbose error messages.  */
+ #ifdef YYERROR_VERBOSE
+ # undef YYERROR_VERBOSE
+ # define YYERROR_VERBOSE 1
+ #else
+ # define YYERROR_VERBOSE 0
+ #endif
+ 
+ /* Enabling the token table.  */
+ #ifndef YYTOKEN_TABLE
+ # define YYTOKEN_TABLE 0
+ #endif
+ 
+ #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+ typedef union YYSTYPE
+ 
+ {
+ 	char *string;
+ 	struct file *file;
+ 	struct symbol *symbol;
+ 	struct expr *expr;
+ 	struct menu *menu;
+ 	struct kconf_id *id;
+ }
+ /* Line 187 of yacc.c.  */
+ 
+ 	YYSTYPE;
+ # define yystype YYSTYPE /* obsolescent; will be withdrawn */
+ # define YYSTYPE_IS_DECLARED 1
+ # define YYSTYPE_IS_TRIVIAL 1
+ #endif
+ 
+ 
+ 
+ /* Copy the second part of user declarations.  */
+ 
+ 
+ /* Line 216 of yacc.c.  */
+ 
+ 
+ #ifdef short
+ # undef short
+ #endif
+ 
+ #ifdef YYTYPE_UINT8
+ typedef YYTYPE_UINT8 yytype_uint8;
+ #else
+ typedef unsigned char yytype_uint8;
+ #endif
+ 
+ #ifdef YYTYPE_INT8
+ typedef YYTYPE_INT8 yytype_int8;
+ #elif (defined __STDC__ || defined __C99__FUNC__ \
+      || defined __cplusplus || defined _MSC_VER)
+ typedef signed char yytype_int8;
+ #else
+ typedef short int yytype_int8;
+ #endif
+ 
+ #ifdef YYTYPE_UINT16
+ typedef YYTYPE_UINT16 yytype_uint16;
+ #else
+ typedef unsigned short int yytype_uint16;
+ #endif
+ 
+ #ifdef YYTYPE_INT16
+ typedef YYTYPE_INT16 yytype_int16;
+ #else
+ typedef short int yytype_int16;
+ #endif
+ 
+ #ifndef YYSIZE_T
+ # ifdef __SIZE_TYPE__
+ #  define YYSIZE_T __SIZE_TYPE__
+ # elif defined size_t
+ #  define YYSIZE_T size_t
+ # elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+      || defined __cplusplus || defined _MSC_VER)
+ #  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+ #  define YYSIZE_T size_t
+ # else
+ #  define YYSIZE_T unsigned int
+ # endif
+ #endif
+ 
+ #define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+ 
+ #ifndef YY_
+ # if YYENABLE_NLS
+ #  if ENABLE_NLS
+ #   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+ #   define YY_(msgid) dgettext ("bison-runtime", msgid)
+ #  endif
+ # endif
+ # ifndef YY_
+ #  define YY_(msgid) msgid
+ # endif
+ #endif
+ 
+ /* Suppress unused-variable warnings by "using" E.  */
+ #if ! defined lint || defined __GNUC__
+ # define YYUSE(e) ((void) (e))
+ #else
+ # define YYUSE(e) /* empty */
+ #endif
+ 
+ /* Identity function, used to suppress warnings about constant conditions.  */
+ #ifndef lint
+ # define YYID(n) (n)
+ #else
+ #if (defined __STDC__ || defined __C99__FUNC__ \
+      || defined __cplusplus || defined _MSC_VER)
+ static int
+ YYID (int i)
+ #else
+ static int
+ YYID (i)
+     int i;
+ #endif
+ {
+   return i;
+ }
+ #endif
+ 
+ #if ! defined yyoverflow || YYERROR_VERBOSE
+ 
+ /* The parser invokes alloca or malloc; define the necessary symbols.  */
+ 
+ # ifdef YYSTACK_USE_ALLOCA
+ #  if YYSTACK_USE_ALLOCA
+ #   ifdef __GNUC__
+ #    define YYSTACK_ALLOC __builtin_alloca
+ #   elif defined __BUILTIN_VA_ARG_INCR
+ #    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+ #   elif defined _AIX
+ #    define YYSTACK_ALLOC __alloca
+ #   elif defined _MSC_VER
+ #    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+ #    define alloca _alloca
+ #   else
+ #    define YYSTACK_ALLOC alloca
+ #    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+      || defined __cplusplus || defined _MSC_VER)
+ #     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+ #     ifndef _STDLIB_H
+ #      define _STDLIB_H 1
+ #     endif
+ #    endif
+ #   endif
+ #  endif
+ # endif
+ 
+ # ifdef YYSTACK_ALLOC
+    /* Pacify GCC's `empty if-body' warning.  */
+ #  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+ #  ifndef YYSTACK_ALLOC_MAXIMUM
+     /* The OS might guarantee only one guard page at the bottom of the stack,
+        and a page size can be as small as 4096 bytes.  So we cannot safely
+        invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+        to allow for a few compiler-allocated temporary stack slots.  */
+ #   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+ #  endif
+ # else
+ #  define YYSTACK_ALLOC YYMALLOC
+ #  define YYSTACK_FREE YYFREE
+ #  ifndef YYSTACK_ALLOC_MAXIMUM
+ #   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+ #  endif
+ #  if (defined __cplusplus && ! defined _STDLIB_H \
+        && ! ((defined YYMALLOC || defined malloc) \
+ 	     && (defined YYFREE || defined free)))
+ #   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+ #   ifndef _STDLIB_H
+ #    define _STDLIB_H 1
+ #   endif
+ #  endif
+ #  ifndef YYMALLOC
+ #   define YYMALLOC malloc
+ #   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+      || defined __cplusplus || defined _MSC_VER)
+ void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+ #   endif
+ #  endif
+ #  ifndef YYFREE
+ #   define YYFREE free
+ #   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+      || defined __cplusplus || defined _MSC_VER)
+ void free (void *); /* INFRINGES ON USER NAME SPACE */
+ #   endif
+ #  endif
+ # endif
+ #endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+ 
+ 
+ #if (! defined yyoverflow \
+      && (! defined __cplusplus \
+ 	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+ 
+ /* A type that is properly aligned for any stack member.  */
+ union yyalloc
+ {
+   yytype_int16 yyss;
+   YYSTYPE yyvs;
+   };
+ 
+ /* The size of the maximum gap between one aligned stack and the next.  */
+ # define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+ 
+ /* The size of an array large to enough to hold all stacks, each with
+    N elements.  */
+ # define YYSTACK_BYTES(N) \
+      ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+       + YYSTACK_GAP_MAXIMUM)
+ 
+ /* Copy COUNT objects from FROM to TO.  The source and destination do
+    not overlap.  */
+ # ifndef YYCOPY
+ #  if defined __GNUC__ && 1 < __GNUC__
+ #   define YYCOPY(To, From, Count) \
+       __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+ #  else
+ #   define YYCOPY(To, From, Count)		\
+       do					\
+ 	{					\
+ 	  YYSIZE_T yyi;				\
+ 	  for (yyi = 0; yyi < (Count); yyi++)	\
+ 	    (To)[yyi] = (From)[yyi];		\
+ 	}					\
+       while (YYID (0))
+ #  endif
+ # endif
+ 
+ /* Relocate STACK from its old location to the new one.  The
+    local variables YYSIZE and YYSTACKSIZE give the old and new number of
+    elements in the stack, and YYPTR gives the new location of the
+    stack.  Advance YYPTR to a properly aligned location for the next
+    stack.  */
+ # define YYSTACK_RELOCATE(Stack)					\
+     do									\
+       {									\
+ 	YYSIZE_T yynewbytes;						\
+ 	YYCOPY (&yyptr->Stack, Stack, yysize);				\
+ 	Stack = &yyptr->Stack;						\
+ 	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+ 	yyptr += yynewbytes / sizeof (*yyptr);				\
+       }									\
+     while (YYID (0))
+ 
+ #endif
+ 
+ /* YYFINAL -- State number of the termination state.  */
+ #define YYFINAL  3
+ /* YYLAST -- Last index in YYTABLE.  */
+ #define YYLAST   259
+ 
+ /* YYNTOKENS -- Number of terminals.  */
+ #define YYNTOKENS  35
+ /* YYNNTS -- Number of nonterminals.  */
+ #define YYNNTS  46
+ /* YYNRULES -- Number of rules.  */
+ #define YYNRULES  110
+ /* YYNRULES -- Number of states.  */
+ #define YYNSTATES  180
+ 
+ /* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+ #define YYUNDEFTOK  2
+ #define YYMAXUTOK   289
+ 
+ #define YYTRANSLATE(YYX)						\
+   ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+ 
+ /* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+ static const yytype_uint8 yytranslate[] =
+ {
+        0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+        2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+        5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+       15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+       25,    26,    27,    28,    29,    30,    31,    32,    33,    34
+ };
+ 
+ #if YYDEBUG
+ /* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+    YYRHS.  */
+ static const yytype_uint16 yyprhs[] =
+ {
+        0,     0,     3,     5,     6,     9,    12,    15,    20,    23,
+       28,    33,    37,    39,    41,    43,    45,    47,    49,    51,
+       53,    55,    57,    59,    61,    63,    67,    70,    74,    77,
+       81,    84,    85,    88,    91,    94,    97,   100,   103,   107,
+      112,   117,   122,   128,   132,   133,   137,   138,   141,   145,
+      148,   150,   154,   155,   158,   161,   164,   167,   170,   175,
+      179,   182,   187,   188,   191,   195,   197,   201,   202,   205,
+      208,   211,   215,   218,   220,   224,   225,   228,   231,   234,
+      238,   242,   245,   248,   251,   252,   255,   258,   261,   266,
+      267,   270,   272,   274,   277,   280,   283,   285,   288,   289,
+      292,   294,   298,   302,   306,   309,   313,   317,   319,   321,
+      322
+ };
+ 
+ /* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+ static const yytype_int8 yyrhs[] =
+ {
+       36,     0,    -1,    37,    -1,    -1,    37,    39,    -1,    37,
+       53,    -1,    37,    64,    -1,    37,     3,    74,    76,    -1,
+       37,    75,    -1,    37,    25,     1,    30,    -1,    37,    38,
+        1,    30,    -1,    37,     1,    30,    -1,    16,    -1,    18,
+       -1,    19,    -1,    21,    -1,    17,    -1,    22,    -1,    20,
+       -1,    30,    -1,    59,    -1,    68,    -1,    42,    -1,    44,
+       -1,    66,    -1,    25,     1,    30,    -1,     1,    30,    -1,
+       10,    25,    30,    -1,    41,    45,    -1,    11,    25,    30,
+       -1,    43,    45,    -1,    -1,    45,    46,    -1,    45,    47,
+       -1,    45,    72,    -1,    45,    70,    -1,    45,    40,    -1,
+       45,    30,    -1,    19,    73,    30,    -1,    18,    74,    77,
+       30,    -1,    20,    78,    77,    30,    -1,    21,    25,    77,
+       30,    -1,    22,    79,    79,    77,    30,    -1,    23,    48,
+       30,    -1,    -1,    48,    25,    49,    -1,    -1,    33,    74,
+       -1,     7,    80,    30,    -1,    50,    54,    -1,    75,    -1,
+       51,    56,    52,    -1,    -1,    54,    55,    -1,    54,    72,
+       -1,    54,    70,    -1,    54,    30,    -1,    54,    40,    -1,
+       18,    74,    77,    30,    -1,    19,    73,    30,    -1,    17,
+       30,    -1,    20,    25,    77,    30,    -1,    -1,    56,    39,
+       -1,    14,    78,    76,    -1,    75,    -1,    57,    60,    58,
+       -1,    -1,    60,    39,    -1,    60,    64,    -1,    60,    53,
+       -1,     4,    74,    30,    -1,    61,    71,    -1,    75,    -1,
+       62,    65,    63,    -1,    -1,    65,    39,    -1,    65,    64,
+       -1,    65,    53,    -1,     6,    74,    30,    -1,     9,    74,
+       30,    -1,    67,    71,    -1,    12,    30,    -1,    69,    13,
+       -1,    -1,    71,    72,    -1,    71,    30,    -1,    71,    40,
+       -1,    16,    24,    78,    30,    -1,    -1,    74,    77,    -1,
+       25,    -1,    26,    -1,     5,    30,    -1,     8,    30,    -1,
+       15,    30,    -1,    30,    -1,    76,    30,    -1,    -1,    14,
+       78,    -1,    79,    -1,    79,    33,    79,    -1,    79,    27,
+       79,    -1,    29,    78,    28,    -1,    34,    78,    -1,    78,
+       31,    78,    -1,    78,    32,    78,    -1,    25,    -1,    26,
+       -1,    -1,    25,    -1
+ };
+ 
+ /* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+ static const yytype_uint16 yyrline[] =
+ {
+        0,   104,   104,   106,   108,   109,   110,   111,   112,   113,
+      114,   118,   122,   122,   122,   122,   122,   122,   122,   126,
+      127,   128,   129,   130,   131,   135,   136,   142,   150,   156,
+      164,   174,   176,   177,   178,   179,   180,   181,   184,   192,
+      198,   208,   214,   220,   223,   225,   236,   237,   242,   251,
+      256,   264,   267,   269,   270,   271,   272,   273,   276,   282,
+      293,   299,   309,   311,   316,   324,   332,   335,   337,   338,
+      339,   344,   351,   356,   364,   367,   369,   370,   371,   374,
+      382,   389,   396,   402,   409,   411,   412,   413,   416,   424,
+      426,   431,   432,   435,   436,   437,   441,   442,   445,   446,
+      449,   450,   451,   452,   453,   454,   455,   458,   459,   462,
+      463
+ };
+ #endif
+ 
+ #if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+ /* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+    First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+ static const char *const yytname[] =
+ {
+   "$end", "error", "$undefined", "T_MAINMENU", "T_MENU", "T_ENDMENU",
+   "T_SOURCE", "T_CHOICE", "T_ENDCHOICE", "T_COMMENT", "T_CONFIG",
+   "T_MENUCONFIG", "T_HELP", "T_HELPTEXT", "T_IF", "T_ENDIF", "T_DEPENDS",
+   "T_OPTIONAL", "T_PROMPT", "T_TYPE", "T_DEFAULT", "T_SELECT", "T_RANGE",
+   "T_OPTION", "T_ON", "T_WORD", "T_WORD_QUOTE", "T_UNEQUAL",
+   "T_CLOSE_PAREN", "T_OPEN_PAREN", "T_EOL", "T_OR", "T_AND", "T_EQUAL",
+   "T_NOT", "$accept", "input", "stmt_list", "option_name", "common_stmt",
+   "option_error", "config_entry_start", "config_stmt",
+   "menuconfig_entry_start", "menuconfig_stmt", "config_option_list",
+   "config_option", "symbol_option", "symbol_option_list",
+   "symbol_option_arg", "choice", "choice_entry", "choice_end",
+   "choice_stmt", "choice_option_list", "choice_option", "choice_block",
+   "if_entry", "if_end", "if_stmt", "if_block", "menu", "menu_entry",
+   "menu_end", "menu_stmt", "menu_block", "source_stmt", "comment",
+   "comment_stmt", "help_start", "help", "depends_list", "depends",
+   "prompt_stmt_opt", "prompt", "end", "nl", "if_expr", "expr", "symbol",
+   "word_opt", 0
+ };
+ #endif
+ 
+ # ifdef YYPRINT
+ /* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+    token YYLEX-NUM.  */
+ static const yytype_uint16 yytoknum[] =
+ {
+        0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+      265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+      275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+      285,   286,   287,   288,   289
+ };
+ # endif
+ 
+ /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+ static const yytype_uint8 yyr1[] =
+ {
+        0,    35,    36,    37,    37,    37,    37,    37,    37,    37,
+       37,    37,    38,    38,    38,    38,    38,    38,    38,    39,
+       39,    39,    39,    39,    39,    40,    40,    41,    42,    43,
+       44,    45,    45,    45,    45,    45,    45,    45,    46,    46,
+       46,    46,    46,    47,    48,    48,    49,    49,    50,    51,
+       52,    53,    54,    54,    54,    54,    54,    54,    55,    55,
+       55,    55,    56,    56,    57,    58,    59,    60,    60,    60,
+       60,    61,    62,    63,    64,    65,    65,    65,    65,    66,
+       67,    68,    69,    70,    71,    71,    71,    71,    72,    73,
+       73,    74,    74,    75,    75,    75,    76,    76,    77,    77,
+       78,    78,    78,    78,    78,    78,    78,    79,    79,    80,
+       80
+ };
+ 
+ /* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+ static const yytype_uint8 yyr2[] =
+ {
+        0,     2,     1,     0,     2,     2,     2,     4,     2,     4,
+        4,     3,     1,     1,     1,     1,     1,     1,     1,     1,
+        1,     1,     1,     1,     1,     3,     2,     3,     2,     3,
+        2,     0,     2,     2,     2,     2,     2,     2,     3,     4,
+        4,     4,     5,     3,     0,     3,     0,     2,     3,     2,
+        1,     3,     0,     2,     2,     2,     2,     2,     4,     3,
+        2,     4,     0,     2,     3,     1,     3,     0,     2,     2,
+        2,     3,     2,     1,     3,     0,     2,     2,     2,     3,
+        3,     2,     2,     2,     0,     2,     2,     2,     4,     0,
+        2,     1,     1,     2,     2,     2,     1,     2,     0,     2,
+        1,     3,     3,     3,     2,     3,     3,     1,     1,     0,
+        1
+ };
+ 
+ /* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+    STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+    means the default is an error.  */
+ static const yytype_uint8 yydefact[] =
+ {
+        3,     0,     0,     1,     0,     0,     0,     0,     0,   109,
+        0,     0,     0,     0,     0,     0,    12,    16,    13,    14,
+       18,    15,    17,     0,    19,     0,     4,    31,    22,    31,
+       23,    52,    62,     5,    67,    20,    84,    75,     6,    24,
+       84,    21,     8,    11,    91,    92,     0,     0,    93,     0,
+      110,     0,    94,     0,     0,     0,   107,   108,     0,     0,
+        0,   100,    95,     0,     0,     0,     0,     0,     0,     0,
+        0,     0,     0,    96,     7,    71,    79,    48,    80,    27,
+       29,     0,   104,     0,     0,    64,     0,     0,     9,    10,
+        0,     0,     0,     0,    89,     0,     0,     0,    44,     0,
+       37,    36,    32,    33,     0,    35,    34,     0,     0,    89,
+        0,    56,    57,    53,    55,    54,    63,    51,    50,    68,
+       70,    66,    69,    65,    86,    87,    85,    76,    78,    74,
+       77,    73,    97,   103,   105,   106,   102,   101,    26,    82,
+        0,    98,     0,    98,    98,    98,     0,     0,     0,    83,
+       60,    98,     0,    98,     0,     0,     0,    38,    90,     0,
+        0,    98,    46,    43,    25,     0,    59,     0,    88,    99,
+       39,    40,    41,     0,     0,    45,    58,    61,    42,    47
+ };
+ 
+ /* YYDEFGOTO[NTERM-NUM].  */
+ static const yytype_int16 yydefgoto[] =
+ {
+       -1,     1,     2,    25,    26,   101,    27,    28,    29,    30,
+       65,   102,   103,   147,   175,    31,    32,   117,    33,    67,
+      113,    68,    34,   121,    35,    69,    36,    37,   129,    38,
+       71,    39,    40,    41,   104,   105,    70,   106,   142,   143,
+       42,    74,   156,    60,    61,    51
+ };
+ 
+ /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+    STATE-NUM.  */
+ #define YYPACT_NINF -80
+ static const yytype_int16 yypact[] =
+ {
+      -80,     2,   132,   -80,   -13,    -1,    -1,    -2,    -1,     9,
+       33,    -1,    27,    40,    -3,    38,   -80,   -80,   -80,   -80,
+      -80,   -80,   -80,    71,   -80,    77,   -80,   -80,   -80,   -80,
+      -80,   -80,   -80,   -80,   -80,   -80,   -80,   -80,   -80,   -80,
+      -80,   -80,   -80,   -80,   -80,   -80,    57,    61,   -80,    63,
+      -80,    76,   -80,    87,   101,   133,   -80,   -80,    -3,    -3,
+      195,    -6,   -80,   136,   149,    39,   104,    65,   150,     5,
+      194,     5,   167,   -80,   176,   -80,   -80,   -80,   -80,   -80,
+      -80,    68,   -80,    -3,    -3,   176,    72,    72,   -80,   -80,
+      177,   187,    78,    -1,    -1,    -3,   196,    72,   -80,   222,
+      -80,   -80,   -80,   -80,   221,   -80,   -80,   205,    -1,    -1,
+      211,   -80,   -80,   -80,   -80,   -80,   -80,   -80,   -80,   -80,
+      -80,   -80,   -80,   -80,   -80,   -80,   -80,   -80,   -80,   -80,
+      -80,   -80,   -80,   -80,   206,   -80,   -80,   -80,   -80,   -80,
+       -3,   223,   209,   223,   197,   223,    72,     7,   210,   -80,
+      -80,   223,   212,   223,   201,    -3,   213,   -80,   -80,   214,
+      215,   223,   208,   -80,   -80,   216,   -80,   217,   -80,   113,
+      -80,   -80,   -80,   218,    -1,   -80,   -80,   -80,   -80,   -80
+ };
+ 
+ /* YYPGOTO[NTERM-NUM].  */
+ static const yytype_int16 yypgoto[] =
+ {
+      -80,   -80,   -80,   -80,   122,   -34,   -80,   -80,   -80,   -80,
+      220,   -80,   -80,   -80,   -80,   -80,   -80,   -80,    59,   -80,
+      -80,   -80,   -80,   -80,   -80,   -80,   -80,   -80,   -80,   125,
+      -80,   -80,   -80,   -80,   -80,   183,   219,    22,   142,    -5,
+      147,   192,    69,   -54,   -79,   -80
+ };
+ 
+ /* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+    positive, shift that token.  If negative, reduce the rule which
+    number is the opposite.  If zero, do what YYDEFACT says.
+    If YYTABLE_NINF, syntax error.  */
+ #define YYTABLE_NINF -82
+ static const yytype_int16 yytable[] =
+ {
+       46,    47,     3,    49,    81,    82,    53,   136,   137,     6,
+        7,     8,     9,    10,    11,    12,    13,    43,   146,    14,
+       15,    86,    56,    57,    44,    45,    58,    87,    48,   134,
+      135,    59,   162,   112,    50,    24,   125,   163,   125,   -28,
+       90,   144,   -28,   -28,   -28,   -28,   -28,   -28,   -28,   -28,
+      -28,    91,    54,   -28,   -28,    92,   -28,    93,    94,    95,
+       96,    97,    98,    52,    99,    55,    90,   161,    62,   100,
+      -49,   -49,    63,   -49,   -49,   -49,   -49,    91,    64,   -49,
+      -49,    92,   107,   108,   109,   110,   154,    73,   141,   115,
+       99,    75,   126,    76,   126,   111,   133,    56,    57,    83,
+       84,   169,   140,   151,   -30,    90,    77,   -30,   -30,   -30,
+      -30,   -30,   -30,   -30,   -30,   -30,    91,    78,   -30,   -30,
+       92,   -30,    93,    94,    95,    96,    97,    98,   120,    99,
+      128,    79,    -2,     4,   100,     5,     6,     7,     8,     9,
+       10,    11,    12,    13,    83,    84,    14,    15,    16,    17,
+       18,    19,    20,    21,    22,     7,     8,    23,    10,    11,
+       12,    13,    24,    80,    14,    15,    88,   -81,    90,   179,
+      -81,   -81,   -81,   -81,   -81,   -81,   -81,   -81,   -81,    89,
+       24,   -81,   -81,    92,   -81,   -81,   -81,   -81,   -81,   -81,
+      116,   119,    99,   127,   122,    90,   130,   124,   -72,   -72,
+      -72,   -72,   -72,   -72,   -72,   -72,   132,   138,   -72,   -72,
+       92,   155,   158,   159,   160,   118,   123,   139,   131,    99,
+      165,   145,   167,   148,   124,    73,    83,    84,    83,    84,
+      173,   168,    83,    84,   149,   150,   153,   155,    84,   157,
+      164,   174,   166,   170,   171,   172,   176,   177,   178,    66,
+      114,   152,    85,     0,     0,     0,     0,     0,     0,    72
+ };
+ 
+ static const yytype_int16 yycheck[] =
+ {
+        5,     6,     0,     8,    58,    59,    11,    86,    87,     4,
+        5,     6,     7,     8,     9,    10,    11,    30,    97,    14,
+       15,    27,    25,    26,    25,    26,    29,    33,    30,    83,
+       84,    34,    25,    67,    25,    30,    70,    30,    72,     0,
+        1,    95,     3,     4,     5,     6,     7,     8,     9,    10,
+       11,    12,    25,    14,    15,    16,    17,    18,    19,    20,
+       21,    22,    23,    30,    25,    25,     1,   146,    30,    30,
+        5,     6,     1,     8,     9,    10,    11,    12,     1,    14,
+       15,    16,    17,    18,    19,    20,   140,    30,    93,    67,
+       25,    30,    70,    30,    72,    30,    28,    25,    26,    31,
+       32,   155,    24,   108,     0,     1,    30,     3,     4,     5,
+        6,     7,     8,     9,    10,    11,    12,    30,    14,    15,
+       16,    17,    18,    19,    20,    21,    22,    23,    69,    25,
+       71,    30,     0,     1,    30,     3,     4,     5,     6,     7,
+        8,     9,    10,    11,    31,    32,    14,    15,    16,    17,
+       18,    19,    20,    21,    22,     5,     6,    25,     8,     9,
+       10,    11,    30,    30,    14,    15,    30,     0,     1,   174,
+        3,     4,     5,     6,     7,     8,     9,    10,    11,    30,
+       30,    14,    15,    16,    17,    18,    19,    20,    21,    22,
+       68,    69,    25,    71,    69,     1,    71,    30,     4,     5,
+        6,     7,     8,     9,    10,    11,    30,    30,    14,    15,
+       16,    14,   143,   144,   145,    68,    69,    30,    71,    25,
+      151,    25,   153,     1,    30,    30,    31,    32,    31,    32,
+      161,    30,    31,    32,    13,    30,    25,    14,    32,    30,
+       30,    33,    30,    30,    30,    30,    30,    30,    30,    29,
+       67,   109,    60,    -1,    -1,    -1,    -1,    -1,    -1,    40
+ };
+ 
+ /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+    symbol of state STATE-NUM.  */
+ static const yytype_uint8 yystos[] =
+ {
+        0,    36,    37,     0,     1,     3,     4,     5,     6,     7,
+        8,     9,    10,    11,    14,    15,    16,    17,    18,    19,
+       20,    21,    22,    25,    30,    38,    39,    41,    42,    43,
+       44,    50,    51,    53,    57,    59,    61,    62,    64,    66,
+       67,    68,    75,    30,    25,    26,    74,    74,    30,    74,
+       25,    80,    30,    74,    25,    25,    25,    26,    29,    34,
+       78,    79,    30,     1,     1,    45,    45,    54,    56,    60,
+       71,    65,    71,    30,    76,    30,    30,    30,    30,    30,
+       30,    78,    78,    31,    32,    76,    27,    33,    30,    30,
+        1,    12,    16,    18,    19,    20,    21,    22,    23,    25,
+       30,    40,    46,    47,    69,    70,    72,    17,    18,    19,
+       20,    30,    40,    55,    70,    72,    39,    52,    75,    39,
+       53,    58,    64,    75,    30,    40,    72,    39,    53,    63,
+       64,    75,    30,    28,    78,    78,    79,    79,    30,    30,
+       24,    74,    73,    74,    78,    25,    79,    48,     1,    13,
+       30,    74,    73,    25,    78,    14,    77,    30,    77,    77,
+       77,    79,    25,    30,    30,    77,    30,    77,    30,    78,
+       30,    30,    30,    77,    33,    49,    30,    30,    30,    74
+ };
+ 
+ #define yyerrok		(yyerrstatus = 0)
+ #define yyclearin	(yychar = YYEMPTY)
+ #define YYEMPTY		(-2)
+ #define YYEOF		0
+ 
+ #define YYACCEPT	goto yyacceptlab
+ #define YYABORT		goto yyabortlab
+ #define YYERROR		goto yyerrorlab
+ 
+ 
+ /* Like YYERROR except do call yyerror.  This remains here temporarily
+    to ease the transition to the new meaning of YYERROR, for GCC.
+    Once GCC version 2 has supplanted version 1, this can go.  */
+ 
+ #define YYFAIL		goto yyerrlab
+ 
+ #define YYRECOVERING()  (!!yyerrstatus)
+ 
+ #define YYBACKUP(Token, Value)					\
+ do								\
+   if (yychar == YYEMPTY && yylen == 1)				\
+     {								\
+       yychar = (Token);						\
+       yylval = (Value);						\
+       yytoken = YYTRANSLATE (yychar);				\
+       YYPOPSTACK (1);						\
+       goto yybackup;						\
+     }								\
+   else								\
+     {								\
+       yyerror (YY_("syntax error: cannot back up")); \
+       YYERROR;							\
+     }								\
+ while (YYID (0))
+ 
+ 
+ #define YYTERROR	1
+ #define YYERRCODE	256
+ 
+ 
+ /* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+    If N is 0, then set CURRENT to the empty location which ends
+    the previous symbol: RHS[0] (always defined).  */
+ 
+ #define YYRHSLOC(Rhs, K) ((Rhs)[K])
+ #ifndef YYLLOC_DEFAULT
+ # define YYLLOC_DEFAULT(Current, Rhs, N)				\
+     do									\
+       if (YYID (N))                                                    \
+ 	{								\
+ 	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+ 	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+ 	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+ 	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+ 	}								\
+       else								\
+ 	{								\
+ 	  (Current).first_line   = (Current).last_line   =		\
+ 	    YYRHSLOC (Rhs, 0).last_line;				\
+ 	  (Current).first_column = (Current).last_column =		\
+ 	    YYRHSLOC (Rhs, 0).last_column;				\
+ 	}								\
+     while (YYID (0))
+ #endif
+ 
+ 
+ /* YY_LOCATION_PRINT -- Print the location on the stream.
+    This macro was not mandated originally: define only if we know
+    we won't break user code: when these are the locations we know.  */
+ 
+ #ifndef YY_LOCATION_PRINT
+ # if YYLTYPE_IS_TRIVIAL
+ #  define YY_LOCATION_PRINT(File, Loc)			\
+      fprintf (File, "%d.%d-%d.%d",			\
+ 	      (Loc).first_line, (Loc).first_column,	\
+ 	      (Loc).last_line,  (Loc).last_column)
+ # else
+ #  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+ # endif
+ #endif
+ 
+ 
+ /* YYLEX -- calling `yylex' with the right arguments.  */
+ 
+ #ifdef YYLEX_PARAM
+ # define YYLEX yylex (YYLEX_PARAM)
+ #else
+ # define YYLEX yylex ()
+ #endif
+ 
+ /* Enable debugging if requested.  */
+ #if YYDEBUG
+ 
+ # ifndef YYFPRINTF
+ #  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+ #  define YYFPRINTF fprintf
+ # endif
+ 
+ # define YYDPRINTF(Args)			\
+ do {						\
+   if (yydebug)					\
+     YYFPRINTF Args;				\
+ } while (YYID (0))
+ 
+ # define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+ do {									  \
+   if (yydebug)								  \
+     {									  \
+       YYFPRINTF (stderr, "%s ", Title);					  \
+       yy_symbol_print (stderr,						  \
+ 		  Type, Value); \
+       YYFPRINTF (stderr, "\n");						  \
+     }									  \
+ } while (YYID (0))
+ 
+ 
+ /*--------------------------------.
+ | Print this symbol on YYOUTPUT.  |
+ `--------------------------------*/
+ 
+ /*ARGSUSED*/
+ #if (defined __STDC__ || defined __C99__FUNC__ \
+      || defined __cplusplus || defined _MSC_VER)
+ static void
+ yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+ #else
+ static void
+ yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+     FILE *yyoutput;
+     int yytype;
+     YYSTYPE const * const yyvaluep;
+ #endif
+ {
+   if (!yyvaluep)
+     return;
+ # ifdef YYPRINT
+   if (yytype < YYNTOKENS)
+     YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+ # else
+   YYUSE (yyoutput);
+ # endif
+   switch (yytype)
+     {
+       default:
+ 	break;
+     }
+ }
+ 
+ 
+ /*--------------------------------.
+ | Print this symbol on YYOUTPUT.  |
+ `--------------------------------*/
+ 
+ #if (defined __STDC__ || defined __C99__FUNC__ \
+      || defined __cplusplus || defined _MSC_VER)
+ static void
+ yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+ #else
+ static void
+ yy_symbol_print (yyoutput, yytype, yyvaluep)
+     FILE *yyoutput;
+     int yytype;
+     YYSTYPE const * const yyvaluep;
+ #endif
+ {
+   if (yytype < YYNTOKENS)
+     YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+   else
+     YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+ 
+   yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+   YYFPRINTF (yyoutput, ")");
+ }
+ 
+ /*------------------------------------------------------------------.
+ | yy_stack_print -- Print the state stack from its BOTTOM up to its |
+ | TOP (included).                                                   |
+ `------------------------------------------------------------------*/
+ 
+ #if (defined __STDC__ || defined __C99__FUNC__ \
+      || defined __cplusplus || defined _MSC_VER)
+ static void
+ yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
+ #else
+ static void
+ yy_stack_print (bottom, top)
+     yytype_int16 *bottom;
+     yytype_int16 *top;
+ #endif
+ {
+   YYFPRINTF (stderr, "Stack now");
+   for (; bottom <= top; ++bottom)
+     YYFPRINTF (stderr, " %d", *bottom);
+   YYFPRINTF (stderr, "\n");
+ }
+ 
+ # define YY_STACK_PRINT(Bottom, Top)				\
+ do {								\
+   if (yydebug)							\
+     yy_stack_print ((Bottom), (Top));				\
+ } while (YYID (0))
+ 
+ 
+ /*------------------------------------------------.
+ | Report that the YYRULE is going to be reduced.  |
+ `------------------------------------------------*/
+ 
+ #if (defined __STDC__ || defined __C99__FUNC__ \
+      || defined __cplusplus || defined _MSC_VER)
+ static void
+ yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+ #else
+ static void
+ yy_reduce_print (yyvsp, yyrule)
+     YYSTYPE *yyvsp;
+     int yyrule;
+ #endif
+ {
+   int yynrhs = yyr2[yyrule];
+   int yyi;
+   unsigned long int yylno = yyrline[yyrule];
+   YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+ 	     yyrule - 1, yylno);
+   /* The symbols being reduced.  */
+   for (yyi = 0; yyi < yynrhs; yyi++)
+     {
+       fprintf (stderr, "   $%d = ", yyi + 1);
+       yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+ 		       &(yyvsp[(yyi + 1) - (yynrhs)])
+ 		       		       );
+       fprintf (stderr, "\n");
+     }
+ }
+ 
+ # define YY_REDUCE_PRINT(Rule)		\
+ do {					\
+   if (yydebug)				\
+     yy_reduce_print (yyvsp, Rule); \
+ } while (YYID (0))
+ 
+ /* Nonzero means print parse trace.  It is left uninitialized so that
+    multiple parsers can coexist.  */
+ int yydebug;
+ #else /* !YYDEBUG */
+ # define YYDPRINTF(Args)
+ # define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+ # define YY_STACK_PRINT(Bottom, Top)
+ # define YY_REDUCE_PRINT(Rule)
+ #endif /* !YYDEBUG */
+ 
+ 
+ /* YYINITDEPTH -- initial size of the parser's stacks.  */
+ #ifndef	YYINITDEPTH
+ # define YYINITDEPTH 200
+ #endif
+ 
+ /* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+    if the built-in stack extension method is used).
+ 
+    Do not make this value too large; the results are undefined if
+    YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+    evaluated with infinite-precision integer arithmetic.  */
+ 
+ #ifndef YYMAXDEPTH
+ # define YYMAXDEPTH 10000
+ #endif
+ 
+ 
+ 
+ #if YYERROR_VERBOSE
+ 
+ # ifndef yystrlen
+ #  if defined __GLIBC__ && defined _STRING_H
+ #   define yystrlen strlen
+ #  else
+ /* Return the length of YYSTR.  */
+ #if (defined __STDC__ || defined __C99__FUNC__ \
+      || defined __cplusplus || defined _MSC_VER)
+ static YYSIZE_T
+ yystrlen (const char *yystr)
+ #else
+ static YYSIZE_T
+ yystrlen (yystr)
+     const char *yystr;
+ #endif
+ {
+   YYSIZE_T yylen;
+   for (yylen = 0; yystr[yylen]; yylen++)
+     continue;
+   return yylen;
+ }
+ #  endif
+ # endif
+ 
+ # ifndef yystpcpy
+ #  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+ #   define yystpcpy stpcpy
+ #  else
+ /* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+    YYDEST.  */
+ #if (defined __STDC__ || defined __C99__FUNC__ \
+      || defined __cplusplus || defined _MSC_VER)
+ static char *
+ yystpcpy (char *yydest, const char *yysrc)
+ #else
+ static char *
+ yystpcpy (yydest, yysrc)
+     char *yydest;
+     const char *yysrc;
+ #endif
+ {
+   char *yyd = yydest;
+   const char *yys = yysrc;
+ 
+   while ((*yyd++ = *yys++) != '\0')
+     continue;
+ 
+   return yyd - 1;
+ }
+ #  endif
+ # endif
+ 
+ # ifndef yytnamerr
+ /* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+    quotes and backslashes, so that it's suitable for yyerror.  The
+    heuristic is that double-quoting is unnecessary unless the string
+    contains an apostrophe, a comma, or backslash (other than
+    backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+    null, do not copy; instead, return the length of what the result
+    would have been.  */
+ static YYSIZE_T
+ yytnamerr (char *yyres, const char *yystr)
+ {
+   if (*yystr == '"')
+     {
+       YYSIZE_T yyn = 0;
+       char const *yyp = yystr;
+ 
+       for (;;)
+ 	switch (*++yyp)
+ 	  {
+ 	  case '\'':
+ 	  case ',':
+ 	    goto do_not_strip_quotes;
+ 
+ 	  case '\\':
+ 	    if (*++yyp != '\\')
+ 	      goto do_not_strip_quotes;
+ 	    /* Fall through.  */
+ 	  default:
+ 	    if (yyres)
+ 	      yyres[yyn] = *yyp;
+ 	    yyn++;
+ 	    break;
+ 
+ 	  case '"':
+ 	    if (yyres)
+ 	      yyres[yyn] = '\0';
+ 	    return yyn;
+ 	  }
+     do_not_strip_quotes: ;
+     }
+ 
+   if (! yyres)
+     return yystrlen (yystr);
+ 
+   return yystpcpy (yyres, yystr) - yyres;
+ }
+ # endif
+ 
+ /* Copy into YYRESULT an error message about the unexpected token
+    YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+    including the terminating null byte.  If YYRESULT is null, do not
+    copy anything; just return the number of bytes that would be
+    copied.  As a special case, return 0 if an ordinary "syntax error"
+    message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+    size calculation.  */
+ static YYSIZE_T
+ yysyntax_error (char *yyresult, int yystate, int yychar)
+ {
+   int yyn = yypact[yystate];
+ 
+   if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+     return 0;
+   else
+     {
+       int yytype = YYTRANSLATE (yychar);
+       YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+       YYSIZE_T yysize = yysize0;
+       YYSIZE_T yysize1;
+       int yysize_overflow = 0;
+       enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+       char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+       int yyx;
+ 
+ # if 0
+       /* This is so xgettext sees the translatable formats that are
+ 	 constructed on the fly.  */
+       YY_("syntax error, unexpected %s");
+       YY_("syntax error, unexpected %s, expecting %s");
+       YY_("syntax error, unexpected %s, expecting %s or %s");
+       YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+       YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+ # endif
+       char *yyfmt;
+       char const *yyf;
+       static char const yyunexpected[] = "syntax error, unexpected %s";
+       static char const yyexpecting[] = ", expecting %s";
+       static char const yyor[] = " or %s";
+       char yyformat[sizeof yyunexpected
+ 		    + sizeof yyexpecting - 1
+ 		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+ 		       * (sizeof yyor - 1))];
+       char const *yyprefix = yyexpecting;
+ 
+       /* Start YYX at -YYN if negative to avoid negative indexes in
+ 	 YYCHECK.  */
+       int yyxbegin = yyn < 0 ? -yyn : 0;
+ 
+       /* Stay within bounds of both yycheck and yytname.  */
+       int yychecklim = YYLAST - yyn + 1;
+       int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+       int yycount = 1;
+ 
+       yyarg[0] = yytname[yytype];
+       yyfmt = yystpcpy (yyformat, yyunexpected);
+ 
+       for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+ 	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+ 	  {
+ 	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+ 	      {
+ 		yycount = 1;
+ 		yysize = yysize0;
+ 		yyformat[sizeof yyunexpected - 1] = '\0';
+ 		break;
+ 	      }
+ 	    yyarg[yycount++] = yytname[yyx];
+ 	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+ 	    yysize_overflow |= (yysize1 < yysize);
+ 	    yysize = yysize1;
+ 	    yyfmt = yystpcpy (yyfmt, yyprefix);
+ 	    yyprefix = yyor;
+ 	  }
+ 
+       yyf = YY_(yyformat);
+       yysize1 = yysize + yystrlen (yyf);
+       yysize_overflow |= (yysize1 < yysize);
+       yysize = yysize1;
+ 
+       if (yysize_overflow)
+ 	return YYSIZE_MAXIMUM;
+ 
+       if (yyresult)
+ 	{
+ 	  /* Avoid sprintf, as that infringes on the user's name space.
+ 	     Don't have undefined behavior even if the translation
+ 	     produced a string with the wrong number of "%s"s.  */
+ 	  char *yyp = yyresult;
+ 	  int yyi = 0;
+ 	  while ((*yyp = *yyf) != '\0')
+ 	    {
+ 	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+ 		{
+ 		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+ 		  yyf += 2;
+ 		}
+ 	      else
+ 		{
+ 		  yyp++;
+ 		  yyf++;
+ 		}
+ 	    }
+ 	}
+       return yysize;
+     }
+ }
+ #endif /* YYERROR_VERBOSE */
+ 
+ 
+ /*-----------------------------------------------.
+ | Release the memory associated to this symbol.  |
+ `-----------------------------------------------*/
+ 
+ /*ARGSUSED*/
+ #if (defined __STDC__ || defined __C99__FUNC__ \
+      || defined __cplusplus || defined _MSC_VER)
+ static void
+ yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+ #else
+ static void
+ yydestruct (yymsg, yytype, yyvaluep)
+     const char *yymsg;
+     int yytype;
+     YYSTYPE *yyvaluep;
+ #endif
+ {
+   YYUSE (yyvaluep);
+ 
+   if (!yymsg)
+     yymsg = "Deleting";
+   YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+ 
+   switch (yytype)
+     {
+       case 51: /* "choice_entry" */
+ 
+ 	{
+ 	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+ 		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+ 	if (current_menu == (yyvaluep->menu))
+ 		menu_end_menu();
+ };
+ 
+ 	break;
+       case 57: /* "if_entry" */
+ 
+ 	{
+ 	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+ 		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+ 	if (current_menu == (yyvaluep->menu))
+ 		menu_end_menu();
+ };
+ 
+ 	break;
+       case 62: /* "menu_entry" */
+ 
+ 	{
+ 	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+ 		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+ 	if (current_menu == (yyvaluep->menu))
+ 		menu_end_menu();
+ };
+ 
+ 	break;
+ 
+       default:
+ 	break;
+     }
+ }
+ 
+ 
+ /* Prevent warnings from -Wmissing-prototypes.  */
+ 
+ #ifdef YYPARSE_PARAM
+ #if defined __STDC__ || defined __cplusplus
+ int yyparse (void *YYPARSE_PARAM);
+ #else
+ int yyparse ();
+ #endif
+ #else /* ! YYPARSE_PARAM */
+ #if defined __STDC__ || defined __cplusplus
+ int yyparse (void);
+ #else
+ int yyparse ();
+ #endif
+ #endif /* ! YYPARSE_PARAM */
+ 
+ 
+ 
+ /* The look-ahead symbol.  */
+ int yychar;
+ 
+ /* The semantic value of the look-ahead symbol.  */
+ YYSTYPE yylval;
+ 
+ /* Number of syntax errors so far.  */
+ int yynerrs;
+ 
+ 
+ 
+ /*----------.
+ | yyparse.  |
+ `----------*/
+ 
+ #ifdef YYPARSE_PARAM
+ #if (defined __STDC__ || defined __C99__FUNC__ \
+      || defined __cplusplus || defined _MSC_VER)
+ int
+ yyparse (void *YYPARSE_PARAM)
+ #else
+ int
+ yyparse (YYPARSE_PARAM)
+     void *YYPARSE_PARAM;
+ #endif
+ #else /* ! YYPARSE_PARAM */
+ #if (defined __STDC__ || defined __C99__FUNC__ \
+      || defined __cplusplus || defined _MSC_VER)
+ int
+ yyparse (void)
+ #else
+ int
+ yyparse ()
+ 
+ #endif
+ #endif
+ {
+   
+   int yystate;
+   int yyn;
+   int yyresult;
+   /* Number of tokens to shift before error messages enabled.  */
+   int yyerrstatus;
+   /* Look-ahead token as an internal (translated) token number.  */
+   int yytoken = 0;
+ #if YYERROR_VERBOSE
+   /* Buffer for error messages, and its allocated size.  */
+   char yymsgbuf[128];
+   char *yymsg = yymsgbuf;
+   YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+ #endif
+ 
+   /* Three stacks and their tools:
+      `yyss': related to states,
+      `yyvs': related to semantic values,
+      `yyls': related to locations.
+ 
+      Refer to the stacks thru separate pointers, to allow yyoverflow
+      to reallocate them elsewhere.  */
+ 
+   /* The state stack.  */
+   yytype_int16 yyssa[YYINITDEPTH];
+   yytype_int16 *yyss = yyssa;
+   yytype_int16 *yyssp;
+ 
+   /* The semantic value stack.  */
+   YYSTYPE yyvsa[YYINITDEPTH];
+   YYSTYPE *yyvs = yyvsa;
+   YYSTYPE *yyvsp;
+ 
+ 
+ 
+ #define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+ 
+   YYSIZE_T yystacksize = YYINITDEPTH;
+ 
+   /* The variables used to return semantic value and location from the
+      action routines.  */
+   YYSTYPE yyval;
+ 
+ 
+   /* The number of symbols on the RHS of the reduced rule.
+      Keep to zero when no symbol should be popped.  */
+   int yylen = 0;
+ 
+   YYDPRINTF ((stderr, "Starting parse\n"));
+ 
+   yystate = 0;
+   yyerrstatus = 0;
+   yynerrs = 0;
+   yychar = YYEMPTY;		/* Cause a token to be read.  */
+ 
+   /* Initialize stack pointers.
+      Waste one element of value and location stack
+      so that they stay on the same level as the state stack.
+      The wasted elements are never initialized.  */
+ 
+   yyssp = yyss;
+   yyvsp = yyvs;
+ 
+   goto yysetstate;
+ 
+ /*------------------------------------------------------------.
+ | yynewstate -- Push a new state, which is found in yystate.  |
+ `------------------------------------------------------------*/
+  yynewstate:
+   /* In all cases, when you get here, the value and location stacks
+      have just been pushed.  So pushing a state here evens the stacks.  */
+   yyssp++;
+ 
+  yysetstate:
+   *yyssp = yystate;
+ 
+   if (yyss + yystacksize - 1 <= yyssp)
+     {
+       /* Get the current used size of the three stacks, in elements.  */
+       YYSIZE_T yysize = yyssp - yyss + 1;
+ 
+ #ifdef yyoverflow
+       {
+ 	/* Give user a chance to reallocate the stack.  Use copies of
+ 	   these so that the &'s don't force the real ones into
+ 	   memory.  */
+ 	YYSTYPE *yyvs1 = yyvs;
+ 	yytype_int16 *yyss1 = yyss;
+ 
+ 
+ 	/* Each stack pointer address is followed by the size of the
+ 	   data in use in that stack, in bytes.  This used to be a
+ 	   conditional around just the two extra args, but that might
+ 	   be undefined if yyoverflow is a macro.  */
+ 	yyoverflow (YY_("memory exhausted"),
+ 		    &yyss1, yysize * sizeof (*yyssp),
+ 		    &yyvs1, yysize * sizeof (*yyvsp),
+ 
+ 		    &yystacksize);
+ 
+ 	yyss = yyss1;
+ 	yyvs = yyvs1;
+       }
+ #else /* no yyoverflow */
+ # ifndef YYSTACK_RELOCATE
+       goto yyexhaustedlab;
+ # else
+       /* Extend the stack our own way.  */
+       if (YYMAXDEPTH <= yystacksize)
+ 	goto yyexhaustedlab;
+       yystacksize *= 2;
+       if (YYMAXDEPTH < yystacksize)
+ 	yystacksize = YYMAXDEPTH;
+ 
+       {
+ 	yytype_int16 *yyss1 = yyss;
+ 	union yyalloc *yyptr =
+ 	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+ 	if (! yyptr)
+ 	  goto yyexhaustedlab;
+ 	YYSTACK_RELOCATE (yyss);
+ 	YYSTACK_RELOCATE (yyvs);
+ 
+ #  undef YYSTACK_RELOCATE
+ 	if (yyss1 != yyssa)
+ 	  YYSTACK_FREE (yyss1);
+       }
+ # endif
+ #endif /* no yyoverflow */
+ 
+       yyssp = yyss + yysize - 1;
+       yyvsp = yyvs + yysize - 1;
+ 
+ 
+       YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+ 		  (unsigned long int) yystacksize));
+ 
+       if (yyss + yystacksize - 1 <= yyssp)
+ 	YYABORT;
+     }
+ 
+   YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+ 
+   goto yybackup;
+ 
+ /*-----------.
+ | yybackup.  |
+ `-----------*/
+ yybackup:
+ 
+   /* Do appropriate processing given the current state.  Read a
+      look-ahead token if we need one and don't already have one.  */
+ 
+   /* First try to decide what to do without reference to look-ahead token.  */
+   yyn = yypact[yystate];
+   if (yyn == YYPACT_NINF)
+     goto yydefault;
+ 
+   /* Not known => get a look-ahead token if don't already have one.  */
+ 
+   /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
+   if (yychar == YYEMPTY)
+     {
+       YYDPRINTF ((stderr, "Reading a token: "));
+       yychar = YYLEX;
+     }
+ 
+   if (yychar <= YYEOF)
+     {
+       yychar = yytoken = YYEOF;
+       YYDPRINTF ((stderr, "Now at end of input.\n"));
+     }
+   else
+     {
+       yytoken = YYTRANSLATE (yychar);
+       YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+     }
+ 
+   /* If the proper action on seeing token YYTOKEN is to reduce or to
+      detect an error, take that action.  */
+   yyn += yytoken;
+   if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+     goto yydefault;
+   yyn = yytable[yyn];
+   if (yyn <= 0)
+     {
+       if (yyn == 0 || yyn == YYTABLE_NINF)
+ 	goto yyerrlab;
+       yyn = -yyn;
+       goto yyreduce;
+     }
+ 
+   if (yyn == YYFINAL)
+     YYACCEPT;
+ 
+   /* Count tokens shifted since error; after three, turn off error
+      status.  */
+   if (yyerrstatus)
+     yyerrstatus--;
+ 
+   /* Shift the look-ahead token.  */
+   YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+ 
+   /* Discard the shifted token unless it is eof.  */
+   if (yychar != YYEOF)
+     yychar = YYEMPTY;
+ 
+   yystate = yyn;
+   *++yyvsp = yylval;
+ 
+   goto yynewstate;
+ 
+ 
+ /*-----------------------------------------------------------.
+ | yydefault -- do the default action for the current state.  |
+ `-----------------------------------------------------------*/
+ yydefault:
+   yyn = yydefact[yystate];
+   if (yyn == 0)
+     goto yyerrlab;
+   goto yyreduce;
+ 
+ 
+ /*-----------------------------.
+ | yyreduce -- Do a reduction.  |
+ `-----------------------------*/
+ yyreduce:
+   /* yyn is the number of a rule to reduce with.  */
+   yylen = yyr2[yyn];
+ 
+   /* If YYLEN is nonzero, implement the default value of the action:
+      `$$ = $1'.
+ 
+      Otherwise, the following line sets YYVAL to garbage.
+      This behavior is undocumented and Bison
+      users should not rely upon it.  Assigning to YYVAL
+      unconditionally makes the parser a bit smaller, and it avoids a
+      GCC warning that YYVAL may be used uninitialized.  */
+   yyval = yyvsp[1-yylen];
+ 
+ 
+   YY_REDUCE_PRINT (yyn);
+   switch (yyn)
+     {
+         case 8:
+ 
+     { zconf_error("unexpected end statement"); ;}
+     break;
+ 
+   case 9:
+ 
+     { zconf_error("unknown statement \"%s\"", (yyvsp[(2) - (4)].string)); ;}
+     break;
+ 
+   case 10:
+ 
+     {
+ 	zconf_error("unexpected option \"%s\"", kconf_id_strings + (yyvsp[(2) - (4)].id)->name);
+ ;}
+     break;
+ 
+   case 11:
+ 
+     { zconf_error("invalid statement"); ;}
+     break;
+ 
+   case 25:
+ 
+     { zconf_error("unknown option \"%s\"", (yyvsp[(1) - (3)].string)); ;}
+     break;
+ 
+   case 26:
+ 
+     { zconf_error("invalid option"); ;}
+     break;
+ 
+   case 27:
+ 
+     {
+ 	struct symbol *sym = sym_lookup((yyvsp[(2) - (3)].string), 0);
+ 	sym->flags |= SYMBOL_OPTIONAL;
+ 	menu_add_entry(sym);
+ 	printd(DEBUG_PARSE, "%s:%d:config %s\n", zconf_curname(), zconf_lineno(), (yyvsp[(2) - (3)].string));
+ ;}
+     break;
+ 
+   case 28:
+ 
+     {
+ 	menu_end_entry();
+ 	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
+ ;}
+     break;
+ 
+   case 29:
+ 
+     {
+ 	struct symbol *sym = sym_lookup((yyvsp[(2) - (3)].string), 0);
+ 	sym->flags |= SYMBOL_OPTIONAL;
+ 	menu_add_entry(sym);
+ 	printd(DEBUG_PARSE, "%s:%d:menuconfig %s\n", zconf_curname(), zconf_lineno(), (yyvsp[(2) - (3)].string));
+ ;}
+     break;
+ 
+   case 30:
+ 
+     {
+ 	if (current_entry->prompt)
+ 		current_entry->prompt->type = P_MENU;
+ 	else
+ 		zconfprint("warning: menuconfig statement without prompt");
+ 	menu_end_entry();
+ 	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
+ ;}
+     break;
+ 
+   case 38:
+ 
+     {
+ 	menu_set_type((yyvsp[(1) - (3)].id)->stype);
+ 	printd(DEBUG_PARSE, "%s:%d:type(%u)\n",
+ 		zconf_curname(), zconf_lineno(),
+ 		(yyvsp[(1) - (3)].id)->stype);
+ ;}
+     break;
+ 
+   case 39:
+ 
+     {
+ 	menu_add_prompt(P_PROMPT, (yyvsp[(2) - (4)].string), (yyvsp[(3) - (4)].expr));
+ 	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+ ;}
+     break;
+ 
+   case 40:
+ 
+     {
+ 	menu_add_expr(P_DEFAULT, (yyvsp[(2) - (4)].expr), (yyvsp[(3) - (4)].expr));
+ 	if ((yyvsp[(1) - (4)].id)->stype != S_UNKNOWN)
+ 		menu_set_type((yyvsp[(1) - (4)].id)->stype);
+ 	printd(DEBUG_PARSE, "%s:%d:default(%u)\n",
+ 		zconf_curname(), zconf_lineno(),
+ 		(yyvsp[(1) - (4)].id)->stype);
+ ;}
+     break;
+ 
+   case 41:
+ 
+     {
+ 	menu_add_symbol(P_SELECT, sym_lookup((yyvsp[(2) - (4)].string), 0), (yyvsp[(3) - (4)].expr));
+ 	printd(DEBUG_PARSE, "%s:%d:select\n", zconf_curname(), zconf_lineno());
+ ;}
+     break;
+ 
+   case 42:
+ 
+     {
+ 	menu_add_expr(P_RANGE, expr_alloc_comp(E_RANGE,(yyvsp[(2) - (5)].symbol), (yyvsp[(3) - (5)].symbol)), (yyvsp[(4) - (5)].expr));
+ 	printd(DEBUG_PARSE, "%s:%d:range\n", zconf_curname(), zconf_lineno());
+ ;}
+     break;
+ 
+   case 45:
+ 
+     {
+ 	struct kconf_id *id = kconf_id_lookup((yyvsp[(2) - (3)].string), strlen((yyvsp[(2) - (3)].string)));
+ 	if (id && id->flags & TF_OPTION)
+ 		menu_add_option(id->token, (yyvsp[(3) - (3)].string));
+ 	else
+ 		zconfprint("warning: ignoring unknown option %s", (yyvsp[(2) - (3)].string));
+ 	free((yyvsp[(2) - (3)].string));
+ ;}
+     break;
+ 
+   case 46:
+ 
+     { (yyval.string) = NULL; ;}
+     break;
+ 
+   case 47:
+ 
+     { (yyval.string) = (yyvsp[(2) - (2)].string); ;}
+     break;
+ 
+   case 48:
+ 
+     {
+ 	struct symbol *sym = sym_lookup((yyvsp[(2) - (3)].string), SYMBOL_CHOICE);
+ 	sym->flags |= SYMBOL_AUTO;
+ 	menu_add_entry(sym);
+ 	menu_add_expr(P_CHOICE, NULL, NULL);
+ 	printd(DEBUG_PARSE, "%s:%d:choice\n", zconf_curname(), zconf_lineno());
+ ;}
+     break;
+ 
+   case 49:
+ 
+     {
+ 	(yyval.menu) = menu_add_menu();
+ ;}
+     break;
+ 
+   case 50:
+ 
+     {
+ 	if (zconf_endtoken((yyvsp[(1) - (1)].id), T_CHOICE, T_ENDCHOICE)) {
+ 		menu_end_menu();
+ 		printd(DEBUG_PARSE, "%s:%d:endchoice\n", zconf_curname(), zconf_lineno());
+ 	}
+ ;}
+     break;
+ 
+   case 58:
+ 
+     {
+ 	menu_add_prompt(P_PROMPT, (yyvsp[(2) - (4)].string), (yyvsp[(3) - (4)].expr));
+ 	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+ ;}
+     break;
+ 
+   case 59:
+ 
+     {
+ 	if ((yyvsp[(1) - (3)].id)->stype == S_BOOLEAN || (yyvsp[(1) - (3)].id)->stype == S_TRISTATE) {
+ 		menu_set_type((yyvsp[(1) - (3)].id)->stype);
+ 		printd(DEBUG_PARSE, "%s:%d:type(%u)\n",
+ 			zconf_curname(), zconf_lineno(),
+ 			(yyvsp[(1) - (3)].id)->stype);
+ 	} else
+ 		YYERROR;
+ ;}
+     break;
+ 
+   case 60:
+ 
+     {
+ 	current_entry->sym->flags |= SYMBOL_OPTIONAL;
+ 	printd(DEBUG_PARSE, "%s:%d:optional\n", zconf_curname(), zconf_lineno());
+ ;}
+     break;
+ 
+   case 61:
+ 
+     {
+ 	if ((yyvsp[(1) - (4)].id)->stype == S_UNKNOWN) {
+ 		menu_add_symbol(P_DEFAULT, sym_lookup((yyvsp[(2) - (4)].string), 0), (yyvsp[(3) - (4)].expr));
+ 		printd(DEBUG_PARSE, "%s:%d:default\n",
+ 			zconf_curname(), zconf_lineno());
+ 	} else
+ 		YYERROR;
+ ;}
+     break;
+ 
+   case 64:
+ 
+     {
+ 	printd(DEBUG_PARSE, "%s:%d:if\n", zconf_curname(), zconf_lineno());
+ 	menu_add_entry(NULL);
+ 	menu_add_dep((yyvsp[(2) - (3)].expr));
+ 	(yyval.menu) = menu_add_menu();
+ ;}
+     break;
+ 
+   case 65:
+ 
+     {
+ 	if (zconf_endtoken((yyvsp[(1) - (1)].id), T_IF, T_ENDIF)) {
+ 		menu_end_menu();
+ 		printd(DEBUG_PARSE, "%s:%d:endif\n", zconf_curname(), zconf_lineno());
+ 	}
+ ;}
+     break;
+ 
+   case 71:
+ 
+     {
+ 	menu_add_entry(NULL);
+ 	menu_add_prompt(P_MENU, (yyvsp[(2) - (3)].string), NULL);
+ 	printd(DEBUG_PARSE, "%s:%d:menu\n", zconf_curname(), zconf_lineno());
+ ;}
+     break;
+ 
+   case 72:
+ 
+     {
+ 	(yyval.menu) = menu_add_menu();
+ ;}
+     break;
+ 
+   case 73:
+ 
+     {
+ 	if (zconf_endtoken((yyvsp[(1) - (1)].id), T_MENU, T_ENDMENU)) {
+ 		menu_end_menu();
+ 		printd(DEBUG_PARSE, "%s:%d:endmenu\n", zconf_curname(), zconf_lineno());
+ 	}
+ ;}
+     break;
+ 
+   case 79:
+ 
+     {
+ 	printd(DEBUG_PARSE, "%s:%d:source %s\n", zconf_curname(), zconf_lineno(), (yyvsp[(2) - (3)].string));
+ 	zconf_nextfile((yyvsp[(2) - (3)].string));
+ ;}
+     break;
+ 
+   case 80:
+ 
+     {
+ 	menu_add_entry(NULL);
+ 	menu_add_prompt(P_COMMENT, (yyvsp[(2) - (3)].string), NULL);
+ 	printd(DEBUG_PARSE, "%s:%d:comment\n", zconf_curname(), zconf_lineno());
+ ;}
+     break;
+ 
+   case 81:
+ 
+     {
+ 	menu_end_entry();
+ ;}
+     break;
+ 
+   case 82:
+ 
+     {
+ 	printd(DEBUG_PARSE, "%s:%d:help\n", zconf_curname(), zconf_lineno());
+ 	zconf_starthelp();
+ ;}
+     break;
+ 
+   case 83:
+ 
+     {
+ 	current_entry->help = (yyvsp[(2) - (2)].string);
+ ;}
+     break;
+ 
+   case 88:
+ 
+     {
+ 	menu_add_dep((yyvsp[(3) - (4)].expr));
+ 	printd(DEBUG_PARSE, "%s:%d:depends on\n", zconf_curname(), zconf_lineno());
+ ;}
+     break;
+ 
+   case 90:
+ 
+     {
+ 	menu_add_prompt(P_PROMPT, (yyvsp[(1) - (2)].string), (yyvsp[(2) - (2)].expr));
+ ;}
+     break;
+ 
+   case 93:
+ 
+     { (yyval.id) = (yyvsp[(1) - (2)].id); ;}
+     break;
+ 
+   case 94:
+ 
+     { (yyval.id) = (yyvsp[(1) - (2)].id); ;}
+     break;
+ 
+   case 95:
+ 
+     { (yyval.id) = (yyvsp[(1) - (2)].id); ;}
+     break;
+ 
+   case 98:
+ 
+     { (yyval.expr) = NULL; ;}
+     break;
+ 
+   case 99:
+ 
+     { (yyval.expr) = (yyvsp[(2) - (2)].expr); ;}
+     break;
+ 
+   case 100:
+ 
+     { (yyval.expr) = expr_alloc_symbol((yyvsp[(1) - (1)].symbol)); ;}
+     break;
+ 
+   case 101:
+ 
+     { (yyval.expr) = expr_alloc_comp(E_EQUAL, (yyvsp[(1) - (3)].symbol), (yyvsp[(3) - (3)].symbol)); ;}
+     break;
+ 
+   case 102:
+ 
+     { (yyval.expr) = expr_alloc_comp(E_UNEQUAL, (yyvsp[(1) - (3)].symbol), (yyvsp[(3) - (3)].symbol)); ;}
+     break;
+ 
+   case 103:
+ 
+     { (yyval.expr) = (yyvsp[(2) - (3)].expr); ;}
+     break;
+ 
+   case 104:
+ 
+     { (yyval.expr) = expr_alloc_one(E_NOT, (yyvsp[(2) - (2)].expr)); ;}
+     break;
+ 
+   case 105:
+ 
+     { (yyval.expr) = expr_alloc_two(E_OR, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr)); ;}
+     break;
+ 
+   case 106:
+ 
+     { (yyval.expr) = expr_alloc_two(E_AND, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr)); ;}
+     break;
+ 
+   case 107:
+ 
+     { (yyval.symbol) = sym_lookup((yyvsp[(1) - (1)].string), 0); free((yyvsp[(1) - (1)].string)); ;}
+     break;
+ 
+   case 108:
+ 
+     { (yyval.symbol) = sym_lookup((yyvsp[(1) - (1)].string), SYMBOL_CONST); free((yyvsp[(1) - (1)].string)); ;}
+     break;
+ 
+   case 109:
+ 
+     { (yyval.string) = NULL; ;}
+     break;
+ 
+ 
+ /* Line 1267 of yacc.c.  */
+ 
+       default: break;
+     }
+   YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+ 
+   YYPOPSTACK (yylen);
+   yylen = 0;
+   YY_STACK_PRINT (yyss, yyssp);
+ 
+   *++yyvsp = yyval;
+ 
+ 
+   /* Now `shift' the result of the reduction.  Determine what state
+      that goes to, based on the state we popped back to and the rule
+      number reduced by.  */
+ 
+   yyn = yyr1[yyn];
+ 
+   yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+   if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+     yystate = yytable[yystate];
+   else
+     yystate = yydefgoto[yyn - YYNTOKENS];
+ 
+   goto yynewstate;
+ 
+ 
+ /*------------------------------------.
+ | yyerrlab -- here on detecting error |
+ `------------------------------------*/
+ yyerrlab:
+   /* If not already recovering from an error, report this error.  */
+   if (!yyerrstatus)
+     {
+       ++yynerrs;
+ #if ! YYERROR_VERBOSE
+       yyerror (YY_("syntax error"));
+ #else
+       {
+ 	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+ 	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+ 	  {
+ 	    YYSIZE_T yyalloc = 2 * yysize;
+ 	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+ 	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+ 	    if (yymsg != yymsgbuf)
+ 	      YYSTACK_FREE (yymsg);
+ 	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+ 	    if (yymsg)
+ 	      yymsg_alloc = yyalloc;
+ 	    else
+ 	      {
+ 		yymsg = yymsgbuf;
+ 		yymsg_alloc = sizeof yymsgbuf;
+ 	      }
+ 	  }
+ 
+ 	if (0 < yysize && yysize <= yymsg_alloc)
+ 	  {
+ 	    (void) yysyntax_error (yymsg, yystate, yychar);
+ 	    yyerror (yymsg);
+ 	  }
+ 	else
+ 	  {
+ 	    yyerror (YY_("syntax error"));
+ 	    if (yysize != 0)
+ 	      goto yyexhaustedlab;
+ 	  }
+       }
+ #endif
+     }
+ 
+ 
+ 
+   if (yyerrstatus == 3)
+     {
+       /* If just tried and failed to reuse look-ahead token after an
+ 	 error, discard it.  */
+ 
+       if (yychar <= YYEOF)
+ 	{
+ 	  /* Return failure if at end of input.  */
+ 	  if (yychar == YYEOF)
+ 	    YYABORT;
+ 	}
+       else
+ 	{
+ 	  yydestruct ("Error: discarding",
+ 		      yytoken, &yylval);
+ 	  yychar = YYEMPTY;
+ 	}
+     }
+ 
+   /* Else will try to reuse look-ahead token after shifting the error
+      token.  */
+   goto yyerrlab1;
+ 
+ 
+ /*---------------------------------------------------.
+ | yyerrorlab -- error raised explicitly by YYERROR.  |
+ `---------------------------------------------------*/
+ yyerrorlab:
+ 
+   /* Pacify compilers like GCC when the user code never invokes
+      YYERROR and the label yyerrorlab therefore never appears in user
+      code.  */
+   if (/*CONSTCOND*/ 0)
+      goto yyerrorlab;
+ 
+   /* Do not reclaim the symbols of the rule which action triggered
+      this YYERROR.  */
+   YYPOPSTACK (yylen);
+   yylen = 0;
+   YY_STACK_PRINT (yyss, yyssp);
+   yystate = *yyssp;
+   goto yyerrlab1;
+ 
+ 
+ /*-------------------------------------------------------------.
+ | yyerrlab1 -- common code for both syntax error and YYERROR.  |
+ `-------------------------------------------------------------*/
+ yyerrlab1:
+   yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+ 
+   for (;;)
+     {
+       yyn = yypact[yystate];
+       if (yyn != YYPACT_NINF)
+ 	{
+ 	  yyn += YYTERROR;
+ 	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+ 	    {
+ 	      yyn = yytable[yyn];
+ 	      if (0 < yyn)
+ 		break;
+ 	    }
+ 	}
+ 
+       /* Pop the current state because it cannot handle the error token.  */
+       if (yyssp == yyss)
+ 	YYABORT;
+ 
+ 
+       yydestruct ("Error: popping",
+ 		  yystos[yystate], yyvsp);
+       YYPOPSTACK (1);
+       yystate = *yyssp;
+       YY_STACK_PRINT (yyss, yyssp);
+     }
+ 
+   if (yyn == YYFINAL)
+     YYACCEPT;
+ 
+   *++yyvsp = yylval;
+ 
+ 
+   /* Shift the error token.  */
+   YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+ 
+   yystate = yyn;
+   goto yynewstate;
+ 
+ 
+ /*-------------------------------------.
+ | yyacceptlab -- YYACCEPT comes here.  |
+ `-------------------------------------*/
+ yyacceptlab:
+   yyresult = 0;
+   goto yyreturn;
+ 
+ /*-----------------------------------.
+ | yyabortlab -- YYABORT comes here.  |
+ `-----------------------------------*/
+ yyabortlab:
+   yyresult = 1;
+   goto yyreturn;
+ 
+ #ifndef yyoverflow
+ /*-------------------------------------------------.
+ | yyexhaustedlab -- memory exhaustion comes here.  |
+ `-------------------------------------------------*/
+ yyexhaustedlab:
+   yyerror (YY_("memory exhausted"));
+   yyresult = 2;
+   /* Fall through.  */
+ #endif
+ 
+ yyreturn:
+   if (yychar != YYEOF && yychar != YYEMPTY)
+      yydestruct ("Cleanup: discarding lookahead",
+ 		 yytoken, &yylval);
+   /* Do not reclaim the symbols of the rule which action triggered
+      this YYABORT or YYACCEPT.  */
+   YYPOPSTACK (yylen);
+   YY_STACK_PRINT (yyss, yyssp);
+   while (yyssp != yyss)
+     {
+       yydestruct ("Cleanup: popping",
+ 		  yystos[*yyssp], yyvsp);
+       YYPOPSTACK (1);
+     }
+ #ifndef yyoverflow
+   if (yyss != yyssa)
+     YYSTACK_FREE (yyss);
+ #endif
+ #if YYERROR_VERBOSE
+   if (yymsg != yymsgbuf)
+     YYSTACK_FREE (yymsg);
+ #endif
+   /* Make sure YYID is used.  */
+   return YYID (yyresult);
+ }
+ 
+ 
+ 
+ 
+ 
+ void conf_parse(const char *name)
+ {
+ 	struct symbol *sym;
+ 	int i;
+ 
+ 	zconf_initscan(name);
+ 
+ 	sym_init();
+ 	menu_init();
+ 	modules_sym = sym_lookup(NULL, 0);
+ 	modules_sym->type = S_BOOLEAN;
+ 	modules_sym->flags |= SYMBOL_AUTO;
+ 	rootmenu.prompt = menu_add_prompt(P_MENU, "Linux Kernel Configuration", NULL);
+ 
+ #if YYDEBUG
+ 	if (getenv("ZCONF_DEBUG"))
+ 		zconfdebug = 1;
+ #endif
+ 	zconfparse();
+ 	if (zconfnerrs)
+ 		exit(1);
+ 	if (!modules_sym->prop) {
+ 		struct property *prop;
+ 
+ 		prop = prop_alloc(P_DEFAULT, modules_sym);
+ 		prop->expr = expr_alloc_symbol(sym_lookup("MODULES", 0));
+ 	}
+ 	menu_finalize(&rootmenu);
+ 	for_all_symbols(i, sym) {
+ 		if (sym_check_deps(sym))
+ 			zconfnerrs++;
+         }
+ 	if (zconfnerrs)
+ 		exit(1);
+ 	sym_set_change_count(1);
+ }
+ 
+ const char *zconf_tokenname(int token)
+ {
+ 	switch (token) {
+ 	case T_MENU:		return "menu";
+ 	case T_ENDMENU:		return "endmenu";
+ 	case T_CHOICE:		return "choice";
+ 	case T_ENDCHOICE:	return "endchoice";
+ 	case T_IF:		return "if";
+ 	case T_ENDIF:		return "endif";
+ 	case T_DEPENDS:		return "depends";
+ 	}
+ 	return "<token>";
+ }
+ 
+ static bool zconf_endtoken(struct kconf_id *id, int starttoken, int endtoken)
+ {
+ 	if (id->token != endtoken) {
+ 		zconf_error("unexpected '%s' within %s block",
+ 			kconf_id_strings + id->name, zconf_tokenname(starttoken));
+ 		zconfnerrs++;
+ 		return false;
+ 	}
+ 	if (current_menu->file != current_file) {
+ 		zconf_error("'%s' in different file than '%s'",
+ 			kconf_id_strings + id->name, zconf_tokenname(starttoken));
+ 		fprintf(stderr, "%s:%d: location of the '%s'\n",
+ 			current_menu->file->name, current_menu->lineno,
+ 			zconf_tokenname(starttoken));
+ 		zconfnerrs++;
+ 		return false;
+ 	}
+ 	return true;
+ }
+ 
+ static void zconfprint(const char *err, ...)
+ {
+ 	va_list ap;
+ 
+ 	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno());
+ 	va_start(ap, err);
+ 	vfprintf(stderr, err, ap);
+ 	va_end(ap);
+ 	fprintf(stderr, "\n");
+ }
+ 
+ static void zconf_error(const char *err, ...)
+ {
+ 	va_list ap;
+ 
+ 	zconfnerrs++;
+ 	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno());
+ 	va_start(ap, err);
+ 	vfprintf(stderr, err, ap);
+ 	va_end(ap);
+ 	fprintf(stderr, "\n");
+ }
+ 
+ static void zconferror(const char *err)
+ {
+ #if YYDEBUG
+ 	fprintf(stderr, "%s:%d: %s\n", zconf_curname(), zconf_lineno() + 1, err);
+ #endif
+ }
+ 
+ void print_quoted_string(FILE *out, const char *str)
+ {
+ 	const char *p;
+ 	int len;
+ 
+ 	putc('"', out);
+ 	while ((p = strchr(str, '"'))) {
+ 		len = p - str;
+ 		if (len)
+ 			fprintf(out, "%.*s", len, str);
+ 		fputs("\\\"", out);
+ 		str = p + 1;
+ 	}
+ 	fputs(str, out);
+ 	putc('"', out);
+ }
+ 
+ void print_symbol(FILE *out, struct menu *menu)
+ {
+ 	struct symbol *sym = menu->sym;
+ 	struct property *prop;
+ 
+ 	if (sym_is_choice(sym))
+ 		fprintf(out, "choice\n");
+ 	else
+ 		fprintf(out, "config %s\n", sym->name);
+ 	switch (sym->type) {
+ 	case S_BOOLEAN:
+ 		fputs("  boolean\n", out);
+ 		break;
+ 	case S_TRISTATE:
+ 		fputs("  tristate\n", out);
+ 		break;
+ 	case S_STRING:
+ 		fputs("  string\n", out);
+ 		break;
+ 	case S_INT:
+ 		fputs("  integer\n", out);
+ 		break;
+ 	case S_HEX:
+ 		fputs("  hex\n", out);
+ 		break;
+ 	default:
+ 		fputs("  ???\n", out);
+ 		break;
+ 	}
+ 	for (prop = sym->prop; prop; prop = prop->next) {
+ 		if (prop->menu != menu)
+ 			continue;
+ 		switch (prop->type) {
+ 		case P_PROMPT:
+ 			fputs("  prompt ", out);
+ 			print_quoted_string(out, prop->text);
+ 			if (!expr_is_yes(prop->visible.expr)) {
+ 				fputs(" if ", out);
+ 				expr_fprint(prop->visible.expr, out);
+ 			}
+ 			fputc('\n', out);
+ 			break;
+ 		case P_DEFAULT:
+ 			fputs( "  default ", out);
+ 			expr_fprint(prop->expr, out);
+ 			if (!expr_is_yes(prop->visible.expr)) {
+ 				fputs(" if ", out);
+ 				expr_fprint(prop->visible.expr, out);
+ 			}
+ 			fputc('\n', out);
+ 			break;
+ 		case P_CHOICE:
+ 			fputs("  #choice value\n", out);
+ 			break;
+ 		default:
+ 			fprintf(out, "  unknown prop %d!\n", prop->type);
+ 			break;
+ 		}
+ 	}
+ 	if (menu->help) {
+ 		int len = strlen(menu->help);
+ 		while (menu->help[--len] == '\n')
+ 			menu->help[len] = 0;
+ 		fprintf(out, "  help\n%s\n", menu->help);
+ 	}
+ 	fputc('\n', out);
+ }
+ 
+ void zconfdump(FILE *out)
+ {
+ 	struct property *prop;
+ 	struct symbol *sym;
+ 	struct menu *menu;
+ 
+ 	menu = rootmenu.list;
+ 	while (menu) {
+ 		if ((sym = menu->sym))
+ 			print_symbol(out, menu);
+ 		else if ((prop = menu->prompt)) {
+ 			switch (prop->type) {
+ 			case P_COMMENT:
+ 				fputs("\ncomment ", out);
+ 				print_quoted_string(out, prop->text);
+ 				fputs("\n", out);
+ 				break;
+ 			case P_MENU:
+ 				fputs("\nmenu ", out);
+ 				print_quoted_string(out, prop->text);
+ 				fputs("\n", out);
+ 				break;
+ 			default:
+ 				;
+ 			}
+ 			if (!expr_is_yes(prop->visible.expr)) {
+ 				fputs("  depends ", out);
+ 				expr_fprint(prop->visible.expr, out);
+ 				fputc('\n', out);
+ 			}
+ 			fputs("\n", out);
+ 		}
+ 
+ 		if (menu->list)
+ 			menu = menu->list;
+ 		else if (menu->next)
+ 			menu = menu->next;
+ 		else while ((menu = menu->parent)) {
+ 			if (menu->prompt && menu->prompt->type == P_MENU)
+ 				fputs("\nendmenu\n", out);
+ 			if (menu->next) {
+ 				menu = menu->next;
+ 				break;
+ 			}
+ 		}
+ 	}
+ }
+ 
+ #include "lex.zconf.c"
+ #include "util.c"
+ #include "confdata.c"
+ #include "expr.c"
+ #include "symbol.c"
+ #include "menu.c"
+ 
Binary files linux-2.6.29.4/scripts/kconfig/zconf.tab.o and liab-linux-2.6.29.4/scripts/kconfig/zconf.tab.o differ
diff -r -C3 -P linux-2.6.29.4/scripts/kconfig/.zconf.tab.o.cmd liab-linux-2.6.29.4/scripts/kconfig/.zconf.tab.o.cmd
*** linux-2.6.29.4/scripts/kconfig/.zconf.tab.o.cmd	1970-01-01 01:00:00.000000000 +0100
--- liab-linux-2.6.29.4/scripts/kconfig/.zconf.tab.o.cmd	2012-04-03 14:03:08.252517017 +0200
***************
*** 0 ****
--- 1,97 ----
+ cmd_scripts/kconfig/zconf.tab.o := gcc -Wp,-MD,scripts/kconfig/.zconf.tab.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -DCURSES_LOC="<ncurses.h>" -DLOCALE  -Iscripts/kconfig -c -o scripts/kconfig/zconf.tab.o scripts/kconfig/zconf.tab.c
+ 
+ deps_scripts/kconfig/zconf.tab.o := \
+   scripts/kconfig/zconf.tab.c \
+   /usr/include/ctype.h \
+   /usr/include/features.h \
+   /usr/include/x86_64-linux-gnu/bits/predefs.h \
+   /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+   /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+   /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+   /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+   /usr/include/x86_64-linux-gnu/bits/types.h \
+   /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+   /usr/include/endian.h \
+   /usr/include/x86_64-linux-gnu/bits/endian.h \
+   /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+   /usr/include/xlocale.h \
+   /usr/lib/gcc/x86_64-linux-gnu/4.6.1/include/stdarg.h \
+   /usr/include/stdio.h \
+   /usr/lib/gcc/x86_64-linux-gnu/4.6.1/include/stddef.h \
+   /usr/include/libio.h \
+   /usr/include/_G_config.h \
+   /usr/include/wchar.h \
+   /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+   /usr/include/x86_64-linux-gnu/bits/sys_errlist.h \
+   /usr/include/x86_64-linux-gnu/bits/stdio.h \
+   /usr/include/x86_64-linux-gnu/bits/stdio2.h \
+   /usr/include/stdlib.h \
+   /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+   /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+   /usr/include/x86_64-linux-gnu/sys/types.h \
+   /usr/include/time.h \
+   /usr/include/x86_64-linux-gnu/sys/select.h \
+   /usr/include/x86_64-linux-gnu/bits/select.h \
+   /usr/include/x86_64-linux-gnu/bits/sigset.h \
+   /usr/include/x86_64-linux-gnu/bits/time.h \
+   /usr/include/x86_64-linux-gnu/sys/sysmacros.h \
+   /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+   /usr/include/alloca.h \
+   /usr/include/x86_64-linux-gnu/bits/stdlib.h \
+   /usr/include/string.h \
+   /usr/include/x86_64-linux-gnu/bits/string.h \
+   /usr/include/x86_64-linux-gnu/bits/string2.h \
+   /usr/include/x86_64-linux-gnu/bits/string3.h \
+   /usr/lib/gcc/x86_64-linux-gnu/4.6.1/include/stdbool.h \
+   scripts/kconfig/lkc.h \
+     $(wildcard include/config/list.h) \
+   scripts/kconfig/expr.h \
+   /usr/include/libintl.h \
+   /usr/include/locale.h \
+   /usr/include/x86_64-linux-gnu/bits/locale.h \
+   scripts/kconfig/lkc_proto.h \
+   scripts/kconfig/zconf.hash.c \
+   scripts/kconfig/lex.zconf.c \
+   /usr/include/errno.h \
+   /usr/include/x86_64-linux-gnu/bits/errno.h \
+   /usr/include/linux/errno.h \
+   /usr/include/x86_64-linux-gnu/asm/errno.h \
+   /usr/include/asm-generic/errno.h \
+   /usr/include/asm-generic/errno-base.h \
+   /usr/lib/gcc/x86_64-linux-gnu/4.6.1/include-fixed/limits.h \
+   /usr/lib/gcc/x86_64-linux-gnu/4.6.1/include-fixed/syslimits.h \
+   /usr/include/limits.h \
+   /usr/include/x86_64-linux-gnu/bits/posix1_lim.h \
+   /usr/include/x86_64-linux-gnu/bits/local_lim.h \
+   /usr/include/linux/limits.h \
+   /usr/include/x86_64-linux-gnu/bits/posix2_lim.h \
+   /usr/include/unistd.h \
+   /usr/include/x86_64-linux-gnu/bits/posix_opt.h \
+   /usr/include/x86_64-linux-gnu/bits/environments.h \
+   /usr/include/x86_64-linux-gnu/bits/confname.h \
+   /usr/include/getopt.h \
+   /usr/include/x86_64-linux-gnu/bits/unistd.h \
+   scripts/kconfig/util.c \
+   scripts/kconfig/confdata.c \
+     $(wildcard include/config/config.h) \
+     $(wildcard include/config/.h) \
+     $(wildcard include/config/overwriteconfig.h) \
+     $(wildcard include/config/notimestamp.h) \
+     $(wildcard include/config/autoconfig.h) \
+     $(wildcard include/config/autoheader.h) \
+   /usr/include/x86_64-linux-gnu/sys/stat.h \
+   /usr/include/x86_64-linux-gnu/bits/stat.h \
+   /usr/include/fcntl.h \
+   /usr/include/x86_64-linux-gnu/bits/fcntl.h \
+   /usr/include/x86_64-linux-gnu/bits/fcntl2.h \
+   scripts/kconfig/expr.c \
+   scripts/kconfig/symbol.c \
+   /usr/include/regex.h \
+   /usr/include/x86_64-linux-gnu/gnu/option-groups.h \
+   /usr/include/x86_64-linux-gnu/sys/utsname.h \
+   /usr/include/x86_64-linux-gnu/bits/utsname.h \
+   scripts/kconfig/menu.c \
+ 
+ scripts/kconfig/zconf.tab.o: $(deps_scripts/kconfig/zconf.tab.o)
+ 
+ $(deps_scripts/kconfig/zconf.tab.o):
